<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kevin346-sc.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="c++">
<meta property="og:type" content="website">
<meta property="og:title" content="Serein’s Blog">
<meta property="og:url" content="https://kevin346-sc.github.io/page/2/index.html">
<meta property="og:site_name" content="Serein’s Blog">
<meta property="og:description" content="c++">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kevin Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kevin346-sc.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Serein’s Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Serein’s Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kevin Huang</p>
  <div class="site-description" itemprop="description">c++</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/11/05/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/05/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/" class="post-title-link" itemprop="url">LeetCode回溯算法章节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-05 16:03:18" itemprop="dateCreated datePublished" datetime="2022-11-05T16:03:18+08:00">2022-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-04 14:35:34" itemprop="dateModified" datetime="2022-12-04T14:35:34+08:00">2022-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LeetCode回溯算法章节"><a href="#LeetCode回溯算法章节" class="headerlink" title="LeetCode回溯算法章节"></a>LeetCode回溯算法章节</h1><h2 id="回溯模板"><a href="#回溯模板" class="headerlink" title="回溯模板"></a>回溯模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void backtrace(参数)&#123;</span><br><span class="line">	if(终止条件)</span><br><span class="line">		return;</span><br><span class="line">	for(每层中的元素)</span><br><span class="line">	&#123;</span><br><span class="line">		存入结果</span><br><span class="line">		backtrace();调用回溯</span><br><span class="line">		删除存入的结果，回溯</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E6%A8%A1%E6%9D%BF.png"></p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>[组合](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>从[1,N]中找到凑成K个数的所有组合，将[i,N]（i&#x3D;1,2,3…N）看做一棵树的不同结点，每取出一个数就把剩下的数看做该结点的子结点，叶子结点则为符合要求的结果。因此，for循环中的是不断取出一个数进入递归，结束递归后删除，再递增取下一个数，直到遇到结束条件退出递归。即for循环会遍历[1,N]中所有的元素，每添加一个元素进入数组就进入一层递归，但进入递归后若符合终止条件则会跳出，避免了N次方的时间复杂度。也相当于枚举法，但会及时止损</p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E7%BB%84%E5%90%88.png"></p>
<ol>
<li><p>确定回溯终止条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(vec.size()==k)</span><br><span class="line">&#123;</span><br><span class="line">	res.push_back(vec);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组大小符合要求时，也就是遇到了叶子结点，这一次递归就终止，并更新结果集</p>
</li>
<li><p>确定回溯返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void search(int n,int k,vector&lt;vector&lt;int&gt;&gt;&amp; res,vector&lt;int&gt;&amp; vec,int start)</span><br><span class="line">&#123;</span><br><span class="line">	不需要返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = start;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	vec.push(i);</span><br><span class="line">	search(n,k,res,vec,start+1);</span><br><span class="line">	vec.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void search(int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int start)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">            search(n, k, res, vec, i + 1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        search(n, k, res, vec, 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化"><a href="#回溯优化" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>在回溯算法当中，由于是回溯的本质就是枚举，对枚举的优化只在于剪枝，通过给定限定条件减少无必要的递归，本题也同样如此，以上版本中将start赋予到了i，却并没有考虑到start的位置要求，在某些分支中，start过于太大，导致剩下的元素不能满足k的数量要求，因此，可以对回溯进行剪枝优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void search(int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int start)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt;= n - (k - vec.size()) + 1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">            search(n, k, res, vec, i + 1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        search(n, k, res, vec, 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>剪枝的原因在于i不必从过于大的start中取值，因此将对for循环中i的循环结束语句修改，从进入递归之前剪枝</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回溯算法难点在于将题意转换成树形结构，对于树形结构可以更好的理解回溯，以及剪枝的操作</p>
<h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><h3 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h3><p>题目思路类似于上一题，只不过将取值范围固定在<code>1~9</code>之间，其余都一样</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(int k, int n, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            if (accumulate(vec.begin(), vec.end(), 0) == n)</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt;= 9; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">            traceback(k, n, res, vec, i + 1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        traceback(k, n, res, vec, 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化-1"><a href="#回溯优化-1" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>在以上版本代码中，容易看出需要优化的地方在于取值的范围是递增的，一旦有满足总和的vec数组，后续的遍历中的数组总和只会更大，因此可以忽略掉后续的遍历。类似地，同样在递归进入条件判断语句中增加限制，考虑到是用数组总和来做判断是否需要剪枝，则增加一个形参<code>sum</code>表示当前<code>vec</code>数组的总和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(int k, int n, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int index, int&amp; sum)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            if (sum == n)</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt;= 9 &amp;&amp; (n - sum) &gt;= i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">            traceback(k, n, res, vec, i + 1, sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        traceback(k, n, res, vec, 1, sum);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在回溯法中，如果想要不重复地访问元素，则需要<code>traceback(k,n,res,vec,i+1)</code>而不是<code>traceback(k,n,res,vec,index+1)</code>，后者会在<code>i</code>遍历时，与<code>index+1</code>有重复值，且重复值只从2开始</p>
<p>本题是与上题相同的回溯思路，但不同的剪枝思路。</p>
<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>[电话号码的字母组合](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h3><p>与前些题目不同的是，没有直接能获取到要进入递归的范围，即递归树的结点，需要借助容器来获取数值范围，这里使用数组保存<code>0~9</code>所分别对应的字母。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; hashmap&#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;,</span><br><span class="line">&#123;&quot;d&quot;,&quot;e&quot;,&quot;f&quot;&#125;,</span><br><span class="line">&#123;&quot;g&quot;,&quot;h&quot;,&quot;i&quot;&#125;,</span><br><span class="line">&#123;&quot;j&quot;,&quot;k&quot;,&quot;l&quot;&#125;,</span><br><span class="line">&#123;&quot;m&quot;,&quot;n&quot;,&quot;o&quot;&#125;,</span><br><span class="line">&#123;&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;&#125;,</span><br><span class="line">&#123;&quot;t&quot;,&quot;u&quot;,&quot;v&quot;&#125;,</span><br><span class="line">&#123;&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>这里保存0,1两个空数组是为了方便索引访问直接对应</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(digits.size()==str.size())</span><br><span class="line">&#123;</span><br><span class="line">	res.push_back(str);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void traceback(vector&lt;string&gt;&amp; res, string&amp; str,const string &amp;digits,int index);</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;hashmap[digit].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str += hashmap[digit][i];</span><br><span class="line">            traceback(res,str,digits,index+1);</span><br><span class="line">            str.pop_back();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; hashmap&#123;</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">    &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;,</span><br><span class="line">    &#123;&quot;d&quot;,&quot;e&quot;,&quot;f&quot;&#125;,</span><br><span class="line">    &#123;&quot;g&quot;,&quot;h&quot;,&quot;i&quot;&#125;,</span><br><span class="line">    &#123;&quot;j&quot;,&quot;k&quot;,&quot;l&quot;&#125;,</span><br><span class="line">    &#123;&quot;m&quot;,&quot;n&quot;,&quot;o&quot;&#125;,</span><br><span class="line">    &#123;&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;&#125;,</span><br><span class="line">    &#123;&quot;t&quot;,&quot;u&quot;,&quot;v&quot;&#125;,</span><br><span class="line">    &#123;&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    void traceback(vector&lt;string&gt;&amp; res,string&amp; str,const string &amp;digits,int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str.size()==digits.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int digit = digits[index] - &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">        for(int i = 0;i&lt;hashmap[digit].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str += hashmap[digit][i];</span><br><span class="line">            traceback(res,str,digits,index+1);</span><br><span class="line">            str.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string str;</span><br><span class="line"></span><br><span class="line">        if(digits.empty())  return res;</span><br><span class="line">        traceback(res,str,digits,0);        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>由回溯过程可知，这个版本的回溯代码不需要剪枝优化。</p>
<p>在本题中，传入递归函数的<code>index</code>形参用来获取<code>digits</code>中的下一位数字，保证每次for循环的都是不同进位上的数字，也是这道题的最大变化点。并且不需要传入其余参数用于表示开始遍历的结点索引，因为需要遍历的是对应数字上的所有字母</p>
<h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>[组合总和](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-3"><a href="#回溯-3" class="headerlink" title="回溯"></a>回溯</h3><p>这道题给定一个数组和目标值，要求从数组中找到不限数量的数组元素，令其和等于目标值，并且能够重复用数组中的元素。最大的不同点在于能够重复使用数组元素，首先能想到的就是不需要index形参，不能让递归每次都从下一个元素开始遍历。</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(target == sum)</span><br><span class="line">&#123;</span><br><span class="line">	res.push_back(vec);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容易想到只要让当前数组的和等于目标值即可结束该层递归，即到达叶子结点。但是这样就会导致了死循环，因为如果一旦数组和大于目标值，则递归永远不会退出。因此需要加上对sum值的限制（在进入递归前判断）</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void traceback(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt; &amp;res,vector&lt;int&gt; &amp;vec,int target,int &amp;sum,int startindex)</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = startindex; i &lt; candidates.size() &amp;&amp; target &gt; sum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在这，startindex作为每次遍历时开始的索引下标，与[III](# 组合总和III)不同，传入到下一次递归的是<code>i</code>而不是<code>i+1</code>，这是因为<strong>允许重复元素的存在</strong></p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int target, int&amp; sum, int startindex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startindex; i &lt; candidates.size() &amp;&amp; target 》 sum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        traceback(candidates, res, vec, target, sum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化-2"><a href="#回溯优化-2" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>可以想到，如同[III](# 组合总和III)，剪枝优化的思路在于当<strong>数组递增</strong>时，一旦有满足目标值的数组元素，往后的元素再进入递归，vec数组的和都会大于目标值，因此可以剪掉，所以<strong>先给数组进行排序</strong>，然后在<strong>递归进入前加以条件的限制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int target, int&amp; sum, int startindex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startindex; i &lt; candidates.size() &amp;&amp; (target - sum) &gt;= candidates[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        int sum = 0;</span><br><span class="line">        traceback(candidates, res, vec, target, sum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>当允许重复元素出现时，在进入下一层递归时就可以传入<code>i</code>而不是<code>i+1</code>。</p>
<p>因为给出的数组非递增，需要先对数组进行排序，优化效果不明显</p>
<h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>[组合总和II](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-4"><a href="#回溯-4" class="headerlink" title="回溯"></a>回溯</h3><p>该题与[II](# 组合总和II)的区别就在于输入的<code>candidates</code>数组允许有重复元素的出现，但<strong>每个元素只能使用一次</strong>，因此传递到下一层递归中的索引就必须是<code>index+1</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int target, int&amp; sum, int startindex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startindex; i &lt; candidates.size() &amp;&amp; target &gt; sum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        traceback(candidates, res, vec, target, sum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外，如果<code>candidates</code>中有重复元素，会导致同层的结点中可能会选取一样的值进入到下一层递归中，就会导致最终结果出现有<strong>相同元素的分组</strong>，如以上版本的代码，仅修改了上一题的<code>index</code>传递值。原因在于，可能会出现保存到<code>res</code>中的元素在回溯删除之后，因为相同值的元素存在，在遍历剩余元素时又被重新添加进去。</p>
<p>可以针对这种情况设立一个<code>tmp</code>变量，先对<code>candidates</code>进行排序，<code>tmp</code>记录刚被删除的元素的值，再下一个元素被添加时判断是否等于<code>tmp</code>，只有不相等时才会被添加进去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int tmp = 0;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int target, int&amp; sum, int startindex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startindex; i &lt; candidates.size() &amp;&amp; (target-sum) &gt;= candidates[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(tmp == candidates[i])</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i+1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            tmp = candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        traceback(candidates, res, vec, target, sum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int i = startindex; i &lt; candidates.size() &amp;&amp; (target-sum) &gt;= candidates[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i &gt; startindex &amp;&amp; candidates[i] == candidates[i-1])</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i+1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化-3"><a href="#回溯优化-3" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>剪枝优化过程同<a href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%96%602">上题</a>，以上版本代码已剪枝</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>candidates</code>没有重复元素，但结果输出可以有重复元素，则修改<code>index</code></p>
<p><code>candidates</code>有重复元素，但结果输出不能有重复元素，即相同元素的分组，则通过添加限制条件防止重复元素进入递归</p>
<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>[分割回文串](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-5"><a href="#回溯-5" class="headerlink" title="回溯"></a>回溯</h3><p>相比较于之前的题目，该题变化点主要集中在于递归结束判断条件，在满足回文的条件的同时，还需要<strong>将整个字符串完全分割</strong></p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg"></p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (index &gt;= s.size())</span><br><span class="line">&#123;</span><br><span class="line">    if (judge())</span><br><span class="line">       res.push_back(vec);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于不能添加重复元素进入递归，所以需要index形参，需要在对整个字符串完成分割的时候才停止递归，并且要满足回文的条件才能保存结果</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void traceback(string s, int index)</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = index; i &lt; s.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    vec.push_back(s.substr(index,i+1-index));</span><br><span class="line">    traceback(s, i + 1);</span><br><span class="line">    vec.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line">    bool judge()</span><br><span class="line">    &#123;</span><br><span class="line">        for(auto sustr:vec)</span><br><span class="line">        &#123;</span><br><span class="line">            int i = 0, j = sustr.size()-1;</span><br><span class="line">            while(i&lt;=j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(sustr[i]!=sustr[j])</span><br><span class="line">                    return false;</span><br><span class="line">                ++i,--j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void traceback(string s, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index&gt;=s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(judge())</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(s.substr(index,i+1-index));</span><br><span class="line">            traceback(s, i + 1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">        if (s.size() == 1)</span><br><span class="line">            return vector&lt;vector&lt;string&gt;&gt;&#123;&#123;s&#125;&#125;;</span><br><span class="line">        traceback(s, 0);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外，还可以在进入递归前完成对回文串的判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line"></span><br><span class="line">    bool judge(int st, int en,string s)</span><br><span class="line">    &#123;</span><br><span class="line">        while(st&lt;=en)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[st]!=s[en])</span><br><span class="line">                return false;</span><br><span class="line">            ++st,--en;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void traceback(string s, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index&gt;=s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!judge(index,i,s))</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(s.substr(index,i+1-index));</span><br><span class="line">            traceback(s, i + 1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">        if (s.size() == 1)</span><br><span class="line">            return vector&lt;vector&lt;string&gt;&gt;&#123;&#123;s&#125;&#125;;</span><br><span class="line">        traceback(s, 0);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>难点在于</p>
<ul>
<li><p><strong>切割问题</strong>转换成<strong>组合问题</strong></p>
<p>关键在于模拟出树形结构</p>
</li>
<li><p>字符串分割如何用代码实现</p>
<p>利用index，以及substr函数，把递归开始时的初值模拟为切割线</p>
</li>
<li><p>判断回文串</p>
<p>双指针法；动态规划</p>
</li>
<li><p>递归结束条件的判断</p>
</li>
</ul>
<h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>本题也属于切割问题，但切割完成的判断更为复杂，切割的IP地址分为4段，需要直接在原字符串中加上<code>&#39;.&#39;</code>表示分段，分段中的IP地址不能有前导0，不能大于255，否则都将是无效的IP。</p>
<p>转换成树形结构</p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/IP.png"></p>
<p>首先，确定判断IP段是否有效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool ok(const string&amp; s, int st, int en)</span><br><span class="line">&#123;</span><br><span class="line">	if(st &gt; en)</span><br><span class="line">		return false;</span><br><span class="line">	if(s[st] == 0 &amp;&amp; st!=en)</span><br><span class="line">		return false;</span><br><span class="line">	int num = 0;</span><br><span class="line">	for(int i = st; i &lt;= en; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		num = num*10 + (s[i] - &#x27;0&#x27;);</span><br><span class="line">		if(num &gt; 255)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仅仅是首元素为0还不一定无效，IP地址段可以只有一个0，但不能是前导0</p>
<p>计算IP地址段可以用<code>for</code>循环，逐位相加，一旦某一位已经超过255则直接返回<code>false</code></p>
<h3 id="回溯1"><a href="#回溯1" class="headerlink" title="回溯1"></a>回溯1</h3><ol>
<li><p>递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(comma == 3)</span><br><span class="line">&#123;</span><br><span class="line">	if(ok(s,index,s.size()-1))</span><br><span class="line">		res.push_back(s);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是直接在源字符串中做分割，在加了3个<code>&#39;.&#39;</code>的情况下，还需要对最后一段IP进行判断是否有效才能加入到结果集中</p>
</li>
<li><p>递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void traceback(vector&lt;string&gt;&amp; res, int comma, int index, string&amp; s)</span><br></pre></td></tr></table></figure>

<p>因为直接在源字符串上操作，并且需要找到所有有效的IP地址，因此不需要返回值。传入参数为引用，不用拷贝并且允许直接修改、删除等操作</p>
</li>
<li><p>单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i = index; i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	s.insert(s.begin() + i + 1, &#x27;.&#x27;);</span><br><span class="line">	++comma;</span><br><span class="line">	traceback(res, comma, i + 2, s);</span><br><span class="line">	--comma;</span><br><span class="line">	s.erase(s.begin() + i + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>insert</code>函数将<code>&#39;.&#39;</code>插在输入的迭代器之前，即取代输入的迭代器位置，<code>erase</code>则是删除输入迭代器当前位置上的元素。进入递归由于插入多了一位，则下一层递归中需要从<code>index = i+2</code>开始</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool ok(const string&amp; s, int st, int en)</span><br><span class="line">    &#123;</span><br><span class="line">        if (st &gt; en)</span><br><span class="line">            return false;</span><br><span class="line">        if (s[st] == &#x27;0&#x27; &amp;&amp; st != en)</span><br><span class="line">            return false;</span><br><span class="line">        int num = 0;</span><br><span class="line">        for (int i = st; i &lt;= en; i++) </span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            num = num * 10 + (s[i] - &#x27;0&#x27;);</span><br><span class="line"></span><br><span class="line">            if (num &gt; 255) </span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void traceback(vector&lt;string&gt;&amp; res, int index, int comma, string&amp; s)</span><br><span class="line">    &#123;</span><br><span class="line">        if (comma == 3)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ok(s, index, s.size() - 1))</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ok(s, index, i))</span><br><span class="line">            &#123;</span><br><span class="line">                s.insert(s.begin() + i + 1, &#x27;.&#x27;);</span><br><span class="line">                ++comma;</span><br><span class="line">                traceback(res, i + 2, comma, s);</span><br><span class="line">                --comma;</span><br><span class="line">                s.erase(s.begin() + i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        traceback(res, 0, 0, s);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="回溯2"><a href="#回溯2" class="headerlink" title="回溯2"></a>回溯2</h3><p>另外一种解法是， 不在源字符串上修改，而是将4段IP地址一段一段的加入一个空字符串中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt;ans;</span><br><span class="line">    void backtrace(string&amp; s,int cnt,int index,string&amp; str)&#123;</span><br><span class="line">        if(cnt==4 || index==s.size() )&#123;</span><br><span class="line">            if(cnt==4 &amp;&amp; index==s.size())</span><br><span class="line">                ans.push_back(str.substr(0,str.size()-1));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=3;i++)&#123;</span><br><span class="line">            if(index+i&gt;s.size()) return;</span><br><span class="line">            if(s[index]==&#x27;0&#x27; &amp;&amp; i!=1) return;</span><br><span class="line">            if(i==3 &amp;&amp; s.substr(index,i)&gt;&quot;255&quot;) return;</span><br><span class="line">            str+=s.substr(index,i);</span><br><span class="line">            str.push_back(&#x27;.&#x27;);</span><br><span class="line">            backtrace(s,cnt+1,index+i,str);</span><br><span class="line">            str = str.substr(0,str.size()-i-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        string str =&quot;&quot;;</span><br><span class="line">        backtrace(s,0,0,str);</span><br><span class="line">        return ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>回溯1是从一整段IP地址直接做分割，回溯2则是将各段分割好的小段最终才拼凑成完整的IP地址，这样做的好处是对于各段统一判断是否有效，而不用像回溯1中在添加了最后一个<code>&#39;.&#39;</code>之后，添加到结果集之前还要做一次有效判断。并且在回溯2中，判断有效更加简洁，可以利用加入的子段最多只有3位直接与”255”进行判断，而回溯1中可能会出现不止3位的IP地址，因此不能直接与”255”判断，但可以修改成<code>if(en - st == 2 &amp;&amp; s.substr(s.begin() + st, 3) &gt; &quot;255&quot;) return false;</code>以及<code>if(en - st &gt; 2)	return false;</code></p>
<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><h3 id="回溯-6"><a href="#回溯-6" class="headerlink" title="回溯"></a>回溯</h3><p>子集问题中，依旧还是回溯的总体思路，不同在于之前结束条件的判断，仅仅只是遍历到数组结尾就退出</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp;nums,vector&lt;int&gt;&amp;vec,vector&lt;vector&lt;int&gt;&gt;&amp;res,int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if(index&gt;=nums.size())</span><br><span class="line">            return;</span><br><span class="line">        for(int i = index; i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            traceback(nums,vec,res,i+1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        res.push_back(vec);</span><br><span class="line">        traceback(nums,vec,res,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>子集问题不需要有判断条件，就直接存入结果集中，相当于将树型结构上的<strong>每个结点</strong>；而组合和切割问题则是<strong>保留叶子结点</strong></p>
<h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><h3 id="回溯-7"><a href="#回溯-7" class="headerlink" title="回溯"></a>回溯</h3><p>给定输入数组中含有重复元素，但要求输出结果中不能有重复子数组，与[组合总和II](# 组合总和II)思路一致，且其余同<a href="#%E5%AD%90%E9%9B%86">子集</a>的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp;nums,vector&lt;int&gt;&amp;vec,vector&lt;vector&lt;int&gt;&gt;&amp;res,int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if(index&gt;=nums.size())</span><br><span class="line">            return;</span><br><span class="line">        for(int i = index; i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;index&amp;&amp;nums[i]==nums[i-1])</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            traceback(nums,vec,res,i+1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        res.push_back(vec);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        traceback(nums,vec,res,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>[递增子序列](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/increasing-subsequences/">491. 递增子序列 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-8"><a href="#回溯-8" class="headerlink" title="回溯"></a>回溯</h3><p>这道题需要理解的几个关键点：</p>
<ul>
<li>要求是子序列，则不能对其排序，有点类似于分割问题但可以只取两边不取中间，即<code>[1,2,3]</code>选<code>[1,3]</code></li>
<li>要求是非严格递增，则在进入递归前应先进行判断，</li>
<li>输入数组中可能会有重复元素，但输出不能包含重复子数组</li>
</ul>
<p>可知，需要在<strong>不能排序</strong>的情况下，还要在递归过程中排除重复项，回溯的时候应该借助容器来帮助<strong>辨别重复项</strong>，容易想到用<code>unordered_set</code>容器储存结果用于去除重复项，然后遍历容器将没有重复的元素依次存放到<code>vector</code>中，但是，不能直接定义<code>unordered_set&lt;vector&lt;int&gt;&gt;</code>，还要有自定义的哈希函数。因此可以<strong>转换思路，在每一层的结点循环中设置一个<code>unordered_set</code>，即单单不允许这一层有重复被选数</strong>，这就避免重复项进入递归，因为前一个所选就囊括了后面所有相同数的子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt;&amp; vec,int index)</span><br><span class="line">    &#123;</span><br><span class="line">        unordered_set&lt;int&gt; uset;</span><br><span class="line">        if(index&gt;=nums.size())</span><br><span class="line">            return;</span><br><span class="line">        for(int i = index;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;index&amp;&amp;nums[i]==nums[i-1])</span><br><span class="line">                continue;</span><br><span class="line">            if(!vec.empty() &amp;&amp; nums[i]&lt;vec.back())</span><br><span class="line">                continue;</span><br><span class="line">            if(uset.find(nums[i])!=uset.end())</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            uset.insert(nums[i]);</span><br><span class="line">            if(vec.size()&gt;1)</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            traceback(nums,res,vec,i+1);</span><br><span class="line">            vec.pop_back();            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        traceback(nums,res,vec,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化1"><a href="#回溯优化1" class="headerlink" title="回溯优化1"></a>回溯优化1</h3><p>以上版本的代码，用到了<code>unordered_set</code>，又因为总数据量较小，可以用<code>vector</code>替代<code>unordered_set</code>以减少开销</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt;&amp; vec,int index)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; used(201,0);</span><br><span class="line">        if(index&gt;=nums.size())</span><br><span class="line">            return;</span><br><span class="line">        for(int i = index;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;index&amp;&amp;nums[i]==nums[i-1])</span><br><span class="line">                continue;</span><br><span class="line">            if(!vec.empty() &amp;&amp; nums[i]&lt;vec.back())</span><br><span class="line">                continue;</span><br><span class="line">            if(used[nums[i]+100]==1)</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            used[nums[i]+100] = 1;</span><br><span class="line">            if(vec.size()&gt;1)</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            traceback(nums,res,vec,i+1);</span><br><span class="line">            vec.pop_back();            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        traceback(nums,res,vec,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化2"><a href="#回溯优化2" class="headerlink" title="回溯优化2"></a>回溯优化2</h3><p>另一种回溯模板的解法，不需要用到额外的容器来记录，但较难理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp;nums,int cur,int last)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur&gt;=nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(vec.size()&gt;1)</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[cur]&gt;=last)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(nums[cur]);</span><br><span class="line">            traceback(nums,cur+1,nums[cur]);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[cur]!=last)</span><br><span class="line">            traceback(nums,cur+1,last);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        traceback(nums,0,-101);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>选择合法项：只有<code>cur</code>值大于等于<code>last</code>，才会选择该元素（添加到vec中）</p>
<p><strong>不借助容器就能排除重复项：只有<code>last</code>和<code>cur</code>指向的值不相同时，才会不选择该结点（不添加到<code>vec</code>中），也就是说当有多个重复元素时，只选最后一个以避免重复</strong></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>另一种回溯模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">vector&lt;int&gt; temp;</span><br><span class="line">void dfs(int cur, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if (cur == nums.size()) &#123;</span><br><span class="line">        // 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span><br><span class="line">        if (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果选择当前元素</span><br><span class="line">    temp.push_back(nums[cur]);</span><br><span class="line">    dfs(cur + 1, nums);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    // 如果不选择当前元素</span><br><span class="line">    dfs(cur + 1, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[子集](# 子集)新解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">    void traceback(int cur, vector&lt;int&gt;&amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur&gt;=nums.size())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vec.push_back(nums[cur]);</span><br><span class="line">        traceback(cur+1,nums);</span><br><span class="line">        vec.pop_back();</span><br><span class="line">        </span><br><span class="line">        traceback(cur+1,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        traceback(0,nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[子集II](# 子集II)新解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">    void traceback(int cur, vector&lt;int&gt;&amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur&gt;=nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec.push_back(nums[cur]);</span><br><span class="line">        traceback(cur+1,nums);</span><br><span class="line">        vec.pop_back();</span><br><span class="line"></span><br><span class="line">        while(cur &lt; nums.size()-1 &amp;&amp; nums[cur]==nums[cur+1])</span><br><span class="line">            ++cur;</span><br><span class="line">        traceback(cur+1,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        traceback(0,nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>该题最关键是在不排序的前提下，排除重复项进入递归，需要借助容器，<strong>并且是在每层递归中重新定义一个容器，从而避免同层相同元素进入递归</strong></p>
<p>另一种回溯模板，<strong>不对应树形结构</strong>，因而更难理解；优先处理更多元素的情况，但因其一层两次递归，时间复杂度更高，但指针使用更加灵活，减少对容器的使用，降低空间复杂度</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><h3 id="回溯-9"><a href="#回溯-9" class="headerlink" title="回溯"></a>回溯</h3><p>排列问题，容易得知，每次递归时需要从0开始遍历数组，这就意味着不能像组合总和一样代入index对递归进行限制。并且，需要借助容器来记录遍历的当前值是否有被使用过。将全排列转化成树形结构，则同一个树枝上不能够有重复值，那么就可以借助全局的<code>vector</code>进行记录，与<code>vec</code>同步增删元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; nums, int index,vector&lt;int&gt; &amp;used)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (used[nums[i] + 10] == 1)</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            used[nums[i] + 10] = 1;</span><br><span class="line">            traceback(nums, index + 1,used);</span><br><span class="line">            used[nums[i] + 10] = 0;</span><br><span class="line">            vec.pop_back();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; used(21, 0);</span><br><span class="line">        traceback(nums, 0,used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与[递增子序列](# 递增子序列)一样，可以通过<code>unordered_set</code>以及<code>vector</code>来记录，<code>vector</code>在数组样本小的情况下性能更加优越</p>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li>组合之和：只能往后选取（排列顺序不影响结果），故需要用index记录每次递归开始选取的位置；去重则通过排序后再对当前值进行是否与前值重复判断</li>
<li>分割：与组合之和差别在于终止条件，分割必须要字符串全部分割</li>
<li>子集：与组合之和差别在于子集的每个结点都是结果集</li>
<li>全排列：不需要index记录每次递归开始选取的位置，因为有排列顺序要求；去重因为没有index，需要借助容器来记录是否被选取过，通常选<code>vector</code></li>
</ul>
<h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><h3 id="回溯1-1"><a href="#回溯1-1" class="headerlink" title="回溯1"></a>回溯1</h3><p>在[全排列](# 全排列)基础上，输入数组可能会有重复值，即不仅在树枝上不能够有重复值，在树层上也不允许有重复值的存在，但是不能直接加上<strong>排序后再判断当前值与前一值是否相等的</strong>去重操作。因为重复值的存在，当在同一条路径上，即树枝上允许有重复值的存在（来源于不同的等值元素），针对树枝上的重复值，可以借助<code>vector</code>先遍历<code>nums</code>记录每个数值的个数，用来判断这个树枝上是否还能使用该数值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; nums, int index,vector&lt;int&gt; &amp;used)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (used[nums[i] + 10] == 0)//树枝去重</span><br><span class="line">                continue;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1])//树层去重，同时防止树枝上取已取过的值</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            --used[nums[i] + 10];</span><br><span class="line">            traceback(nums, index + 1,used);</span><br><span class="line">            ++used[nums[i] + 10];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; used(21, 0);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        for(int i:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++used[i+10];</span><br><span class="line">        &#125;</span><br><span class="line">        traceback(nums, 0,used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>关键语句在于<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])	continue;</code>，既做到了对同一层上的结点去重，也做到在一棵树枝上对取过的值的去重（全排列的要求，相当于全排列中的used数组）</strong></p>
<h3 id="回溯2-1"><a href="#回溯2-1" class="headerlink" title="回溯2"></a>回溯2</h3><p>另一种做法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt; &amp;used)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;used[i-1]==false)//树层去重</span><br><span class="line">                continue;</span><br><span class="line">            if(used[i]==false)//树枝去重</span><br><span class="line">            &#123;</span><br><span class="line">                used[i]=true;</span><br><span class="line">                vec.push_back(nums[i]);</span><br><span class="line">                traceback(nums,used);</span><br><span class="line">                used[i]=false;</span><br><span class="line">                vec.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;bool&gt; used(nums.size(), false);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        traceback(nums,used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直观的用<code>used</code>数组表示原始数组中的每一个值是否使用过，是对全排列的进一步改进。不只是加上直接加上<strong>排序后再判断当前值与前一值是否相等的</strong>去重操作，为了防止树枝上的多余去重，额外增加了<code>&amp;&amp;used[i-1]==false</code>，限定了只在树层上去重，而不影响树枝上对等值元素的取用</p>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>在全排列的基础上，只增加<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])	continue;</code>语句会导致竖向上首元素会被重复加入（因为i从0开始），而语句本意是跳过横向重复结点和跳过已加入的竖向重复结点，因此，要么选择再增加对跳过竖向结点的限制，如[回溯2](# 回溯2)用额外<code>used</code>数组记录每个元素是否被访问过，如果前一个元素未被访问<code>nums[i-1]==false</code>，且满足当前元素与前一个元素相同<code>i&gt;0 &amp;&amp; nums[i]==nums[i-1]</code>，证明这是在横向上的重复结点（树层），应当跳过，而竖向上如果再次访问访问过的结点<code>used[i]==true</code>，则会执行跳过，不重复加入结果中（另一个角度，如果在满足当前元素与前一个元素相同<code>i&gt;0 &amp;&amp; nums[i]==nums[i-1]</code>时，前一个元素被访问过<code>nums[i-1]==true</code>，此时当前元素也可以被跳过，保留的是横向上的结点，而竖向重复结点被跳过）；要么在<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])	continue;</code>语句不能跳过已加入的竖向重复结点和横向重复结点的情况下，限制加入的重复结点数量如[回溯1](# 回溯1)用<code>used</code>数组记录每一个结点的数量，那么当i从开始时，只会最多加入原数组数量的元素，一旦超过就会被跳过。以上两种算法过程都如下图，</p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%85%A8%E6%8E%92%E5%88%97.png"></p>
<h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a><strong>重新安排行程</strong></h2><h3 id="回溯-10"><a href="#回溯-10" class="headerlink" title="回溯"></a>回溯</h3><p>本题中，关键点在于</p>
<ul>
<li>记录出发机场和目标机场的容器，同时还要记录是否访问过，防止死循环</li>
<li>回溯的终止条件，因为一定存在合理路径，所以机票数+1 &#x3D; 机场数</li>
<li>容器按字典序排列目标机场，若访问字典序较高的目标机场时，该机场是死胡同，则应返回或者回溯</li>
<li>回溯的返回值应该是bool类型，用返回值来判断是否应该回溯（删除死胡同元素）</li>
</ul>
<ol>
<li><p>递归终止条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(tickets.size()==res.size()-1)</span><br><span class="line">&#123;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool traceback(vector&lt;string&gt;&amp;res,vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span><br></pre></td></tr></table></figure>

<p>当返回值为true时，意味着已添加到结果集的元素符合要求，应该直接返回，而不应回溯（删除）；但当返回值为false时，代表着根据字典序优先访问到的这个机场无法再访问其他机场，是个死胡同，应该回溯（pop_back)</p>
</li>
<li><p>递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for(auto const &amp; ticket:tickets[res[res.size()-1]])</span><br><span class="line">&#123;</span><br><span class="line">	if(ticket.second&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		res.push_back(ticket.first);</span><br><span class="line">		ticket.second--;</span><br><span class="line">		if(traceback(res,tickets))	return true;</span><br><span class="line">		ticket.second++;</span><br><span class="line">		res.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure>
<p>上述代码在取目的机场的map时，使用范围for循环，<code>auto &amp;ticket:tickets[res[res.size()-1]]</code>等价于<code>pair&lt;const string,int&gt; &amp;ticket:tickets[res[res.size()-1]]</code>，其中因为map的key值不能改变，所以一定要用const引用，或者只是用副本<code>pair&lt;string,int&gt;ticket:tickets[res[res.size()-1]]</code>。而当不使用范围for循环时，类型符就要更改为<code>map&lt;const string, int&gt;&amp; ticket = tickets[res[res.size()-1]]</code>，因为赋值需要同样的类型或者可转变的类型，而pair不能转变为map</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;</span><br><span class="line">    bool traceback(vector&lt;string&gt;&amp; res, vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span><br><span class="line">    &#123;</span><br><span class="line">        if (res.size() == tickets.size() + 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto&amp; target:targets[res[res.size()-1]])</span><br><span class="line">        &#123;</span><br><span class="line">            if(target.second&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                target.second--;</span><br><span class="line">                res.push_back(target.first);</span><br><span class="line">                if(traceback(res,tickets))return true;</span><br><span class="line">                res.pop_back();</span><br><span class="line">                target.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        res.push_back(&quot;JFK&quot;);</span><br><span class="line">        for (auto ticket : tickets)</span><br><span class="line">        &#123;</span><br><span class="line">            targets[ticket[0]][ticket[1]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        traceback(res, tickets);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="special解法"><a href="#special解法" class="headerlink" title="special解法"></a>special解法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, std::greater&lt;string&gt;&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; stk;</span><br><span class="line"></span><br><span class="line">    void dfs(const string&amp; curr) &#123;</span><br><span class="line">        while (vec.count(curr) &amp;&amp; vec[curr].size() &gt; 0) &#123;</span><br><span class="line">            string tmp = vec[curr].top();</span><br><span class="line">            vec[curr].pop();</span><br><span class="line">            dfs(move(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        stk.emplace_back(curr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;</span><br><span class="line">        for (auto&amp; it : tickets) &#123;</span><br><span class="line">            vec[it[0]].emplace(it[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(&quot;JFK&quot;);</span><br><span class="line"></span><br><span class="line">        reverse(stk.begin(), stk.end());</span><br><span class="line">        return stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>按字典序从<code>priority_queue</code>中访问目标机场，对新访问的机场进行深度有限搜索，并删除访问过的机场，直到该机场是最后一个机场，则添加到数组当中，再不断返回，将之前访问过的机场也添加到数组中，最后将数组逆序即为结果集</p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>该题巧妙选择容器，记录复杂的信息，用<code>unordered_map</code>记录出发机场和目标机场，是因为不需要对出发机场进行排序，为了减少开销，用<code>map&lt;string,int&gt;</code>按字典序记录目标机场及机票数，不使用<code>multiset</code>单纯记录目标机场，就是为了防止同一张机票的重复访问，防止死循环</p>
<p>在第二种解法中，使用不用的容器来记录，通过优先队列来按字典序记录目标机场，每次访问只需要<code>p.top()</code>，访问时间复杂度是O(1)，删除的时间复杂度是O(logm)</p>
<h2 id="破解保险箱"><a href="#破解保险箱" class="headerlink" title="破解保险箱"></a>破解保险箱</h2><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a><strong>N皇后</strong></h2><p>[N皇后](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a>)</p>
<p>要求在<code>n*n</code>的棋盘上放置n个皇后，并且皇后互相不能攻击，即同行同列包括斜角线上不能有两个皇后</p>
<p>逐行遍历棋盘，因为只需要在一行中摆放一个皇后，则不需要两层循环遍历，同时还要有判断是否冲突的函数</p>
<p>首先，根据规则判断在该位置上放置皇后是否会被攻击</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool noattack(vector&lt;string&gt;&amp; chessboard, int n, int index, int row)</span><br><span class="line">&#123;</span><br><span class="line">	//列</span><br><span class="line">	for(int i = 0;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][index] == &#x27;Q&#x27;)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//左上角斜线</span><br><span class="line">	for(int i = row - 1, j = index - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][j] == &#x27;Q&#x27;)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//右上角斜线</span><br><span class="line">	for(int i = row - 1, j = index + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][j] == &#x27;Q&#x27;)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是每一行遍历，因此不需要判断同行是否还有其他皇后；也因为是逐行往下遍历，不需要判断下方是否还有其他皇后，仅判断左上和右上方即可</p>
<h3 id="回溯-11"><a href="#回溯-11" class="headerlink" title="回溯"></a>回溯</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(chessboard.size()==n)</span><br><span class="line">&#123;</span><br><span class="line">	res.push_back(chessboard);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不断添加单行到棋盘中，当棋盘中数量达到n时，就是一个符合要求的棋盘摆法</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void traceback(...)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为可能有多种不同符合规则的摆法，因此返回值为void，遍历所有可能值再返回</p>
</li>
<li><p>确定单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (noattack(chessboard, n,index,i))</span><br><span class="line">    &#123;</span><br><span class="line">        chessboard[index][i] = &#x27;Q&#x27;;</span><br><span class="line">        traceback(res, n, chessboard, index + 1);</span><br><span class="line">        chessboard[index][i] = &#x27;.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对单行棋盘中皇后的摆放位置进行枚举，再递归进入下一行，如果发生相互攻击（遍历完所有值都不符合要求）则进行回溯，不发生攻击则继续递归下一行，直到满足要求</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool noattack(const vector&lt;string&gt;&amp; chessboard, int n, int row, int column)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt;= row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (chessboard[i][column] == &#x27;Q&#x27;)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = row - 1, j = column - 1; i &gt;= 0 &amp;&amp;j &gt;= 0; --i, --j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (chessboard[i][j] == &#x27;Q&#x27;)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = row - 1, j = column + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (chessboard[i][j] == &#x27;Q&#x27;)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void traceback(vector&lt;vector&lt;string&gt;&gt;&amp; res, int n, vector&lt;string&gt;&amp; chessboard, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index &gt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(chessboard);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (noattack(chessboard, n,index,i))</span><br><span class="line">            &#123;</span><br><span class="line">                chessboard[index][i] = &#x27;Q&#x27;;</span><br><span class="line">                traceback(res, n, chessboard, index + 1);</span><br><span class="line">                chessboard[index][i] = &#x27;.&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; chessboard(n, string(n, &#x27;.&#x27;));</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        traceback(res, n, chessboard, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>该题的关键点在于</p>
<ul>
<li>不需要两层循环，虽然是二维棋盘，但N皇后中不需要在二维棋盘的每一个点上都要放置皇后，仅是<strong>判断当前的点是否能放，因此使用单层循环</strong></li>
<li>回溯不需要返回值，是因为要寻找<strong>所有可行的棋盘摆放</strong>，应当<strong>用全局变量或者引用返回</strong>，同时要遍历所有情况；若只需要找到<strong>一种可行的棋盘</strong>，则返回值应为**<code>bool</code><strong>，一旦找到则</strong>返回<code>true</code>退出递归**</li>
<li>不需要对同行皇后进行判断，是因为对<strong>同行位置进行遍历时，肯定不会发生同一行同时有两个皇后出现</strong>，一旦某一个位置能够摆放皇后，就会马上<strong>进入到下一层递归</strong>，即到下一行的遍历，而后面回溯回本行时，又会将原位置的皇后删除，再从下一位进行遍历</li>
</ul>
<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a><strong>解数独</strong></h2><p>[解数独](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a>)</p>
<p>与上题<a href="#N%E7%9A%87%E5%90%8E">N皇后</a>相比，解数独也是在一个二维棋盘上，但不仅要判断该点是否会有冲突，还要在遍历时在每个点上都要填充数字，也就是说，不能像上题一样，如果是单层循环，填完该位置上的数字就进入递归，遍历下一行。因此需要两层循环，填完数字后进入递归，还是从刚填过的位置开始继续填。</p>
<p>同样，首先需要根据规则判断是否有冲突</p>
<ul>
<li>同行不能有重复数字</li>
<li>同列不能有重复数字</li>
<li>同一个3x3格子不能有重复数字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool ok(vector&lt;vector&lt;char&gt;&gt; &amp; chessboard,int row, int col, int tmp)</span><br><span class="line">&#123;</span><br><span class="line">	//判断列</span><br><span class="line">	for(int i = row;i&lt;9;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][col]==tmp+&#x27;0&#x27;)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//判断行</span><br><span class="line">	for(int j = 0;j&lt;9;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[row][j]==tmp+&#x27;0&#x27;)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//判断9宫格</span><br><span class="line">	int subrow = (row / 3) * 3;	//0,1,2行等于0, 3,4,5行等于3，6,7,8行等于6</span><br><span class="line">	int subcol = (col / 3) * 3;	</span><br><span class="line">	for(int i = subrow; i &lt; subrow + 3; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j = subcol; j &lt; subcol + 3; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(board[i][j]==tmp+&#x27;0&#x27;)</span><br><span class="line">				return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，需要多次的循环来完成一次的判断。则可以用哈希表的方法，先储存已有的数字，然后在一次循环完成冲突的判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//全局变量</span><br><span class="line">int row[9][10] &#123;0&#125;;</span><br><span class="line">int col[9][10] &#123;0&#125;;</span><br><span class="line">int subbox[9][10] &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">//先完成对棋盘上已有数字的存储</span><br><span class="line">for(int i = 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">	for(int j = 0; j &lt; 9; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][j]!=&#x27;.&#x27;)</span><br><span class="line">		&#123;</span><br><span class="line">			int tmp = chessboard[i][j]-&#x27;0&#x27;;</span><br><span class="line">			row[i][tmp] = 1;</span><br><span class="line">			col[j][tmp] = 1;</span><br><span class="line">			subbox[j/3 + (i/3)*3][tmp] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ok(int i, int j, int tmp)</span><br><span class="line">&#123;</span><br><span class="line">	if(row[i][tmp]==1)</span><br><span class="line">		return false;</span><br><span class="line">	if(col[j][tmp]==1)</span><br><span class="line">		return false;</span><br><span class="line">	if(subbox[j/3+(i/3)*3][tmp]==1)</span><br><span class="line">		return false;</span><br><span class="line">	row[i][tmp] = 1;</span><br><span class="line">	col[j][tmp] = 1;</span><br><span class="line">	subbox[j/3+(i/3)*3][tmp] = 1;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将三种规则分别替换为三个用二维数组记录的哈希表，行表（row）用第一维表示对应的行数，用第二维表示该行上出现过的数字<code>0-9</code>，如果出现过则置为1，列表（col）同理；由于9宫格中刚好有九个数字，也可以用同样的方法来记录，将棋盘上行列号映射为9个不同的9宫格序号，再记录出现过的数字</p>
<h3 id="回溯-12"><a href="#回溯-12" class="headerlink" title="回溯"></a>回溯</h3><ol>
<li><p>确定递归结束条件</p>
<p>因为结束时，总是需要遍历棋盘上所有位置，当遍历结束也就是递归的结束，因此不需要递归的结束条件</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool traceback(vector&lt;vector&lt;char&gt;&gt;&amp; chessboard, int row, int col)</span><br></pre></td></tr></table></figure>

<p>因为只需要寻找到一种符合的答案，一旦遇到有，则应立即退出递归并返回</p>
</li>
<li><p>递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;9;i++)</span><br><span class="line">&#123;</span><br><span class="line">	for(int j = 0;j&lt;9;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][j]==&#x27;.&#x27;)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int tmp = 1;tmp&lt;10;tmp++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(ok(i,j,tmp))</span><br><span class="line">				&#123;</span><br><span class="line">					chessboard[i][j]=tmp+&#x27;0&#x27;;</span><br><span class="line">					if(traceback(chessboard)) return true;</span><br><span class="line">					chessboard[i][j]=&#x27;.&#x27;;</span><br><span class="line">					row[i][tmp] = 0;</span><br><span class="line">					col[j][tmp] = 0;</span><br><span class="line">					subbox[j/3+(i/3)*3][tmp] = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int row[9][10] = &#123;0&#125;,column[9][10] = &#123;0&#125;, subbox[9][10] = &#123;0&#125;;</span><br><span class="line">    bool ok(int i, int j, int tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        if(row[i][tmp]==1)</span><br><span class="line">            return false;</span><br><span class="line">        if(column[j][tmp]==1)</span><br><span class="line">            return false;</span><br><span class="line">        if(subbox[j/3+(i/3)*3][tmp]==1)</span><br><span class="line">            return false;</span><br><span class="line">        row[i][tmp] = 1;</span><br><span class="line">        column[j][tmp] = 1;</span><br><span class="line">        subbox[j/3+(i/3)*3][tmp] = 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool traceback(vector&lt;vector&lt;char&gt;&gt;&amp; board)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 0;i&lt;9;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0;j&lt;9;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(board[i][j]==&#x27;.&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    for(int tmp = 1;tmp&lt;10;tmp++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if(ok(i,j,tmp))</span><br><span class="line">                        &#123;</span><br><span class="line">                            board[i][j] = tmp+&#x27;0&#x27;;</span><br><span class="line">                            if(traceback(board)) return true;</span><br><span class="line">                            board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                            row[i][tmp] = 0;</span><br><span class="line">                            column[j][tmp] = 0;</span><br><span class="line">                            subbox[j/3+(i/3)*3][tmp] = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        for(int i = 0;i&lt;9;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0;j&lt;9;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(board[i][j]!=&#x27;.&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    int tmp = board[i][j]-&#x27;0&#x27;;</span><br><span class="line">                    row[i][tmp] = 1;</span><br><span class="line">                    column[j][tmp] = 1;</span><br><span class="line">                    subbox[j/3+(i/3)*3][tmp] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        traceback(board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>该题的关键点在于</p>
<ul>
<li>递归中需要用双层循环，<strong>如果单层循环，则在该行填入一个数字之后进入递归，不管传入怎样的参数都不能使继续填充该行并且完成换行继续填充</strong></li>
<li>递归不需要结束条件，因为题目需要对棋盘上所有点都进行一次遍历，递归结束时就是得到结果时，即遍历结束即为递归结束</li>
<li>递归需要返回值，题目保证能找到一个有效的解决方案，且最多只有一个解，因此返回bool值，当找到时，即遍历完棋盘，就返回true；当在棋盘上某一个点遍历完9个数字都没有合适结果时，应当返回false，令上一层递归进行回溯。也就是说，有返回值如bool类型，可以通过判断返回值（如果为真）可以避免进一步递归，同时还能让进入多余分支的递归及时退出，防止了死循环（如本题，在没有递归结束条件的情况下，如果不用返回值限制则会导致死循环）；而无返回值的通常是要遍历所有分支，从中找到所有解</li>
<li>一次循环即可完成对数独是否有效的判断，借助哈希表，将一维的数据通过二维的哈希表进行重复性判断</li>
</ul>
<h2 id="最接近目标价格的甜点成本"><a href="#最接近目标价格的甜点成本" class="headerlink" title="最接近目标价格的甜点成本"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/closest-dessert-cost/">最接近目标价格的甜点成本</a></h2><p>该题要求从必选数组<code>base</code>中选择一份基料，以及从可选数组<code>topping</code>中选择0份、1份或者2份配料，组成的冰淇淋总价格最接近<code>target</code>且成本最低</p>
<h3 id="回溯-13"><a href="#回溯-13" class="headerlink" title="回溯"></a>回溯</h3><p>容易想到，给定数据量较少，可以用回溯算法对数组进行遍历，用<code>set</code>保存可行的方案，并最终选择最合适的一个价格返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    set&lt;int&gt; vec;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; toppingCosts, int target, int index, int res)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index == toppingCosts.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt; toppingCosts.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += toppingCosts[i];</span><br><span class="line">            vec.insert(res);</span><br><span class="line">            traceback(toppingCosts, target, i + 1, res);</span><br><span class="line">            res += toppingCosts[i];</span><br><span class="line">            vec.insert(res);</span><br><span class="line">            traceback(toppingCosts, target, i + 1, res);</span><br><span class="line">            res -= toppingCosts[i] * 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int closestCost(vector&lt;int&gt;&amp; baseCosts, vector&lt;int&gt;&amp; toppingCosts, int target) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        //int m = toppingCosts.size();</span><br><span class="line">        //for (int i = 0; i &lt; m; i++)</span><br><span class="line">        //&#123;</span><br><span class="line">        //    toppingCosts.push_back(toppingCosts[i]);</span><br><span class="line">        //&#125;</span><br><span class="line">        for (int i = 0; i &lt; baseCosts.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = baseCosts[i];</span><br><span class="line">            vec.insert(res);</span><br><span class="line">            traceback(toppingCosts, target, 0, res);</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        for (auto it: vec)</span><br><span class="line">        &#123;</span><br><span class="line">            if (abs(target - it) &lt; abs(ans - target))</span><br><span class="line">                ans = it;</span><br><span class="line">            else if(abs(target - it == abs(ans-target)))</span><br><span class="line">                ans = it &lt; ans? it:ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><del>因为最多可以添加两份配料，则将原数组<code>topping</code>中的元素都复制一遍，再进行回溯</del>，但会超时</p>
<p>则可以对数组<code>topping</code>中的同一个元素进行两次回溯递归，分别将一份和两份配料的价格传递到递归当中</p>
<p>无论价格是多少，都会被存入到<code>set</code>当中，因为难以在存入结果之前对结果的合法性进行判断，所以只能被动地存入所有结果，最后在遍历所有结果的时候，选取最合适的结果</p>
<h3 id="回溯优化-4"><a href="#回溯优化-4" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>优化在只需要用O(1)的空间存储结果，存储的不再是所有结果，而是最合适的结果，并对其进行维护</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int ans = INT_MAX;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; toppingCosts, int target, int index, int res)</span><br><span class="line">    &#123;</span><br><span class="line">        if (abs(target-ans) &gt; abs(res-target))</span><br><span class="line">            ans = res;</span><br><span class="line">        if(abs(target-ans) == abs(res-target) &amp;&amp; res &lt; ans )</span><br><span class="line">            ans = res;</span><br><span class="line">        if(res &gt; target)</span><br><span class="line">            return;</span><br><span class="line">        for (int i = index; i &lt; toppingCosts.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            traceback(toppingCosts, target, i + 1, res + toppingCosts[i]);</span><br><span class="line">            traceback(toppingCosts, target, i + 1, res+ 2 * toppingCosts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int closestCost(vector&lt;int&gt;&amp; baseCosts, vector&lt;int&gt;&amp; toppingCosts, int target) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; baseCosts.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = baseCosts[i];</span><br><span class="line">            traceback(toppingCosts, target, 0, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><strong>回溯算法的题目要注意回溯参数<code>i</code>与 <code>index</code>，如果是<code>i</code>，则是允许元素重复加入结果集，在本题中，使用<code>i</code>作为参数传递而不是<code>i+1</code>，则意味着可以使用任意数量的配料<code>topping</code>，不符合题意；添加元素到结果集时，向递归函数传递的参数永远都是<code>i</code>而不是<code>index</code></strong></p>
<p><strong>因为有必选数组和可选数组的存在，对必选数组进行<code>for</code>循环遍历，再进行回溯，保证结果集中有必选数组的元素；而必选数组中又可以对不同数量的元素重复使用（同一个元素最多两次），则可以通过两次回溯调用来实现</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/10/18/C3P%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/18/C3P%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C3P阅读笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-18 16:13:20" itemprop="dateCreated datePublished" datetime="2022-10-18T16:13:20+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-16 14:32:04" itemprop="dateModified" datetime="2022-11-16T14:32:04+08:00">2022-11-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="第二章——变量和基本类型"><a href="#第二章——变量和基本类型" class="headerlink" title="第二章——变量和基本类型"></a>第二章——变量和基本类型</h2><h3 id="char类型及其扩展"><a href="#char类型及其扩展" class="headerlink" title="char类型及其扩展"></a>char类型及其扩展</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody><tr>
<td><code>char</code></td>
<td>字符</td>
<td>8bit</td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td>宽字符</td>
<td>16bit</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>Unicode字符</td>
<td>16bit</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>Unicode字符</td>
<td>32bit</td>
</tr>
</tbody></table>
<p><code>wchar_t</code>确保可以存放机器最大扩展字符集中的任一个字符，char16_t和char32_t为Unicode字符集服务</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>如果赋予一个取值区间之外的值，如<code>unsigned char</code>（8bit）表示0-255，赋予-2，则-2对256取模后的余数，实际结果为254(数据类型所占位数而定)</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>默认的，整形字面值数据类型是带符号数，即<code>int</code>；浮点型默认数据类型为<code>double</code>，因为float精度不够且双精度浮点数计算代价与单精度差不多；字符串字面值结尾处会多一个空字符<code>\0</code>，字符串字面值的实际长度要比它的内容多1；若两个字符串字面值位置紧邻且仅由<em><strong>空格、缩进和换行符</strong></em>分割时，实际上是一个整体</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n 换行符		\t 横向制表符		\v 纵向制表符		\b 退格符		\r 回车符(清空当前行并回到行首)</span><br></pre></td></tr></table></figure>

<p>如果反斜线后的八进制数字超过三个，只有前三个与反斜线构成转义序列；如果跟着十六进制数字，则所有十六进制数字都参与构成转义序列</p>
<h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><table>
<thead>
<tr>
<th>前缀&#x2F;后缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>Unicode16字符</td>
<td><code>char16_t</code></td>
</tr>
<tr>
<td>U</td>
<td>Unicode32字符</td>
<td><code>char32_t</code></td>
</tr>
<tr>
<td>L</td>
<td>宽字符</td>
<td><code>wchar_t</code></td>
</tr>
<tr>
<td>u8</td>
<td>UTF-8</td>
<td><code>char</code></td>
</tr>
<tr>
<td>整型后缀</td>
<td></td>
<td></td>
</tr>
<tr>
<td>u&#x2F;U</td>
<td>无符号型</td>
<td><code>unsigned</code></td>
</tr>
<tr>
<td>l&#x2F;L</td>
<td></td>
<td><code>long</code></td>
</tr>
<tr>
<td>ll&#x2F;LL</td>
<td></td>
<td><code>long long</code></td>
</tr>
<tr>
<td>浮点型后缀</td>
<td></td>
<td></td>
</tr>
<tr>
<td>f&#x2F;F</td>
<td></td>
<td><code>float</code></td>
</tr>
<tr>
<td>l&#x2F;L</td>
<td></td>
<td><code>long double</code></td>
</tr>
</tbody></table>
<p>整型字面值不能添加浮点型后缀F</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>如果使用列表初始化且初始值存在信息丢失的风险，则会报错，如<code>int a = &#123;3.14&#125;</code></p>
<ol>
<li>在任何函数体之外的变量会被初始化为0</li>
<li>在函数体内部的内置型变量不会被初始化，其未定义，不可被访问</li>
<li>类不初始化则由类自己定义</li>
</ol>
<p>变量声明规定了变量的类型和名字，定义则为其开辟空间</p>
<p>变量声明：在变量名前添加关键字 <code>extern</code>，如<code>extern int i;</code>。但如果包含了初始值，就变成了定义：<code>extern double pi = 3.14;</code></p>
<p>变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。</p>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>同时存在全局和局部变量时，已定义局部变量的作用域中可用<code>::reused</code>显式访问全局变量reused。</p>
<h3 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h3><p>引用类型的初始值必须是一个<em><strong>对象</strong></em>（不能是字面值），必须在定义时给引用赋初值</p>
<p>指针本身就是一个对象，可以不赋初值</p>
<p>引用自加——引用的对象加一</p>
<p>指针自加——指针指向下一个类型，即向后偏移一个类型的大小</p>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a><code>void*</code>指针</h3><p>可以存放任意对象的地址，但不能访问对象</p>
<ol>
<li>与其它指针比较</li>
<li>当做函数的输入或输出</li>
<li>赋值给另一个<code>void*</code>指针</li>
</ol>
<h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3><p><code>int i = 0; </code></p>
<p><code>int* b = &amp;i; </code></p>
<p><code>int * &amp; a = b;</code></p>
<p><code>i</code>是整型变量，<code>b</code>是指向整型变量<code>i</code>的整型指针，<code>a</code>是指向整型指针<code>b</code>的整型引用</p>
<p><code>*a = 1;</code>通过引用对整型变量进行访问和修改</p>
<h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a><code>const</code>限定符</h3><p><code>const</code>对象一旦创建就不能被修改，因此在定义时必须赋初值</p>
<p><code>const int ci = 0; int i = ci; </code>	<code>const</code>的常量特征只在被修改时显示，因此可以用常量值赋初值</p>
<h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a><code>const</code>的引用</h3><p>即为对常量的引用，且无法对引用对象进行修改(常量引用)</p>
<p><code>const int ci = 30; const int &amp; cr = ci</code></p>
<p>则<code>cr</code>为对<code>ci</code>的常量引用</p>
<p>常量引用初始化时能够用字面值赋值，而引用不能，且能够用任意表达式进行初始化</p>
<p><code>const</code>引用的也可以不是常量，因为引用对象本身不是常量，即时不能通过引用修改对象，但能通过其他途径来修改。</p>
<h3 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a><em><strong>常量指针和指针常量</strong></em></h3><p><code>const int ci = 30; int const* cptr =&amp;ci;</code> 则<code>cptr</code>为指向常量的<code>int</code>指针，且因为其是指针，可以不用初始化</p>
<p>常量指针指向的也可以不是常量，只是不能通过指针改变对象的值，但仍可以通过其他途径修改。底层<code>const</code></p>
<p><code>const int ci = 30; const int *const ptrc = &amp;ci;</code>则<code>ptrc</code>为指针常量，是一个指向整型常量的<code>const int</code>指针常量</p>
<p><code>int i = 30; int *const ptri = &amp;i;</code>则<code>prti</code>为指针常量，是一个指向整型字面量的<code>int</code>指针常量。顶层<code>const</code></p>
<p>相同地，指针常量指向的也可以不是常量，只是不能更改指针常量本身的指向，但仍可以通过其他途径修改对象的值</p>
<h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>声明为<code>constexpr</code>的变量一定是一个常量（顶层<code>const</code>），且必须用常量表达式初始化。一个<code>constexpr</code>指针的初始值必须为0或者<code>nullptr</code>或者是存在某个固定地址的对象；定义于所有函数体之外的对象其地址固定不变，此时能用于初始化<code>constexpr</code>指针。</p>
<p><code>constexpr int *q = nullptr</code>则q为指向整数的指针常量</p>
<h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a><em><strong>处理类型</strong></em></h3><p><code>using SI = Sales_item;</code> 类型别名</p>
<p><code>typedef char *pstring; </code>			<code>pstring</code>为<code>char*</code>类型，指向<code>char</code>类型的指针</p>
<p> <code>const pstring cstr = 0; </code>			<code>cstr</code>为指向<code>char</code>的指针常量，注意与下一个式子的区别</p>
<p> <code>const char *cstr = 0; </code>				<code>cstr</code>为指向<code>char</code>的常量指针</p>
<p><code>decltype</code>返回表达式结果或变量对应的类型；如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型；如果表达式或者变量加多一层括号，则也将得到引用类型</p>
<p><code>const int ci = 0;decltype(ci) x = 0</code>则x的类型为<code>const int</code></p>
<p><code>int i = 30; decltype(*p) c = i</code>则p的类型为引用类型</p>
<p><code>decltype ((i)) d = i</code>则d的类型也为引用类型</p>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><ul>
<li><code>#indef</code>已定义时为真</li>
<li><code>#inndef</code>未定义时为真</li>
<li>头文件保护符的名称需要唯一，且保持全部大写。养成良好习惯，不论是否该头文件被包含，要加保护符。</li>
</ul>
<h2 id="第三章——字符串、向量和数组"><a href="#第三章——字符串、向量和数组" class="headerlink" title="第三章——字符串、向量和数组"></a>第三章——字符串、向量和数组</h2><h3 id="string对象"><a href="#string对象" class="headerlink" title="string对象"></a>string对象</h3><p>如果提供一个字符串字面值给string对象初始化，则该字面值中除了最后的空字符其他所有字符都被拷贝到string对象</p>
<ul>
<li><p>string io：</p>
<ul>
<li><code>string word; cin&gt;&gt;word</code>忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止</li>
<li><code>string word; while(cin&gt;&gt;word)</code>读取到文件结束符或非法输入时停止 Ctrl+Z</li>
<li><code>getline</code>：读取一整行，<strong>包括空白符</strong>，直到换行符，但不会将换行符存到string对象中</li>
<li>string line; while(getline(cin,line))</li>
</ul>
</li>
<li><p><code>s.size()</code>返回的时<code>string::size_type</code>类型，记住是一个<strong>无符号</strong>类型的值，不要和<code>int</code>混用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void check (size_type i, const string &amp;msg) const</span><br><span class="line">&#123;</span><br><span class="line">	if(i&gt;=data-&gt;size())</span><br><span class="line">		throw out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line">当i小于0，会自动转换成正整数，即i = i + UINT_MAX;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>s1+s2</code>使用时，保证至少一侧是string类型。<code>string s1 = &quot;hello&quot; + &quot;world&quot; // 错误，两侧均为字符串字面值</code></p>
</li>
</ul>
<p><code>cctype</code>头文件中的标准函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>isalnum(c)</code></td>
<td>当<code>c</code>是字母或数字时为真</td>
</tr>
<tr>
<td><code>isalpha(c)</code></td>
<td>当<code>c</code>是字母时为真</td>
</tr>
<tr>
<td><code>iscntrl(c)</code></td>
<td>当<code>c</code>是控制字符时为真</td>
</tr>
<tr>
<td><code>isdigit(c)</code></td>
<td>当<code>c</code>是数字时为真</td>
</tr>
<tr>
<td><code>isgraph(c)</code></td>
<td>当<code>c</code>不是空格但可以打印时为真</td>
</tr>
<tr>
<td><code>islower(c)</code></td>
<td>当<code>c</code>是小写字母时为真</td>
</tr>
<tr>
<td><code>isprint(c)</code></td>
<td>当<code>c</code>是可打印字符时为真</td>
</tr>
<tr>
<td><code>ispunct(c)</code></td>
<td>当<code>c</code>是标点符号时为真</td>
</tr>
<tr>
<td><code>isspace(c)</code></td>
<td>当<code>c</code>是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</td>
</tr>
<tr>
<td><code>isupper(c)</code></td>
<td>当<code>c</code>是大写字母时为真</td>
</tr>
<tr>
<td><code>isxdigit(c)</code></td>
<td>当<code>c</code>是十六进制数字时为真</td>
</tr>
<tr>
<td><code>tolower(c)</code></td>
<td>当<code>c</code>是大写字母，输出对应的小写字母；否则原样输出<code>c</code></td>
</tr>
<tr>
<td><code>toupper(c)</code></td>
<td>当<code>c</code>是小写字母，输出对应的大写字母；否则原样输出<code>c</code></td>
</tr>
</tbody></table>
<h3 id="vector对象"><a href="#vector对象" class="headerlink" title="vector对象"></a>vector对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v1(10);		//v1中有10个元素，默认值为0</span><br><span class="line">vector&lt;int&gt; v2&#123;10&#125;;		//v2中有1个元素，值为10</span><br></pre></td></tr></table></figure>

<p>如果初始化用的是圆括号，则提供的值是用来构造vector对象；</p>
<p>如果初始化用的是花括号，则表示列表初始化vector对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v3&#123;10&#125;;		//v3中有10个元素，默认值为空</span><br></pre></td></tr></table></figure>

<p>当初始化用了花括号的形式，但提供的值又无法列表初始化，则编译器会尝试用默认值初始化vector对象</p>
<p>因为范围for循环语句内不应改变其所遍历序列的大小，因此不能用范围for循环向vector添加元素</p>
<p>size返回值的类型是由vector定义的size_type类型即<code>vector&lt;int&gt;::size_type</code></p>
<p>用下标访问vector，下标类型应是size_type类型，可以通过<code>auto</code>或者<code>decltype</code>获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(decltype(ivec.size()) index=0;index&lt;=10;index++)</span><br><span class="line">	ivec.push_back(ix);</span><br></pre></td></tr></table></figure>

<pre><code>### vector迭代器
</code></pre>
<p><code>*iter.mem</code>等同于<code>iter-&gt;mem</code></p>
<p><code>vector&lt;int&gt;::iterator it1; </code>					&#x2F;&#x2F;<code>it1</code>能够读写元素</p>
<p><code>vector&lt;int&gt;::const_iterator it2;</code>			&#x2F;&#x2F;it2只能读元素，不能写</p>
<p>两个迭代器之间的运算只有减法运算，返回值类型为<code>difference_type</code></p>
<p><code>difference_type</code>返回带符号整数，所得结果是右侧迭代器向前移动能追上左侧迭代器的距离</p>
<p>迭代器与整数值之间有加法运算</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的大小确定不变，不能随意向数组中增加元素</p>
<p>数组声明时，其中维度必须是<em><strong>常量表达式</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unsigned cnt = 30;</span><br><span class="line">constexpr unsigned sz = 30;</span><br><span class="line">int arr[30];			//正确</span><br><span class="line">int arr[cnt];			//报错，cnt不是常量表达式</span><br><span class="line">int ve[sz];				//正确</span><br></pre></td></tr></table></figure>

<p><em><strong>字符数组在用字符串字面值初始化时，会自动添加表示字符串结束的空字符</strong></em></p>
<p><em><strong>不允许数组拷贝初始化，也不允许用数组给其他数组赋值</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;0, 1, 2&#125;;</span><br><span class="line">int a2[] = a;			//报错，不允许数组拷贝初始化</span><br><span class="line">a2 = a;					//报错，不允许用数组赋值</span><br></pre></td></tr></table></figure>



<p>数组下标类型为<code>size_t</code>（头文件cstddef），而vector和string的下标类型为<code>size_type</code></p>
<h3 id="复杂数组"><a href="#复杂数组" class="headerlink" title="复杂数组"></a>复杂数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *ptrs[10];</span><br><span class="line">int (*parray)[10]=&amp;arr;</span><br><span class="line">int (&amp;array)[10]=arr;</span><br></pre></td></tr></table></figure>

<p><code>ptrs</code>是一个数组，包含了10个整型指针——指针数组</p>
<p> <code>parray</code>是一个指针，指向一个有10个整型元素的数组——数组指针</p>
<p><code>array</code>是一个引用，引用对象是一个有10个整型元素的数组</p>
<p><code>int *(&amp;array)[10]=ptrs</code>则是一个引用，引用对象是一个有10个整型指针的数组</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>数组名就是数组首元素的指针</p>
<p><code>string *p2=nums;		//等价于p2 = &amp;nums[0];</code></p>
<p>auto可以推断数组名得到指针类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ia[] = &#123;0,1,2,3,4&#125;;</span><br><span class="line">auto ia2(ia);			//ia2是一个指针，指向数组ia首元素</span><br><span class="line">auto ia3(&amp;ia[0]);		//同上</span><br></pre></td></tr></table></figure>

<p>但当用decltype时则不一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(ia) ia4;		//获取到的是ia的数组类型，即ia4是一个整型数组</span><br></pre></td></tr></table></figure>

<h3 id="数组的库函数"><a href="#数组的库函数" class="headerlink" title="数组的库函数"></a>数组的库函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iterator&gt;</span><br><span class="line">int ia[] = &#123;0,1,2,3,4&#125;;</span><br><span class="line">int *beg = begin(ia);		//beg指向首元素</span><br><span class="line">int *last = end(ia);		//last指向尾元素</span><br></pre></td></tr></table></figure>

<p>当两个数组指针相减时，返回的类型为<code>ptrdiff_t</code>；vector和string返回的类型为<code>difference_type</code>，都是一种带符号类型</p>
<p>数组下标可以是负数，而vector的下标只能是正整数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p = &amp;ia[2];			//p指向数组第三个元素</span><br><span class="line">int j = p[-2];				//指向数组ia的首元素</span><br></pre></td></tr></table></figure>

<h3 id="C风格的字符串-不推荐使用"><a href="#C风格的字符串-不推荐使用" class="headerlink" title="C风格的字符串(不推荐使用)"></a>C风格的字符串(不推荐使用)</h3><p>会在字符串最后一个字符后面跟着一个空字符(<code>\0</code>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char ca[] = &#123;&#x27;k&#x27;,&#x27;e&#x27;,&#x27;v&#x27;,&#x27;\0&#x27;&#125;;</span><br><span class="line">const char ca1[] = &quot;hello&quot;;</span><br></pre></td></tr></table></figure>

<p>C标准库String函数，定义在<code>&lt;cstring&gt;</code> 中：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><code>strlen(p)</code></td>
<td>返回<code>p</code>的长度，空字符不计算在内</td>
</tr>
<tr>
<td><code>strcmp(p1, p2)</code></td>
<td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td>
</tr>
<tr>
<td><code>strcat(p1, p2)</code></td>
<td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td>
</tr>
<tr>
<td><code>strcpy(p1, p2)</code></td>
<td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code></td>
</tr>
</tbody></table>
<p>C风格字符串不支持运算符操作，如<code>+,-,==</code>，因为操作的是指针而非字符串本身，并无意义</p>
<h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><p>允许使用string对象给C风格字符串初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;hello!&quot;;</span><br><span class="line">const char *str = s.c_str();	//c_str()返回一个C风格的字符串，即一个指针，并在数组最后加上空字符结束</span><br></pre></td></tr></table></figure>

<p>使用数组给vector初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ia[] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">vector&lt;int&gt; vec(begin(ia),end(ia));</span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>数组的数组，由内而外的顺序理解</p>
<p>使用范围for循环访问多维数组时，外层循环需要使用引用类型，这是为了在内层循环数组被自动转成指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ia[] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">for(const auto &amp;row: ia)</span><br><span class="line">&#123;</span><br><span class="line">	for(auto col:row)</span><br><span class="line">		cout &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果不加引用</span><br><span class="line">for(auto row: ia)</span><br><span class="line">	for(auto col:row)</span><br><span class="line">		//此时row转成指针，类型为int* 因此在内层循环时就会报错</span><br></pre></td></tr></table></figure>

<p>利用别名代替，使多维数组降维访问</p>
<p><code>using int_array int[4];	</code></p>
<p><code>typedef int int_array[4];</code></p>
<p>编写3个不同版本的程序，令其均能输出<code>ia</code>的元素。<br>版本1使用范围<code>for</code>语句管理迭代过程；版本2和版本3都使用普通<code>for</code>语句，其中版本2要求使用下标运算符，版本3要求使用指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cout; using std::endl;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[3][4] = </span><br><span class="line">    &#123; </span><br><span class="line">        &#123; 0, 1, 2, 3 &#125;,</span><br><span class="line">        &#123; 4, 5, 6, 7 &#125;,</span><br><span class="line">        &#123; 8, 9, 10, 11 &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">	//范围for</span><br><span class="line">    for(auto&amp; p:arr)</span><br><span class="line">    	for(auto q:p)</span><br><span class="line">    		cout &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    //范围for</span><br><span class="line">    for(const int (&amp;p)[4]:arr)</span><br><span class="line">    	for(int q:p)</span><br><span class="line">    		cout &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">    		</span><br><span class="line">    //下标for</span><br><span class="line">    for(size_t i = 0; i &lt; arr.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	for(size_t j = 0; j&lt;arr[0].size(); j++)</span><br><span class="line">    		cout &lt;&lt; arr[i][j] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //指针for</span><br><span class="line">    for(int *p = begin(arr); p! = end(arr); p++)</span><br><span class="line">    &#123;</span><br><span class="line">    	for(int *q = begin(*p);q!= end（*p);q++)</span><br><span class="line">    		cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //指针for</span><br><span class="line">    for(int(*p)[4]=arr;p &lt; arr.size();p++)</span><br><span class="line">    	for(int *q = *p;q &lt; arr[0].size();q++)</span><br><span class="line">    		cout &lt;&lt; *q &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第四章——表达式"><a href="#第四章——表达式" class="headerlink" title="第四章——表达式"></a>第四章——表达式</h2><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>当一个对象被用作左值时，使用的是对象的身份（在内存中的位置）；</p>
<p>当一个对象被用作右值时，使用的是对象的值</p>
<p>解引用符返回的结果是左值</p>
<p>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype(*p);		//返回引用类型int&amp;</span><br><span class="line">decltype(&amp;p);		//返回指针类型int**，即指向整型指针的指针</span><br></pre></td></tr></table></figure>

<p>表达式的结果是左值，decltype得到引用类型；表达式的结果是右值，decltype得到指针类型</p>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>运算对象和运算结果都是右值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool b = true;</span><br><span class="line">bool b2 = -b;		//b2依然为true</span><br></pre></td></tr></table></figure>

<p>参与取余运算的运算对象都为整数类型</p>
<p><code>(-m)/n,m/(-n)</code>结果都为<code>-(m/n)</code></p>
<p><code>m%(-n)</code>结果为<code>m%n</code>，<code>(-m)%n</code>结果为<code>-(m%n)</code></p>
<p>逻辑和关系运算符运算对象和运算结果都是右值</p>
<h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p>前置递增运算符将对象本身作为左值返回，后置递增则将对象原始值的副本作为右值返回。后置需要将原始值存储下来以便返回这个未修改的内容，如果不需要修改前的值，应直接使用前置递增</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto iter = vi.begin();</span><br><span class="line">while (iter!=vi.end()&amp;&amp;*iter&gt;=0)</span><br><span class="line">	cout&lt;&lt;*iter++&lt;&lt;endl;	// 输出当前值，指针向前移1</span><br></pre></td></tr></table></figure>

<p>后置递增运算符高于解引用运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec[ival++]&lt;=vec[ival];		//表达式未定义,应改为</span><br><span class="line">vec[ival]&lt;=vec[ival+1];</span><br></pre></td></tr></table></figure>

<p>不应在运算符左右两边都用到一个变量，并且右侧还改变其值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while(beg!=s.end() &amp;&amp; !isspace(*beg))</span><br><span class="line">	*beg = toupper(*beg++);			//未定义</span><br></pre></td></tr></table></figure>



<p>假设<code>iter</code>的类型是<code>vector::iterator</code>, 说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(a) *iter++;</span><br><span class="line">(b) (*iter)++;</span><br><span class="line">(c) *iter.<span class="built_in">empty</span>();</span><br><span class="line">(d) iter-&gt;<span class="built_in">empty</span>();</span><br><span class="line">(e) ++*iter;</span><br><span class="line">(f) iter++-&gt;<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>

<p>解：</p>
<ul>
<li>(a)合法。返回迭代器所指向的元素，然后迭代器递增。</li>
<li>(b)不合法。因为<code>vector</code>元素类型是<code>string</code>，没有<code>++</code>操作。</li>
<li>(c)不合法。这里应该加括号。</li>
<li>(d)合法。判断迭代器当前的元素是否为空。</li>
<li>(e)不合法。<code>string</code>类型没有<code>++</code>操作。</li>
<li>(f)合法。判断迭代器当前元素是否为空，然后迭代器递增。</li>
</ul>
<h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><ul>
<li>对引用类型执行sizeof运算得到引用对象的类型大小</li>
<li>对解引用指针类型执行sizeof运算得到指针指向对象的类型大小，指针可以不有效</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，而不会把数组转换成指针</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，与对象中元素个数或所占空间大小无关</li>
</ul>
<p>通过查看STL源码可以看到vector有四个成员变量<br>   _A  allocator; </p>
<p>   iterator  _First,  _Last,  _End; </p>
<p>所以<code>sizeof(vec)</code>会返回4个字节即16bit</p>
<h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><p>隐式转换</p>
<ul>
<li><p>常见的char、bool、short能存在int就会转换成int，否则提升为<code>unsigned int</code></p>
</li>
<li><p><code>wchar_t,char16_t,char32_t</code>提升为整型中<code>int,long,long long ……</code>最小的，且能容纳原类型所有可能值的类型</p>
</li>
<li><p>当数组被用作<code>decltype</code>关键字的参数，或者作为取地址符(&amp;)、<code>sizeof</code>及<code>typeid</code>等运算符的运算对象时，转换不发生</p>
</li>
</ul>
<p>显示转换</p>
<ul>
<li><p><strong>static_cast</strong>：任何明确定义的类型转换，只要不包含底层const，都可以使用。 <code>double slope = static_cast&lt;double&gt;(j);</code></p>
</li>
<li><p><strong>dynamic_cast</strong>：支持运行时类型识别</p>
</li>
<li><p><strong>const_cast</strong>：只能改变运算对象的底层const，一般可用于去除const性质。 <code>const char *pc; char *p = const_cast&lt;char*&gt;(pc)</code>只有其可以改变常量属性，通常用在<em><strong>函数重载</strong></em></p>
</li>
<li><p><strong>reinterpret_cast</strong>：通常为运算对象的位模式提供低层次上的重新解释，实际上仍为原类型</p>
</li>
</ul>
<h2 id="第五章——语句"><a href="#第五章——语句" class="headerlink" title="第五章——语句"></a>第五章——语句</h2><h3 id="悬垂else"><a href="#悬垂else" class="headerlink" title="悬垂else"></a>悬垂else</h3><p>有多个if时，else只与离它最近的尚未匹配的if匹配或者在想要匹配的if语句下加上花括号，以控制执行路径</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>case关键字和它对应的值一起被称为case标签，其必须是整型常量表达式</p>
<p>如果某个case标签匹配成功，将从改标签开始往后顺序执行所有case分支，因此需要添加break语句</p>
<p>若以一个空的default标签作为结束，则必须跟上一个空语句或者空块</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(init-statement;condition;expression)</span><br><span class="line">	statement;</span><br></pre></td></tr></table></figure>

<p>在init-statement中可以定义多个对象，但只能有一条声明语句，即所有变量的基础类型都必须相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(decltype(v.size() ) i=0,sz = v.size(); i != sz; ++i)</span><br><span class="line">	v.push_back(v[i]);</span><br></pre></td></tr></table></figure>

<p>for语句也可以省略掉任意一部分，但要以一条空语句代替，即要保留分号</p>
<p><code>if(cin.eof())</code>可以读取<code>eof</code>文件结束符，可以用<code>Ctrl+z</code>代替</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常处理包括：</p>
<ul>
<li><strong>throw表达式</strong>：异常检测部分使用 <code>throw</code>表达式来表示它遇到了无法处理的问题。我们说 <code>throw</code>引发 <code>raise</code>了异常。</li>
<li><strong>try语句块</strong>：以 <code>try</code>关键词开始，以一个或多个 <code>catch</code>字句结束。 <code>try</code>语句块中的代码抛出的异常通常会被某个 <code>catch</code>捕获并处理。 <code>catch</code>子句也被称为<strong>异常处理代码</strong>。</li>
<li><strong>异常类</strong>：用于在 <code>throw</code>表达式和相关的 <code>catch</code>子句之间传递异常的具体信息</li>
</ul>
<p>try语句块内声明的变量在块外部无法访问，在catch子句内也无法访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while(cin &gt;&gt; item1 &gt;&gt; item2)&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		if(item1.isbn()!=item2.isbn())</span><br><span class="line">			throw runtime_error(&quot;Data must refer to same ISBN&quot;);</span><br><span class="line">		//如果没有抛出异常，则表示两个isbn是相同的</span><br><span class="line">		cout &lt;&lt; item1 + item2 &lt;&lt; endl;</span><br><span class="line">	&#125;catch(runtime_error err)&#123;</span><br><span class="line">		//异常处理代码，提醒用户异常，询问是否继续</span><br><span class="line">		cout &lt;&lt; err.what() &lt;&lt; endl</span><br><span class="line">			&lt;&lt; &quot;Try again? Enter y or n&quot; &lt;&lt; endl;</span><br><span class="line">		char c;</span><br><span class="line">		cin &gt;&gt; c;</span><br><span class="line">		if(!cin || c == &#x27;n&#x27;)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理程序中，<code>err.what()</code>的返回值是C风格字符串，返回初始化<code>runtime_error</code>对象时的string对象的副本</p>
<p>如果异常抛出，但最终没有找到任何匹配的catch语句，程序转到名为<code>terminate</code>的标准库函数，一般将导致程序非正常退出</p>
<p><stdexcept>头文件定义的异常类</p>
<table>
<thead>
<tr>
<th><code>exception</code></th>
<th>最常见的问题</th>
</tr>
</thead>
<tbody><tr>
<td><code>runtime_error</code></td>
<td>只有在运行时才能检测出来的问题</td>
</tr>
<tr>
<td><code>range_error</code></td>
<td>结果超出有意义的值域范围</td>
</tr>
<tr>
<td><code>overflow_error</code></td>
<td>计算上溢</td>
</tr>
<tr>
<td><code>underflow_error</code></td>
<td>计算下溢</td>
</tr>
<tr>
<td><code>logic_error</code></td>
<td>逻辑错误</td>
</tr>
<tr>
<td><code>domain_error</code></td>
<td>参数对应的结果值不存在</td>
</tr>
<tr>
<td><code>invalid_argument</code></td>
<td>无效参数</td>
</tr>
<tr>
<td><code>length_error</code></td>
<td>试图创建一个超出该类型最大长度的对象</td>
</tr>
<tr>
<td><code>out_of_range</code></td>
<td>使用一个超出有效范围的值</td>
</tr>
</tbody></table>
<p>对于<code>exception</code>，<code>bad_alloc</code>，<code>bad_cast</code>只能默认初始化而不允许提供初始值</p>
<h2 id="第六章——函数"><a href="#第六章——函数" class="headerlink" title="第六章——函数"></a>第六章——函数</h2><h3 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h3><p>当执行指针拷贝操作时，拷贝的是指针的值，可以通过指针改变所指的对象的值，但不改变指针本身</p>
<p>编写一个函数，使用指针形参交换两个整数的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void swap(int* p,int* q)</span><br><span class="line">&#123;</span><br><span class="line">	int tmp = *p;</span><br><span class="line">	*p = *q;</span><br><span class="line">	*q = tmp;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 1, b = 2;</span><br><span class="line">	swap(&amp;a,&amp;b);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><ul>
<li><p>使用引用可以避免额外空间开销</p>
</li>
<li><p>还可以利用引用形参返回额外信息</p>
</li>
</ul>
<p><em><strong>右值实参不能用作引用形参</strong></em></p>
<h3 id="常量形参"><a href="#常量形参" class="headerlink" title="常量形参"></a><em><strong>常量形参</strong></em></h3><p>尽量使用常量引用，因为如果是普通引用如字符串，将无法接收<em><strong>字符字面值常量</strong></em>以及<em><strong>常量字符串</strong></em></p>
<p>不能把const对象、结果为该类型的表达式、字面值或者需要类型转换的对象传递给普通的引用形参</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组——不允许拷贝，不允许赋值给其他数组，使用数组时通常会将其转换成指针</p>
<p>数组形参只能以<code>const int *</code>类型传参，但可以有不同形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void print(const int* pa);</span><br><span class="line">void print(const int pa[]);</span><br><span class="line">void print(const int pa[10]);	//维度以实参为主</span><br></pre></td></tr></table></figure>

<p>三种形式等价</p>
<h3 id="管理数组指针形参"><a href="#管理数组指针形参" class="headerlink" title="管理数组指针形参"></a>管理数组指针形参</h3><ol>
<li><p>使用标记指定数组长度</p>
<p>如C风格字符串，自带有空字符，遇到空字符时即停止，但数组没有明显标记</p>
<p><code>void print(const char *cp)</code></p>
</li>
<li><p>使用标准库规范</p>
<p>传递指向数组首元素和尾元素的指针，<code>begin</code>和<code>end</code>函数</p>
<p><code>void print(const int *beg,const int *end)</code></p>
</li>
<li><p>显示传递表示数组大小的形参</p>
<p><code>void print(const int ia[],size_t size)</code></p>
</li>
</ol>
<h3 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h3><p>形参可以是数组的引用，且<em><strong>维度</strong></em>是类型的一部分，但绑定了维度就意味着函数只能作用于固定维度的数组</p>
<p><code>void print(int (&amp;arr)[10])</code></p>
<h3 id="多维数组形参"><a href="#多维数组形参" class="headerlink" title="多维数组形参"></a>多维数组形参</h3><p>数组第二维以及后面所有维度的大小都是数组类型的一部分，不能省略</p>
<p><code>void print(int (*arr)[10])</code>指针指向10个整数数组，等价于<code>void print(int arr[][10])</code></p>
<p><code>void print(int *arr [10])</code>则代表10个整型指针的数组</p>
<h3 id="处理命令行选项"><a href="#处理命令行选项" class="headerlink" title="处理命令行选项"></a>处理命令行选项</h3><p><code>int main(int argc,char* argv[])</code>等价于<code>int main(int argc,char**argv)</code></p>
<p>其中第一个形参表示数组中字符串的数量，第二个形参表示数组，元素是指向C风格字符串的指针</p>
<p>argv中的实参0保存程序的名字，往后是用户输入的实参，最后一个指针之后的元素值保证是0</p>
<h3 id="可变形参的函数"><a href="#可变形参的函数" class="headerlink" title="可变形参的函数"></a>可变形参的函数</h3><ul>
<li><p>如果所有的实参类型相同，可以传递一个名为<code>initializer_list</code>的标准库类型，表示某种特定类型的值的数组</p>
<p><code>initializer_list</code>对象中的元素永远是常量值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line"></span><br><span class="line">int sum(std::initializer_list&lt;int&gt; const&amp; il)</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (auto i : il) sum += i;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    auto il = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; //可变长度</span><br><span class="line">    std::cout &lt;&lt; sum(il) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果类型不相同，可以用可变参数模板</p>
</li>
<li><p>省略符，一般只用于与C函数机交互的接口程序</p>
</li>
</ul>
<h3 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h3><p>调用一个返回引用的函数得到左值，其他返回类型得到右值</p>
<p>函数返回类型不能是数组或者函数，但可以是指向数组或者函数的指针</p>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a><em><strong>返回数组指针</strong></em></h3><ul>
<li><code>Type (*function (parameter_list))[dimension]</code>如<code>int (*func(int i)[10])</code>表明需要实参类型是int，函数调用结果返回的是指针类型，指针指向的是个大小为10的整型数组，</li>
<li>使用类型别名： <code>typedef int arrT[10];</code> 或者 <code>using arrT = int[10;]</code>，然后 <code>arrT* func() &#123;...&#125;</code></li>
<li>使用 <code>decltype</code>： <code>int odd[] = &#123;1,2,3,4,5&#125;; decltype(odd) *arrPtr(int i) &#123;...&#125;</code></li>
<li><strong>尾置返回类型</strong>： 在形参列表后面以一个<code>-&gt;</code>开始：<code>auto func(int i) -&gt; int(*)[10]</code></li>
</ul>
<p>编写一个函数声明，使其返回数组的引用并且该数组包含10个string对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string (&amp;fun())[10];				//初始版本</span><br><span class="line"></span><br><span class="line">typedef string str_arr[10];			//类型别名</span><br><span class="line">str_arr&amp; fun();</span><br><span class="line"></span><br><span class="line">auto fun()-&gt;string(&amp;)[10];			//尾置返回类型</span><br><span class="line"></span><br><span class="line">string s[10];						//decltype关键字</span><br><span class="line">decltype(s)&amp; fun();</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>不允许两个函数除了返回类型外其他都一样，这不是重载的函数</p>
<p><em><strong>顶层const不影响传入函数的对象，因此不能用顶层const来进行函数重载，而底层const则可以</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void add(const int*);		//形参为常量指针，是底层const，可以对函数重载</span><br><span class="line">void add(int*);				//函数重载为普通指针的形参</span><br><span class="line"></span><br><span class="line">void add(int* const);		//形参为指针常量，是顶层const</span><br><span class="line">void add(int*);				//等价于上式，重复声明函数</span><br></pre></td></tr></table></figure>

<p>const形参重载可借助<code>const_cast</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const string &amp;shorterString(const string &amp;s1,const string&amp; s2)</span><br><span class="line">&#123;</span><br><span class="line">	return s1.size() &lt;= s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string &amp;shorterString(string &amp;s1, string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">	auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1),const_cast&lt;const string&amp;&gt;(s2));</span><br><span class="line">	return const_cast&lt;string &amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当普通引用传入时，调用第二个版本函数，将普通引用强制转换成const引用，再调用第一个版本函数，返回得到const引用绑定为一个引用上，再将其转换回普通引用返回</p>
<p>若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名</p>
<h3 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h3><ul>
<li><p>默认实参</p>
<p><code>string screen(sz ht = 24, sz wid = 80, char backgrnd = &#39; &#39;);</code></p>
<p>一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值</p>
<p>局部变量不能作为默认实参</p>
</li>
<li><p>内联函数</p>
<p>可避免函数调用的开销</p>
<p><code>inline const string &amp;shorterString(const string &amp;s1,const string&amp; s2)</code></p>
</li>
<li><p>constexpr函数</p>
<p>函数的返回类型及所有形参的类型都得是字面值类型，不一定返回常量表达式</p>
</li>
<li><p>调试帮助</p>
<ul>
<li><p>assert预处理宏</p>
<p><code>assert(expr)</code>如果expr为真则忽略，为假则输出信息并终止程序</p>
<p>通常用于检查不能发生的条件</p>
</li>
<li><p>NDEBUG预处理变量</p>
<p><code>CC -D NDEBUG main.c</code>可以定义这个变量<code>NDEBUG</code>，等价于在main.c一开始写# define NDEBUG</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error:&quot;</span> &lt;&lt; __FILE__</span><br><span class="line">             &lt;&lt; <span class="string">&quot;: in funciton &quot;</span> &lt;&lt; __func__</span><br><span class="line">             &lt;&lt; <span class="string">&quot;at line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl</span><br><span class="line">             &lt;&lt; <span class="string">&quot; Compiled on &quot;</span> &lt;&lt; __DATE__</span><br><span class="line">             &lt;&lt; <span class="string">&quot;at &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别输出报错的文件名的字符串字面值、当前调试的函数名的字符串字面值、行号的整型字面值、编译日期和编译时间的字符串字面值</p>
</li>
</ul>
</li>
</ul>
<h3 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h3><ul>
<li>重载函数匹配的<strong>三个步骤</strong>：1.候选函数；2.可行函数；3.寻找最佳匹配。</li>
<li><strong>候选函数</strong>：选定本次调用对应的重载函数集，集合中的函数称为候选函数</li>
<li><strong>可行函数</strong>：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数</li>
<li><strong>寻找最佳匹配</strong>：实参转换等级：精确匹配-const转换的匹配-类型提升-算术类型转换-类类型转换</li>
</ul>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a><em><strong>函数指针</strong></em></h3><p>函数名作为一个值使用，该函数自动转换成指针</p>
<p>声明一个指向函数的指针，需包括返回类型和形参类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool lengthCompare(const string &amp;,const string&amp;);			//函数声明</span><br><span class="line">bool (*pf)(const string&amp;, const string&amp;);					//函数指针，用指针替换函数名</span><br></pre></td></tr></table></figure>

<p>使用函数指针时，解引用与不解引用指针等价。<code>bool flag = pf(&quot;hh&quot;,&quot;kk&quot;);</code>等价于<code>bool flag = (*pf)(&quot;hh&quot;,&quot;kk&quot;);</code></p>
<p>把函数指针用作形参时，使用函数定义和使用函数指针定义等价</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void useBigger(const string&amp; s1,const string&amp;s2, bool pf(const string&amp;,const string&amp;));</span><br><span class="line">//形参为函数类型，将自动转换成函数指针类型</span><br><span class="line">void useBigger(const string&amp; s1,const string&amp;s2, bool (*pf)(const string&amp;,const string&amp;));</span><br><span class="line">//形参为显式定义函数指针</span><br></pre></td></tr></table></figure>

<p>另外，可以用类型别名或者decltype简化需要用到函数指针的函数声明</p>
<h3 id="函数指针当返回值"><a href="#函数指针当返回值" class="headerlink" title="函数指针当返回值"></a><em><strong>函数指针当返回值</strong></em></h3><ol>
<li><p>普通版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*f(int))(int*,int);</span><br></pre></td></tr></table></figure>

<p>首先，这是一个函数指针，且函数形参为int类型，指针本身也有形参列表，所以该指针指向函数，函数返回类型为int</p>
</li>
<li><p>类型别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using F = int(int* ,int);			//F是函数类型</span><br><span class="line">using PF = int(*)(int* ,int);		//PF是函数指针类型</span><br><span class="line"></span><br><span class="line">PF f(int);</span><br><span class="line">F* f(int);							//两种均等价于普通版本</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾置返回类型</p>
<p>与返回数组指针类型类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f(int) -&gt;int(*)(int*,int);</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto和decltype</p>
<p>如果明确知道返回函数，可以使用decltype简化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(f1)* f(int* ,int);			//f1即为需要返回的函数类型</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第七章——类"><a href="#第七章——类" class="headerlink" title="第七章——类"></a>第七章——类</h2><p>类的基本思想是<em><strong>数据抽象</strong></em> 和<em><strong>封装</strong></em></p>
<p>数据抽象依赖于<em><strong>接口</strong></em> 和<em><strong>实现</strong></em> 技术</p>
<p>定义在类内部的函数都是隐式的inline函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Sales_data&#123;</span><br><span class="line">	//成员函数</span><br><span class="line">	std::string isbn() const &#123;return bookNo;&#125;</span><br><span class="line">	//返回书本的ISBN编号</span><br><span class="line">	Sales_data &amp;combine(const Sales_data&amp;);</span><br><span class="line">	//两个类对象属性相加，返回原对象</span><br><span class="line">	doule avg_price() const;</span><br><span class="line">	//返回平均价格</span><br><span class="line">	</span><br><span class="line">	std::string bookNo;</span><br><span class="line">	//ISBN编号</span><br><span class="line">	unsigned units_sold = 0;</span><br><span class="line">	//数量</span><br><span class="line">	double revenue = 0;</span><br><span class="line">	//总收入</span><br><span class="line">&#125;;</span><br><span class="line">//声明非成员函数，即接口</span><br><span class="line">Sales_data add(const Sales_data&amp;,const Sales_data&amp;);</span><br><span class="line">std::ostream&amp; print(std::ostream&amp; os,const Sales_data&amp;);</span><br><span class="line">std::istream&amp; add(std::istream&amp; is,Sales_data&amp;);</span><br></pre></td></tr></table></figure>

<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数通过this隐式参数来访问调用的对象，当调用成员函数时，隐式地先将类对象的地址初始化this</p>
<p><code>struct *const this</code>，this是一个指针常量，指针指向不变，即一直保存对象的地址</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>目的并非通用，属于类的实现部分</p>
<p>成员函数的声明需在类内，函数声明在其他成员之后，因此不用考虑函数体和其他成员的次序</p>
<p>默认情况下，this是指向非常量的指针常量，意味着不能将this绑定到常量对象上，则无法正常使用到该成员函数，因此应该在函数声明时，在函数形参列表后函数体前加上const，<code>std::string isbn() const&#123;return bookNo;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double Sales_data::avg_price() const</span><br><span class="line">&#123;</span><br><span class="line">	if(units_sold)</span><br><span class="line">		return revenue/units_sold;</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回this对象的函数"><a href="#返回this对象的函数" class="headerlink" title="返回this对象的函数"></a>返回this对象的函数</h3><p><code>return *this</code>语句返回调用该函数的对象，令函数能够被连续调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sales_data &amp;Sales_data::combine(const Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	units_sold += rhs.units_sold;</span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用代码</span><br><span class="line">Sales_data sd1,sd2,sd3;</span><br><span class="line">sd1.combine(sd2).combine(sd3);</span><br></pre></td></tr></table></figure>

<h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><p>属于类的接口的组成部分，非成员函数声明与类声明在同一个文件，但不在类内</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//输入书本ISBN编号，数量以及单价</span><br><span class="line">std::istream&amp; read(std::istream&amp; is,Sales_data&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">	double price = 0;</span><br><span class="line">	is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">	item.revenue = price * item.units_sold;</span><br><span class="line">	return is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//打印输出书本ISBN编号、数量、总销售额及均价</span><br><span class="line">std::ostream&amp; print(std::ostream&amp; os, const Sale_data&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; item.bookNo &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot;</span><br><span class="line">    &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price();</span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line">//执行输出任务的函数尽量减少对格式控制，让用户代码决定是否换行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//add函数，输入两个类类型，返回一个新类的副本</span><br><span class="line">Sales_data add(const Sales_data&amp;item1,const Sales_data&amp;item2)</span><br><span class="line">&#123;</span><br><span class="line">	Sales_data tmp = item1;</span><br><span class="line">	item1.combine(item2);</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>构造函数是特殊的成员函数</li>
<li>无返回值</li>
<li>构造函数放在类的<code>public</code>部分</li>
<li>直到构造函数完成，对象才会有常量属性，因此构造函数可以向const对象写值</li>
<li><code>=default</code>要求编译器合成默认的构造函数</li>
<li>初始化列表：冒号和花括号之间的代码： <code>Sales_item(): units_sold(0), revenue(0.0) &#123; &#125;</code></li>
</ul>
<p>class和struct默认访问权限不同，struct则在第一个访问说明符之前的成员是public的，class则是private</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>允许特定的<strong>非成员函数</strong>访问一个类的<strong>私有成员</strong>，通常将友元声明成组地放在<strong>类定义的开始或者结尾</strong></p>
<p>必须在友元声明之外再对函数进行一次声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data&#123;</span><br><span class="line">friend Sales_data add(const Sales_data&amp;,const Sales_data&amp;);</span><br><span class="line">friend std::istream&amp; read(std::istream&amp; is, Sales_data&amp;);</span><br><span class="line">friend std::ostream&amp; print(std::ostream&amp; os,const Sales_data&amp;);</span><br><span class="line">public:</span><br><span class="line">	Sales_data() = default;</span><br><span class="line">	Sales_data(const std::string &amp;s,unsigned n,douple p):</span><br><span class="line">			boodNo(s),revenue(p),units_sold(n) &#123;&#125;</span><br><span class="line">	Sales_data(const std::string &amp;s):bookNo(s) &#123;&#125;</span><br><span class="line">	Sales_data(std::istream&amp;);//类外实现构造函数</span><br><span class="line">	//类内实现构造函数 Sales_data(std::istream&amp; is) &#123;return read(is,*this);&#125;</span><br><span class="line">	</span><br><span class="line">	std::string&amp; isbn() const &#123;return bookNo&#125;;</span><br><span class="line">	Sales_data&amp; combine(const Sales_data&amp;);</span><br><span class="line">	double&amp; avg_price(const Sales_data&amp;) const;</span><br><span class="line">private:</span><br><span class="line">	std::string bookNo;</span><br><span class="line">	double revenue = 0.0;</span><br><span class="line">	unsigned units_sold = 0;</span><br><span class="line">&#125;;</span><br><span class="line">//类外接口函数声明</span><br><span class="line">Sales_data add(const Sales_data&amp;,const Sales_data&amp;);</span><br><span class="line">std::istream&amp; read(std::istream&amp; is, Sales_data&amp;);</span><br><span class="line">std::ostream&amp; print(std::ostream&amp; os,const Sales_data&amp;);</span><br></pre></td></tr></table></figure>

<p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员</p>
<p>也可以只对声明另一个类中的某个成员函数为友元，并说明该成员函数的作用域</p>
<p>若想要把一组重载函数声明为友元，则需要对每一个分别声明</p>
<h3 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h3><p><em><strong>用来定义类型的成员必须先定义后使用</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Screen&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef std::string::size_type pos;</span><br><span class="line">private:</span><br><span class="line">	pos cursor = 0;</span><br><span class="line">	pos height = 0, width = 0;</span><br><span class="line">	std::string contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义在类内部的成员函数都是自动inline的，可以在类内部显式inline声明，也能在类外部定义的时候说明inline</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Screen&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef std::string::size_type pos;</span><br><span class="line">	Screen() = default;//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br><span class="line">	Screen(pos ht,pos wd,char c):height(ht),width(wd),contents(ht*wd,c) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	char get() const &#123;return contents[cursor];&#125;</span><br><span class="line">	//获取光标当前的内容,隐式内联</span><br><span class="line">	inline char get(pos ht,pos wd) const;//显式内联，在类外定义</span><br><span class="line">	Screen &amp;move(pos r,pos c);</span><br><span class="line">private:</span><br><span class="line">	pos cursor = 0;</span><br><span class="line">	pos height = 0, width = 0;</span><br><span class="line">	std::string contents;</span><br><span class="line">&#125;;</span><br><span class="line">inline</span><br><span class="line">char Screen::get(pos ht,pos wd) const //因为已经在类内声明过inline，此处可以省略</span><br><span class="line">&#123;</span><br><span class="line">	return contents[ht*width+wd];</span><br><span class="line">&#125;</span><br><span class="line">inline</span><br><span class="line">Screen &amp;move(pos r, pos c)</span><br><span class="line">&#123;</span><br><span class="line">	cursor = r * width + c;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若希望能修改类的const成员函数中的某个成员变量，可以通过变量声明前加入mutable实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Screen&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef std::string::size_type pos;</span><br><span class="line">	Screen() = default;//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br><span class="line">	Screen(pos ht,pos wd,char c):height(ht),width(wd),contents(ht*wd,c) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	char get() const &#123;return contents[cursor];&#125;</span><br><span class="line">	//获取光标当前的内容,隐式内联</span><br><span class="line">	inline char get(pos ht,pos wd) const;//显式内联，在类外定义</span><br><span class="line">	Screen &amp;move(pos r,pos c);</span><br><span class="line">	</span><br><span class="line">	void some_member() const;//修改mutable变量函数</span><br><span class="line">private:</span><br><span class="line">	pos cursor = 0;</span><br><span class="line">	pos height = 0, width = 0;</span><br><span class="line">	std::string contents;</span><br><span class="line">	</span><br><span class="line">	mutable size_t access_ctr;//被修改mutable变量</span><br><span class="line">&#125;;</span><br><span class="line">inline</span><br><span class="line">char Screen::get(pos ht,pos wd) const //因为已经在类内声明过inline，此处可以省略</span><br><span class="line">&#123;</span><br><span class="line">	return contents[ht*width+wd];</span><br><span class="line">&#125;</span><br><span class="line">inline</span><br><span class="line">Screen &amp;move(pos r, pos c)</span><br><span class="line">&#123;</span><br><span class="line">	cursor = r * width + c;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">void some_member() const</span><br><span class="line">&#123;</span><br><span class="line">	++access_ctr;//记录被调用次数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回*this的成员函数，返回对象本身，则可以连续调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Screen&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef std::string::size_type pos;</span><br><span class="line">	Screen() = default;//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br><span class="line">	Screen(pos ht,pos wd,char c):height(ht),width(wd),contents(ht*wd,c) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	char get() const &#123;return contents[cursor];&#125;</span><br><span class="line">	//获取光标当前的内容,隐式内联</span><br><span class="line">	inline char get(pos ht,pos wd) const;//显式内联，在类外定义</span><br><span class="line">	Screen &amp;move(pos r,pos c);</span><br><span class="line">	void some_member() const;//修改mutable变量函数</span><br><span class="line">	</span><br><span class="line">	Screen&amp; set(pos,pos,char);</span><br><span class="line">	Screan&amp; set(char);</span><br><span class="line">private:</span><br><span class="line">	pos cursor = 0;</span><br><span class="line">	pos height = 0, width = 0;</span><br><span class="line">	std::string contents;</span><br><span class="line">	</span><br><span class="line">	mutable size_t access_ctr;//被修改mutable变量</span><br><span class="line">&#125;;</span><br><span class="line">inline</span><br><span class="line">char Screen::get(pos ht,pos wd) const //因为已经在类内声明过inline，此处可以省略</span><br><span class="line">&#123;</span><br><span class="line">	return contents[ht*width+wd];</span><br><span class="line">&#125;</span><br><span class="line">inline</span><br><span class="line">Screen &amp;move(pos r, pos c)</span><br><span class="line">&#123;</span><br><span class="line">	cursor = r * width + c;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">void some_member() const</span><br><span class="line">&#123;</span><br><span class="line">	++access_ctr;//记录被调用次数</span><br><span class="line">&#125;</span><br><span class="line">inline</span><br><span class="line">Screen&amp; Screen::set(char c)</span><br><span class="line">&#123;</span><br><span class="line">	contents[cursor] = c;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">inline</span><br><span class="line">Screen&amp; screen::set(pos r,pos col, char c)</span><br><span class="line">&#123;</span><br><span class="line">	contents[r * width + col] = c;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用set  myScreen.move(4,0).set(&#x27;#&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a><em><strong>基于const的重载</strong></em></h3><p>若有常量成员函数，即使返回对象本身，也不能与非常量成员函数一起连续调用，则应该对该常量成员函数进行非常量版本的重载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Screen&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef std::string::size_type pos;</span><br><span class="line">	Screen() = default;//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br><span class="line">	Screen(pos ht,pos wd,char c):height(ht),width(wd),contents(ht*wd,c) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	char get() const &#123;return contents[cursor];&#125;</span><br><span class="line">	//获取光标当前的内容,隐式内联</span><br><span class="line">	inline char get(pos ht,pos wd) const;//显式内联，在类外定义</span><br><span class="line">	Screen &amp;move(pos r,pos c);</span><br><span class="line">	void some_member() const;//修改mutable变量函数</span><br><span class="line">	Screen&amp; set(pos,pos,char);</span><br><span class="line">	Screen&amp; set(char);</span><br><span class="line">	</span><br><span class="line">	//display函数重载</span><br><span class="line">	Screen&amp; display(std::ostream &amp;os) &#123;do_display(os);return *this;&#125;</span><br><span class="line">	const Screen&amp; display(std::ostream &amp;os) const &#123;do_display(os);return *this;&#125;</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	pos cursor = 0;</span><br><span class="line">	pos height = 0, width = 0;</span><br><span class="line">	std::string contents;</span><br><span class="line">	mutable size_t access_ctr;//被修改mutable变量</span><br><span class="line">	</span><br><span class="line">	void do_display(std::ostream&amp; os) const &#123;os &gt;&gt; contents;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">inline</span><br><span class="line">char Screen::get(pos ht,pos wd) const //因为已经在类内声明过inline，此处可以省略</span><br><span class="line">&#123;</span><br><span class="line">	return contents[ht*width+wd];</span><br><span class="line">&#125;</span><br><span class="line">inline</span><br><span class="line">Screen &amp;move(pos r, pos c)</span><br><span class="line">&#123;</span><br><span class="line">	cursor = r * width + c;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">void some_member() const</span><br><span class="line">&#123;</span><br><span class="line">	++access_ctr;//记录被调用次数</span><br><span class="line">&#125;</span><br><span class="line">inline</span><br><span class="line">Screen&amp; Screen::set(char c)</span><br><span class="line">&#123;</span><br><span class="line">	contents[cursor] = c;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">inline</span><br><span class="line">Screen&amp; screen::set(pos r,pos col, char c)</span><br><span class="line">&#123;</span><br><span class="line">	contents[r * width + col] = c;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//此时可以调用 myScreen.display(cout).set(&#x27;*&#x27;);</span><br></pre></td></tr></table></figure>

<p>以上，display函数有常量和非常量版本，对于常量版本，调用do_display函数，常量对象再被调用成常量对象，即直接对常量对象操作，常量对象传递到函数内部并打印并返回常量对象；对于非常量版本，调用do_display函数，非常量对象被传递，此时传递的是对该非常量对象的常量调用，传递到函数内部并打印，返回该调用的常量对象，即原来的非常量对象。也就是说，将非常量对象通过多一次的函数调用统一成常量对象的调用，而对常量对象不影响。</p>
<p>每个类都是唯一的类型，类在声明后定义前，是一个不完全类型，可以定义指向给类的指针或引用，也可以声明以该类类型作为参数或返回类型的函数。</p>
<h3 id="Person类程序"><a href="#Person类程序" class="headerlink" title="Person类程序"></a>Person类程序</h3><p>编写一个Person类，表示人员的姓名和住址，string来存放，能够返回姓名和住址，能够读取和打印Person对象，构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	friend std::istream&amp; read(std::istream&amp;, Person&amp;);</span><br><span class="line">	friend std::ostream&amp; pritn(std::ostream&amp;,const Person&amp;);</span><br><span class="line">public:</span><br><span class="line">	auto get_name() const -&gt; std::string const&amp; &#123;return name;&#125;</span><br><span class="line">	auto get_address() const -&gt; std::string const&amp; &#123;return address;&#125;</span><br><span class="line">	//const位置不影响,也可以在std::string之前</span><br><span class="line">	//等价于</span><br><span class="line">	const std::string&amp; get_neme() const &#123;return name;&#125;</span><br><span class="line">	std::string const&amp; get_address() const &#123;return address;&#125;</span><br><span class="line">	</span><br><span class="line">	Person() = default;</span><br><span class="line">	Person(const string&amp; s1,const string&amp; s2): name(s1),name(s2) &#123;&#125;</span><br><span class="line">	Person(std::istream&amp;)&#123;&#125;;//类外定义</span><br><span class="line">	//类内定义 Person(std::istream&amp; is) &#123;read(is,*this);&#125;</span><br><span class="line">private:</span><br><span class="line">	string name,address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::istream&amp; read(std::istream&amp; is, Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	is &lt;&lt; p.name &lt;&lt; p.address;</span><br><span class="line">	return is;</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; print(std::ostream&amp; os, const Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	os &gt;&gt; p.name &gt;&gt; p.address;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line">Person::person(std::istream&amp; is)</span><br><span class="line">&#123;</span><br><span class="line">	read(is,*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数的<strong>返回类型</strong>通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外</p>
<p>如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，则必须通过构造函数初始值列表为这些成员提供初值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class NoDefault&#123;</span><br><span class="line">	NoDefault(int)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//NoDefault类没有提供默认构造函数，此时必须给C加上构造函数</span><br><span class="line">class C&#123;</span><br><span class="line">	C(int x): NoDefault(x) &#123;&#125;</span><br><span class="line">	NoDefault nf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>委托构造函数使用所属类中其他的构造函数来执行自己的初始化过程，受委托的构造函数的初始值列表和函数体被依次执行，最后再执行委托者的函数体</p>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则实际上定义了转换为此类类型的<strong>隐式转换机制</strong>，编译器只会自动地执行<strong>仅一步</strong>类型转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string null_book = &quot;9999-99&quot;;</span><br><span class="line">item.combine(null_book);</span><br></pre></td></tr></table></figure>

<p>string实参传入combine成员函数时，string会自动创建一个Sales_data对象</p>
<p>编译器只会执行一步类型转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">item.combine(&quot;9999-99&quot;);//此时会报错</span><br><span class="line">item.combine(string(&quot;9999-99&quot;));</span><br><span class="line">item.combine(Sales_data(&quot;9999-99&quot;));//加上一步显式类型转换则不报错</span><br></pre></td></tr></table></figure>

<p>通过对成员函数声明explicit可以阻止隐式类型转换，explicit只能出现在类内函数的声明中。但可以使用构造函数进行显式的类型转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.combine(Sales_data(null_book));</span><br><span class="line">item.combine(static_cast&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></table></figure>

<p><code>explicit</code>构造函数只能用于直接初始化，不能用于拷贝形式的初始化</p>
<h3 id="聚合类-（aggregate-class）"><a href="#聚合类-（aggregate-class）" class="headerlink" title="聚合类 （aggregate class）"></a>聚合类 （aggregate class）</h3><ul>
<li>满足以下所有条件：<ul>
<li>所有成员都是<code>public</code>的。</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值。</li>
<li>没有基类，也没有<code>virtual</code>函数。</li>
</ul>
</li>
<li>可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。</li>
</ul>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><ul>
<li><code>constexpr</code>函数的参数和返回值必须是字面值。</li>
<li><strong>字面值类型</strong>：除了算术类型、引用和指针外，某些类也是字面值类型。</li>
<li>数据成员都是字面值类型的聚合类是字面值常量类。</li>
<li>如果不是聚合类，则必须满足下面所有条件：<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个<code>constexpr</code>构造函数。</li>
<li>如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。</li>
</ul>
</li>
</ul>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ul>
<li>非<code>static</code>数据成员存在于类类型的每个对象中。</li>
<li>成员函数可以直接使用静态成员</li>
<li>每个<code>static</code>数据成员是与类关联的对象，并不与该类的对象相关联。</li>
<li>声明：<ul>
<li>声明之前加上关键词<code>static</code>。</li>
</ul>
</li>
<li>使用：<ul>
<li>成员算符**<code>::</code>直接访问静态成员:<code>r = Account::rate();</code></li>
<li>也可以使用对象访问：<code>r = ac.rate();</code></li>
</ul>
</li>
<li>定义：在类外部定义时不用加<code>static</code>。</li>
<li>初始化：<ul>
<li>通常不在类的内部初始化，而是在定义时进行初始化，如 <code>double Account::interestRate = initRate();</code></li>
<li>如果一定要在类内部定义，则要求必须是字面值常量类型的<code>constexpr</code>。</li>
</ul>
</li>
</ul>
<h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="第八章——IO库"><a href="#第八章——IO库" class="headerlink" title="第八章——IO库"></a>第八章——IO库</h2><h3 id="标准库定义的IO类型"><a href="#标准库定义的IO类型" class="headerlink" title="标准库定义的IO类型"></a>标准库定义的IO类型</h3><ul>
<li><code>iostream</code>头文件：从标准流中读写数据，<code>istream</code>、<code>ostream</code>等。</li>
<li><code>fstream</code>头文件：从文件中读写数据，<code>ifstream</code>、<code>ofstream</code>等。</li>
<li><code>sstream</code>头文件：从字符串中读写数据，<code>istringstream</code>、<code>ostringstream</code></li>
</ul>
<h3 id="IO对象不可复制或赋值"><a href="#IO对象不可复制或赋值" class="headerlink" title="IO对象不可复制或赋值"></a>IO对象不可复制或赋值</h3><ul>
<li>1.IO对象不能存在容器里.</li>
<li>2.形参和返回类型也不能是流类型</li>
<li>3.形参和返回类型一般是流的<strong>引用</strong></li>
<li>4.读写一个IO对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的</li>
</ul>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><p><code>strm</code>是一种IO类型，（如<code>istream</code>）， <code>s</code>是一个流对象</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>strm:iostate</code></td>
<td>是一种机器无关的<strong>类型</strong>，提供了表达条件状态的完整功能</td>
</tr>
<tr>
<td><code>strm:badbit</code></td>
<td>用来指出流已经崩溃</td>
</tr>
<tr>
<td><code>strm:failbit</code></td>
<td>用来指出一个IO操作失败了</td>
</tr>
<tr>
<td><code>strm:eofbit</code></td>
<td>用来指出流到达了文件结束</td>
</tr>
<tr>
<td><code>strm:goodbit</code></td>
<td>用来指出流未处于错误状态，此值保证为零</td>
</tr>
<tr>
<td><code>s.eof()</code></td>
<td>若流<code>s</code>的<code>eofbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.fail()</code></td>
<td>若流<code>s</code>的<code>failbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.bad()</code></td>
<td>若流<code>s</code>的<code>badbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.good()</code></td>
<td>若流<code>s</code>处于有效状态，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>将流<code>s</code>中所有条件状态位复位，将流的状态设置成有效，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.clear(flags)</code></td>
<td>将流<code>s</code>中指定的条件状态位复位，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.setstate(flags)</code></td>
<td>根据给定的标志位，将流<code>s</code>中对应的条件状态位置位，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.rdstate()</code></td>
<td>返回流<code>s</code>的当前条件状态，返回值类型为<code>strm::iostate</code></td>
</tr>
</tbody></table>
<p>从给定流中读取数据，直至遇到文件结束符时停止，然后对流进行按所需位复位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string buf;</span><br><span class="line">while(cin &gt;&gt; buf)</span><br><span class="line">	std::cout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">cin.clear(cin.rdstate() &amp; ~cin.eobit);</span><br><span class="line">//cin.clear();直接将failbit,badbit,eofbit复位</span><br></pre></td></tr></table></figure>

<h3 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h3><p>缓冲刷新的原因</p>
<ul>
<li><p>程序正常结束</p>
</li>
<li><p>缓冲区满</p>
</li>
<li><p>endl显式刷新缓冲区</p>
</li>
<li><p>操纵符unitbuf设置流的内部状态来清空缓冲区，对cerr默认设置unitbuf，即cerr是立即刷新的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf; //所有输出操作都会立即刷新缓冲区</span><br><span class="line">cout &lt;&lt; nounitbuf; //恢复正常缓冲方式</span><br></pre></td></tr></table></figure>
</li>
<li><p>当读写被关联的流时，关联到的流的缓冲区会被刷新。如cin和cerr关联到cout，读cin或写cerr都导致cout刷新缓冲区</p>
</li>
<li><p>flush刷新缓冲区，不附加任何额外字符</p>
</li>
<li><p>ends插入一个空字符，再刷新缓冲区</p>
</li>
</ul>
<p>交互式系统通常应该关联输入流和输出流，则所有输出包括用户提示，都会在读操作之前被打印出来</p>
<h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p><code>fstream</code>是头文件<code>fstream</code>中定义的一个类型，<code>fstrm</code>是一个文件流对象</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>fstream fstrm;</code></td>
<td>创建一个未绑定的文件流。</td>
</tr>
<tr>
<td><code>fstream fstrm(s);</code></td>
<td>创建一个文件流，并打开名为<code>s</code>的文件，<code>s</code>可以是<code>string</code>也可以是<code>char</code>指针</td>
</tr>
<tr>
<td><code>fstream fstrm(s, mode);</code></td>
<td>与前一个构造函数类似，但按指定<code>mode</code>打开文件</td>
</tr>
<tr>
<td><code>fstrm.open(s)</code></td>
<td>打开名为<code>s</code>的文件，并和<code>fstrm</code>绑定</td>
</tr>
<tr>
<td><code>fstrm.close()</code></td>
<td>关闭和<code>fstrm</code>绑定的文件</td>
</tr>
<tr>
<td><code>fstrm.is_open()</code></td>
<td>返回一个<code>bool</code>值，指出与<code>fstrm</code>关联的文件是否成功打开且尚未关闭</td>
</tr>
</tbody></table>
<p>在要求用到基类对象的地方，可以用继承类型对象来替代。则接受iostream引用参数的函数可以用一个fstream类型调用</p>
<p>当一个fstream对象被销毁时，close自动会被调用</p>
<table>
<thead>
<tr>
<th>文件模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>in</code></td>
<td>以读的方式打开</td>
</tr>
<tr>
<td><code>out</code></td>
<td>以写的方式打开</td>
</tr>
<tr>
<td><code>app</code></td>
<td>每次写操作前均定位到文件末尾</td>
</tr>
<tr>
<td><code>ate</code></td>
<td>打开文件后立即定位到文件末尾</td>
</tr>
<tr>
<td><code>trunc</code></td>
<td>截断文件</td>
</tr>
<tr>
<td><code>binary</code></td>
<td>以二进制方式进行IO操作。</td>
</tr>
</tbody></table>
<p>默认情况下，out模式打开会是trunc模式，out模式打开同时指定app模式或者in模式才不会被截断</p>
<h3 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h3><p><code>sstream</code>是头文件<code>sstream</code>中任意一个类型。<code>s</code>是一个<code>string</code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>sstream strm</code></td>
<td>定义一个未绑定的<code>stringstream</code>对象</td>
</tr>
<tr>
<td><code>sstream strm(s)</code></td>
<td>用<code>s</code>初始化对象</td>
</tr>
<tr>
<td><code>strm.str()</code></td>
<td>返回<code>strm</code>所保存的<code>string</code>的拷贝</td>
</tr>
<tr>
<td><code>strm.str(s)</code></td>
<td>将<code>s</code>拷贝到<code>strm</code>中，返回<code>void</code></td>
</tr>
</tbody></table>
<h3 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a>istringstream</h3><p>对整行文本进行读取，对其中行内的单词进行处理，则可以使用<code>istringstream</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct PersonInfo&#123;</span><br><span class="line">	string name;</span><br><span class="line">	vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line">string line, word;</span><br><span class="line">vector&lt;PersonInfo&gt; people;</span><br><span class="line">while(getline(cin,line))</span><br><span class="line">&#123;</span><br><span class="line">	PersonInfo info;</span><br><span class="line">	istringstream record(line);</span><br><span class="line">	record &gt;&gt; info.name;</span><br><span class="line">	while(record &gt;&gt; word)</span><br><span class="line">		info.phones.push_back(word);</span><br><span class="line">	people.push_back(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第九章——顺序容器"><a href="#第九章——顺序容器" class="headerlink" title="第九章——顺序容器"></a>第九章——顺序容器</h2><p><code>value_type</code>  元素类型  </p>
<p><code>reference</code>  元素的左值类型，和<code>value_type &amp;</code>含义相同  </p>
<p><code>const_reference</code>  元素的<code>const</code>左值类型，即<code>const value_type &amp;</code></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><code>forward list</code>迭代器不支持递减运算符</p>
<p>将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同；而当使用迭代器来拷贝一个范围时，就不要求容器类型相同</p>
<h3 id="array容器"><a href="#array容器" class="headerlink" title="array容器"></a>array容器</h3><p>定义array时，不仅要指定元素类型，还要指定容器大小，<code>array&lt;int,42&gt; arr</code>，默认构造的array是非空的，包含了与其大小一样多的元素</p>
<p>不能对<strong>内置数组</strong>进行拷贝或对象赋值操作，但array可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;int, 10&gt; digits = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">array&lt;int, 10&gt; copy = digits;</span><br></pre></td></tr></table></figure>

<h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和<code>swap</code></h3><p><code>c.assign(b, e)</code>  将<code>c</code>中的元素替换成迭代器<code>b</code>和<code>e</code>表示范围中的元素，<code>b</code>和<code>e</code>不能指向<code>c</code>中的元素  </p>
<p><code>c.assign(il)</code>  将<code>c</code>中的元素替换成初始化列表<code>il</code>中的元素  </p>
<p><code>c.assign(n, r)</code>  将<code>c</code>中的元素替换为<code>n</code>个值是<code>t</code>的元素</p>
<p>array容器不能使用assign；由于值列表对象的大小与原对象大小不一样，也不允许用花括号包围的值列表进行赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;const char*&gt; oldstyle;</span><br><span class="line">names = oldstyle;// 报错，容器类型不匹配</span><br><span class="line">name.assign(oldstyle.begin(),oldstyle.end());</span><br></pre></td></tr></table></figure>

<p>赋值运算会导致指向左边容器的迭代器、引用和指针都失效，swap则不会（array和string除外）这是因为swap不对元素进行交换，只交换两个容器内部的数据结构，时间复杂度为O(1)。而swap对string会导致失效；对array进行swap会真正交换它们的元素</p>
<h3 id="容器操作——insert"><a href="#容器操作——insert" class="headerlink" title="容器操作——insert"></a>容器操作——<code>insert</code></h3><p><code>c.insert(p, t)</code>  在迭代器<code>p</code>指向的元素之前创建一个值是<code>t</code>的元素，返回指向新元素的迭代器</p>
<p><code>c.insert(p, n, t)</code>  在迭代器<code>p</code>指向的元素之前插入<code>n</code>个值为<code>t</code>的元素，返回指向第一个新元素的迭代器；如果<code>n</code>是0，则返回<code>p</code>  </p>
<p><code>c.insert(p, b, e)</code>  将迭代器<code>b</code>和<code>e</code>范围内的元素，插入到<code>p</code>指向的元素之前；如果范围为空，则返回<code>p</code>  </p>
<p><code>c.insert(p, il)</code>  <code>il</code>是一个花括号包围中的元素值列表，将其插入到<code>p</code>指向的元素之前；如果<code>il</code>是空，则返回<code>p</code></p>
<p><code>insert</code>函数将元素插入到迭代器指定位置<strong>之前</strong>，时间复杂度为O(n)，对于list时间复杂度则为O(1)</p>
<p>向<code>vector</code>,<code>string</code>,<code>deque</code>容器中插入元素都会使所有迭代器、指针和引用失效，向deque首尾位置添加元素，迭代器失效，但指针和引用不失效</p>
<p>利用insert的返回值，可以在容器中一个特定位置反复插入元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; lst;</span><br><span class="line">auto iter = lst.begin();</span><br><span class="line">while(cin &gt;&gt; word)</span><br><span class="line">	iter = lst.insert(iter,word);//不断在链表头插入元素</span><br></pre></td></tr></table></figure>

<h3 id="容器操作——emplace"><a href="#容器操作——emplace" class="headerlink" title="容器操作——emplace"></a>容器操作——<code>emplace</code></h3><p><code>emplace_back(args)</code>在尾部创建一个由args创建的元素</p>
<p><code>emplace_front(args)</code>在头部创建一个由args创建的元素</p>
<p><code>emplace(p,args)</code>在迭代器p指向的元素之前创建一个由args创建的元素，返回指向新添加元素的迭代器</p>
<p><code>emplace</code>开头的函数是新标准引入的，这些操作是构造而不是拷贝元素,传递给<code>emplace</code>的参数必须和元素类型的<strong>构造函数</strong>相匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//c是一个Sales_data对象</span><br><span class="line">c.emplace_back(&quot;989-32000&quot;,25,15.99);</span><br><span class="line">//在c的末尾构造一个Sales_data对象</span><br><span class="line">c.push_back(Sales_data(&quot;989-32000&quot;,25,15.99));</span><br><span class="line">//相当于创建一个临时的Sales_data对象传递给push_back</span><br></pre></td></tr></table></figure>

<p>上述语句都会创建新的Sales_data对象，在调用emplace_back时，会在容器管理的内存空间中直接创建对象，而调用push_back则会创建一个局部临时对象，并将其压入容器中。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.back()</code></td>
<td>返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><code>c.front()</code></td>
<td>返回<code>c</code>中头元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><code>c[n]</code></td>
<td>返回<code>c</code>中下标是<code>n</code>的元素的引用，<code>n</code>时候一个无符号证书。若<code>n&gt;=c.size()</code>，则函数行为未定义</td>
</tr>
<tr>
<td><code>c.at(n)</code></td>
<td>返回下标为<code>n</code>的元素引用。如果下标越界，则抛出<code>out_of_range</code>异常</td>
</tr>
</tbody></table>
<p>访问成员函数返回的是引用</p>
<p>如果希望确保下标是合法的，可以使用at成员函数</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><code>c.erase(p)</code>  删除迭代器<code>p</code>指向的元素，返回一个指向被删除元素之后的元素的迭代器，若<code>p</code>本身是尾后迭代器，则函数行为未定义  </p>
<p><code>c.erase(b, e)</code>  删除迭代器<code>b</code>和<code>e</code>范围内的元素，返回指向最后一个被删元素<strong>之后</strong>元素的迭代器，若<code>e</code>本身就是尾后迭代器，则返回尾后迭代器</p>
<p>删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效，删除deque的尾元素会导致尾后迭代器失效。指向vector、string被删除元素位置之后的迭代器、引用和指针都会失效</p>
<h3 id="forward-list容器"><a href="#forward-list容器" class="headerlink" title="forward_list容器"></a><code>forward_list</code>容器</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>lst.before_begin()</code></td>
<td>返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。</td>
</tr>
<tr>
<td><code>lst.cbefore_begin()</code></td>
<td>同上，但是返回的是常量迭代器。</td>
</tr>
<tr>
<td><code>lst.insert_after(p, t)</code></td>
<td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象。返回<strong>最后一个</strong>插入元素的迭代器</td>
</tr>
<tr>
<td><code>lst.insert_after(p, n, t)</code></td>
<td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象，<code>n</code>是数量。若<code>n</code>是0则函数行为未定义</td>
</tr>
<tr>
<td><code>lst.insert_after(p, b, e)</code></td>
<td>在迭代器<code>p</code>之后插入元素。由迭代器<code>b</code>和<code>e</code>指定范围，不能指向lst内</td>
</tr>
<tr>
<td><code>lst.insert_after(p, il)</code></td>
<td>在迭代器<code>p</code>之后插入元素。由<code>il</code>指定初始化列表。</td>
</tr>
<tr>
<td><code>emplace_after(p, args)</code></td>
<td>使用<code>args</code>在<code>p</code>之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若<code>p</code>为尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td><code>lst.erase_after(p)</code></td>
<td>删除<code>p</code>指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若<code>p</code>指向<code>lst</code>的尾元素或者是一个尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td><code>lst.erase_after(b, e)</code></td>
<td>类似上面，删除对象换成从<code>b</code>到<code>e</code>指定的范围。</td>
</tr>
</tbody></table>
<p>当在<code>forward_list</code>中添加或删除元素时，需要关注两个迭代器，指向当前元素和指向其前驱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//删除所有奇数元素</span><br><span class="line">forward_list&lt;int&gt; flst = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">auto prev = flst.begin_before();</span><br><span class="line">auto curr = flst.begin();</span><br><span class="line">while(curr!=flst.end())</span><br><span class="line">&#123;</span><br><span class="line">	if(*curr&amp;0x1)</span><br><span class="line">		curr = flst.erase_after(prev);</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		prev = curr;</span><br><span class="line">		++curr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除奇数元素程序"><a href="#删除奇数元素程序" class="headerlink" title="删除奇数元素程序"></a>删除奇数元素程序</h3><p>编写程序，查找并删除<code>forward_list&lt;int&gt;</code>中的奇数元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;forward_list&gt;</span><br><span class="line"></span><br><span class="line">using std::forward_list;</span><br><span class="line">using std::cout;</span><br><span class="line"></span><br><span class="line">auto remove_odds(forward_list&lt;int&gt;&amp; flist)</span><br><span class="line">&#123;</span><br><span class="line">    auto is_odd = [] (int i) &#123; return i &amp; 0x1; &#125;;</span><br><span class="line">    flist.remove_if(is_odd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    forward_list&lt;int&gt; data = &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;</span><br><span class="line">    remove_odds(data);</span><br><span class="line">    for (auto i : data) </span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>remove_if</code>是list容器的特定算法，让谓词为真时删除该元素</p>
<h3 id="容器大小管理操作"><a href="#容器大小管理操作" class="headerlink" title="容器大小管理操作"></a>容器大小管理操作</h3><p>调用<code>reserve</code>不会减少容器所占用的内存空间，即<code>capacity</code>，将会大于或等于当前的容量大小传递给<code>reserve</code>的参数；<code>resize</code>只会改变容器中元素的数量，即<code>size</code>而不改变容器的容量；<code>shrink_to_fit</code>则会请求退回多余的内存空间，但不保证一定退回</p>
<h3 id="string的额外操作"><a href="#string的额外操作" class="headerlink" title="string的额外操作"></a>string的额外操作</h3><p>构造string</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>string s(cp, n)</code></td>
<td><code>s</code>是<code>cp</code>指向的数组中前<code>n</code>个字符的拷贝，此数组</td>
</tr>
<tr>
<td><code>string s(s2, pos2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符的拷贝。若<code>pos2 &gt; s2.size()</code>，则构造函数的行为未定义。</td>
</tr>
<tr>
<td><code>string s(s2, pos2, len2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的<code>len2</code>个字符的拷贝。</td>
</tr>
</tbody></table>
<p>从一个<code>const char*</code>创建string时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符串时停止；如果构造函数中还有计数值作为形参，数组则不必以空字符结尾</p>
<p>substr操作</p>
<p><code>s.substr(pos, n)</code>  返回一个<code>string</code>，包含<code>s</code>中<strong>从<code>pos</code>开始</strong>的<code>n</code>个字符的拷贝。<code>pos</code>的默认值是0，<code>n</code>的默认值是<code>s.size() - pos</code>，即拷贝从<code>pos</code>开始的所有字符</p>
<p>改变string的其他方法</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.insert(pos, args)</code></td>
<td>在<code>pos</code>之前插入<code>args</code>指定的字符。<code>pos</code>可以使是下标或者迭代器。接受下标的版本返回指向<code>s</code>的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td>
</tr>
<tr>
<td><code>s.erase(pos, len)</code></td>
<td>删除从<code>pos</code>开始的<code>len</code>个字符，如果<code>len</code>被省略，则删除后面所有字符，返回指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.assign(args)</code></td>
<td>将<code>s</code>中的字符替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.append(args)</code></td>
<td>将<code>args</code>指定的字符追加到<code>s</code>，返回一个指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.replace(range, args)</code></td>
<td>删除<code>s</code>中范围<code>range</code>中的字符，替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td>
</tr>
</tbody></table>
<p>编写一个函数，接受三个<code>string</code>参数是<code>s</code>、<code>oldVal</code> 和<code>newVal</code>。使用迭代器及<code>insert</code>和<code>erase</code>函数将<code>s</code>中所有<code>oldVal</code>替换为<code>newVal</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstddef&gt;</span><br><span class="line"></span><br><span class="line">using std::cout; </span><br><span class="line">using std::endl; </span><br><span class="line">using std::string;</span><br><span class="line"></span><br><span class="line">auto replace_with(string &amp;s, string const&amp; oldVal, string const&amp; newVal)</span><br><span class="line">&#123;</span><br><span class="line">    for (auto cur = s.begin(); cur &lt;= s.end() - oldVal.size(); )</span><br><span class="line">        if (oldVal == string&#123; cur, cur + oldVal.size() &#125;)</span><br><span class="line">            cur = s.erase(cur, cur + oldVal.size()),</span><br><span class="line">            cur = s.insert(cur, newVal.begin(), newVal.end()),</span><br><span class="line">            cur += newVal.size();</span><br><span class="line">        else  </span><br><span class="line">            ++cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s&#123; &quot;To drive straight thru is a foolish, tho courageous act.&quot; &#125;;</span><br><span class="line">    replace_with(s, &quot;tho&quot;, &quot;though&quot;);</span><br><span class="line">    replace_with(s, &quot;thru&quot;, &quot;through&quot;);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写上一题的函数，这次使用一个下标和<code>replace</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using std::cout; </span><br><span class="line">using std::endl;</span><br><span class="line">using std::string;</span><br><span class="line"></span><br><span class="line">auto replace_with(string &amp;s, string const&amp; oldVal, string const&amp; newVal)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t pos = 0; pos &lt;= s.size() - oldVal.size();)</span><br><span class="line">        if (s[pos] == oldVal[0] &amp;&amp; s.substr(pos, oldVal.size()) == oldVal)</span><br><span class="line">            s.replace(pos, oldVal.size(), newVal),</span><br><span class="line">            pos += newVal.size();</span><br><span class="line">        else</span><br><span class="line">            ++pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str&#123; &quot;To drive straight thru is a foolish, tho courageous act.&quot; &#125;;</span><br><span class="line">    replace_with(str, &quot;tho&quot;, &quot;though&quot;);</span><br><span class="line">    replace_with(str, &quot;thru&quot;, &quot;through&quot;);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="string的搜索操作"><a href="#string的搜索操作" class="headerlink" title="string的搜索操作"></a>string的搜索操作</h3><p>每个操作都接受一个可选的第二参数，表示从什么位置开始搜索</p>
<table>
<thead>
<tr>
<th>搜索操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.find(args)</code></td>
<td>查找<code>s</code>中<code>args</code>第一次出现的位置</td>
</tr>
<tr>
<td><code>s.rfind(args)</code></td>
<td>查找<code>s</code>中<code>args</code>最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_of(args)</code></td>
<td>在<code>s</code>中查找<code>args</code>中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_last_of(args)</code></td>
<td>在<code>s</code>中查找<code>args</code>中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>在<code>s</code>中查找第一个不在<code>args</code>中的字符</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>在<code>s</code>中查找最后一个不在<code>args</code>中的字符</td>
</tr>
</tbody></table>
<p>每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。如果搜索失败则返回一个名为<code>string::npos</code>的<code>static</code>成员（类型是<code>string::size_type</code>，初始化值是-1，npos是一个无符号类型，也就是<code>string</code>最大的可能大小）</p>
<h3 id="string的比较操作"><a href="#string的比较操作" class="headerlink" title="string的比较操作"></a>string的比较操作</h3><table>
<thead>
<tr>
<th>参数形式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s2</code></td>
<td>比较<code>s</code>和<code>s2</code></td>
</tr>
<tr>
<td><code>pos1, n1, s2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td>
</tr>
<tr>
<td><code>pos1, n1, s2, pos2, n2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td>
</tr>
<tr>
<td><code>cp</code></td>
<td>比较<code>s</code>和<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td><code>pos1, n1, cp</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td><code>pos1, n1, cp, n2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的地址开始<code>n2</code>个字符</td>
</tr>
</tbody></table>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><code>to_string(val)</code>  一组重载函数，返回数值<code>val</code>的<code>string</code>表示。<code>val</code>可以使任何算术类型。对每个浮点类型和<code>int</code>或更大的整型，都有相应版本的<code>to_string()</code>。和往常一样，小整型会被提升。</p>
<p><code>stoi(s, p, b)</code>  返回<code>s</code>起始子串（表示整数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0，即函数不保存下标。<code>b</code>是转换所用的基数，默认是10。返回<code>int</code></p>
<p>要转换为数值的string中第一个非空表字符必须是数值中可能出现的字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s2 = &quot;pi = 3.14&quot;;</span><br><span class="line">d = stod(s2.substr(s2.find_first_of(&quot;+-.0123456789&quot;)));</span><br></pre></td></tr></table></figure>

<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>适配器是使一事物的行为类似于另一事物的行为的一种机制。函数、容器和迭代器都有适配器</p>
<p>三个顺序容器适配器：stack、queue和priority_queue</p>
<p>默认下，stack和queue是基于deque实现的，priority_queue是基于vector实现的，可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，实现对默认容器类型的重载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int,&lt;vector&lt;int&gt;&gt; stk;</span><br></pre></td></tr></table></figure>

<p>stack需要实现后进先出，即<code>push_back</code>和<code>pop_back</code>的操作，则可以使用<code>vector</code>和<code>deque</code>实现，而不可以用<code>forward_list</code>构建</p>
<p>queue需要实现先进先出，即<code>push_back</code>和<code>pop_front</code>的操作，那么就不可以使用<code>vector</code>而可以使用<code>deque</code>和<code>list</code>构建</p>
<p>priority_queue需要有随机访问的能力，因此可使用<code>vector</code>和<code>deque</code>构建</p>
<p>对于每个容器适配器，只可以使用适配器操作，而不能使用底层容器类型的操作</p>
<h2 id="第十章——泛型算法"><a href="#第十章——泛型算法" class="headerlink" title="第十章——泛型算法"></a>第十章——泛型算法</h2><p>泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现</p>
<p>算法<strong>永远不会改变底层容器的大小</strong>。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素</p>
<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p> <code>accumulate</code>（在<code>numeric</code>中定义），接受三个参数，前两个指出需要求和的元素的范围，第三个是求和的初值。由于在string中定义了“+”运算符，则可以通过accumulate将string元素连接起来；如果传入一个字符串字面值给第三个参数，类型将是<code>const char *</code>，并没有“+”运算符，则会报错</p>
<p><code>find_first_of</code>，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的<code>end</code>迭代器。</p>
<p>对于只读取而不改变元素的算法，通常最好使用<code>cbegin</code>和<code>cend</code></p>
<p><code>equal</code>：确定两个序列是否保存相同的值，前两个表示第一个序列中的范围，第三个表示第二个序列的首元素。若在传入C风格字符串，则比较的是两个指针指向的地址</p>
<p>只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长</p>
<h3 id="写容器的算法"><a href="#写容器的算法" class="headerlink" title="写容器的算法"></a>写容器的算法</h3><p><code>fill</code>： <code>fill(vec.begin(), vec.end(), 0);</code> 将每个元素重置为0</p>
<p><code>fill_n</code>： <code>fill_n(vec.begin(), 10, 0);</code>将给定值赋予迭代器指向的元素开始的指定个元素，但要确保容器能容纳要写入的元素</p>
<p>插入迭代器<code>back_inserter</code>：</p>
<p>用来确保算法有足够的空间存储数据。<code>#include &lt;iterator&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec;				//空vector</span><br><span class="line">auto it = back_inserter(vec);	 //创建插入迭代器</span><br><span class="line">*it = 42;						//添加一个元素</span><br><span class="line">fill_n(back_inserter(vec),10,0);  //添加10个元素</span><br></pre></td></tr></table></figure>

<p>拷贝算法<code>copy</code>，前两个参数指定输入范围，第三个指向目标序列。传递给copy的目的序列至少要包含与输入序列一样多的元素，返回目的位置迭代器递增后的位置。可以用copy实现对内置数组的拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a1[] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">int a2[sizeof(a1)/sizeof(*a1)];</span><br><span class="line">auto ret = copy(begin(a1),end(a1),a2);</span><br><span class="line">//ret指向拷贝到a2的尾元素之后的位置</span><br></pre></td></tr></table></figure>

<p>replace算法将输入序列中所有等于给定值的元素都改为另一个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(ilst.begin(),ilst.edn(),0,42);</span><br></pre></td></tr></table></figure>

<p>上述语句将该序列中所有0替换成42，若希望原序列不变，则用replace_copy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace_copy(ilst.cbegin(),ilst.cend(),back_inserter(ivec),0,42);</span><br></pre></td></tr></table></figure>

<p>ivec包含ilst的一份拷贝，且将所有0换成42</p>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort(words.begin(),words.end());//只根据首字母排字典序</span><br><span class="line">auto end_unique = unique(words.begin(),words.end());//返回的是指向不重复区域之后第一个位置的迭代器</span><br><span class="line">words.erase(end_unique,words.end());//要删除重复元素必须要用到容器操作</span><br></pre></td></tr></table></figure>

<h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>谓词是一个<strong>可调用的表达式</strong>，返回结果是一个能用作条件的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool isShorter(const string&amp; s1,const string&amp; s2)</span><br><span class="line">&#123;</span><br><span class="line">	return s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line">sort(words.begin(),words.end(),isShorter);//按照单词长短排序</span><br><span class="line">stable_sort(words.begin(),words.end(),isShorter);//单词长度相同的则会保持字典序</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>可以向一个算法传递任何类别的可调用对象，包括<strong>函数、函数指针、重载函数调用运算符的类和lambda表达式</strong></p>
<p><code>lambda</code>表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数</p>
<p><code>[capture list](parameter list) -&gt; return type &#123;function body&#125;</code></p>
<ul>
<li><p><code>capture list</code>捕获列表</p>
<p>不可忽略。为空时表明不使用它所在函数中的任何局部变量。捕获列表只用于局部非static变量，lambda可直接使用局部static变量和它所在函数之外声明的名字</p>
</li>
<li><p><code>return type</code>是返回类型。可忽略</p>
<p>如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void；当需要为一个lambda定义返回类型时，必须使用尾置返回类型</p>
</li>
<li><p><code>parameter</code>是参数列表。可忽略</p>
</li>
<li><p><code>function body</code>是函数体。不可忽略</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(words.begin(),words.end(),[](const string&amp;a, const string&amp; b)&#123;return a.size()&lt;b.size();&#125;);</span><br><span class="line">auto wc = find_if(words.begin(), words.end(), [sz](const string &amp;a)&#123;return a.size() &gt;= sz;&#125;);</span><br><span class="line">//获取一个迭代器，指向第一个满足size&gt;=sz的元素</span><br><span class="line">for_each(wc, words.end(), [](const string &amp;s)&#123;cout &lt;&lt; s &lt;&lt; &quot; &quot;;&#125;)</span><br></pre></td></tr></table></figure>

<p>使用partition算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto pivot = partition(vs.begin(), vs.end(), [sz](const std::string &amp;s)&#123;</span><br><span class="line">        return s.size() &gt;= sz;&#125;);//相当于排序好，符合谓词的元素排在前，返回最后一个符合谓词元素的后一个位置迭代器</span><br><span class="line"></span><br><span class="line">for(auto it = vs.cbegin(); it != pivot; ++it)</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br></pre></td></tr></table></figure>

<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>定义<code>lambda</code>时会生成一个新的类类型和该类型的一个对象</p>
<p>当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的</p>
<p>隐式捕获：&amp;告诉编译器采用捕获引用方式，&#x3D;则表示值捕获方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc = find_if(words.begin(), words.end(), [=](const string &amp;a)&#123;return a.size() &gt;= sz;&#125;);</span><br></pre></td></tr></table></figure>

<p>混合使用隐式捕获和显式捕获时，捕获列表第一个元素必须是一个&amp;或&#x3D;，显式捕获的变量必须使用与隐式捕获不同的方式，即如果隐式捕获采用引用方式（&amp;），则显式捕获命名变量必须采用值方式。</p>
<h3 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变lambda</h3><p>如果希望能改变一个<strong>被捕获的变量</strong>的值（不改变原来的值），就必须在<strong>参数列表首</strong>加上<code>mutable</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t v1 = 42;</span><br><span class="line">auto f = [v1] () mutable &#123;return ++v1;&#125;;</span><br><span class="line">v1 = 0;</span><br><span class="line">auto j = f(); //j为43</span><br></pre></td></tr></table></figure>

<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>标准库bind函数，定义在头文件<code>functional</code>中，可以看做为一个通用的函数适配器。接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表</p>
<p><code>auto newCallable = bind(callable, arg_list);</code></p>
<p><code>arg_list</code>中的参数可能包含形如<code>_n</code>的名字，其中n是一个整数，这些是占位符。<code>_n</code>代表第n个位置的参数。定义在<code>placeholders</code>的命名空间中。<code>using std::placeholder::_1;</code>或<code>using namespace std::placeholders;</code>使得由<code>placeholders</code>定义的所有名字都可用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool check_size(const string&amp; s, string::size_type sz)</span><br><span class="line">&#123;</span><br><span class="line">	return s.size() &gt;= sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要将这个函数作为<code>find_if</code>（接受一个一元谓词）的参数，则可以绑定<code>check_size</code>的sz参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto check6 = bind(check_size,_1,6);</span><br><span class="line"></span><br><span class="line">string s = &quot;hello&quot;;</span><br><span class="line">bool b1 = check6(s);	//相当于调用check_size(s,6);</span><br></pre></td></tr></table></figure>

<p><code>auto g = bind(f, a, b, _2, c, _1);</code>，调用<code>g(_1, _2)</code>实际上调用<code>f(a, b, _2, c, _1)</code></p>
<p>非占位符的参数要使用引用传参，必须使用标准库<code>ref</code>函数或者<code>cref</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;print(ostream &amp;os,const string &amp;s,char c)</span><br><span class="line">&#123;</span><br><span class="line">	return os &lt;&lt; s &lt;&lt; c; </span><br><span class="line">&#125;</span><br><span class="line">for_each(words.begin(),words.end(),bind(print,ref(os),_1,&#x27; &#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素</p>
<ul>
<li><code>back_inserter</code>：创建一个使用<code>push_back</code>的迭代器。</li>
<li><code>front_inserter</code>创建一个使用<code>push_front</code>的迭代器。元素总是插入到容器的第一个元素之前</li>
<li><code>inserter</code>创建一个使用<code>insert</code>的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被查到迭代器所指向的元素<strong>之前</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lst = &#123;1,2,3,4&#125;;</span><br><span class="line">list&lt;int&gt; lst2,lst3;</span><br><span class="line">copy(lst.begin(),lst.end(),front_inserter(lst2));		//生成&#123;4,3,2,1&#125;</span><br><span class="line">copy(lst.begin(),lst.end(),inserter(lst3,lst.begin()));	//生成&#123;1,2,3,4&#125;</span><br></pre></td></tr></table></figure>

<p><code>front_inserter</code>生成的迭代器会将插入的元素序列的顺序颠倒过来，而<code>inserter</code>和<code>back_inserter</code>则不会</p>
<h3 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h3><p>迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator &lt;int&gt; in_iter(cin);	//从cin读入int</span><br><span class="line">istream_iteraator &lt;int&gt; eof;			//尾后迭代器</span><br><span class="line">while(in_iter!=eof)</span><br><span class="line">&#123;</span><br><span class="line">	vec.push_back(*in_iter++);</span><br><span class="line">&#125;</span><br><span class="line">//另一种方式</span><br><span class="line">vector&lt;int&gt; vec(in_iter,eof);</span><br></pre></td></tr></table></figure>

<p>ostream_iterator提供可选第二参数，是一个C风格字符串，每各元素输出后都打印此字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;int&gt; out_iter(cout,&quot; &quot;);</span><br><span class="line">for(auto e:vec)</span><br><span class="line">	*out_iter+= = e;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//另一种方式</span><br><span class="line">copy(vec.begin(),vec.end(),out_iter);</span><br></pre></td></tr></table></figure>

<p>其中解引用和递增运算可以忽略，不产生作用。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>递增一个反向迭代器会移动到前一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string line = &quot;first,second,third&quot;;</span><br><span class="line">auto comma = find(line.cbegin(),line.cend(),&#x27;,&#x27;);		//comma指向第一个逗号</span><br><span class="line">auto rcomma = find(line.crbegin(),line.crend(),&#x27;,&#x27;);	//rcomma指向的是最后一个逗号</span><br></pre></td></tr></table></figure>

<p>当需要打印出第一个和最后一个单词时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; string(line.cbegin(),comma);</span><br><span class="line">cout &lt;&lt; string(line.rcbegin(),rcomma);//这里打印出来的单词逆序打印</span><br><span class="line">cout &lt;&lt; string(rcomma.base(),line.rcend());//正序打印最后一个单词</span><br></pre></td></tr></table></figure>

<h3 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h3><p>对于<code>list</code>和<code>forward_list</code>，优先使用成员函数版本的算法而不是通用算法</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>lst.merge(lst2)</code></td>
<td>将来自<code>lst2</code>的元素合并入<code>lst</code>，二者都必须是有序的，元素将从<code>lst2</code>中删除。</td>
</tr>
<tr>
<td><code>lst.merge(lst2, comp)</code></td>
<td>同上，给定比较操作。</td>
</tr>
<tr>
<td><code>lst.remove(val)</code></td>
<td>调用<code>erase</code>删除掉与给定值相等(&#x3D;&#x3D;)的每个元素</td>
</tr>
<tr>
<td><code>lst.remove_if(pred)</code></td>
<td>调用<code>erase</code>删除掉令一元谓词为真的每个元素</td>
</tr>
<tr>
<td><code>lst.reverse()</code></td>
<td>反转<code>lst</code>中元素的顺序</td>
</tr>
<tr>
<td><code>lst.sort()</code></td>
<td>使用<code>&lt;</code>排序元素</td>
</tr>
<tr>
<td><code>lst.sort(comp)</code></td>
<td>使用给定比较操作排序元素</td>
</tr>
<tr>
<td><code>lst.unique()</code></td>
<td>调用<code>erase</code>删除同一个值的连续拷贝。使用<code>==</code>。</td>
</tr>
<tr>
<td><code>lst.unique(pred)</code></td>
<td>调用<code>erase</code>删除同一个值的连续拷贝。使用给定的二元谓词。</td>
</tr>
</tbody></table>
<p><strong>list和forward_list的splice成员函数版本的参数</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>(p, lst2)</code></td>
<td><code>p</code>是一个指向<code>lst</code>中元素的迭代器，或者一个指向<code>flst</code>首前位置的迭代器。函数将<code>lst2</code>中的所有元素移动到<code>lst</code>中<code>p</code>之前的位置或是<code>flst</code>中<code>p</code>之后的位置。将元素从<code>lst2</code>中删除。<code>lst2</code>的类型必须和<code>lst</code>相同，而且不能是同一个链表。</td>
</tr>
<tr>
<td><code>(p, lst2, p2)</code></td>
<td>同上，<code>p2</code>是一个指向<code>lst2</code>中位置的有效的迭代器，将<code>p2</code>指向的元素移动到<code>lst</code>中，或将<code>p2</code>之后的元素移动到<code>flst</code>中。<code>lst2</code>可以是于<code>lst</code>或<code>flst</code>相同的链表。</td>
</tr>
<tr>
<td><code>(p, lst2, b, e)</code></td>
<td><code>b</code>和<code>e</code>表示<code>lst2</code>中的合法范围。将给定范围中的元素从<code>lst2</code>移动到<code>lst</code>或<code>first</code>中。<code>lst2</code>与<code>lst</code>可以使相同的链表，但<code>p</code>不能指向给定范围中的元素。</td>
</tr>
</tbody></table>
<ul>
<li>使用<code>lst.splice(args)</code>或<code>flst.splice_after(args)</code></li>
</ul>
<p>链表特有版本与通用版本的区别在于链表版本会改变底层的容器</p>
<h2 id="第十一章——关联容器"><a href="#第十一章——关联容器" class="headerlink" title="第十一章——关联容器"></a>第十一章——关联容器</h2><p>关联容器中的元素时按照<strong>关键字</strong>来保存和访问的，支持通过关键字来高效地查找和读取元素</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器，关键字类型必须定义元素比较的方法。默认是<code>&lt;</code></p>
<p>对于自定义类型，如果想传递一个比较的函数，所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>（小于等于），可以这样定义，提供关键字类型（Sales_data）以及比较操作类型（函数指针类型）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool compareIsbn(const Sales_data &amp;lhs, const Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	return lhs.isbn() &lt; rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line">//1.</span><br><span class="line">multiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn);</span><br><span class="line">//2.</span><br><span class="line">bool (*pf) (const Sales_data &amp;,const Sales_data &amp;) = &amp;compareIsbn;//&amp;可忽略</span><br><span class="line">multiset&lt;Sales_data, pf&gt; bookstore(pf);</span><br><span class="line">//3.</span><br><span class="line">using pf = bool (*) (const Sales_data &amp;,const Sales_data &amp;);</span><br><span class="line">multiset&lt;Sales_data, pf&gt; bookstore(pf);</span><br></pre></td></tr></table></figure>

<p>用<code>compareIsbn</code>来初始化<code>bookstore</code>对象，表明在向对象添加元素时，将调用<code>compareIsbn</code>函数来进行排序。且可以代替<code>&amp;compareIsbn</code>，当使用一个函数名字时，会自动转换成指针类型</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>在<code>utility</code>头文件中定义</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>pair&lt;T1, T2&gt; p;</code></td>
<td><code>p</code>是一个<code>pair</code>，两个类型分别是<code>T1</code>和<code>T2</code>的成员都进行了值初始化。</td>
</tr>
<tr>
<td><code>pair&lt;T1, T2&gt; p(v1, v2);</code></td>
<td><code>first</code>和<code>second</code>分别用<code>v1</code>和<code>v2</code>进行初始化。</td>
</tr>
<tr>
<td><code>pair&lt;T1, T2&gt;p = &#123;v1, v2&#125;;</code></td>
<td>等价于&#96;p(v1, v2)</td>
</tr>
<tr>
<td><code>make_pair(v1, v2);</code></td>
<td><code>pair</code>的类型从<code>v1</code>和<code>v2</code>的类型推断出来。</td>
</tr>
</tbody></table>
<p>当函数需要返回一个pair时，可以直接对返回值进行列表初始化</p>
<p><code>return &#123;v.back(),v.back().size()&#125;;</code></p>
<h3 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h3><table>
<thead>
<tr>
<th>类型别名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>key_type</code></td>
<td>此容器类型的关键字类型</td>
</tr>
<tr>
<td><code>mapped_type</code></td>
<td>每个关键字关联的类型，只适用于<code>map</code></td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>对于<code>map</code>，是<code>pair&lt;const key_type, mapped_type&gt;</code>; 对于<code>set</code>，和<code>key_type</code>相同。</td>
</tr>
</tbody></table>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>解引用一个关联容器迭代器时，<strong>会得到一个类型为容器的<code>value_type</code>的值的引用</strong></p>
<p>虽然set定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种类型都只允许只读访问</p>
<p>遍历<code>map</code>、<code>multimap</code>、<code>set</code>、<code>multiset</code>时，迭代器按<strong>关键字升序</strong>遍历元素</p>
<p>使用关联容器定义的专用算法会比泛型算法快很多</p>
<table>
<thead>
<tr>
<th><code>insert</code>操作</th>
<th>关联容器</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.insert(v)</code>  <code>c.emplace(args)</code></td>
<td><code>v</code>是<code>value_type</code>类型的对象；<code>args</code>用来构造一个元素。 对于<code>map</code>和<code>set</code>，只有元素的关键字不存在<code>c</code>中才插入或构造元素。函数返回一个<code>pair</code>，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的<code>bool</code>值。对于<code>multimap</code>和<code>multiset</code>则会插入范围中的每个元素。</td>
</tr>
<tr>
<td><code>c.insert(b, e)</code> <code>c.insert(il)</code></td>
<td><code>b</code>和<code>e</code>是迭代器，表示一个<code>c::value_type</code>类型值的范围；<code>il</code>是这种值的花括号列表。函数返回<code>void</code>。对于 <code>map</code>和<code>set</code>，只插入关键字不在<code>c</code>中的元素。</td>
</tr>
<tr>
<td><code>c.insert(p, v)</code>  <code>c.emplace(p, args)</code></td>
<td>类似<code>insert(v)</code>，但将迭代器<code>p</code>作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。</td>
</tr>
</tbody></table>
<p>向<code>map</code>添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word_count.insert(&#123;word, 1&#125;);</span><br><span class="line">word_count.insert(make_pair(word, 1));</span><br><span class="line">word_count.insert(pair&lt;string, size_t&gt;(word, 1));</span><br><span class="line">`word_count.insert(map&lt;string, size_t&gt;::value_type (word, 1));`</span><br></pre></td></tr></table></figure>

<p>以上四种添加方式等价</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (cin &gt;&gt; word)</span><br><span class="line">	++word_count.insert(&#123;word, 0&#125;).first-&gt;second;</span><br></pre></td></tr></table></figure>

<p>这条语句等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (cin &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">	auto result = word_count.insert(&#123;word, 0&#125;);</span><br><span class="line">	++(result.first-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>insert</code>成功时，返回指向该元素位置的迭代器，并对其值加一操作，即<code>insert</code>一个<code>&#123;word，1&#125;;</code></p>
<p><code>insert</code>失败时，返回的是指向map容器中已有的该元素位置的迭代器，并对其值加一操作</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.erase(k)</code></td>
<td>从<code>c</code>中删除每个关键字为<code>k</code>的元素。返回一个<code>size_type</code>值，指出删除的元素的数量。</td>
</tr>
<tr>
<td><code>c.erase(p)</code></td>
<td>从<code>c</code>中删除迭代器<code>p</code>指定的元素。<code>p</code>必须指向<code>c</code>中一个真实元素，不能等于<code>c.end()</code>。返回一个指向<code>p</code>之后元素的迭代器，若<code>p</code>指向<code>c</code>中的尾元素，则返回<code>c.end()</code></td>
</tr>
<tr>
<td><code>c.erase(b, e)</code></td>
<td>删除迭代器对<code>b</code>和<code>e</code>所表示范围中的元素。返回<code>e</code>。</td>
</tr>
</tbody></table>
<h3 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h3><p>只有**<code>map</code>和<code>unordered_map（非const）</code>有下标运算符和对应的at函数**，set类型不支持下标，<code>multimap</code>或<code>unordered_multimap</code>可能有多个值与关键字相关联，也不支持下标操作</p>
<p>如果使用下标操作时，关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化</p>
<h3 id="访问查找元素"><a href="#访问查找元素" class="headerlink" title="访问查找元素"></a>访问查找元素</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.find(k)</code></td>
<td>返回一个迭代器，指向第一个关键字为<code>k</code>的元素，若<code>k</code>不在容器中，则返回尾后迭代器</td>
</tr>
<tr>
<td><code>c.count(k)</code></td>
<td>返回关键字等于<code>k</code>的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1。</td>
</tr>
<tr>
<td><code>c.lower_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>不小于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.upper_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>大于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.equal_range(k)</code></td>
<td>返回一个迭代器<code>pair</code>，表示关键字等于<code>k</code>的元素的范围。若<code>k</code>不存在，<code>pair</code>的两个成员均等于<code>c.end()</code>。</td>
</tr>
</tbody></table>
<p><code>lower_bound</code>和<code>upper_bound</code>不适用于无序容器</p>
<h3 id="打印作者的所有著作"><a href="#打印作者的所有著作" class="headerlink" title="打印作者的所有著作"></a>打印作者的所有著作</h3><p>使用find和count函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string search_item(&quot;Kevin&quot;);//要查找的作者</span><br><span class="line">auto entries = authors.count(search_item);</span><br><span class="line">auto iter = authors.find(search_item);</span><br><span class="line">while(entries)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    ++iter;</span><br><span class="line">    --entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>lower_bound</code>和<code>upper_bound</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(auto beg = authors.lower_bound(search_item);beg!=authors.upper_bound(search_item);beg++)</span><br><span class="line">	cout &lt;&lt; beg-&gt;second &lt;&lt; endl;</span><br><span class="line">//lower_bound 返回的是第一个等于查找值的迭代器，upper_bound 返回的是最后一个等于查找值的后一个元素的迭代器</span><br></pre></td></tr></table></figure>

<p>使用<code>equal_range</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(auto pos = authors.equal_range(search_item);pos.first!=pos.second;++pos.first)</span><br><span class="line">	cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="单词转换程序？？？"><a href="#单词转换程序？？？" class="headerlink" title="单词转换程序？？？"></a>单词转换程序？？？</h3><p>here is the link to [istringistream](# istringstream)</p>
<p>通过读取map_file文件获得单词转换规则，在读入input文件过程中将根据映射返回转换后的内容，即打印出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; buildMap(ifstream &amp;map_file)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const string&amp; transform(const string&amp; s, const map&lt;string,string&gt; &amp;m)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void word_transform(ifstream &amp;map_file,ifstream &amp;input)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h3><p>有序容器使用比较运算符来组织元素；无序容器使用哈希函数和关键字类型的<code>==</code>运算符</p>
<p>无序容器在存储上组织为一组桶(bucket)，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>桶接口</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.bucket_count()</code></td>
<td>正在使用的桶的数目</td>
</tr>
<tr>
<td><code>c.max_bucket_count()</code></td>
<td>容器能容纳的最多的桶的数目</td>
</tr>
<tr>
<td><code>c.bucket_size(n)</code></td>
<td>第<code>n</code>个桶中有多少个元素</td>
</tr>
<tr>
<td><code>c.bucket(k)</code></td>
<td>关键字为<code>k</code>的元素在哪个桶中</td>
</tr>
<tr>
<td><strong>桶迭代</strong></td>
<td></td>
</tr>
<tr>
<td><code>local_iterator</code></td>
<td>可以用来访问桶中元素的迭代器类型</td>
</tr>
<tr>
<td><code>const_local_iterator</code></td>
<td>桶迭代器的<code>const</code>版本</td>
</tr>
<tr>
<td><code>c.begin(n)</code>，<code>c.end(n)</code></td>
<td>桶<code>n</code>的首元素迭代器</td>
</tr>
<tr>
<td><code>c.cbegin(n)</code>，<code>c.cend(n)</code></td>
<td>与前两个函数类似，但返回<code>const_local_iterator</code>。</td>
</tr>
<tr>
<td><strong>哈希策略</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.load_factor()</code></td>
<td>每个桶的平均元素数量，返回<code>float</code>值。</td>
</tr>
<tr>
<td><code>c.max_load_factor()</code></td>
<td><code>c</code>试图维护的平均比桶大小，返回<code>float</code>值。<code>c</code>会在需要时添加新的桶，以使得<code>load_factor&lt;=max_load_factor</code></td>
</tr>
<tr>
<td><code>c.rehash(n)</code></td>
<td>重组存储，使得<code>bucket_count&gt;=n</code>，且<code>bucket_count&gt;size/max_load_factor</code></td>
</tr>
<tr>
<td><code>c.reverse(n)</code></td>
<td>重组存储，使得<code>c</code>可以保存<code>n</code>个元素且不必<code>rehash</code>。</td>
</tr>
</tbody></table>
<p>无序容器的性能依赖于哈希函数的质量和桶的数量和大小</p>
<h3 id="无序类型对关键字类型的要求"><a href="#无序类型对关键字类型的要求" class="headerlink" title="无序类型对关键字类型的要求"></a>无序类型对关键字类型的要求</h3><p>不能直接定义关键字类型为自定义类类型的无序容器，需要提供自定义的哈希值函数以及提供函数替代<code>==</code>运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_t hasher(const Sales_data &amp;sd)</span><br><span class="line">&#123;</span><br><span class="line">	return hash&lt;string&gt;() (sd.isbn());</span><br><span class="line">&#125;</span><br><span class="line">bool eqOp(const Sales_data &amp;lhs,const Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	return lhs.isbn() == rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line">//使用重载的哈希值计算函数和比较函数来定义无序容器</span><br><span class="line">using SD_multiset = unordered_multiset&lt;Sales_data,decltype(hasher)*,decltype(eqOp)*&gt;;</span><br><span class="line">SD_multiset bookstore(42,hasher,eqOp);</span><br></pre></td></tr></table></figure>

<h2 id="第十二章——动态内存"><a href="#第十二章——动态内存" class="headerlink" title="第十二章——动态内存"></a>第十二章——动态内存</h2><ul>
<li><strong>静态内存</strong>用来保存局部<code>static</code>对象、类<code>static</code>对象、定义在任何函数之外的变量（全局）。</li>
<li><strong>栈内存</strong>用来保存定义在函数内的非<code>static</code>对象（局部）。</li>
<li><strong>堆内存</strong>，又称自由空间，用来存储<strong>动态分配</strong>的对象，即在程序运行时分配的对象，需要显式地销毁</li>
</ul>
<p>动态内存管理通过<code>new</code>为对象分配空间并返回一个指向该对象的指针，通过<code>delete</code>接收一个动态对象的指针，销毁对象并释放内存。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><strong>shared_ptr和unique_ptr都支持的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>shared_ptr&lt;T&gt; sp</code>  <code>unique_ptr&lt;T&gt; up</code></td>
<td>空智能指针，可以指向类型是<code>T</code>的对象</td>
</tr>
<tr>
<td><code>p</code></td>
<td>将<code>p</code>用作一个条件判断，若<code>p</code>指向一个对象，则为<code>true</code></td>
</tr>
<tr>
<td><code>*p</code></td>
<td>解引用<code>p</code>，获得它指向的对象。</td>
</tr>
<tr>
<td><code>p-&gt;mem</code></td>
<td>等价于<code>(*p).mem</code></td>
</tr>
<tr>
<td><code>p.get()</code></td>
<td>返回<code>p</code>中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。</td>
</tr>
<tr>
<td><code>swap(p, q)</code> <code>p.swap(q)</code></td>
<td>交换<code>p</code>和<code>q</code>中的指针</td>
</tr>
</tbody></table>
<p><strong>shared_ptr独有的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>make_shared&lt;T&gt;(args)</code></td>
<td>返回一个<code>shared_ptr</code>，指向一个动态分配的类型为<code>T</code>的对象。使用<code>args</code>初始化此对象。</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt;p(q)</code></td>
<td><code>p</code>是<code>shared_ptr q</code>的拷贝；此操作会<strong>递增</strong><code>q</code>中的计数器。<code>q</code>中的指针必须能转换为<code>T*</code></td>
</tr>
<tr>
<td><code>p = q</code></td>
<td><code>p</code>和<code>q</code>都是<code>shared_ptr</code>，所保存的指针必须能互相转换。此操作会<strong>递减</strong><code>p</code>的引用计数，<strong>递增</strong><code>q</code>的引用计数；若<code>p</code>的引用计数变为0，则将其管理的原内存释放。</td>
</tr>
<tr>
<td><code>p.unique()</code></td>
<td>若<code>p.use_count()</code>是1，返回<code>true</code>；否则返回<code>false</code></td>
</tr>
<tr>
<td><code>p.use_count()</code></td>
<td>返回与<code>p</code>共享对象的智能指针数量；可能很慢，主要用于调试。</td>
</tr>
</tbody></table>
<p><code>make_shared</code>用其参数来构造给定类型的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto p = make_shared&lt;string&gt;(5,&#x27;5&#x27;); </span><br></pre></td></tr></table></figure>

<p>每个<code>shared_ptr</code>都有一个关联的计数器，称为引用计数，记录有多少个<code>shared_ptr</code>指向相同的对象。当指向一个对象的最后一个<code>shared_ptr</code>被销毁时，会自动销毁此对象，即释放相关联的内存。</p>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>用new动态分配和初始化对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string *ps1 = new string;		//默认初始化为空</span><br><span class="line">string *ps2 = new string();		//值初始化为空</span><br><span class="line">int *pi1 = new int;				//默认初始化，未定义</span><br><span class="line">int *pi2 = new int();			//值初始化为0，*pi2 为0</span><br></pre></td></tr></table></figure>

<p>对于内置类型来说，值初始化有定义的值，默认初始化的对象的值则是未定义；对于定义了构造函数的类类型，都会通过默认构造函数来初始化</p>
<p>由于要用初始化器的类型来推断要分配的类型，只有当括号中有单一初始化器才可以使用auto</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto p1 = new auto(obj);</span><br></pre></td></tr></table></figure>

<p>默认下，new不能分配所要求的内存空间，会抛出<code>bad_alloc</code>的异常，可以将<code>nothrow</code>传递给new阻止其抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = new (nothrow) int;</span><br></pre></td></tr></table></figure>

<p><code>delete</code>要求必须指向<strong>动态分配的内存</strong>或者是一个<strong>空指针</strong></p>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>接受指针参数的智能指针构造函数是<code>explicit</code>的，不能将一个内置指针隐式转换成智能指针，只能直接初始化，即用new返回的指针来初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; p1 = new int(1024);</span><br><span class="line">//错误，不能隐式转换,类似于函数传参</span><br><span class="line">shared_ptr&lt;int&gt; p2(new int(1024));</span><br><span class="line">//正确</span><br></pre></td></tr></table></figure>

<p><strong>定义和改变shared_ptr的其他方法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>shared_ptr&lt;T&gt; p(q)</code></td>
<td><code>p</code>管理内置指针<code>q</code>所指向的对象；<code>q</code>必须指向<code>new</code>分配的内存，且能够转换为<code>T*</code>类型</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(u)</code></td>
<td><code>p</code>从<code>unique_ptr u</code>那里接管了对象的所有权；将<code>u</code>置为空</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(q, d)</code></td>
<td><code>p</code>接管了内置指针<code>q</code>所指向的对象的所有权。<code>q</code>必须能转换为<code>T*</code>类型。<code>p</code>将使用可调用对象<code>d</code>来代替<code>delete</code>。</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(p2, d)</code></td>
<td><code>p</code>是<code>shared_ptr p2</code>的拷贝，唯一的区别是<code>p</code>将可调用对象<code>d</code>来代替<code>delete</code>。</td>
</tr>
<tr>
<td><code>p.reset()</code></td>
<td>若<code>p</code>是唯一指向其对象的<code>shared_ptr</code>，<code>reset</code>会释放此对象。若传递了可选的参数内置指针<code>q</code>，会令<code>p</code>指向<code>q</code>，否则会将<code>p</code>置空。若还传递了参数<code>d</code>，则会调用<code>d</code>而不是<code>delete</code>来释放<code>q</code>。</td>
</tr>
<tr>
<td><code>p.reset(q)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>p.reset(q, d)</code></td>
<td>同上</td>
</tr>
</tbody></table>
<p>get函数返回一个<strong>内置指针</strong>，指向智能指针管理的对象。只有在确定代码不会delete指针的情况下才使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(!p.unique())</span><br><span class="line">	p.reset(new int(*p));</span><br><span class="line">//如果不是唯一用户，则将一份拷贝到新内存上并使其成为唯一用户</span><br></pre></td></tr></table></figure>

<p>不使用get()初始化或reset另一个智能指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process(shared_ptr&lt;int&gt;(p.get()));</span><br></pre></td></tr></table></figure>

<p><code>p.get()</code>返回内置指针，然后创建了新的临时<code>shared_ptr</code>智能指针，也是指向p指向的对象，但这是新的<code>shared_ptr</code>，此时计数值为1，当执行完该语句后，临时智能指针被销毁，所指向的内存也被释放，则原有的p指针成为空悬指针，再对p进行操作会出现错误</p>
<p><strong>只有<code>shared_ptr&lt;int&gt; p2(p)</code>，此时p2与p共同指向同一个对象，计数值为2</strong></p>
<h3 id="使用自己的释放操作"><a href="#使用自己的释放操作" class="headerlink" title="使用自己的释放操作"></a>使用自己的释放操作</h3><p>如果你使用智能指针管理的资源不是<code>new</code>分配的内存，记住传递给它一个删除器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">struct connection</span><br><span class="line">&#123;</span><br><span class="line">	std::string ip;</span><br><span class="line">	int port;</span><br><span class="line">	connection(std::string i, int p) : ip(i), port(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct destination</span><br><span class="line">&#123;</span><br><span class="line">	std::string ip;</span><br><span class="line">	int port;</span><br><span class="line">	destination(std::string i, int p) : ip(i), port(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">connection connect(destination* pDest)</span><br><span class="line">&#123;</span><br><span class="line">	std::shared_ptr&lt;connection&gt; pConn(new connection(pDest-&gt;ip, pDest-&gt;port));</span><br><span class="line">	std::cout &lt;&lt; &quot;creating connection(&quot; &lt;&lt; pConn.use_count() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</span><br><span class="line">	return *pConn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void disconnect(connection pConn)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;connection close(&quot; &lt;&lt; pConn.ip &lt;&lt; &quot;:&quot; &lt;&lt; pConn.port &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void end_connection(connection* pConn)</span><br><span class="line">&#123;</span><br><span class="line">	disconnect(*pConn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f(destination &amp;d)</span><br><span class="line">&#123;</span><br><span class="line">	connection conn = connect(&amp;d);</span><br><span class="line">	std::shared_ptr&lt;connection&gt; p(&amp;conn, end_connection);</span><br><span class="line">	std::cout &lt;&lt; &quot;connecting now(&quot; &lt;&lt; p.use_count() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	destination dest(&quot;220.181.111.111&quot;, 10086);</span><br><span class="line">	f(dest);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当p被销毁时，会调用删除器函数<code>end_connection</code>，即使发生异常，p同样会被销毁从而关闭连接</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>某一个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象，不支持拷贝或者赋值操作</p>
<p><strong>unique_ptr操作</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>unique_ptr&lt;T&gt; u1</code></td>
<td>空<code>unique_ptr</code>，可以指向类型是<code>T</code>的对象。<code>u1</code>会使用<code>delete</code>来是释放它的指针。</td>
</tr>
<tr>
<td><code>unique_ptr&lt;T, D&gt; u2</code></td>
<td><code>u2</code>会使用一个类型为<code>D</code>的可调用对象来释放它的指针。</td>
</tr>
<tr>
<td><code>unique_ptr&lt;T, D&gt; u(d)</code></td>
<td>空<code>unique_ptr</code>，指向类型为<code>T</code>的对象，用类型为<code>D</code>的对象<code>d</code>代替<code>delete</code></td>
</tr>
<tr>
<td><code>u = nullptr</code></td>
<td>释放<code>u</code>指向的对象，将<code>u</code>置为空。</td>
</tr>
<tr>
<td><code>u.release()</code></td>
<td><code>u</code>放弃对指针的控制权，返回指针，并将<code>u</code>置空。</td>
</tr>
<tr>
<td><code>u.reset()</code></td>
<td>释放<code>u</code>指向的对象</td>
</tr>
<tr>
<td><code>u.reset(q)</code></td>
<td>令<code>u</code>指向<code>q</code>指向的对象</td>
</tr>
<tr>
<td><code>u.reset(nullptr)</code></td>
<td>将<code>u</code>置空</td>
</tr>
</tbody></table>
<p>可以通过调用<code>release</code>或<code>reset</code>将指针的所有权转移给另一个<code>unique_ptr</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; p1(new int (42));</span><br><span class="line">unique_ptr&lt;int&gt; p2(p1.release());//release返回悬空指针</span><br><span class="line">p2.reset(p1.release());//reset释放掉原来的对象，并指向给定的指针，即p1指针release之后的指针，指向p1原来的对象</span><br></pre></td></tr></table></figure>

<p>可以拷贝或赋值一个将要被销毁的<code>unique_ptr</code>，即通过函数的返回值返回</p>
<p>与<code>shared_ptr</code>不同，<code>unique_ptr</code>管理删除器的方式必须在指向类型之后提供删除器类型（可调用对象）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;connection,decltype(end_connection)*&gt; p(&amp;c,end_connection);</span><br></pre></td></tr></table></figure>

<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>weak_ptr&lt;T&gt; w</code></td>
<td>空<code>weak_ptr</code>可以指向类型为<code>T</code>的对象</td>
</tr>
<tr>
<td><code>weak_ptr&lt;T&gt; w(sp)</code></td>
<td>与<code>shared_ptr</code>指向相同对象的<code>weak_ptr</code>。<code>T</code>必须能转换为<code>sp</code>指向的类型。</td>
</tr>
<tr>
<td><code>w = p</code></td>
<td><code>p</code>可以是<code>shared_ptr</code>或一个<code>weak_ptr</code>。赋值后<code>w</code>和<code>p</code>共享对象。</td>
</tr>
<tr>
<td><code>w.reset()</code></td>
<td>将<code>w</code>置为空。</td>
</tr>
<tr>
<td><code>w.use_count()</code></td>
<td>与<code>w</code>共享对象的<code>shared_ptr</code>的数量。</td>
</tr>
<tr>
<td><code>w.expired()</code></td>
<td>若<code>w.use_count()</code>为0，返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td><code>w.lock()</code></td>
<td>如果<code>expired</code>为<code>true</code>，则返回一个空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code>。</td>
</tr>
</tbody></table>
<p>创建一个<code>weak_ptr</code>时，需要用<code>shared_ptr</code>来初始化它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto p = make_shared&lt;int&gt;(42);</span><br><span class="line">weak_ptr&lt;int&gt; wk(p);</span><br></pre></td></tr></table></figure>

<p>wk和p指向相同的对象，但wk不影响p的引用计数。wk指向的对象可能会被释放掉</p>
<h3 id="StrBlob和StrBlobPtr程序"><a href="#StrBlob和StrBlobPtr程序" class="headerlink" title="StrBlob和StrBlobPtr程序"></a><strong>StrBlob和StrBlobPtr程序</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr;</span><br><span class="line">class StrBlob&#123;</span><br><span class="line">friend class StrBlobPtr;</span><br><span class="line">public:</span><br><span class="line">	string&amp; begin();</span><br><span class="line">	string&amp; end();</span><br><span class="line">	</span><br><span class="line">	StrBlob() : data(make_shared&lt;vector&lt;string&gt;())&#123;&#125;</span><br><span class="line">	StrBlob(initializer_list&lt;string&gt; il) : data(make_shared&lt;vector&lt;string&gt;(il)) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	vector&lt;string&gt;::size_type size() const &#123;return data-&gt;size;&#125;</span><br><span class="line">	bool empty() const &#123;return data-&gt;empty(&#125;</span><br><span class="line">	</span><br><span class="line">	string&amp; front() &#123;check(0,&quot;no front&quot;);return data-&gt;front();&#125;</span><br><span class="line">	string&amp; back() &#123;check(0,&quot;no back&quot;);return data-&gt;back();&#125;</span><br><span class="line">	const string&amp; front() const &#123;check(0,&quot;no front&quot;);return data-&gt;front();&#125;</span><br><span class="line">	const string&amp; back() const &#123;check(0,&quot;no back&quot;);return data-&gt;back();&#125;</span><br><span class="line">	</span><br><span class="line">	void push_back(const string&amp; s) &#123;data-&gt;push_back(s);&#125;</span><br><span class="line">	void pop_back() &#123;check(0,&quot;no back to pop&quot;); data-&gt;pop_back();&#125;</span><br><span class="line">private:</span><br><span class="line">	void check(vector&lt;string&gt;::size_type t, const string&amp; msg) const</span><br><span class="line">	&#123;</span><br><span class="line">		if(t &gt;= data-&gt;size())</span><br><span class="line">			throw out_of_range(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlob::begin()</span><br><span class="line">&#123;</span><br><span class="line">	return StrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlob::end()</span><br><span class="line">&#123;</span><br><span class="line">	return StrBlobPtr(*this, data-&gt;size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义<code>StrBlob</code>类，用<code>shared_ptr</code>存储数组，提供访问元素和始末迭代器接口，声明<code>friend</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr&#123;</span><br><span class="line">public:</span><br><span class="line">	StrBlobPtr(): cur(0) &#123;&#125;</span><br><span class="line">	StrBlobPtr(StrBlob&amp; sb, size_type t = 0): wkptr(sb.data),cur(t) &#123;&#125;</span><br><span class="line">	bool operator!=(const StrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</span><br><span class="line">	string&amp; deref() const </span><br><span class="line">	&#123;</span><br><span class="line">		//检查指针是否存在以及是否超出范围</span><br><span class="line">		auto p = check(cur, &quot;dereference past end&quot;);</span><br><span class="line">		return (*p)[cur];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	StrBlobPtr&amp; incr() </span><br><span class="line">	&#123;</span><br><span class="line">		//检查是否超出范围，如果已经指向尾后迭代器则不能递增</span><br><span class="line">		check(cur, &quot;increase past end&quot;);</span><br><span class="line">		cur++;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt; check(size_type t, const string&amp; msg) const</span><br><span class="line">	&#123;</span><br><span class="line">		auto p = wkptr.lock();</span><br><span class="line">		if(!p)				//如果p为空指针</span><br><span class="line">			throw runningtime_error(&quot;unbound&quot;);</span><br><span class="line">		if(i &gt;= p-&gt;size())</span><br><span class="line">			throw out_of_range(msg);</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	weak_ptr&lt;vector&lt;string&gt;&gt; wkptr;</span><br><span class="line">	vector&lt;string&gt;::size_type cur;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>核查指针类，定义一个<code>weak_ptr</code>与<code>StrBlob</code>共享存储数组，要么指向为空，要么指向<code>vector</code>，但不增加引用数</p>
<p><code>bool operator!=(const StrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</code>重载运算符<code>!=</code>判断两个指针类是否相等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs(&quot;books.txt&quot;);</span><br><span class="line">	StrBlob sb;</span><br><span class="line">	string s;</span><br><span class="line">	while (getline(ifs, s))</span><br><span class="line">	&#123;</span><br><span class="line">		sb.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	for (StrBlobPtr sbp = sb.begin(); sbp != sb.end(); sbp.incr())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; sbp.deref() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对两个类的使用，类似于指针与指针指向对象的操作</p>
<h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p><code>new</code>一个动态数组：类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量），返回<strong>指向第一个元素类型的指针</strong>，而不是数组类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p = new int[10];	//未初始化</span><br><span class="line">int *p2 = new int[10]();//值初始化为0</span><br></pre></td></tr></table></figure>

<p>因为在值初始化的括号中未能提供初始化器，因此不能用auto</p>
<p>当用new分配一个大小为0的数组时，返回一个合法的非空指针，但不能解引用，类似于尾后迭代器</p>
<p><code>delete</code>一个动态数组：</p>
<p><code>delete [] p;</code></p>
<h3 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int []&gt; up(new int[10]);//up指向一个包含10个元素的未初始化数组</span><br></pre></td></tr></table></figure>

<p>指向数组的<code>unique_ptr</code>不支持成员访问运算符（点和箭头），可以用下标访问数组中的元素</p>
<p><code>shared_ptr</code>不直接支持管理动态数组，需要提供自定义的删除器，且<code>shared_ptr</code>未定义下标运算符，则需要通过get函数获取一个内置指针来访问数组元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp(new int[10],[](int*p)&#123;delete[] p;&#125;);</span><br><span class="line">for(size_t i = 0; i != 10; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	*(sp.get() + i) = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>定义在头文件<code>memory</code>中，将内存分配和对象构造分离开</p>
<p><strong>标准库allocator类及其算法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>allocator&lt;T&gt; a</code></td>
<td>定义了一个名为<code>a</code>的<code>allocator</code>对象，它可以为类型为<code>T</code>的对象分配内存</td>
</tr>
<tr>
<td><code>a.allocate(n)</code></td>
<td>分配一段原始的、未构造的内存，保存<code>n</code>个类型为<code>T</code>的对象。</td>
</tr>
<tr>
<td><code>a.deallocate(p, n)</code></td>
<td>释放从<code>T*</code>指针<code>p</code>中地址开始的内存，这块内存保存了<code>n</code>个类型为<code>T</code>的对象；<code>p</code>必须是一个先前由<code>allocate</code>返回的指针。且<code>n</code>必须是<code>p</code>创建时所要求的大小。在调用<code>deallocate</code>之前，用户必须对每个在这块内存中创建的对象调用<code>destroy</code>。</td>
</tr>
<tr>
<td><code>a.construct(p, args)</code></td>
<td><code>p</code>必须是一个类型是<code>T*</code>的指针，指向一块原始内存；<code>args</code>被传递给类型为<code>T</code>的构造函数，用来在<code>p</code>指向的内存中构造一个对象。</td>
</tr>
<tr>
<td><code>a.destroy(p)</code></td>
<td><code>p</code>为<code>T*</code>类型的指针，此算法对<code>p</code>指向的对象执行析构函数。</td>
</tr>
</tbody></table>
<p><strong>allocator伴随算法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>uninitialized_copy(b, e, b2)</code></td>
<td>从迭代器<code>b</code>和<code>e</code>给定的输入范围中拷贝元素到迭代器<code>b2</code>指定的未构造的原始内存中。<code>b2</code>指向的内存必须足够大，能够容纳输入序列中元素的拷贝。返回目的位置迭代器，指向最后一个构造的元素之后的位置</td>
</tr>
<tr>
<td><code>uninitialized_copy_n(b, n, b2)</code></td>
<td>从迭代器<code>b</code>指向的元素开始，拷贝<code>n</code>个元素到<code>b2</code>开始的内存中。</td>
</tr>
<tr>
<td><code>uninitialized_fill(b, e, t)</code></td>
<td>在迭代器<code>b</code>和<code>e</code>执行的原始内存范围中创建对象，对象的值均为<code>t</code>的拷贝。</td>
</tr>
<tr>
<td><code>uninitialized_fill_n(b, n, t)</code></td>
<td>从迭代器<code>b</code>指向的内存地址开始创建<code>n</code>个对象。<code>b</code>必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n = 5;</span><br><span class="line">	allocator&lt;string&gt; alloc;</span><br><span class="line">	auto p = alloc.allocate(n);</span><br><span class="line">	string s;</span><br><span class="line">	auto q = p;</span><br><span class="line">	while (cin &gt;&gt; s &amp;&amp; q != p + n)</span><br><span class="line">	&#123;</span><br><span class="line">		alloc.construct(q++, s);</span><br><span class="line">	&#125;</span><br><span class="line">	while (q != p)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; *--q &lt;&lt; &quot; &quot;;</span><br><span class="line">		alloc.destroy(q);</span><br><span class="line">	&#125;</span><br><span class="line">	alloc.deallocate(p, n);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="文本查询程序"><a href="#文本查询程序" class="headerlink" title="文本查询程序"></a>文本查询程序</h1><ul>
<li>当程序读取输入文件时，需记住单词出现的每一行</li>
<li>输出需提取每个单词所关联的行号，行号升序出现且只出现一次，还要打印给定行号的文本</li>
</ul>
<p>对应地，</p>
<ul>
<li>将使用<code>istringstream</code>读取文件中的每一行，并拆分成逐个单词，再用<code>vector&lt;string&gt;</code>进行保存</li>
<li>用<code>map</code>保存与行号的映射，<code>set</code>保存一个单词对应的所有行号</li>
</ul>
<p>将上述定义为一个抽象的解决方案，定义一个保存输入文件的类<code>TextQuery</code>，包含<code>vector</code>和<code>map</code>，还有读取给定输入文件的构造函数和查询函数，查询函数返回单词出现次数，行号以及每行的文本；又将返回的结果定义成另一个类<code>QueryResult</code>，用来保存输出结果，包含一个<code>print</code>函数，完成结果的打印</p>
<p>显然，需要在两个类之间共享数据，如果只是将数据拷贝传输，则会浪费；如果是返回迭代器或指针，则可能会导致空悬指针；因此将用到<code>shared_ptr</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void run(ifstream &amp;infile)</span><br><span class="line">&#123;</span><br><span class="line">	TextQuery tq(infile);</span><br><span class="line">	while(true)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;enter word to look for, or q to quit:&quot;;</span><br><span class="line">		string s;</span><br><span class="line">		if(!(cin &gt;&gt; s) || s == &#x27;q&#x27;)	break;</span><br><span class="line">		print(cout, tq.query(s)) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>infile</code>初始化<code>TextQuery</code>对象，构造函数读取输入文件，保存在成员变量<code>vector</code>中，并建立单词行号映射的<code>map</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class QueryResult;</span><br><span class="line">class TextQuery&#123;</span><br><span class="line">public:</span><br><span class="line">	using line_no = vector&lt;string&gt;::size_type;</span><br><span class="line">	TextQuery() = default;</span><br><span class="line">	TextQuery(ifstream&amp; infile);</span><br><span class="line">	QueryResult query(const string&amp;) const;</span><br><span class="line">private:</span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt; file;</span><br><span class="line">	map&lt;string,shared_ptr&lt;set&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑与<code>QueryResult</code>类对象共享数据的需求，<code>QueryResult</code>需要共享保存输入文件的<code>vector</code>，用于输入同行的文本；<code>QueryResult</code>还需要共享保存单词关联的行号的<code>set</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TextQuery::TextQuery(ifstream&amp; infile): file(new vector&lt;string&gt;)//file(make_shared&lt;vector&lt;string&gt;&gt;())</span><br><span class="line">&#123;</span><br><span class="line">	string text;</span><br><span class="line">	while(getline(infile,text))</span><br><span class="line">	&#123;</span><br><span class="line">		file-&gt;push_back(text);</span><br><span class="line">		int n = file-&gt;size() - 1;</span><br><span class="line">		istringstream line(text);</span><br><span class="line">		string word;</span><br><span class="line">		while(line &gt;&gt; word)</span><br><span class="line">		&#123;</span><br><span class="line">			auto&amp; lines = wm[word];		//返回的是shared_ptr指针</span><br><span class="line">			if(!lines)				   //指针为空即第一次出现该单词，则新建一个</span><br><span class="line">				lines.reset(new set&lt;line_no&gt;);</span><br><span class="line">			lines-&gt;insert(n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数分配一个<code>vector</code>保存输入文件的文本。<code>getline</code>逐行读取文件并存入<code>vector</code>中，再用一个<code>istringstream</code>处理刚读入的一行中的每个单词，内层<code>while</code>用<code>istringstream</code>的输入运算符从当前行读取每个单词存入<code>word</code>中。当<code>map</code>中不存在<code>word</code>，即第一次出现该单词，下标运算符创建了一个<code>word</code>，返回一个空的智能指针，则再将指针<code>reset</code>，分配新的<code>set</code>，令其指向该<code>set</code>，再向<code>set</code>中插入行号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class QueryResult&#123;</span><br><span class="line">friend ostream&amp; print (ostream&amp; os, const QueryResult&amp; qr);</span><br><span class="line">public:</span><br><span class="line">	QueryResult(string s, shared_prt&lt;set&lt;TextQuery::line_no&gt;&gt; l, shared_ptr&lt;vector&lt;string&gt;&gt; p): sought(s), file(p), lines(l) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	string sought;								//搜索的单词</span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt; file;			 //输入文件</span><br><span class="line">	shared_ptr&lt;set&lt;TextQuery::line_no&gt;&gt; lines;	  //记录的行号</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>声明友元函数<code>print</code>，定义构造函数，将参数保存在数据成员中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QueryResult TextQuery::query(const string&amp; s) const</span><br><span class="line">&#123;</span><br><span class="line">	// static shared_ptr&lt;set&lt;line_no&gt;&gt; nodata(new set&lt;line_no&gt;);</span><br><span class="line">	auto pos = wm.find(s);</span><br><span class="line">	if(pos == wm.end())		  //找不到单词</span><br><span class="line">		return QueryResult(s,make_shared&lt;set&lt;line_no&gt;&gt;(),file);</span><br><span class="line">		//return QuertResult(s,nodata,file);</span><br><span class="line">	else					//找到单词</span><br><span class="line">		return QueryResult(s, pos-&gt;second, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>query</code>函数接受一个单词，在<code>map</code>中定位其对应的行号，并构造一个<code>QueryResult</code>对象返回，包括<code>string, file, set</code>的<code>TextQuery</code>成员，并且共享着相同的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string make_plural(size_t ctr, const string&amp; word, const string&amp; ending)</span><br><span class="line">&#123;</span><br><span class="line">	return (ctr &gt; 1) ? word + ending : word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; print(ostream&amp; os, const QueryResult&amp; qr)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; qr.sought &lt;&lt; &quot;occurs &quot; &lt;&lt; qr.lines-&gt;size() &lt;&lt; &quot; &quot;</span><br><span class="line">		&lt;&lt; make_plural(qr.lines-&gt;size(), &quot;times&quot;, &quot;s&quot;) &lt;&lt; endl;</span><br><span class="line">	for(auto num : *qr.lines)</span><br><span class="line">	&#123;</span><br><span class="line">		os &lt;&lt; &quot;\t(line&quot; &lt;&lt; num + 1 &lt;&lt; &quot;)&quot;</span><br><span class="line">		&lt;&lt; *(qr.file-&gt;begin() + num) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>qr.lines</code>是指向记录的行号的智能指针，需要先解引用或者用<code>-&gt;</code>运算符，范围for循环中解引用得到的<code>num</code>是取出<code>set</code>的每一个行号，对应类型为<code>set&lt;TextQuery::line_no&gt;&gt;::size_type</code>，而<code>qr.file</code>指向记录文本的数组，用<code>qr.file-&gt;begin()+num</code>则指向对应<code>num</code>行号的文本，同样，解引用即可获得整行文本。另外，程序能正确处理未找到单词的情况，只打印第一条输出语句，次数为0不进入范围for循环</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/10/15/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/15/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AB%A0%E8%8A%82/" class="post-title-link" itemprop="url">LeetCode贪心算法章节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-15 16:13:21" itemprop="dateCreated datePublished" datetime="2022-10-15T16:13:21+08:00">2022-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-24 08:28:24" itemprop="dateModified" datetime="2022-11-24T08:28:24+08:00">2022-11-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LeetCode二叉树章节"><a href="#LeetCode二叉树章节" class="headerlink" title="LeetCode二叉树章节"></a>LeetCode二叉树章节</h1><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><p>形式固定，相对简单，不同遍历仅仅改变代码顺序</p>
<ul>
<li>先序递归遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中左右</span></span><br><span class="line"><span class="comment">//            1</span></span><br><span class="line"><span class="comment">//         /     \</span></span><br><span class="line"><span class="comment">//        2       3</span></span><br><span class="line"><span class="comment">//       /  \    /  \</span></span><br><span class="line"><span class="comment">//      4    5  6    7     遍历顺序 1 - 2 - 4 - 5 - 3 - 6 - 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(nullprt),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x,TreeNode* leftnode, TreeNode* rightnode):<span class="built_in">val</span>(x),<span class="built_in">left</span>(leftnode),<span class="built_in">right</span>(rightnode)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(TreeNode* root)</span><span class="comment">//用数组返回储存遍历的结点的值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);	<span class="comment">//中</span></span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);	 	<span class="comment">//左</span></span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);	 	<span class="comment">//右</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>中序递归遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左中右</span></span><br><span class="line"><span class="comment">//            1</span></span><br><span class="line"><span class="comment">//         /     \</span></span><br><span class="line"><span class="comment">//        2       3</span></span><br><span class="line"><span class="comment">//       /  \    /  \</span></span><br><span class="line"><span class="comment">//      4    5  6    7     遍历顺序 4 - 2 - 5 - 1 - 6 - 3 - 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x,TreeNode* left,TreeNode* right):<span class="built_in">val</span>(x),<span class="built_in">left</span>(left),<span class="built_in">right</span>(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);          <span class="comment">//左</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);	  <span class="comment">//中</span></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);		 <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>后序递归遍历<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右中</span></span><br><span class="line"><span class="comment">//            1</span></span><br><span class="line"><span class="comment">//         /     \</span></span><br><span class="line"><span class="comment">//        2       3</span></span><br><span class="line"><span class="comment">//       /  \    /  \</span></span><br><span class="line"><span class="comment">//      4    5  6    7     遍历顺序 4 - 5 - 2 - 6 - 7 - 3 - 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x,TreeNode* left,TreeNode* right):<span class="built_in">val</span>(x),<span class="built_in">left</span>(left),<span class="built_in">right</span>(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;left);		<span class="comment">//左</span></span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;right);		<span class="comment">//右</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);	<span class="comment">//中</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><p>先、中、后序遍历均属于DFS（深度优先搜索算法），借助栈实现</p>
<p>而层序遍历为BFS（广度优先搜索算法），借助队列实现</p>
<ul>
<li>先序迭代遍历</li>
</ul>
<p>对于先序迭代遍历（中左右）和后序迭代遍历（左右中），<strong>访问顺序</strong>和<strong>处理顺序</strong>相同，仅需要改变入栈顺序，再翻转数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//中左右</span><br><span class="line">//            1</span><br><span class="line">//         /     \</span><br><span class="line">//        2       3</span><br><span class="line">//       /  \    /  \</span><br><span class="line">//      4    5  6    7     遍历顺序 1 - 2 - 4 - 5 - 3 - 6 - 7</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">int val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line"></span><br><span class="line">TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">TreeNode(int x):val(x),left(nullprt),right(nullptr)&#123;&#125;</span><br><span class="line">TreeNode(int x,TreeNode* leftnode, TreeNode* rightnode):val(x),left(leftnode),right(rightnode)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">    vector&lt;int&gt; preorder(TreeNode* root)//用数组返回储存遍历的结点的值</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        while(!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        	TreeNode* node = stk.top();</span><br><span class="line">        	stk.pop();</span><br><span class="line">        	res.push_back(node-&gt;val);				//中</span><br><span class="line">        	if(node-&gt;right) stk.push(node-&gt;right);	 //右，保证空结点不入栈</span><br><span class="line">        	if(node-&gt;left) stk.push(node-&gt;left);	 //左，保证空结点不入栈</span><br><span class="line">        	//由于栈的先进后出，后进先出的特性，先将右节点入栈，再将左节点入栈</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>后序迭代遍历<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//左右中</span><br><span class="line">//            1</span><br><span class="line">//         /     \</span><br><span class="line">//        2       3</span><br><span class="line">//       /  \    /  \</span><br><span class="line">//      4    5  6    7     遍历顺序 4 - 5 - 2 - 6 - 7 - 3 - 1</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">int val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line"></span><br><span class="line">TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">TreeNode(int x):val(x),left(nullprt),right(nullptr)&#123;&#125;</span><br><span class="line">TreeNode(int x,TreeNode* leftnode, TreeNode* rightnode):val(x),left(leftnode),right(rightnode)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">    vector&lt;int&gt; preorder(TreeNode* root)//用数组返回储存遍历的结点的值</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        while(!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        	TreeNode* node = stk.top();</span><br><span class="line">        	stk.pop();</span><br><span class="line">        	res.push_back(node-&gt;val);				//中</span><br><span class="line">        	if(node-&gt;left) stk.push(node-&gt;left);	 //左，保证空结点不入栈</span><br><span class="line">        	if(node-&gt;right) stk.push(node-&gt;right);	 //右，保证空结点不入栈</span><br><span class="line">        	//由于栈的先进后出，后进先出的特性，先将左节点入栈，再将右节点入栈，翻转后符合左右中</span><br><span class="line">        &#125;</span><br><span class="line">        return reverse(res.begin(),res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>中序迭代遍历</li>
</ul>
<p>而中序迭代遍历（左中右）先访问中间结点，但先处理左结点（存入数组），故需要额外用<em><strong>cur指针</strong></em>不断指向最左结点并将沿路左结点入栈，先处理左结点随后不断回退读取中间结点和右结点完成遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//左中右</span><br><span class="line">//            1</span><br><span class="line">//         /     \</span><br><span class="line">//        2       3</span><br><span class="line">//       /  \    /  \</span><br><span class="line">//      4    5  6    7     遍历顺序 4 - 2 - 5 - 1 - 6 - 3 - 7</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    vector&lt;int&gt; inorder(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        while(!stk.empty()||!cur)</span><br><span class="line">        &#123;</span><br><span class="line">        	if(!cur) 				//cur已指向最左结点的左结点(nullptr)</span><br><span class="line">        	&#123;</span><br><span class="line">        		TreeNode* node = stk.top();</span><br><span class="line">                 stk.pop();</span><br><span class="line">                 res.push_back(node-&gt;val);					//中</span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">                 if(node-&gt;right) stk.push(node-&gt;right);		 //右      有漏洞</span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">        	&#125;</span><br><span class="line">        	else					//cur不指向空结点时</span><br><span class="line">        	&#123;</span><br><span class="line">        		stk.push(cur);							   //左，且保证空结点不入栈</span><br><span class="line">                 cur = cur-&gt;left;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码段有漏洞，原因在于<code> if(node-&gt;right) stk.push(node-&gt;right)</code> ，没有考虑到当前右结点还有左结点的可能性，从而导致没有完全遍历。因此，并不需要创建新节点<code> TreeNode* node</code> ，而是继续赋值给<code>cur</code>指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(!cur)</span><br><span class="line">&#123;</span><br><span class="line">    cur = stk.top();</span><br><span class="line">    stk.pop();</span><br><span class="line">    cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续让<code>cur</code> 指针指向子树中的最左结点，完成遍历。</p>
<ul>
<li>层序迭代遍历<br>因为需要边访问（入）边处理结点（出），栈无法满足使用需求，因此使用队列完成层序迭代遍历<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//            1</span><br><span class="line">//         /     \</span><br><span class="line">//        2       3</span><br><span class="line">//       /  \    /  \</span><br><span class="line">//      4    5  6    7     遍历顺序 1 - 2 - 3 - 4 - 5 - 6 - 7</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">	vector&lt;int&gt; levelorder(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return res;</span><br><span class="line">		queue&lt;TreeNode*&gt; que;</span><br><span class="line">		que.push(root);</span><br><span class="line">		while(!que.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int qsize = que.size();</span><br><span class="line">			for(int i = 0; i&lt;qsize;i++)</span><br><span class="line">			&#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                res.push_back(node-&gt;val);</span><br><span class="line">                if(node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>[LeetCode226](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（LeetCode）</a>)</p>
<p>给你一颗二叉树的根节点<code>root</code>，翻转这棵二叉树，并返回其根节点。</p>
<p>示例1：</p>
<p><img src="http://rjwc2zvww.hn-bkt.clouddn.com/invert2-tree.jpg?e=1666095210&token=nvUz3pCbpAvvS7EDBSYy4y-3Z_w8Q5E-JegZiINf:Asr154wbRoPorJIjGWPjLHwOz3k=" alt="示例1"></p>
<p><img src="/invert1-tree.jpg" alt="aa"></p>
<div align="center"> <img src="/invert2-tree.jpg"/> </div>
示例2：

<p><img src="http://rjwc2zvww.hn-bkt.clouddn.com/invert1-tree.jpg?e=1666095256&token=nvUz3pCbpAvvS7EDBSYy4y-3Z_w8Q5E-JegZiINf:oS9ISvGEMgbb3DZszw7vezLUNjA=" alt="示例2"></p>
<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>首先，可以考虑<em><strong>递归</strong></em>，并使用<code>swap(TreeNode* left,TreeNode* right)</code>函数完成左右子结点的交换，即翻转。考虑到处理顺序，可以使用先序递归遍历。</p>
<ol>
<li>确定递归的终止条件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root) return root;</span><br></pre></td></tr></table></figure>
①不判断<code>root-&gt;left</code>或<code>root-&gt;right</code>是否为空，会导致也将叶子结点也进行翻转，造成一定的浪费；②或递归前判断是否空结点，空结点不进入到下一层递归；③或考虑<code>root-&gt;left</code>或<code>root-&gt;right</code>是否为空，减少对叶子结点翻转的时间开销。</li>
<li>确定递归的返回值<br>由题目要求返回翻转后的根节点可知返回root结点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root)</span><br><span class="line">return root;</span><br></pre></td></tr></table></figure></li>
<li>单层递归中的逻辑处理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swap(root-&gt;left,root-&gt;right);</span><br><span class="line">if(root-&gt;let) invertTree(root-&gt;left);</span><br><span class="line">if(root-&gt;right) invertTree(root-&gt;right);</span><br></pre></td></tr></table></figure>
整体代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//全部非空结点都对其子结点进行翻转，多耗费O(2^(h-1))的时间，h为二叉树层高</span><br><span class="line">//①</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        swap(root-&gt;left,root-&gt;right);</span><br><span class="line">	    if(root-&gt;left) invertTree(root-&gt;left);</span><br><span class="line">	    if(root-&gt;right) invertTree(root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//对子结点进行判断，非子结点才进行递归，子结点不进入递归</span><br><span class="line">//②</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        if(!root-&gt;left&amp;&amp;!root-&gt;right) return root;  //子结点则退出递归</span><br><span class="line">        if(root-&gt;left&amp;&amp;(root-&gt;left-&gt;left||root-&gt;left-&gt;right)) invertTree(root-&gt;left);//判断是否子结点</span><br><span class="line">        if(root-&gt;right&amp;&amp;(root-&gt;right-&gt;left||root-&gt;right-&gt;right)) invertTree(root-&gt;right);</span><br><span class="line">        swap(root-&gt;left,root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//如果是子结点则退出递归，非子结点和子结点都进入递归</span><br><span class="line">//③</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        if(!root-&gt;left&amp;&amp;!root-&gt;right) return root;</span><br><span class="line">        swap(root-&gt;left,root-&gt;right);</span><br><span class="line">	    if(root-&gt;left) invertTree(root-&gt;left);</span><br><span class="line">	    if(root-&gt;right) invertTree(root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在对结点的子结点的子结点进行判断时，要注意结点的子结点的空指针判断！</p>
<p><code>if(root-&gt;left-&gt;left||root-&gt;left-&gt;right)</code>则忽略掉了<code>root-&gt;left</code>是空结点的可能性，</p>
<p>应改为<code>if(root-&gt;left&amp;&amp;(root-&gt;left-&gt;left||root-&gt;left-&gt;right))</code></p>
<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>下面是迭代的解法</p>
<p>很容易想到层序迭代遍历，对每个结点进行遍历然后对其子结点进行翻转；亦或者用先序迭代遍历和后序迭代遍历，都能达到翻转整棵二叉树的效果。唯独不能使用中序迭代遍历，因为左中右的处理顺序，在处理<em><strong>中间结点</strong></em>时，会将原来的左右子树也翻转，这就导致按照左中右来翻转二叉树，实际上是左中左的翻转操作顺序。</p>
<p><em><strong>迭代解法不再考虑子结点是否为空，统一只判断当前结点是否为空，即也对叶子结点进行翻转</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//层序迭代遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        	int qsize = que.size();</span><br><span class="line">        	for(int i = 0; i&lt;qsize;i++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		TreeNode* node = que.front();</span><br><span class="line">        		que.pop();</span><br><span class="line">        		swap(node-&gt;left,node-&gt;right);</span><br><span class="line">        		if(node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">        		if(node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//先序迭代遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        while(!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        	TreeNode* node = stk.top();</span><br><span class="line">        	stk.pop();</span><br><span class="line">        	swap(node-&gt;left,node-&gt;right);				//中</span><br><span class="line">        	if(node-&gt;right) stk.push(node-&gt;right);		//右</span><br><span class="line">        	if(node-&gt;left) stk.push(node-&gt;left);		//左</span><br><span class="line">        	//swap(node-&gt;left,node-&gt;right);				//中，后序遍历</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>翻转二叉树题目中，主要需要注意到对结束条件的判断以及后续要处理结点的条件约束，如是否需要处理叶子结点。如果设定要非叶子结点才能进入判断即<code>!root-&gt;left-&gt;left||!root-&gt;left-&gt;right</code>，需要先加入判断<code>root-&gt;left!=nullptr</code>保证孙子结点能够被合法访问</p>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>[对称二叉树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">Loading Question… - 力扣（LeetCode）</a>)</p>
<p>检查以<code>root</code>为根节点的树是否对称</p>
<h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>首先，可以想到递归法，递归函数传入两个结点，判断其值是否相等，并把下一个要判断的结点放入递归栈中</p>
<ol>
<li>判断递归结束条件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(!root) return true;</span><br><span class="line"></span><br><span class="line">if(left==nullptr&amp;&amp;right==nullptr) return true;</span><br><span class="line">if(left-&gt;val!=right-&gt;val) return false;</span><br></pre></td></tr></table></figure></li>
<li>递归返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool judge(TreeNode* left,TreeNode* right)</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure></li>
<li>单层递归函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(left-&gt;val==right-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    judge(left-&gt;left,right-&gt;right);</span><br><span class="line">    judge(right-&gt;left,left-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right; </span><br><span class="line">    TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//递归判断平衡二叉树</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	bool judge(TreeNode* left,TreeNode* right)</span><br><span class="line">	&#123;</span><br><span class="line">		if(left==nullptr&amp;&amp;right==nullptr)	return true;</span><br><span class="line">		if(left==nullptr&amp;&amp;right!=nullptr)	return false;</span><br><span class="line">		if(left!=nullptr&amp;&amp;right==nullptr)	return false;</span><br><span class="line">        bool flagleft,flagright;</span><br><span class="line">		if(left-&gt;val!=right-&gt;val)	return false;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			flagleft = judge(left-&gt;left,right-&gt;right);</span><br><span class="line">			flagright = judge(left-&gt;right,right-&gt;left);</span><br><span class="line">		&#125;</span><br><span class="line">        return flagleft&amp;&amp;flagright;</span><br><span class="line">	&#125;</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return true;</span><br><span class="line">        bool flag = judge(root-&gt;left,root-&gt;right);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a><strong>迭代法</strong></h3><p>选择层序迭代遍历最为恰当</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//层序迭代遍历</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	bool isSymmetric(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root-&gt;left);</span><br><span class="line">        que.push(root-&gt;right);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* left = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            TreeNode* right = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(left==nullptr&amp;&amp;right==nullptr)	continue;</span><br><span class="line">            else if(left==nullptr&amp;&amp;right!=nullptr)	return false;</span><br><span class="line">            else if(left!=nullptr&amp;&amp;right==nullptr)	return false;</span><br><span class="line">            else if(left-&gt;val!=right-&gt;val)	return false;</span><br><span class="line">            que.push(left-&gt;left);</span><br><span class="line">            que.push(right-&gt;right);</span><br><span class="line">            que.push(left-&gt;right);</span><br><span class="line">            que.push(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这道题主要要对不同情况进行分类判断，并且要注意后续进行<strong>两两判断</strong>的结点，递归法更为清晰；迭代法则需要注意当<code>left==nullptr&amp;&amp;right==nullptr</code>时并不能直接返回<code>true</code>与递归法不同，因为递归法返回的是上一层递归，仍需要继续对其他结点进行判断，因此在使用迭代法时需要对返回值特别注重，另外，在迭代法中不能强行按照模板<code>for(int i = 0;i&lt;que.size();i++</code>，在本题中，由于每次处理所读取的队头元素并不只有一个，因为不能用队列数量来给定处理结点的次数。 </p>
<h2 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h2><p>[二叉树最大深度](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">Loading Question… - 力扣（LeetCode）</a>)</p>
<p>对于求最大深度，可以首先想到层序迭代遍历，用<code>level</code>来记录深度，每执行一轮就<code>level++</code>，最后返回<code>level</code>输出答案。层序迭代遍历时间复杂度为O(n)，n为结点数，空间复杂度最大为O(n)</p>
<h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	int maxDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		int level = 0;</span><br><span class="line">		queue&lt;TreeNode*&gt; que;</span><br><span class="line">		que.push(root);</span><br><span class="line">		while(!que.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int qsize = que.size();</span><br><span class="line">			for(int i =0;i&lt;qsize;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				TreeNode* node = que.front();</span><br><span class="line">				que.pop();</span><br><span class="line">				if(node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">				if(node-&gt;right)	que.push(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			level++;</span><br><span class="line">		&#125;</span><br><span class="line">		return level;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h3><p>先序递归遍历</p>
<ol>
<li>确定递归终止判断条件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root-&gt;left&amp;&amp;!root-&gt;right)	return level;</span><br></pre></td></tr></table></figure></li>
<li>确定返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private: int level = 0;</span><br><span class="line">int maxDepth(TreeNode* root)</span><br><span class="line">return level;</span><br></pre></td></tr></table></figure></li>
<li>确定单层递归函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void dfs(TreeNode* node,int level)</span><br><span class="line">level++;				//中</span><br><span class="line">dfs(root-&gt;left,level);	 //左</span><br><span class="line">dfs(root-&gt;right,level);	 //右</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">int res = 0;</span><br><span class="line">	void dfs(TreeNode* node, int level)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node) return;</span><br><span class="line">		res = max(level,res);			//中</span><br><span class="line">		dfs(node-&gt;left,level+1);		//左</span><br><span class="line">		dfs(node-&gt;right,level+1);		//右</span><br><span class="line">	&#125;</span><br><span class="line">	int maxDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		dfs(root,1);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后序递归遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">int res = 0;</span><br><span class="line">	int dfs(TreeNode* node)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node) return 0;</span><br><span class="line">		int llevel = dfs(node-&gt;left);</span><br><span class="line">		int rlevel = dfs(node-&gt;right);</span><br><span class="line">		return max(llevel,rlevel)+1;</span><br><span class="line">	&#125;</span><br><span class="line">	int maxDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		res = dfs(root);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归法时间复杂度O(n)，空间复杂度为O(h)，h为树高</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>层序遍历迭代法更容易理解，但付出空间复杂度可能更高的代价；递归法有先序递归遍历和后序递归遍历，先序递归遍历是<em><strong>由顶至底</strong></em>的遍历顺序，求的是从根节点开始的二叉树<em><strong>深度</strong></em>，而后序递归遍历则是<strong>由底至顶</strong>的遍历顺序，求的是从叶子结点开始的二叉树<em><strong>高度</strong></em>。也正因如此，先序递归遍历首先处理中间结点，<code>level++</code>，不需要返回值；而后序递归遍历最后处理中间结点，在此之前已得出子结点的高度，则需要返回值并加一，表示返回当前的高度。</p>
<h2 id="N叉树最大深度"><a href="#N叉树最大深度" class="headerlink" title="N叉树最大深度"></a>N叉树最大深度</h2><h3 id="递归法-3"><a href="#递归法-3" class="headerlink" title="递归法"></a>递归法</h3><p>后序递归遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(Node* node)</span><br><span class="line">	&#123;</span><br><span class="line">		int res = 0;</span><br><span class="line">		if(!node) return 0;</span><br><span class="line">		for(Node* child : node-&gt;children)</span><br><span class="line">		&#123;</span><br><span class="line">			int clevel = dfs(child);</span><br><span class="line">			res = max(res,clevel);</span><br><span class="line">		&#125;</span><br><span class="line">		return res+1;</span><br><span class="line">	&#125;</span><br><span class="line">	int maxDepth(Node* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		int res = dfs(root);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先序递归遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">int res = 0;</span><br><span class="line">	void dfs(Node* node,int level)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node) return;</span><br><span class="line">		res = max(res,level);</span><br><span class="line">		for(Node* child : node-&gt;children)</span><br><span class="line">			dfs(child,level+1);</span><br><span class="line">	&#125;</span><br><span class="line">	int maxDepth(Node* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		dfs(root,1);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	int maxDepth(Node* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		int level = 0;</span><br><span class="line">		queue&lt;Node*&gt; que;</span><br><span class="line">		que.push(root);</span><br><span class="line">		while(!que.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int qsize = que.size();</span><br><span class="line">			for(int i =0;i&lt;qsize;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				Node* node = que.front();</span><br><span class="line">				que.pop();</span><br><span class="line">				for(Node* child:node-&gt;children)</span><br><span class="line">					que.push(child);</span><br><span class="line">			&#125;</span><br><span class="line">			level++;</span><br><span class="line">		&#125;</span><br><span class="line">		return level;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>与二叉树最大深度如出一辙。注意如何获取<code>children</code>结点，</p>
<p><code>vector&lt;Node *&gt; children = root-&gt;children;</code></p>
<p><code>for(auto child:children)</code></p>
<h2 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h2><p>[二叉树最小深度](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-4"><a href="#递归法-4" class="headerlink" title="递归法"></a><em><strong>递归法</strong></em></h3><p>先序递归遍历</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(!root-&gt;left&amp;&amp;root-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">	res = min(res,level);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定返回值</p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dfs(TreeNode* root, int level)</span><br><span class="line">return;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>确定单层递归逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(root-&gt;left,level+1);</span><br><span class="line">dfs(root-&gt;right,level+1);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">int res = INT_MAX;</span><br><span class="line">	void dfs(TreeNode* node, int level)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node-&gt;left&amp;&amp;!node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">        	res = min(res,level);						//中</span><br><span class="line">        	return;</span><br><span class="line">        &#125;</span><br><span class="line">		if(node-&gt;left)	dfs(node-&gt;left,level+1);		//左</span><br><span class="line">		if(node-&gt;right)	dfs(node-&gt;right,level+1);		//右</span><br><span class="line">	&#125;</span><br><span class="line">	int minDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		dfs(root,1);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同理，后序遍历做法模仿二叉树最大深度，整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(TreeNode* node)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node-&gt;left&amp;&amp;!node-&gt;right)</span><br><span class="line">        	return 0;</span><br><span class="line">        int llevel = INT_MAX,rlevel = INT_MAX;</span><br><span class="line">        if(node-&gt;left)</span><br><span class="line">		    llevel = dfs(node-&gt;left);		//左</span><br><span class="line">		if(node-&gt;right)</span><br><span class="line">            rlevel = dfs(node-&gt;right);		 //右</span><br><span class="line">		return min(llevel,rlevel) + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	int minDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		return dfs(root) + 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>另一种后序递归遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getDepth(TreeNode* node) &#123;</span><br><span class="line">        if (node == NULL) return 0;</span><br><span class="line">        // 当一个左子树为空，右不为空，这时并不是最低点</span><br><span class="line">        if (node-&gt;left == NULL &amp;&amp; node-&gt;right != NULL) &#123; </span><br><span class="line">            return 1 + getDepth(node-&gt;right);</span><br><span class="line">        &#125;   </span><br><span class="line">        // 当一个右子树为空，左不为空，这时并不是最低点</span><br><span class="line">        if (node-&gt;left != NULL &amp;&amp; node-&gt;right == NULL) &#123; </span><br><span class="line">            return 1 + getDepth(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        int result = 1 + min(leftDepth, rightDepth);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">    	if(!root)	return 0;</span><br><span class="line">        return getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-4"><a href="#迭代法-4" class="headerlink" title="迭代法"></a>迭代法</h3><p>层序迭代遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	int minDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		int res =INT_MAX;</span><br><span class="line">		int level = 1;</span><br><span class="line">		queue&lt;TreeNode*&gt; que;</span><br><span class="line">		que.push(root);</span><br><span class="line">		while(!que.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int qsize = que.size();</span><br><span class="line">			for(int i = 0; i &lt; qsize; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				TreeNode* node = que.front();</span><br><span class="line">				que.pop();</span><br><span class="line">				if(!node-&gt;left&amp;&amp;!node-&gt;right)//只有到达叶子结点才更新res</span><br><span class="line">				&#123;</span><br><span class="line">					res = min(res,level);</span><br><span class="line">				&#125;</span><br><span class="line">				if(node-&gt;left)	que.push(node-&gt;left);</span><br><span class="line">				if(node-&gt;right)	que.push(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			level++;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>这题的突破点主要在于理解只有在到达叶子结点时才是二叉树的深度，即[2,null,3,null,4,null,5,null,6]的最小深度不是1，而是5。另外，在递归遍历中，可以根据不同的递归判断（判断是否让该结点进入下一层递归），来确定不同的返回值，如<code>if(!node)	return 0;</code>或<code>if(!node-&gt;left&amp;&amp;!node-&gt;right)</code>，并且如果是后者，需要先判断<code>node</code>结点本身是否为空，否则会报错；如果是前者，则必须保证能够让单亲结点进入递归（否则直接返回错误的最小深度）</p>
<h2 id="完全二叉树的结点个数"><a href="#完全二叉树的结点个数" class="headerlink" title="完全二叉树的结点个数"></a><strong>完全二叉树的结点个数</strong></h2><p>[完全二叉树的结点个数](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a>)</p>
<p>最直观的做法就是遍历每个结点，非空则计数+1，直至遇到空结点，可采用先序、中序和后序的递归遍历、迭代遍历法，也可以用层序迭代遍历法</p>
<h3 id="递归法-5"><a href="#递归法-5" class="headerlink" title="递归法"></a>递归法</h3><p>先序递归遍历</p>
<ol>
<li>确定递归结束条件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!node) return;</span><br></pre></td></tr></table></figure></li>
<li>确定返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">void dfs(TreeNode* node)</span><br><span class="line">return;</span><br></pre></td></tr></table></figure></li>
<li>确定单层逻辑<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum++;</span><br><span class="line">dfs(node-&gt;left);</span><br><span class="line">dfs(node-&gt;right);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sums = 0;</span><br><span class="line">    void dfs(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">    	if(!node)	return;</span><br><span class="line">    	sums++;</span><br><span class="line">    	dfs(node-&gt;left);</span><br><span class="line">    	dfs(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">    	if(!root)	return 0;</span><br><span class="line">    	dfs(root);</span><br><span class="line">        return sums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="迭代法-5"><a href="#迭代法-5" class="headerlink" title="迭代法"></a>迭代法</h3><p>中序迭代遍历法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">    	if(!root)	return 0;</span><br><span class="line">        //中序迭代遍历</span><br><span class="line">        int res = 0;</span><br><span class="line">    	stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line">        while(cur!=nullptr||!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            if(!cur)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = stk.top();stk.pop();</span><br><span class="line">                res++;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="special解法"><a href="#special解法" class="headerlink" title="special解法"></a><em><strong>special解法</strong></em></h3><p>然而，以上方法都只是遍历所有结点才能确定结点个数，只是单纯当成一个普通的二叉树，时间复杂度都是O(n)。可以利用完全二叉树的性质来减小时间复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/*对于一颗完全二叉树，如果找到最底层是n，可以用公式计算前n-1层的结点数`2^(n-1)-1`再加上第n层的结点</span><br><span class="line"></span><br><span class="line">对于第n层上的结点，利用二分法不断缩小范围来找到最后一个结点</span><br><span class="line"></span><br><span class="line">			  1</span><br><span class="line">		   /      \</span><br><span class="line">		  2        3</span><br><span class="line">		 / \      / \</span><br><span class="line">		4   5    6   7</span><br><span class="line"></span><br><span class="line">给定二分法的范围，通过序号的二进制数顺序即可判断结点是否存在，如在level = 3，序号为6的结点，二进制数为110，取除最高位剩下的即10,从根节点出发，1代表右子树，0代表左子树，则根节点的右子树的左子树即为该节点;再如level = 4，序号为9的结点，除最高位剩下的二进制数为001，即代表从根节点出发，其左子树的左子树的右子树即为该结点</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	bool is_exist(TreeNode* root, int level, int index)</span><br><span class="line">	&#123;</span><br><span class="line">		int cmp = 1&lt;&lt;(level - 2);</span><br><span class="line">		//cmp 用作取序号index对应位置上的数</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">		while(node!=nullptr&amp;&amp;cmp)</span><br><span class="line">		&#123;</span><br><span class="line">			if(cmp&amp;index)</span><br><span class="line">				node = node-&gt;right;</span><br><span class="line">			else</span><br><span class="line">				node = node-&gt;left;</span><br><span class="line">			cmp &gt;&gt;= 1;</span><br><span class="line">		&#125;</span><br><span class="line">		return node!=nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">    	if(!root)	return 0;</span><br><span class="line">    	//先循环左子树找出树高</span><br><span class="line">    	int level = 1;</span><br><span class="line">    	TreeNode* node = root;</span><br><span class="line">    	while(node-&gt;left)</span><br><span class="line">    	&#123;</span><br><span class="line">    		level++;</span><br><span class="line">    		node = node-&gt;left;</span><br><span class="line">    	&#125;</span><br><span class="line">    	//这时node结点为二叉树最大深度的最左结点</span><br><span class="line">    	int left = 1 &lt;&lt; (level - 1), right = (1 &lt;&lt; level) - 1;</span><br><span class="line">    	//left 指向最大深度的最左结点，right 指向最大深度的最右结点</span><br><span class="line">    	while(left &lt; right)</span><br><span class="line">    	&#123;</span><br><span class="line">    		int mid = left + (right - left + 1) / 2;	//+1为了防止死循环</span><br><span class="line">    		if(is_exist(root,level,mid))</span><br><span class="line">    			left = mid;</span><br><span class="line">    		else</span><br><span class="line">    			right = mid -1;</span><br><span class="line">    	&#125;</span><br><span class="line">    	//此时，mid即为最大结点序号</span><br><span class="line">     	return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于上述程序的时间复杂度，循环查找二叉树最大深度<code>O(logn)</code>，二分法时间复杂度<code>O(logn)</code>，但嵌套了时间复杂度为O(log n)<code>的结点存在判断算法，因此总的时间复杂度为</code>O(log n+log n^2)&#96;</p>
<blockquote>
<p>时间复杂度：O(log^2 n)，其中 n 是完全二叉树的节点数。</p>
<p>首先需要 O(h)的时间得到完全二叉树的最大层数，其中 h 是完全二叉树的最大层数；使用二分查找确定节点个数时，需要查找的次数为 O(log2^h)&#x3D;O(h)，每次查找需要遍历从根节点开始的一条长度为 h 的路径，需要 O(h)的时间，因此二分查找的总时间复杂度是 O(h^2)。因此总时间复杂度是 O(h^2)，由于完全二叉树满足 2^h &lt;&#x3D; n &lt;&#x3D;2^(h+1)，因此有 O(h)&#x3D;O(log n)，O(h^2)&#x3D;O(\log^2 n)</p>
</blockquote>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>在题目中的位运算解法中，需要弄清楚完全二叉树的特殊性质，即结点按顺序从左到右依次填满，以及可以通过序号反推从根节点开始到该结点的路径，并且清楚位运算中<code>1 &lt;&lt; n</code>等价于<code>1*2^n</code>，在运算时间上位运算也会更有优势，再结合二分法即可在小于O(n)的时间复杂度内完成</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h2><p>[平衡二叉树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（LeetCode）</a>)</p>
<h3 id="由顶至底法"><a href="#由顶至底法" class="headerlink" title="由顶至底法"></a>由顶至底法</h3><p>最容易想到的一种方法就是分别求出左右子树的高度，再根据两者的差值进行判断。若是用先序遍历（求树深）的方法来做，需要有更多变量来保存临时树深和最大树深，因此更适合用后序遍历来做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(TreeNode* node)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node)	return 0;</span><br><span class="line">        int llevel = dfs(node-&gt;left);</span><br><span class="line">        int rlevel = dfs(node-&gt;right);</span><br><span class="line">		return max(llevel,rlevel)+1;</span><br><span class="line">	&#125;</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">		if(!root)	return true;</span><br><span class="line">        if(abs(dfs(root-&gt;right)-dfs(root-&gt;left))&gt;1)</span><br><span class="line">            return false;</span><br><span class="line">		return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述方法还有个bug，没有考虑到子树本身是否平衡，因此需要再对子树进行平衡判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(TreeNode* node)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node)	return 0;</span><br><span class="line">         int llevel = dfs(node-&gt;left);</span><br><span class="line">         int rlevel = dfs(node-&gt;right);</span><br><span class="line">		return max(llevel,rlevel)+1;</span><br><span class="line">	&#125;</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">		if(!root)	return true;</span><br><span class="line">         if(abs(dfs(root-&gt;right)-dfs(root-&gt;left))&gt;1)</span><br><span class="line">            return false;</span><br><span class="line">		return isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于进行了大量的重复运算，最坏情况下时间复杂度为O(n^2)</p>
<h3 id="由底至顶法"><a href="#由底至顶法" class="headerlink" title="由底至顶法"></a><em><strong>由底至顶法</strong></em></h3><p>上述代码中，重复运算的原因在于子树高度时一旦遇到子树的子树不平衡时，没有及时向上返回，而是只返回最大深度，这就导致了还要对子树的子树进行额外的重复运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dfs(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node)	return 0;</span><br><span class="line">        int llevel = dfs(node-&gt;left);</span><br><span class="line">        if (llevel == -1)	return -1;</span><br><span class="line">        int rlevel = dfs(node-&gt;right);</span><br><span class="line">        if (rlevel == -1)	return -1;</span><br><span class="line">        return abs(llevel - rlevel) &gt; 1 ? -1 : max(llevel, rlevel) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        if (!root)	return true;</span><br><span class="line">        return dfs(root) != -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，最多每个结点运算一次</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>进一步理解求树深用先序遍历，求树高用后序遍历。在做判断二叉树是否符合某种要求题目时，不仅要考虑根节点，还要考虑其子树是否同样符合。</p>
<p>由底至顶法提到，涉及到判断树是否符合某种条件时，一旦遇到不符合的，应立即向上返回，避免做其他开销，只需要加多判断语句，在本题中，形象上看起来就像是由底至顶地判断</p>
<h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a><strong>二叉树的所有路径</strong></h2><p>[二叉树的所有路径](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-6"><a href="#递归法-6" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!node-&gt;left&amp;&amp;!node-&gt;right)</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归返回值</p>
<p>​	递归结束时即遇到了叶子结点，则证明改路径结束，应该返回整条路径并输出到res中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void traversal(TreeNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	//将path整条打印成&quot;node1-&gt;node2-&gt;...-&gt;noden&quot;格式</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(node-&gt;left) </span><br><span class="line">&#123;</span><br><span class="line">	traversal(node-&gt;left);</span><br><span class="line">	path.pop_back();//回溯</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">if(node-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">	traversal(node-&gt;right);</span><br><span class="line">	path.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traversal(TreeNode* node, vector&lt;string&gt; &amp;res, vector&lt;TreeNode*&gt; &amp;path)</span><br><span class="line">    &#123;</span><br><span class="line">        path.push_back(node);</span><br><span class="line">        if (!node-&gt;left&amp;&amp;!node-&gt;right)//叶子结点则路径结束</span><br><span class="line">        &#123;</span><br><span class="line">            string str;</span><br><span class="line">            for (int i = 0; i &lt; path.size() - 1; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                str += to_string(path[i]-&gt;val);</span><br><span class="line">                str += &quot;-&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            str += to_string(path.back()-&gt;val);</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(node-&gt;left)  traversal(node-&gt;left, res, path);</span><br><span class="line">        if(node-&gt;right) traversal(node-&gt;right, res, path);</span><br><span class="line">        path.pop_back();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;TreeNode*&gt;path;</span><br><span class="line">        traversal(root, res, path);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>本题是第一次遇到回溯算法，在二叉树中的回溯算法结合递归可能较难以理解，需要多加模拟回溯过程，体验不同的回溯方式可以更好理解。因为要求按顺序打印路径，此题就需要用先序遍历（先打印的是根结点），但一般来说，回溯法使用后序遍历更简便</p>
<h2 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h2><p>[左叶子之和](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和 - 力扣（LeetCode）</a>)</p>
<p>首先要清楚如何判断是否是左叶子结点，哪种情况下才能算是左叶子，例如<code>[1,null,2]</code>中并不存在左叶子。因此可以得到关键判断语句<code>if(root-&gt;left&amp;&amp;!root-&gt;left-&gt;left&amp;&amp;!root-&gt;left-&gt;right)</code>，这是解题的关键</p>
<h3 id="递归法-7"><a href="#递归法-7" class="headerlink" title="递归法"></a>递归法</h3><p>后序递归遍历</p>
<ol>
<li><p>确定递归结束条件</p>
<p>遇到左叶子或者遇到叶子结点即返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(root-&gt;left&amp;&amp;!root-&gt;left-&gt;left&amp;&amp;!root-&gt;left-&gt;right) return lsum+rsum+root-&gt;left-&gt;val;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int dfs(TreeNode* node)</span><br><span class="line">int lsum = 0,rsum = 0;</span><br><span class="line">return lsum + rsum;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(node-&gt;left)	dfs(root-&gt;left);</span><br><span class="line">if(node-&gt;right)	dfs(root-&gt;right);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dfs(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">        int lsum = 0,rsum = 0;</span><br><span class="line">        if (node-&gt;left) </span><br><span class="line">            lsum = sumOfLeftLeaves(node-&gt;left);</span><br><span class="line">        if (node-&gt;right) </span><br><span class="line">            rsum = sumOfLeftLeaves(node-&gt;right);</span><br><span class="line">        if (node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)//左叶子结点</span><br><span class="line">            return node-&gt;left-&gt;val+lsum+rsum;</span><br><span class="line">        return lsum + rsum;</span><br><span class="line">    &#125;</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if (!root-&gt;left &amp;&amp; !root-&gt;right) return 0;</span><br><span class="line">        return dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为在进入递归之前加上了结点是否为空的判断，因此在递归结束判断条件中并不是传统的<code>if(!node)</code>判断，只需要判断是否为左叶子即可</p>
<p>先序递归遍历</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int res = 0;</span><br><span class="line">    void dfs(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)//左叶子结点</span><br><span class="line">            res += node-&gt;left-&gt;val;</span><br><span class="line">        if (node-&gt;left) sumOfLeftLeaves(node-&gt;left);</span><br><span class="line">        if (node-&gt;right) sumOfLeftLeaves(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if (!root-&gt;left &amp;&amp; !root-&gt;right) return 0;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先序递归遍历代码只是对左叶子的判断语句提前，符合先序遍历中左右的结点处理顺序</p>
<h3 id="迭代法-6"><a href="#迭代法-6" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法采用层序迭代遍历，代码思路较为简单直接</p>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)   </span><br><span class="line">            return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        TreeNode* node;</span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            for(int i = 0;i&lt;size;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    node = que.front();</span><br><span class="line">                    que.pop();</span><br><span class="line">                    if(node-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        que.push(node-&gt;left);</span><br><span class="line">                        if(node-&gt;left-&gt;left == nullptr&amp;&amp;node-&gt;left-&gt;right ==nullptr)</span><br><span class="line">                            res+=node-&gt;left-&gt;val;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(node-&gt;right)</span><br><span class="line">                        que.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>本题的关键点在于理解左叶子结点，如何对左叶子结点进行判断，需要通过父结点，判断其是否为左孩子，再判断是否为叶子结点，算是扩展了一种解题的新思路</p>
<h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value">找树左下角的值</a></p>
<p>本题中，需要找到左下角的结点，即需要最大深度和最左边的叶子结点，则可以利用先序（中、后序同样也可以）递归遍历的特点，先访问左结点再访问右结点，即<strong>只要记录下当前深度和最大深度</strong>，若是当前深度大于最大深度，则更新最大深度，并把当前的结点作为左下角的结点；若当前深度等于最大深度，则不更新，因为当前结点仅仅只是最大深度，一定不是左下角的点；若当前深度小于最大深度则同理。</p>
<h3 id="递归法-8"><a href="#递归法-8" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root) return;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int res = 0;</span><br><span class="line">int height = -1;</span><br><span class="line">void dfs(TreeNode* node, int level)</span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(level &gt; height)//当前深度为最大深度</span><br><span class="line">&#123;</span><br><span class="line">	height = level;</span><br><span class="line">	res = node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">if(node-&gt;left)	dfs(node-&gt;left);</span><br><span class="line">if(node-&gt;right)	dfs(node-&gt;right);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int res = 0;</span><br><span class="line">int height = -1;</span><br><span class="line">    void dfs(TreeNode* node,int level)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!node)   return;</span><br><span class="line">        if(height &lt; level)//如遇到更大深度的，则直接修改res，且只遇到第一个更深的结点才修改</span><br><span class="line">        &#123;</span><br><span class="line">            res = node-&gt;val;</span><br><span class="line">            height = level;</span><br><span class="line">        &#125;   </span><br><span class="line">        if(node-&gt;left) dfs(node-&gt;left,level + 1);</span><br><span class="line">        if(node-&gt;right) dfs(node-&gt;right,level + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">        if(!root-&gt;left&amp;&amp;!root-&gt;right)   return root-&gt;val;</span><br><span class="line">        dfs(root,1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在本题递归解法中，实际上也有使用到回溯的过程，即在判断<code>node-&gt;left</code>进入递归时，应对当前深度加一，退出递归后又要将当前深度减一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth = INT_MIN;</span><br><span class="line">    int result;</span><br><span class="line">    void traversal(TreeNode* root, int depth) &#123;</span><br><span class="line">        if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123;</span><br><span class="line">            if (depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                result = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;left) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            traversal(root-&gt;left, depth);</span><br><span class="line">            depth--; // 回溯</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;right) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            traversal(root-&gt;right, depth);</span><br><span class="line">            depth--; // 回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">        traversal(root, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-7"><a href="#迭代法-7" class="headerlink" title="迭代法"></a>迭代法</h3><p>层序迭代法更为直观理解，只要在每一层遍历时，存入第一个结点的值即为结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        if (root != NULL) que.push(root);</span><br><span class="line">        int result = 0;</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                if (i == 0) result = node-&gt;val; // 记录最后一行第一个元素</span><br><span class="line">                if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>两种方法的时间复杂度为O(n)，其中若是链式结构，递归法空间复杂度为O(n)，若是完全二叉树，迭代法空间复杂度O(n&#x2F;2)。递归法用到了回溯的思想，但可以将其隐藏起来，并不会对结果产生影响。</p>
<h2 id="路径之和"><a href="#路径之和" class="headerlink" title="路径之和"></a>路径之和</h2><p>[路径之和](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-9"><a href="#递归法-9" class="headerlink" title="递归法"></a>递归法</h3><p>很明显这道题需要用到回溯的思想，与寻找二叉树所有路径题相似，通过深度优先遍历递归寻找到一条“路径”（指从根节点到叶子结点的完整路径），再比较路径上结点的值是否与target值相等。需要注意的是在回退上一层父结点时，需要将加入的子结点及时pop出去，即回溯（删除结点）发生在访问到叶子结点的时候。</p>
<p>根据题意，因为要先处理中间结点，更适合用先序遍历</p>
<ol>
<li><p>确定递归结束条件</p>
<p>因为在进入递归前先判断结点是否为空，则递归结束条件不是结点为空，而是当前结点到达路径终点，即结点是叶子结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root-&gt;left&amp;&amp;!root-&gt;right)</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int lflag = false;</span><br><span class="line">int rflag = false;</span><br><span class="line">bool dfs(TreeNode* node,vector&lt;int&gt;&amp; vec,int target)</span><br><span class="line">&#123;</span><br><span class="line">	return lflag||rflag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定单层递归逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vec.push_back(node);</span><br><span class="line">if(node-&gt;left) </span><br><span class="line">&#123;</span><br><span class="line">	lflag = dfs(node-&gt;left,vec,target);</span><br><span class="line">	vec.pop_back();//回溯</span><br><span class="line">&#125;</span><br><span class="line">if(node-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">	rflag = dfs(node-&gt;right,vec,target);</span><br><span class="line">	vec.pop_back();//回溯</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lflag = false, rflag = false;</span><br><span class="line">    bool dfs(TreeNode* node, vector&lt;int&gt;&amp; vec, int target)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(node-&gt;val);</span><br><span class="line">        if (!node-&gt;left &amp;&amp; !node-&gt;right)//遇到叶子结点则路径结束</span><br><span class="line">        &#123;</span><br><span class="line">            if (accumulate(vec.begin(), vec.end(), 0) == target)</span><br><span class="line">                return true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            lflag = lflag||dfs(node-&gt;left, vec, target);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        if (node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            rflag = rflag||dfs(node-&gt;right, vec, target);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        return lflag || rflag;</span><br><span class="line">    &#125;</span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (!root)  return false;</span><br><span class="line">        vector &lt;int&gt; vec;</span><br><span class="line">        return dfs(root, vec, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该版本代码在任何情况下都需要遍历所有结点，因此时间复杂度是O(n)，最坏情况下的空间复杂度是O(n)。可以先判断flag的值是否有被修改成true，如果有，则证明存在一条路径符合要求，此时即可直接返回true，只需要添加以下语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(lflag||rflag) return true;</span><br></pre></td></tr></table></figure>

<p>修改过的版本有类似于平衡二叉树中由底至顶法的意思，一旦遇到有符合的路径就要及时返回，避免额外开销</p>
<h3 id="迭代法-8"><a href="#迭代法-8" class="headerlink" title="迭代法"></a>迭代法</h3><p>先序迭代遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (!root) return false;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, int&gt;&gt; stk;</span><br><span class="line">        stk.push(make_pair(root, root-&gt;val));</span><br><span class="line">        while (!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = stk.top().first;</span><br><span class="line">            int tmp = stk.top().second;</span><br><span class="line">            stk.pop();</span><br><span class="line">            if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; targetSum==tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(make_pair(node-&gt;right, node-&gt;right-&gt;val + tmp));</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(make_pair(node-&gt;left, node-&gt;left-&gt;val + tmp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>在递归法中，需要注意与二叉树的所有路径题目不同的是，应该在每次调用递归之后马上进行回溯，即删除结点，这也是个良好的习惯，二叉树的所有路径题中只是因为没有返回值，才导致可以有多个回溯方式，但理论上应统一回溯只发生在递归结束之后。并且根据题目应该遇到合适路径就要立即返回，不需要再做额外的递归开销</p>
<p>在迭代法中，依旧使用stack进行先序遍历，但不能只存储<code>TreeNode*</code>结点，还要存储上当前结点的路径总和值，当遇到叶子结点并且路径总和值与target值相等时，即可直接返回true。其他迭代遍历版本亦是如此</p>
<h2 id="路径之和II"><a href="#路径之和II" class="headerlink" title="路径之和II"></a>路径之和II</h2><p>[路径之和](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-10"><a href="#递归法-10" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* node, vector&lt;int&gt;&amp;path,vector&lt;vector&lt;int&gt;&gt; &amp;res,int target)</span><br><span class="line">    &#123;</span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        if(!node-&gt;left&amp;&amp;!node-&gt;right)//遇到叶子结点则当前路径结束</span><br><span class="line">        &#123;</span><br><span class="line">            if(accumulate(path.begin(),path.end(),0)==target)</span><br><span class="line">                res.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(node-&gt;left,path,res,target);</span><br><span class="line">            path.pop_back();//回溯</span><br><span class="line">        &#125;</span><br><span class="line">        if(node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(node-&gt;right,path,res,target);</span><br><span class="line">            path.pop_back();//回溯</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(!root)   return res;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        dfs(root,path,res,targetSum);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>与路径之和思路一致，只不过换了方式存储结果和路径结点的值，其他都如出一辙</p>
<h2 id="从中序和后序遍历序列构造二叉树"><a href="#从中序和后序遍历序列构造二叉树" class="headerlink" title="从中序和后序遍历序列构造二叉树"></a><strong>从中序和后序遍历序列构造二叉树</strong></h2><p>[从中序和后序遍历序列构造二叉树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-11"><a href="#递归法-11" class="headerlink" title="递归法"></a>递归法</h3><p>大致思路如下</p>
<ol>
<li><p>从中序遍历和后序遍历比对，先从后序遍历找到最后一个值，即为根节点的值，在中序遍历序列找到该值并分割</p>
</li>
<li><p>根据中序遍历分割得到的左右段区间，即为该结点的左右子树，根据左子树区间长度，获取后序遍历中前一部分相等长度的区间，即获得左子树的中序遍历和后序遍历序列，再进入递归运算，返回值作为根节点的左子树；右子树区间同理</p>
</li>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(postorder.size()==0)	return nullprt;</span><br></pre></td></tr></table></figure>

<p>当递归到获取到空的数组时则证明递归结束</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* buildtree(vector&lt;int&gt;&amp; inorder,vector&lt;int&gt;&amp; postorder)</span><br><span class="line">&#123;</span><br><span class="line">	TreeNode* root = new TreeNode(postorder.back());</span><br><span class="line">	if(postorder.size()==1)	return root;</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回当前的结点作为根节点</p>
</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = buildtree(**新的中序遍历序列数组**，**新的后序遍历序列数组**);</span><br><span class="line">root-&gt;right = buildtree(**新的中序遍历序列数组**，**新的后序遍历序列数组**);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if(postorder.size()==0) return nullptr;</span><br><span class="line">        TreeNode* root = new TreeNode(postorder[postorder.size()-1]);</span><br><span class="line">        if(postorder.size()==1) return root;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i; i &lt; inorder.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(inorder[i]==postorder[postorder.size()-1])</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; tmp(inorder.begin(),inorder.begin()+i);</span><br><span class="line">        vector&lt;int&gt; tmp1(postorder.begin(),postorder.begin()+i);</span><br><span class="line">        TreeNode* lnode = buildTree(tmp,tmp1);</span><br><span class="line">        root-&gt;left = lnode;</span><br><span class="line">        vector&lt;int&gt; tmp2(inorder.begin()+i+1,inorder.end());</span><br><span class="line">        vector&lt;int&gt; tmp3(postorder.begin()+i,postorder.end()-1);</span><br><span class="line">        TreeNode* rnode = buildTree(tmp2,tmp3);</span><br><span class="line">        root-&gt;right = rnode;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码较为直观，容易理解，但每次递归都会产生很多新的数组，而且不必要；在寻找<code>i</code>即分割序号时，每次递归都要遍历数组来查找，浪费较多时间。因此，在代码改进上可以只传递两个原有的数组，两组新数组的边界点来达到减少内存开销；通过使用<code>hashmap</code>存储元素和下标实现对时间开销的减少</p>
<p>改进后的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int, int&gt; hashmap;</span><br><span class="line">    int index;</span><br><span class="line">    TreeNode* traversal(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int lboarder, int rboarder)//lboarder代表的是左子树的左边界点，rboarder代表的是右子树的右边界点</span><br><span class="line">    &#123;</span><br><span class="line">        if (rboarder &lt; lboarder) return nullptr;</span><br><span class="line">        int rinb = hashmap[postorder[index]] + 1;</span><br><span class="line">        int linb = hashmap[postorder[index]] - 1;</span><br><span class="line">        TreeNode* root = new TreeNode(postorder[index--]);</span><br><span class="line">        if (rboarder == lboarder) return root;</span><br><span class="line">        //分割点：hashmap[postorder[index]],为根节点</span><br><span class="line">        root-&gt;right = traversal(inorder, postorder, rinb, rboarder);</span><br><span class="line">        root-&gt;left = traversal(inorder, postorder, lboarder, linb);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        index = postorder.size() - 1;</span><br><span class="line">        for (const auto&amp; num : inorder)</span><br><span class="line">        &#123;</span><br><span class="line">            hashmap[num] = i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return traversal(inorder, postorder, 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法？？？"><a href="#迭代法？？？" class="headerlink" title="迭代法？？？"></a>迭代法？？？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if (postorder.size() == 0) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        auto root = new TreeNode(postorder[postorder.size() - 1]);</span><br><span class="line">        auto s = stack&lt;TreeNode*&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        int inorderIndex = inorder.size() - 1;</span><br><span class="line">        for (int i = int(postorder.size()) - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            int postorderVal = postorder[i];</span><br><span class="line">            auto node = s.top();</span><br><span class="line">            if (node-&gt;val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node-&gt;right = new TreeNode(postorderVal);</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while (!s.empty() &amp;&amp; s.top()-&gt;val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = s.top();</span><br><span class="line">                    s.pop();</span><br><span class="line">                    inorderIndex--;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;left = new TreeNode(postorderVal);</span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>递归解法中，解法思路类似于手算构造二叉树过程，但在程序当中，若要低开销的算法，又有很多的小问题小细节需要注意。通常来说，递归解法最好要另外创建一个函数，方便传递不同数量或类型的参数。在本题中，若想要传入数组的大小<code>size</code>，与另一个边界值组成一个区间的形参，如<code>(inorder,postorder,size,lboarder,rboarded)</code>，就要<strong>仔细考虑<code>lboarder</code>和<code>rboarder</code>所需要代表是哪一个边界值</strong>，如果是左子树的左边界和右子树的右边界点，那么可以得以实现；而如果是左子树的右边界和右子树的左边界，那么无法实现，因为已经知道<code>index</code>代表分割点的位置，即+1或-1就可以知道这两个边界点，<strong>两个参数实际上只是一个参数</strong>，所以无法实现，必须再传入其他的参数。因此也可以直接传入四个边界点作为形参。</p>
<h2 id="从先序和中序遍历序列构造二叉树"><a href="#从先序和中序遍历序列构造二叉树" class="headerlink" title="从先序和中序遍历序列构造二叉树"></a>从先序和中序遍历序列构造二叉树</h2><p>[从先序和中序遍历序列构造二叉树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-12"><a href="#递归法-12" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int, int&gt; hashmap;</span><br><span class="line">    int index;</span><br><span class="line">    TreeNode* traversal(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int size, int lboarder, int rboarder)</span><br><span class="line">    &#123;</span><br><span class="line">        if (size == 0) return nullptr;</span><br><span class="line">        TreeNode* root = new TreeNode(postorder[index--]);</span><br><span class="line">        if (size == 1) return root;</span><br><span class="line">        //分割点：hashmap[postorder[rboarder]],为根节点</span><br><span class="line">        int lsize = hashmap[postorder[rboarder]];</span><br><span class="line">        int rsize = size - hashmap[postorder[rboarder]] - 1;</span><br><span class="line">        lboarder = hashmap[postorder[rboarder]] - 1;</span><br><span class="line">        rboarder = hashmap[postorder[rboarder]] + 1;</span><br><span class="line">        root-&gt;right = traversal(inorder, postorder, rsize, rboarder, rboarder + rsize - 1);</span><br><span class="line">        root-&gt;left = traversal(inorder, postorder, lsize, lboarder - lsize + 1, lboarder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        index = postorder.size() - 1;</span><br><span class="line">        for (const auto&amp; num : inorder)</span><br><span class="line">        &#123;</span><br><span class="line">            hashmap[num] = i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return traversal(inorder, postorder, postorder.size(), 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>与上一题思路一样。但能发现，要构造出唯一的二叉树，无论是先序还是后序遍历序列，都必须要有中序遍历序列，这是因为只有中序遍历序列才能得到左右子树的分界线，仅靠先序和后序遍历根本无法得知左右子树的分区间。</p>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><p>[最大二叉树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-13"><a href="#递归法-13" class="headerlink" title="递归法"></a>递归法</h3><p>本题中，与构造二叉树题有些许相似，都是需要用到数组的区间来构造二叉树，但这题需要额外找到当前区间的最大值来做根节点并递归</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(lboarder&gt;rboarder)	return nullptr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* traversal(vector&lt;int&gt;&amp;nums,int lboarder,int rboarder)</span><br><span class="line">&#123;</span><br><span class="line">	return 根节点;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//find_maximum并创建根节点root</span><br><span class="line">root-&gt;left = traversal(nums,lboarder,index-1);</span><br><span class="line">root-&gt;right = traversal(nums,index+1,rboarder);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int root_val;</span><br><span class="line">    int find_maximum(const vector&lt;int&gt;&amp; nums, int l, int r)//返回最大元素的下标值</span><br><span class="line">    &#123;</span><br><span class="line">        root_val = 0;</span><br><span class="line">        int root_index = 0;</span><br><span class="line">        for (int i = l; i &lt;= r; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &gt; root_val)</span><br><span class="line">            &#123;</span><br><span class="line">                root_index = i;</span><br><span class="line">                root_val = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root_index;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* traversal(vector&lt;int&gt;&amp; nums, int lboarder, int rboarder)</span><br><span class="line">    &#123;</span><br><span class="line">        if (lboarder &gt; rboarder) return nullptr;</span><br><span class="line">        int mid = find_maximum(nums, lboarder, rboarder);</span><br><span class="line">        TreeNode* root = new TreeNode(root_val);</span><br><span class="line">        if (lboarder == rboarder)  return root;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = traversal(nums, lboarder, mid - 1);</span><br><span class="line">        root-&gt;right = traversal(nums, mid + 1, rboarder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* root = new TreeNode(nums[0]);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        return traversal(nums, 0, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单调栈special解法"><a href="#单调栈special解法" class="headerlink" title="单调栈special解法"></a><strong>单调栈special解法</strong></h3><p>针对找到当前最大值元素作为根节点，联想到单调栈实现，并根据在栈中元素关系确定左右子树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* root = new TreeNode(-1);</span><br><span class="line">        for(int i = 0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = new TreeNode(nums[i]);</span><br><span class="line">            while(!stk.empty()&amp;&amp;nums[i]&gt;stk.top()-&gt;val)//栈顶有元素且比当前元素小，则栈顶元素作当前元素的左子结点</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* cur = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                node-&gt;left = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(!stk.empty())//栈还有元素，则比当前元素大，当前元素为栈顶元素的右子结点</span><br><span class="line">            &#123;</span><br><span class="line">                stk.top()-&gt;right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(node);</span><br><span class="line">            if(root-&gt;val&lt;node-&gt;val)</span><br><span class="line">                root = node;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>在递归法中，根据构造二叉树题中的经验，创建额外的递归函数，并以左右子树区间为形参，再将遍历找到最大元素进行函数封装，避免了每次递归创建新的数组的额外开销。时间复杂度为O(n^2)，最坏情况下数组每个元素都会被遍历一次的同时寻找最大元素也会遍历一遍数组，即此时为递增或递减数组；空间复杂度最坏情况下，<code>nums</code>为递减数组或递增数组，需要递归n层，此时空间复杂度为O(n)</p>
<p>针对不断找到最大元素这个点，提出单调栈来优化，在元素存入单调栈的过程中，不断剔除比当前元素小的栈顶元素，并将栈顶元素作为当前元素的左子结点；遇到比当前元素大的栈顶元素，则把当前元素作为栈顶元素的右子结点。时间复杂度为O(n)，数组每个元素最多只被遍历一次；空间复杂度为O(n)，最坏情况下递减或递增数组需要大小为n的栈空间</p>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><h3 id="递归法-14"><a href="#递归法-14" class="headerlink" title="递归法"></a>递归法</h3><p>先序遍历递归</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root1&amp;&amp;!root2)	return nullptr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* mergeTrees(TreeNode* root1,TreeNode* root2)</span><br><span class="line">&#123;</span><br><span class="line">	return root1;	//直接在root1上操作，避免新建树产生的额外开销</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root1-&gt;val += root2-&gt;val;</span><br><span class="line">root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        if (!root1 &amp;&amp; !root2)  return nullptr;</span><br><span class="line">        if (root1 &amp;&amp; !root2) return root1;</span><br><span class="line">        else if (!root1 &amp;&amp; root2)  return root2;</span><br><span class="line">        else</span><br><span class="line">            root1-&gt;val += root2-&gt;val;								//中</span><br><span class="line">        root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);			  //左</span><br><span class="line">        root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);		  //右</span><br><span class="line">        return root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于中间结点的处理语句，只要更改相对于左右结点处理语句的顺序，就可以实现不同顺序递归遍历二叉树，而不对结果造成影响</p>
<h3 id="迭代法-9"><a href="#迭代法-9" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        if(!root1)  return root2;</span><br><span class="line">        if(!root2)  return root1;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root1);</span><br><span class="line">        que.push(root2);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node1 = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            TreeNode* node2 = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            node1-&gt;val += node2-&gt;val;</span><br><span class="line">            if(node1-&gt;left&amp;&amp;node2-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(node1-&gt;left);</span><br><span class="line">                que.push(node2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            if(node1-&gt;right&amp;&amp;node2-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(node1-&gt;right);</span><br><span class="line">                que.push(node2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            if(!node1-&gt;left&amp;&amp;node2-&gt;left)</span><br><span class="line">                node1-&gt;left = node2-&gt;left;</span><br><span class="line">            if(!node1-&gt;right&amp;&amp;node2-&gt;right)</span><br><span class="line">                node1-&gt;right = node2-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="指针法？？？"><a href="#指针法？？？" class="headerlink" title="指针法？？？"></a>指针法？？？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void process(TreeNode** t1, TreeNode** t2) &#123;</span><br><span class="line">        if ((*t1) == NULL &amp;&amp; (*t2) == NULL) return;</span><br><span class="line">        if ((*t1) != NULL &amp;&amp; (*t2) != NULL) &#123;</span><br><span class="line">            (*t1)-&gt;val += (*t2)-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((*t1) == NULL &amp;&amp; (*t2) != NULL) &#123;</span><br><span class="line">            *t1 = *t2;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((*t1) != NULL &amp;&amp; (*t2) == NULL) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        process(&amp;((*t1)-&gt;left), &amp;((*t2)-&gt;left));</span><br><span class="line">        process(&amp;((*t1)-&gt;right), &amp;((*t2)-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;</span><br><span class="line">        process(&amp;t1, &amp;t2);</span><br><span class="line">        return t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>这道题提醒了同时在处理两颗二叉树时的操作，类似于对称二叉树，考虑的需要更加复杂。</p>
<h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><p>[二叉搜索树中的搜索](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a>)</p>
<p>根据二叉搜索树的特性，左子结点值小于根节点值小于右子结点值，通过判断当前结点的值与所要求的值的大小，快速找到所要求的值的方向，可以有递归法和迭代法实现</p>
<h3 id="递归法-15"><a href="#递归法-15" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return nullprt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* searchBST(TreeNode* root,int val)</span><br><span class="line">if(root-&gt;val==val)	return root;</span><br><span class="line">return nullptr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归单层逻辑</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(root-&gt;val &gt; val) 		searchBST(root-&gt;left, val);</span><br><span class="line">else if(root-&gt;val &lt; val)	searchBST(root-&gt;right, val);</span><br><span class="line">else	return root;</span><br></pre></td></tr></table></figure>

<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">        if(!root)   return nullptr;</span><br><span class="line">        if(root-&gt;val==val)  return root;</span><br><span class="line">        return root-&gt;val &gt; val? searchBST(root-&gt;left,val): searchBST(root-&gt;right,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-10"><a href="#迭代法-10" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">    	TreeNode* node = root;</span><br><span class="line">    	while(node)</span><br><span class="line">    	&#123;</span><br><span class="line">			if(node-&gt;val)	return node;</span><br><span class="line">			if(node-&gt;val &gt; node)</span><br><span class="line">				node = node-&gt;left;</span><br><span class="line">			else if(node-&gt;val &lt; node)</span><br><span class="line">				node = node-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>根据二叉搜索树的特性，能够极大地简化了代码的复杂程度。在递归法中，由于二叉搜索树有方向性，从而不用考虑是否需要回溯，如平衡二叉树和路径之和题；在迭代法中，二叉搜索树则不需要借助栈或者队列完成对二叉树的遍历，也是因为其特有的方向性。</p>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>[验证二叉搜索树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-16"><a href="#递归法-16" class="headerlink" title="递归法"></a>递归法</h3><p>对于本题，先想到验证二叉搜索树的方法是 左子结点的值小于根节点的值小于右子结点的值，再对整棵二叉树进行该过程的递归遍历。但这就掉入一个坑中，因为二叉搜索树不仅需要当前的左右子结点与根节点符合规律，还要整棵左右子树都要符合规律，即根节点的左子树上的所有结点都要比根节点要小，同理右子树也是，但这种方法显然无法满足。</p>
<p>因此，借助于中序遍历，若一棵二叉树时二叉搜索树，则中序遍历序列为递增的序列，只要通过一个变量记录最大值，并递归检查当前结点的值是否要比最大值要大，就可以判断是否为二叉搜索树。另外，这个变量为了符合数据大小的要求，结点最小值为INT_MIN，则可以将该变量设为LONG_MIN；或者可以设为前一个结点pre</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return true</span><br></pre></td></tr></table></figure>

<p>当前结点为空时，也为二叉搜索树，返回true</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int tmp = LONG_MIN;</span><br><span class="line">bool isValidBST(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">	bool lflag = true,rflag = true;</span><br><span class="line">	</span><br><span class="line">	return lflag&amp;&amp;rflag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lflag = isValidBST(root-&gt;left);</span><br><span class="line">if(tmp &gt;= root-&gt;val)	return false;</span><br><span class="line">rflag = isValidBST(root-&gt;right);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下（使用<code>long long</code>变量）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">long long maxi = LONG_MIN;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return true;</span><br><span class="line">        bool lflag = true, rflag = true;</span><br><span class="line">        if(root-&gt;left)  lflag = isValidBST(root-&gt;left);</span><br><span class="line">        if(root-&gt;val &gt; maxi)    </span><br><span class="line">            maxi = root-&gt;val;</span><br><span class="line">        else    </span><br><span class="line">            return false;</span><br><span class="line">        if(root-&gt;right) rflag = isValidBST(root-&gt;right);</span><br><span class="line">        return lflag&amp;&amp;rflag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（使用前一个结点变量）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">TreeNode* pre = nullptr;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return true;</span><br><span class="line">        bool lflag = true, rflag = true;</span><br><span class="line">        if(root-&gt;left)  lflag = isValidBST(root-&gt;left);</span><br><span class="line">        if(!pre||pre-&gt;val &lt; root-&gt;val)</span><br><span class="line">            pre = root;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">        if(root-&gt;right) rflag = isValidBST(root-&gt;right);</span><br><span class="line">        return lflag&amp;&amp;rflag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-11"><a href="#迭代法-11" class="headerlink" title="迭代法"></a>迭代法</h3><p>使用中序迭代遍历法，只需稍微修改即可,对应地，迭代法也可以用一个long long变量或者前一个结点来存储最大值，下面只给出long long变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return true;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        long long tmp = LONG_MIN;</span><br><span class="line">        while(!stk.empty()||node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node=node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                node = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                if(tmp &gt;= node-&gt;val)</span><br><span class="line">                    return false;</span><br><span class="line">                tmp = node-&gt;val;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>为了验证一棵二叉搜索树，要将其当成一棵普通二叉树来看待，就不能利用二叉搜索树的特性。在判断时，需要注意<strong>左子树小于根节点小于右子树</strong>，而不只是单单的左子结点小于根节点小于右子结点，再结合中序遍历，可以利用严格单调有序性来判断一棵树是否为二叉搜索树，这时就要用到一个变量来记录当前下的最大结点值，结合所给定数据范围，可以将这个变量设为LONG_MIN来完成所有INT数据的测试；但如果测试数据中<strong>出现了LONG型数据</strong>，那可以将这个变量设为一个<strong>树的结点类型</strong>，用于存储前一个结点，这就不用考虑数据的类型和大小范围。</p>
<p>对于迭代法，则是基于中序迭代遍历模板的改变版，同样也有两种不同类型变量。两种方法的时间复杂度和空间复杂度都是O(n)，最坏情况下是一条链。</p>
<h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><p>[二叉搜索树的最小绝对差](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-17"><a href="#递归法-17" class="headerlink" title="递归法"></a>递归法</h3><p>根据题意，因为是<strong>任意两个结点的差</strong>，依旧可以使用中序遍历的方法对二叉树进行遍历，且因为中序遍历序列严格单调递增，则可以通过对相邻两个结点的值进行判断来获取最小绝对差。此外，该题中，既可以先用数组存储所有结点的值，再遍历一次数组进行判断；也可以通过一个结点变量，记录前一个结点的值，从而在遍历二叉树过程中就完成对绝对差的记录</p>
<p>中序递归遍历+转换成数组计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">int ans = INT_MAX;</span><br><span class="line">    void dfs(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root)   return;</span><br><span class="line">        if(root-&gt;left)  dfs(root-&gt;left);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        if(root-&gt;right) dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        int i = 1, j = 0;</span><br><span class="line">        for(i,j;i&lt;res.size();i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = min(ans,abs(res[i]-res[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>记录前一个结点与当前结点进行判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int res = INT_MAX;</span><br><span class="line">    int pre = -1,cur = -1;</span><br><span class="line">    int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">        if (!root)   return 0;</span><br><span class="line">        if (root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = root-&gt;left-&gt;val;</span><br><span class="line">            getMinimumDifference(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = root-&gt;val;</span><br><span class="line">        //if(pre!=-1)即可</span><br><span class="line">        if (pre!=-1&amp;&amp;abs(cur - pre))</span><br><span class="line">            res = min(abs(cur - pre), res);</span><br><span class="line">        pre = cur;</span><br><span class="line">        if (root-&gt;right) getMinimumDifference(root-&gt;right);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，在以上的程序中，也可以沿用上题中的两种方式，一种是用一个整型变量来记录前一个结点的值（如上）；另一种是用一个<code>TreeNode*</code>变量来记录前一个结点。后者只需要在更新res时将判断条件修改为<code>if(pre)</code>本质上都是一样</p>
<h3 id="迭代法-12"><a href="#迭代法-12" class="headerlink" title="迭代法"></a>迭代法</h3><p>依旧使用中序遍历迭代法，基于模板上修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while(!stk.empty()||node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                node = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                res.push_back(node-&gt;val);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0,j=1;j&lt;res.size();++j,++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = min(ans,abs(res[i]-res[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，迭代法中也可以不用新建一个数组，最后再遍历一次数组得到答案，也是设定前一个结点，可以是整型变量存结点的值，也可以直接存一个结点来实现</p>
<h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>本题与上一题验证二叉搜索树的遍历思路一致，只是上题判断前后两者大小关系，本题计算前后两者大小并取最小值</p>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p>[二叉搜索树中的众数](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a>)</p>
<p>从寻找众数角度出发，通常需要借助一个数组或哈希表等来存储元的值以及对应的出现次数，先遍历一遍二叉树得到存储整棵树的数组或哈希表，再将数组或哈希表进行排序，取出排序最大的一个或多个元素，存入到结果当中。而这就需要O(N)的时间复杂度，最坏情况下所有元素都只出现一次，时间复杂度是O(2N)，空间复杂度也会很大。</p>
<p>上述方法仅对一般的二叉树，但在本题中是一颗二叉搜索树，也就是说是一棵已经排好序的二叉树，相同的值的结点都是邻接在一起的，因此，仅需要一次遍历，通过pre指针指向上一个结点，与当前结点比较，并统计相同值结点的个数，就能找出其众数</p>
<h3 id="递归法-18"><a href="#递归法-18" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!node)	return;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int times = 0, ttimes = 0;</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">TreeNode* pre = nullptr;</span><br><span class="line">void dfs(TreeNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	dfs(node-&gt;left);</span><br><span class="line">	//根结点</span><br><span class="line">	dfs(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (pre &amp;&amp; pre-&gt;val != node-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    ttimes = 0;</span><br><span class="line">&#125;</span><br><span class="line">if (pre &amp;&amp; pre-&gt;val == node-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    ++ttimes;</span><br><span class="line">&#125;</span><br><span class="line">if (ttimes == times)</span><br><span class="line">&#123;</span><br><span class="line">    res.push_back(node-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">if (ttimes &gt; times)</span><br><span class="line">&#123;</span><br><span class="line">    times = ttimes;</span><br><span class="line">    res.clear();</span><br><span class="line">    res.push_back(node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    TreeNode* pre = nullptr;</span><br><span class="line">    int times = 0;</span><br><span class="line">    int ttimes = 0;</span><br><span class="line">    void dfs(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node)   return;</span><br><span class="line">        dfs(node-&gt;left);</span><br><span class="line">        if (pre &amp;&amp; node-&gt;val != pre-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ttimes = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pre &amp;&amp; pre-&gt;val == node-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ttimes;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ttimes == times)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ttimes &gt; times)</span><br><span class="line">        &#123;</span><br><span class="line">            res.clear();</span><br><span class="line">            times = ttimes;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        dfs(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-13"><a href="#迭代法-13" class="headerlink" title="迭代法"></a>迭代法</h3><p>同样地，用中序迭代遍历法，而处理根结点代码与递归法中的一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        TreeNode* pre = nullptr;</span><br><span class="line">        int times = 0, ttimes = 0;</span><br><span class="line">        while(!stk.empty()||node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                node = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                if(pre&amp;&amp;pre-&gt;val!=node-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    ttimes = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if(pre&amp;&amp;pre-&gt;val == node-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++ttimes;</span><br><span class="line">                &#125;</span><br><span class="line">                if(ttimes==times)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                if(ttimes&gt;times)</span><br><span class="line">                &#123;</span><br><span class="line">                    times = ttimes;</span><br><span class="line">                    res.clear();</span><br><span class="line">                    res.push_back(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = node;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p>对本题而言，依旧是对<strong>pre指针和cur指针</strong>的同时运用，这一点上与前两题都一致，不同的是本题还需要对pre和cur指向的结点的值出现次数进行统计，而在统计这里提出针对一般情况和针对二叉搜索树的不同解法，一般情况下借助于特殊的数据结构来对元素的值及其出现次数进行统计，但在二叉搜索树下则不用，因为其本身就已经是排序好的。若是针对一般情况下，有其他数据结构支撑的，可以选取任意的遍历顺序，但针对二叉搜索树时，为了运用到它的有序性，通常都会用中序遍历，也只有中序遍历序列是有序的。在迭代法中，无非就是在处理根结点的代码上将递归法的代码照搬过来，套用在模板上。</p>
<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><strong>二叉树的最近公共祖先</strong></h2><p>[二叉树的最近公共祖先](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a>)</p>
<p>最近公共祖先可简化成两种情况，一种是直接找到除要寻找的两结点之外的第三结点作为两结点的公共祖先，即要返回该第三结点作为结果；另一种则是其中一个结点是另一结点的祖先，则返回该结点作为结果即可。</p>
<h3 id="递归法-19"><a href="#递归法-19" class="headerlink" title="递归法"></a>递归法</h3><p>根据题意，这题可以用到回溯法，由于后续遍历本身就是回溯（左右中），可以先判断左右子树是否有包含要找的结点，再来判断当前结点是否是公共祖先。同时，这也是一种由底至顶的方法。</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return nullptr;</span><br><span class="line">if(root==q||root==p) return root;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当当前结点即为要寻找的结点时，即可直接返回当前结点，向上回溯；如果没有找到，则返回空结点</p>
<ol start="3">
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* ltree = lowestCommonAncestor(root-&gt;left,p,q);				//左</span><br><span class="line">TreeNode* rtree = lowestCommonAncestor(root-&gt;right,p,q);			//右</span><br><span class="line">if(ltree&amp;&amp;rtree)	return root;								  //中</span><br><span class="line">else if(!ltree&amp;&amp;rtree)	return rtree;</span><br><span class="line">else if(ltree&amp;&amp;rtree)	return ltree;</span><br><span class="line">return nullptr;</span><br></pre></td></tr></table></figure>

<p>如果当前的根节点的左子结点和右子结点的返回值不为空（返回值为p和q），则证明当前的根节点就是他们的公共祖先，直接返回根节点；如果当前结点的左子结点为空，但右子结点不为空，则证明p或q在右子结点，直接返回右子结点；右子结点为空同理；最后，都没有找到则证明p和q都不在当前结点的子树下，返回空结点</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(!root)   return NULL;</span><br><span class="line">        if(root==p||root==q)    return root;</span><br><span class="line">        TreeNode* ltree = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* rtree = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        if(ltree&amp;&amp;rtree) </span><br><span class="line">            return root;</span><br><span class="line">        else if(ltree&amp;&amp;!rtree) </span><br><span class="line">            return ltree;</span><br><span class="line">        else if(!ltree&amp;&amp;rtree)</span><br><span class="line">            return rtree;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归hashmap查表法"><a href="#递归hashmap查表法" class="headerlink" title="递归hashmap查表法"></a>递归<code>hashmap</code>查表法</h3><p>不边递归回溯边记录判断，则需要独立遍历一次二叉树，借助<code>unordered_map&lt;int,TreeNode*&gt; fanode</code>进行父结点的记录，再将p或q通过<code>fanode</code>向上查询父结点，借助另一个<code>unordered_map&lt;int,bool&gt; cmp</code>进行有无相同父结点的判断</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">unordered_map&lt;int,TreeNode*&gt; fanode;</span><br><span class="line">unordered_map&lt;int,bool&gt; cmp;</span><br><span class="line">    void dfs(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            fanode[root-&gt;left-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            fanode[root-&gt;right-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        fanode[root-&gt;val] = NULL;</span><br><span class="line">        dfs(root);</span><br><span class="line">        while(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cmp[p-&gt;val]=true;</span><br><span class="line">            p=fanode[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        while(q)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cmp[q-&gt;val])</span><br><span class="line">                return q;</span><br><span class="line">            q = fanode[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>遍历每个结点获取对应父结点需要时间O(n)，在向上寻找p、q共同父结点时，遍历的结点数不会超过n，最坏情况下是树单独成链，总的时间复杂度是O(n)，且接近O(2n)；对于递归遍历每个结点所占用的递归栈空间最坏情况下为O(n)，而储存n个结点的哈希表空间复杂度也为O(n)，因此总的空间复杂度为O(3n)，性能与第一种解法无量级上的差异但比第一种解法要差</p>
<h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p>通用解法是在递归的过程中直接记录和处理，这就省去了额外的时间和空间开销。在处理最近公共祖先问题上，最先想到应该由底至顶的遍历二叉树，即回溯，而后序遍历又是天生的回溯顺序。这一点上与相同用到回溯法的平衡二叉树题一致，都用到后序遍历；但在有关二叉树路径题中，因为递归的过程需要先处理根结点，所以用的是先序遍历回溯。</p>
<p>回溯递归使用先序遍历中，通过成员变量快速判断有无符合条件的情况发生，可以直接向上回溯，如路径之和；而使用后序遍历，都要先遍历完所有的结点，因为要用到处理结点后的返回值，先进入递归才能再判断有无发生，如由底至顶的平衡二叉树。</p>
<p><code>if(root==q||root==p)	return root;</code>这是对结束条件的补充，为的是遇到想要查找的结点时及时返回，获取返回值，并且不必继续做无谓的遍历直至叶子结点</p>
<p>递归法中对于情况二的处理，只分开根结点的左、右子树作为查找对象，即在一个子树上只寻找一个目标结点，（情况二则是两个目标结点都在一个子树上，且以其中一个结点作为公共祖先返回结果），因此一旦找寻到其中一个结点，即可直接返回该结点，也正是目标结点的公共祖先。</p>
<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><strong>二叉搜索树的最近公共祖先</strong></h2><p>[二叉搜索树的最近公共祖先](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-20"><a href="#递归法-20" class="headerlink" title="递归法"></a>递归法</h3><p>明显这道题与上题相比，需要用到二叉搜索树的特性，即有序性。</p>
<p>因为是要寻找公共祖先，是由底至顶的查找，所以要用后序遍历，同时符合了回溯的要求。</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return root;</span><br></pre></td></tr></table></figure>

<p>也可以不写，因为题目保证了能够找得到公共祖先</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* lflag = NULL,*rflag = NULL;</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root,TreeNode* p,TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	if(lflag||rflag)	return lflag==NULL?rflag:lflag;</span><br><span class="line">	return root;										//中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果找到p或q则返回当前结点；如果<code>lflag</code>或<code>rflag</code>被赋值，证明找到p或者q，则返回被赋值的那个<code>flag</code></p>
</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(q-&gt;val &lt; root-&gt;val &amp;&amp; p-&gt;val &lt; root-&gt;val)</span><br><span class="line">	lflag = lowestCommonAncestor(root-&gt;left,p,q);			//左</span><br><span class="line">if(q-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)</span><br><span class="line">	rflag = lowestCommonAncestor(root-&gt;right,p,q);			//右</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">TreeNode* lflag=NULL, *rflag=NULL;</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(!root)   return root;</span><br><span class="line">        if(p-&gt;val &lt; root-&gt;val&amp;&amp;q-&gt;val &lt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            rflag = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        if(p-&gt;val &gt; root-&gt;val&amp;&amp;q-&gt;val &gt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            lflag = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        if(lflag||rflag)    return lflag==NULL?rflag:lflag;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-14"><a href="#迭代法-14" class="headerlink" title="迭代法"></a>迭代法</h3><p>在上述递归的过程中，其实就是迭代的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        TreeNode* res = root;</span><br><span class="line">        while(res)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res-&gt;val &gt; p-&gt;val&amp;&amp;res-&gt;val &gt; q-&gt;val)</span><br><span class="line">                res = res-&gt;left;</span><br><span class="line">            else if(res-&gt;val &lt; p-&gt;val&amp;&amp;res-&gt;val &lt; q-&gt;val)</span><br><span class="line">                res = res-&gt;right;</span><br><span class="line">            else</span><br><span class="line">                return res;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p>在递归法中，首先，当<code>q-&gt;val &lt; root-&gt;val &amp;&amp; p-&gt;val &gt; root-&gt;val</code>或者<code>q-&gt;val &gt;  root-&gt;val &amp;&amp; p-&gt;val &lt; root-&gt;val</code>，换句话说，当当前结点值处于p和q值的区间内，那么当前结点就一定是p和q的最近公共祖先（有序性）。其次，因为是一定能够找到公共祖先，所以单层逻辑中对中间结点的处理就是递归的返回值——直接返回当前结点（即公共祖先），这也是递归的最深一层。</p>
<p>相对于普通的二叉树，在寻找二叉搜索树的最近公共祖先时，可以更加的有方向性去寻找所要的结点，不需要遍历所有结点，而当找到所要找的结点时，由于没有多余遍历其他结点，也就不会遇到返回值为空的结点，对有返回值的结点处理也更加简洁（只在lflag或rflag中，直接返回结果就行），<strong>因此实际上并没使用到回溯</strong>。因为没有遍历所有结点，空间复杂度为O(1)</p>
<p>同样地，二叉搜索树的最近公共祖先也有两种情况，一种是直接找到除要寻找的两结点之外的第三结点作为两结点的公共祖先，即要返回该第三结点作为结果；另一种则是其中一个结点是另一结点的祖先，则返回该结点作为结果即可。对于第二种情况，只要不满足p和q结点值同时大于或者小于当前结点的值，就直接返回当前结点，而当前结点也正是它们的共同祖先（其中一个结点本身）</p>
<p>另外，该题也可以用普通二叉树的最近公共祖先两种做法</p>
<h2 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h2><p>[二叉搜索树中的插入操作](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-21"><a href="#递归法-21" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        if(!root)   </span><br><span class="line">            return new TreeNode(val);</span><br><span class="line">        if(val &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = insertIntoBST(root-&gt;left,val);</span><br><span class="line">        else if(val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = insertIntoBST(root-&gt;right,val);</span><br><span class="line">        return  root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-15"><a href="#迭代法-15" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        TreeNode* newnode = new TreeNode(val);</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        if(!node)</span><br><span class="line">        &#123;</span><br><span class="line">            return newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        while(node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(val &lt; node-&gt;val&amp;&amp;node-&gt;left)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            else if(val &gt; node-&gt;val&amp;&amp;node-&gt;right)</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            else if(val &lt; node-&gt;val&amp;&amp;!node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left = newnode;</span><br><span class="line">                node = newnode-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(val &gt; node-&gt;val&amp;&amp;!node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right = newnode;</span><br><span class="line">                node = newnode-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p>本题还有重新构建二叉搜索树的方法，但在本解法中只做了直接向二叉搜索树添加新结点的做法，并没有手算向二叉搜索树插入操作的代码实现方法</p>
<h2 id="删除二叉搜索树中的结点"><a href="#删除二叉搜索树中的结点" class="headerlink" title="删除二叉搜索树中的结点"></a><strong>删除二叉搜索树中的结点</strong></h2><p>[删除二叉搜索树中的结点](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a>)</p>
<h3 id="对回溯法的理解"><a href="#对回溯法的理解" class="headerlink" title="对回溯法的理解"></a>对回溯法的理解</h3><p>首先，要做的第一步是 找到要删除结点的父结点，利用递归回溯的思想，借助栈保存当前访问结点的父结点，一旦确定当前结点是要删除的结点，则栈顶元素就是其父结点。因为要找根结点，因此选择了先序递归遍历。但缺点在于无论什么时候找到要目标结点，都会遍历整棵二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool find_fa_dfs(int key, stack&lt;TreeNode*&gt; &amp; stk)</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* tmp = stk.top();</span><br><span class="line">    if (tmp-&gt;val == key)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (tmp-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        stk.push(tmp-&gt;left);</span><br><span class="line">        if (find_fa_dfs( key, stk))</span><br><span class="line">            fa = tmp;</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    if (tmp-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        stk.push(tmp-&gt;right);</span><br><span class="line">        if (find_fa_dfs( key, stk))</span><br><span class="line">            fa = tmp;</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于代码中的改进点，要求当找到目标结点后要及时返回或结束递归，可加上一个判断，<code>if(fa!=nullptr)return false;</code>当找到了目标结点，<code>fa</code>结点就会被修改，因此对于遍历中不在回溯路径上的后续结点，当进入递归时就会直接返回。但如果目标结点是根结点<code>fa=nullptr</code>，则无效，依旧会遍历整棵二叉树。</p>
<p>另外，题中这是一颗二叉搜索树，则可以利用其特性快速找到目标结点及其父结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* fa = nullptr;</span><br><span class="line">void find_fa_dfs(TreeNode* node,int key)</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* lnode = nullptr, * rnode = nullptr;</span><br><span class="line">    if (!node)   return;</span><br><span class="line">    if (node-&gt;val &lt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        fa = node;</span><br><span class="line">        find_fa_dfs(node-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (node-&gt;val &gt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        fa = node;</span><br><span class="line">        find_fa_dfs(node-&gt;left, key);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归法-22"><a href="#递归法-22" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return nullptr;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* deleteNode(TreeNode* root,int key)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<p>在本题中，关键在于对不同情况的分类讨论</p>
<ul>
<li>当前结点为空，直接返回空结点</li>
<li>当前结点值比key大，递归进入当前结点的左子结点</li>
<li>当前结点值比key小，递归进入当前结点的右子结点</li>
<li>当前结点值等于key值，则证明找到目标删除结点<ul>
<li>目标结点是叶子结点，直接删除，返回空结点</li>
<li>目标结点有单孩子结点，孩子结点补上，作为根节点返回</li>
<li>目标结点有两个孩子结点，将目标结点的左孩子结点作为目标结点的右孩子结点的最左下叶子结点的左子树，右孩子结点作为根结点返回</li>
</ul>
</li>
<li>都不符合，则是key不存在于当前树中，无需删除，返回root</li>
</ul>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        if (!root)   return root;</span><br><span class="line">        if (root-&gt;val &lt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (root-&gt;val &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                delete root;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!root-&gt;right)</span><br><span class="line">                return root-&gt;left;</span><br><span class="line">            else if (!root-&gt;left)</span><br><span class="line">                return root-&gt;right;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* tmp = root-&gt;right;</span><br><span class="line">                while (tmp-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = tmp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp-&gt;left = root-&gt;left;</span><br><span class="line">                TreeNode* node = root;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">                delete node;</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重要的是，理解在每次调用递归时，返回的值是作为当前结点下删除目标结点后的新的子树</p>
</li>
</ol>
<h3 id="迭代法-16"><a href="#迭代法-16" class="headerlink" title="迭代法"></a>迭代法</h3><p>   模拟实现递归的过程，但会因为在分类讨论下，多出了判断当前结点是否为二叉搜索树的根结点，从而导致代码出现很多重复，也可以封装成一个函数</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        if (!root)   return root;</span><br><span class="line">        TreeNode* node = root, * fa = nullptr;</span><br><span class="line">        while (node)</span><br><span class="line">        &#123;</span><br><span class="line">            if (key &lt; node-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                fa = node;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (key &gt; node-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                fa = node;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (key == node-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!node-&gt;left &amp;&amp; !node-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(!fa) return nullptr;</span><br><span class="line">                    if(fa-&gt;val &gt; key)</span><br><span class="line">                        fa-&gt;left = nullptr;</span><br><span class="line">                    else</span><br><span class="line">                        fa-&gt;right = nullptr;</span><br><span class="line">                    delete node;</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!node-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(!fa)</span><br><span class="line">                        return node-&gt;right;</span><br><span class="line">                    if (fa-&gt;val &gt; key)</span><br><span class="line">                        fa-&gt;left = node-&gt;right;</span><br><span class="line">                    else</span><br><span class="line">                        fa-&gt;right = node-&gt;right;</span><br><span class="line">                    delete node;</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!node-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(!fa)</span><br><span class="line">                        return node-&gt;left;</span><br><span class="line">                    if (fa-&gt;val &gt; key)</span><br><span class="line">                        fa-&gt;left = node-&gt;left;</span><br><span class="line">                    else</span><br><span class="line">                        fa-&gt;right = node-&gt;left;</span><br><span class="line">                    delete node;</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* lnode = node-&gt;left;</span><br><span class="line">                    TreeNode* tmp = node-&gt;right;</span><br><span class="line">                    while (tmp-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp = tmp-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp-&gt;left = lnode;</span><br><span class="line">                    if (!fa)</span><br><span class="line">                    &#123;</span><br><span class="line">                        node = node-&gt;right;</span><br><span class="line">                        return node;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (fa-&gt;val &gt; key)</span><br><span class="line">                        fa-&gt;left = node-&gt;right;</span><br><span class="line">                    else</span><br><span class="line">                        fa-&gt;right = node-&gt;right;</span><br><span class="line">                    delete node;</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><p>对于本题中的递归法，类似其他二叉搜索树的题目，都能用到递归算法，且可以利用二叉搜索树的特性简化递归过程。这一题考查了分类讨论的多种情况，并要求在递归遍历找到目标删除结点的父结点，或根据返回值对父结点的指向作更新。同时，对比迭代法，因为不能用返回值不断向上返回新的根结点，迭代法需要找到目标结点的父结点，才能修改删除结点后父结点的指向，可得知，<strong>用函数封装后的返回值可以简便的修改二叉树结构</strong>。</p>
<p>在力扣编译器中，就算是叶子结点，直接将其delete掉也会报错，需要把其父结点更改为<strong>指向空结点</strong>，即断开跟不删除结点的所有连接才能不报错</p>
<p>递归法和迭代法的时间复杂度都是O(n)，遍历一次二叉树的结点。递归法的空间复杂度最坏情况下是O(n)，迭代法的空间复杂度是O(1)，只占用常量级的空间，因为二叉搜索树的迭代不需要用到栈或队列</p>
<h2 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h2><p>[修剪二叉搜索树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-23"><a href="#递归法-23" class="headerlink" title="递归法"></a>递归法</h3><p>类比上一题，后序遍历所有二叉树结点，并将修剪过后的子树的根结点作为返回值，作为根结点的新左子结点或者新右子结点。如果当前结点值小于要求范围，根据二叉搜索树的特性，从当前结点的右子树不断向右寻找，直到值在要求范围内，并返回该结点；如果当前结点值大于要求范围，也同理</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return nullptr;</span><br></pre></td></tr></table></figure>

<p>当遇到空结点时返回空结点</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* trimBST(TreeNode* root, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">	root-&gt;left = trimBST(root-&gt;left,low,high);</span><br><span class="line">	root-&gt;right = trimBST(root-&gt;right,low,high);</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让左子结点进入递归，并将新的结点作为返回值，给该结点的左子结点重新赋值</p>
<p>右子结点同理</p>
<p>全部子树修剪完成，则返回根结点</p>
</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(root-&gt;val &lt; low)</span><br><span class="line">&#123;</span><br><span class="line">	TreeNode* tmp = root-&gt;right;</span><br><span class="line">	while(tmp &amp;&amp; tmp-&gt;val &lt; low)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = tmp-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	return tmp == nullptr?nullptr:tmp;</span><br><span class="line">&#125;</span><br><span class="line">//另一边同理</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if (!root)   return root;</span><br><span class="line">        //后序遍历</span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, low, high);</span><br><span class="line">        if (root-&gt;val &lt; low)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp = root-&gt;right;</span><br><span class="line">            while (tmp &amp;&amp; tmp-&gt;val &lt; low)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = tmp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            return tmp == nullptr ? nullptr : tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;val &gt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp = root-&gt;left;</span><br><span class="line">            while (tmp &amp;&amp; tmp-&gt;val &gt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            return tmp == nullptr ? nullptr : tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个版本的递归中，每个结点都进入了递归，其实不需要，只是将符合范围的当前结点的左右结点送入递归即可，但不能够直接改成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(root-&gt;val &gt; low &amp;&amp; root-&gt;val &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">	root-&gt;left = trimBST(root-&gt;left,low,high);</span><br><span class="line">	root-&gt;right = trimBST(root-&gt;right,low,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为后面在处理中间结点的代码，相当于循环迭代处理，没有保证到根结点的子树都会进入递归，因此，可以将中间结点的处理过程修改成递归形式，整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if (!root)   return root;</span><br><span class="line">        if(root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = trimBST(root-&gt;left,low,high);</span><br><span class="line">            root-&gt;right = trimBST(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;val &lt; low)</span><br><span class="line">        &#123;</span><br><span class="line">            return trimBST(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;val &gt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            return trimBST(root-&gt;left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题在于，会导致占用更多的栈空间，让整个程序的空间复杂度比原有的更加大。</p>
<p>综上所述，第一个版本的递归由于带上了部分迭代的版本，总体性能更优</p>
<h3 id="迭代法-17"><a href="#迭代法-17" class="headerlink" title="迭代法"></a>迭代法</h3><p>类似上一题删除二叉搜索树中的结点，迭代法需要找到目标结点的父结点，并改变父结点的指向，在本题中，需要先循环寻找到在范围之内的根结点，再分别对左子树和右子树进行循环判断和更改，循环过程是关键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if (!root)   return root;</span><br><span class="line">        while(root&amp;&amp;(root-&gt;val &lt; low || root-&gt;val &gt; high))</span><br><span class="line">        &#123;</span><br><span class="line">            if(root-&gt;val &lt; low)</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            else</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while(node)</span><br><span class="line">        &#123;</span><br><span class="line">            while (node-&gt;right &amp;&amp; node-&gt;right-&gt;val &gt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right = node-&gt;right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        node = root;</span><br><span class="line">        while(node)</span><br><span class="line">        &#123;</span><br><span class="line">            while (node-&gt;left &amp;&amp; node-&gt;left-&gt;val &lt; low)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left = node-&gt;left-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h3><p>这两题中，迭代法由于不占用递归栈的空间，空间复杂度都为O(1)，<strong>但需要考虑的情况更加多</strong>，比递归法更为复杂</p>
<h2 id="将有序数组转换成二叉搜索树"><a href="#将有序数组转换成二叉搜索树" class="headerlink" title="将有序数组转换成二叉搜索树"></a>将有序数组转换成二叉搜索树</h2><p>[将有序数组转换成二叉搜索树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-24"><a href="#递归法-24" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(start&lt;end)	return nullptr;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeNode*(vector&lt;int&gt;&amp;nums,int start,int end)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* root = new TreeNode(nums[(left + right + 1)/2]);</span><br><span class="line">root-&gt;left = sortedArrayIndexToBST(nums, start, rootindex - 1);</span><br><span class="line">root-&gt;right = sortedArrayIndexToBST(nums, rootindex + 1, end);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayIndexToBST(vector&lt;int&gt;&amp; nums, int start, int end)</span><br><span class="line">    &#123;</span><br><span class="line">        if (end &lt; start)   return nullptr;</span><br><span class="line">        int rootindex = (end+start+1) / 2;</span><br><span class="line">        TreeNode* root = new TreeNode(nums[rootindex]);</span><br><span class="line">        root-&gt;left = sortedArrayIndexToBST(nums, start, rootindex - 1);</span><br><span class="line">        root-&gt;right = sortedArrayIndexToBST(nums, rootindex + 1, end);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()==1)  </span><br><span class="line">            return new TreeNode(nums[0]);</span><br><span class="line">        return sortedArrayIndexToBST(nums,0,nums.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-18"><a href="#迭代法-18" class="headerlink" title="迭代法"></a><strong>迭代法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        queue&lt;pair&lt;TreeNode*, int&gt;&gt; que;     //父结点和index</span><br><span class="line">        TreeNode* root = new TreeNode(0);</span><br><span class="line">        que.push(make_pair(nullptr, nums.size() / 2));</span><br><span class="line"></span><br><span class="line">        while (!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int index = que.front().second;</span><br><span class="line">            TreeNode* fa = que.front().first;</span><br><span class="line">            que.pop();</span><br><span class="line"></span><br><span class="line">            TreeNode* cur = new TreeNode(nums[index]);</span><br><span class="line">            if (fa &amp;&amp; nums[index] &lt; fa-&gt;val)</span><br><span class="line">                fa-&gt;left = cur;</span><br><span class="line">            else if (fa &amp;&amp; nums[index] &gt; fa-&gt;val)</span><br><span class="line">                fa-&gt;right = cur;</span><br><span class="line">            else</span><br><span class="line">                root = cur;</span><br><span class="line">            if (index - 1 &gt;= 0) que.push(make_pair(cur, index / 2));</span><br><span class="line">            if (index + 1 &lt; nums.size())   que.push(make_pair(cur, (index + nums.size() + 1) / 2));</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上版本的代码会死循环，原因在于条件判断进入队列，由于子区间<strong>没有边界限定</strong>，而只使用原始nums的边界，就会导致一直有实际上并不合法的结点进入队列。此时，需要有额外的容器去记录边界</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 0) return nullptr;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = new TreeNode(0);   // 初始根节点</span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQue;           // 放遍历的节点</span><br><span class="line">        queue&lt;int&gt; leftQue;                 // 保存左区间下标</span><br><span class="line">        queue&lt;int&gt; rightQue;                // 保存右区间下标</span><br><span class="line">        nodeQue.push(root);                 // 根节点入队列</span><br><span class="line">        leftQue.push(0);                    // 0为左区间下标初始位置</span><br><span class="line">        rightQue.push(nums.size() - 1);     // nums.size() - 1为右区间下标初始位置</span><br><span class="line"></span><br><span class="line">        while (!nodeQue.empty()) &#123;</span><br><span class="line">            TreeNode* curNode = nodeQue.front();</span><br><span class="line">            nodeQue.pop();</span><br><span class="line">            int left = leftQue.front(); leftQue.pop();</span><br><span class="line">            int right = rightQue.front(); rightQue.pop();</span><br><span class="line">            int mid = left + ((right - left) / 2);</span><br><span class="line"></span><br><span class="line">            curNode-&gt;val = nums[mid];       // 将mid对应的元素给中间节点</span><br><span class="line"></span><br><span class="line">            if (left &lt;= mid - 1) &#123;          // 处理左区间</span><br><span class="line">                curNode-&gt;left = new TreeNode(0);</span><br><span class="line">                nodeQue.push(curNode-&gt;left);</span><br><span class="line">                leftQue.push(left);</span><br><span class="line">                rightQue.push(mid - 1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (right &gt;= mid + 1) &#123;         // 处理右区间</span><br><span class="line">                curNode-&gt;right = new TreeNode(0);</span><br><span class="line">                nodeQue.push(curNode-&gt;right);</span><br><span class="line">                leftQue.push(mid + 1);</span><br><span class="line">                rightQue.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-25"><a href="#总结-25" class="headerlink" title="总结"></a>总结</h3><p>这道题也属于修改二叉搜索树的结构，通常在处理中间结点后，可以利用递归返回值来更新二叉搜索树的左右结点，并递归下去</p>
<p>且迭代法要考虑的比递归法要复杂很多，在本题中，迭代法最终实现过程还是依据了递归法的过程，用边界条件作为参数，不断缩小边界，只不过<strong>在递归法中使用函数的传参代替了迭代法中用于记录这几个参数的容器</strong></p>
<h2 id="把二叉搜索树转换成累加树"><a href="#把二叉搜索树转换成累加树" class="headerlink" title="把二叉搜索树转换成累加树"></a>把二叉搜索树转换成累加树</h2><p>[把二叉搜索树转换成累加树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-25"><a href="#递归法-25" class="headerlink" title="递归法"></a>递归法</h3><p>灵活运用遍历顺序，根据题意，需要找最大的结点，即最右结点，再访问第二大的结点，即中间结点，最后才是左结点，实际上这就是中序遍历的逆序</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int res = 0;</span><br><span class="line">    TreeNode* convertBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return nullptr;</span><br><span class="line">        convertBST(root-&gt;right);</span><br><span class="line">        res += root-&gt;val;</span><br><span class="line">        root-&gt;val = res;</span><br><span class="line">        convertBST(root-&gt;left);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-19"><a href="#迭代法-19" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法所用到的也是中序遍历的模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* convertBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return nullptr;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while(!stk.empty()||node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                node = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                node-&gt;val = sum;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-26"><a href="#总结-26" class="headerlink" title="总结"></a>总结</h3><p>第一想法是，第一次遍历二叉树，借助数组存储每个结点的值，再遍历一次数组，对数组的值进行处理，使得每个下标对应的是累加后的数值，最后遍历一次二叉树修改原值。</p>
<p>这一题摆脱了常规的遍历顺序，尝试了先访问右结点的逆向中序遍历</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/10/11/%E8%BF%99%E9%87%8C%E6%98%AF%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/11/%E8%BF%99%E9%87%8C%E6%98%AF%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" class="post-title-link" itemprop="url">这里是第一篇博客文章</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-11 16:58:01 / 修改时间：17:05:36" itemprop="dateCreated datePublished" datetime="2022-10-11T16:58:01+08:00">2022-10-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>this is my first blog article in my website!</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
