<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git操作</title>
    <link href="/2024/08/17/git%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/08/17/git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>假设远程仓库中有main分支，其中有Init的commit</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180012078.png" alt="image-20240817191625062"></p><p>首先克隆同步到本地仓库，<code>git clone https://github.com/xx/xx.git</code></p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180012437.png" alt="image-20240817191750339"></p><p>为了不扰乱main分支，应该在本地仓库中创建新的分支<code>git checkout -b my-feature</code></p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180012127.png" alt="image-20240817191914518"></p><p>后续在此分支上进行自己的代码修改，修改完成后，使用<code>git diff</code>查看修改的代码，然后可<code>git add .</code> 添加修改到暂存区（staging）并告知本地git，<code>git commit -m &quot;f-commit&quot;</code>提交commit给local git</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180012359.png" alt="image-20240817192347300"></p><p><code>git push -u origin my-feature</code>同步到远程仓库，此时远程仓库中也会新增<code>my-feature</code>分支</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180014909.png" alt="image-20240817192627062"></p><p>如果此时远程仓库的代码有更新，则需要先拉取远程仓库main到本地的main，先切换到main分支<code>git checkout main</code>，<u>值得注意的是，这时候disk中的代码是Init状态的代码，并非在<code>f-commit</code>下的代码</u></p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013385.png" alt="image-20240817193511042"></p><p>这时候使用pull拉取<code>git pull origin main</code>，这时本地仓库与远程仓库状态一样，都有两个分支，切换回my-feature分支，为了在此分支上同步main分支代码更新，使用<code>git rebase main</code>，先让main的最新修改与当前分支同步，在这个基础上尝试添加该分支之前的commit(即<code>f-commit</code>)，如果有<code>rebase conflict</code>，需要手动选择保留哪个修改，这时候my-feature分支上会在f-commit前插入与远程分支一样的update commit</p><p> <img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013678.png" alt="image-20240817193714442"></p><p>再将本地同步到远程，<code>git push -f origin my-feature</code>，push需要加-f表示强制push，因为此时远程仓库的my-feature分支同样也有Init，update和f-commit三个commit</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013702.png" alt="image-20240817193839660"></p><p>将my-feature分支合并到main分支中<code>pull request</code></p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013236.png" alt="image-20240817194108191"></p><p>使用<code>squash and merge</code>，将一个分支上的所有改变合并成一个commit，合并完成后删除远程的my-feature分支，同样在本地仓库上<code>git checkout main</code> 切换到main分支再<code>git branch -D my-feature</code>删除my-feature，最后在main分支上<code>git pull origin main</code>同步远程仓库的更新，如此反复</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013307.png" alt="image-20240817194340700"></p><p>以上内容来源于<a href="https://www.youtube.com/watch?v=uj8hjLyEBmU">https://www.youtube.com/watch?v=uj8hjLyEBmU</a></p><p>关于撤销</p><p>假设初始状态下四个区域一致，disk是硬盘，staging暂存区，local本地仓库以及远端仓库remote</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013036.png" alt="image-20240817194658402"></p><p>如果发生修改change，但并未进行<code>git add</code>等操作，也就是说只在硬盘上修改，如果想要撤销，可以使用<code>git checkout &lt;changed_file&gt;</code> 或者<code>git restore &lt;changed_file&gt;</code>直接回退到Init状态，也就是上一次commit这个文件的状态，新版本的git更推荐使用restore</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180014997.png" alt="image-20240817195333798"></p><p>在git add 后，也就是修改被同步到暂存区”git status -&gt; Changes to be commited”，如果想要撤销在暂存区的修改而保留硬盘上的修改，也就是取消git add的效果，就可以使用<code>git reset &lt;changed_file&gt;</code>或者<code>git restore --staged &lt;changed_file&gt;</code></p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013762.png" alt="image-20240817195619809"></p><p>如果想要连同硬盘上的修改也撤销，可以使用<code>git checkout HEAD &lt;changed_file&gt;</code>表示将文件撤销到最近一次commit的状态（HEAD）</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013837.png" alt="image-20240817195653564"></p><p>在git commit后，修改被提交到了本地git中，如果仅撤销本地git的修改，即取消git commit的效果，则可以使用<code>git reset --soft HEAD~1</code>，因为HEAD表示最近的一次commit，所以这里使用<code>HEAD~1</code>来表示想要回退到的Init状态</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013141.png" alt="image-20240817195853788"></p><p>进一步，如果想要取消连同取消git commit 和 git add 的效果，只保留在硬盘上的修改，那么可以使用<code>git reset HEAD~1</code>进行实现，也可以使用<code>git reset --mixed HEAD~1</code></p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013964.png" alt="image-20240817195922651"></p><p>要是连硬盘上的修改也撤销，就可以使用<code>git reset --hard HEAD~1</code></p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013247.png" alt="image-20240817200437211"></p><p>另一种撤销git revert，本质上是通过添加一个新的commit，使得看起来将change删除了，<code>git revert HEAD</code>这里的HEAD就是指commit过的change</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013905.png" alt="image-20240817200933821"></p><p>使用revert的好处有1. 可以撤销中间提交的任意一个commit </p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013753.png" alt="image-20240817201119527"></p><p>2.当修改push到远端remote仓库后，想要撤销公有分支上的修改，那么就只能使用revert，然后再push到远端仓库，从结果上撤销这个修改，否则会令使用这个公有分支的开发者混乱；也有可能这个分支是私有分支，就可以使用<code>git reset --hard HEAD~1</code>并推送到远端<code>git push -f</code>，-f 就是让remote强行接受这个分支变化，但不能用在共有分支上</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408180013999.png" alt="image-20240817201336433"></p><p>以上内容来源于<a href="https://www.youtube.com/watch?v=ol7CMoJuAvI&t=17s">https://www.youtube.com/watch?v=ol7CMoJuAvI&amp;t=17s</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>template</title>
    <link href="/2023/11/19/template/"/>
    <url>/2023/11/19/template/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集DisjointSet"><a href="#并查集DisjointSet" class="headerlink" title="并查集DisjointSet"></a>并查集DisjointSet</h2><p>并查集中每个强连通分量视为一个集合，强连通分量中任意两点均可达</p><p>并查集的两个基本操作</p><ul><li>Find：查找元素所属集合</li><li>Union：合并两个子集为一个新的集合</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Disjointset&#123;<br><span class="hljs-keyword">private</span>: <br>vector&lt;<span class="hljs-built_in">int</span>&gt; fa;<br>    <span class="hljs-constructor">Disjointset(<span class="hljs-params">int</span> <span class="hljs-params">max_size</span>)</span>: fa(vector&lt;<span class="hljs-built_in">int</span>&gt;(max_size))<br>        &#123;<br>            <span class="hljs-comment">// 初始化fa数组</span><br>            iota(fa.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, fa.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>public:<br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">Find(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(fa<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span><span class="hljs-operator"> == </span>x) <span class="hljs-comment">// 自己就是根结点</span><br>                return x;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//继续查找父结点，直到根结点</span><br>            &#123;<br>                <span class="hljs-built_in">int</span> parent = <span class="hljs-constructor">Find(<span class="hljs-params">fa</span>[<span class="hljs-params">x</span>])</span>;<br>                return parent;<br>            &#125;<br>            <span class="hljs-comment">// 三目运算符写法</span><br>            <span class="hljs-comment">// return fa[x] == x ? x : Find(fa[x]);</span><br>        &#125;<br><br>        void <span class="hljs-constructor">Union(<span class="hljs-params">int</span> <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> pa_a = <span class="hljs-constructor">Find(<span class="hljs-params">a</span>)</span>;<br>            <span class="hljs-built_in">int</span> pa_b = <span class="hljs-constructor">Find(<span class="hljs-params">b</span>)</span>;<br>            <span class="hljs-keyword">if</span>(pa_a<span class="hljs-operator"> == </span>pa_b) <span class="hljs-comment">// 同属一个集合中，无需合并</span><br>                return;<br>            fa<span class="hljs-literal">[<span class="hljs-identifier">pa_a</span>]</span> = pa_b;<br>            <span class="hljs-comment">// 也可以无需判断，直接写成 fa[pa_a] = pa_b;</span><br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样子，在树高较高的情况下（链表），find的复杂度可以达到O(n)，可以通过秩或者路径压缩的方法来减小复杂度</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 秩，代表树的高度</span><br><span class="hljs-comment">// 当秩为a 与 秩为b 的两个子集合并时，将秩较小的合并到秩较大的集合上；若相等，则任意合并，秩+1</span><br><span class="hljs-keyword">class</span> Disjointset&#123;<br><span class="hljs-keyword">private</span>: <br>vector&lt;<span class="hljs-built_in">int</span>&gt; fa;<br>vector&lt;<span class="hljs-built_in">int</span>&gt; rank; <span class="hljs-comment">// 秩</span><br>    <span class="hljs-constructor">Disjointset(<span class="hljs-params">int</span> <span class="hljs-params">max_size</span>)</span>: fa(vector&lt;<span class="hljs-built_in">int</span>&gt;(max_size), rank(vector&lt;<span class="hljs-built_in">int</span>&gt;(max_size, <span class="hljs-number">0</span>)))<br>        &#123;<br>            <span class="hljs-comment">// 初始化fa数组</span><br>            iota(fa.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, fa.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>public:<br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">Find(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(fa<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span><span class="hljs-operator"> == </span>x) <span class="hljs-comment">// 自己就是根结点</span><br>                return x;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//继续查找父结点，直到根结点</span><br>            &#123;<br>                <span class="hljs-built_in">int</span> parent = <span class="hljs-constructor">Find(<span class="hljs-params">fa</span>[<span class="hljs-params">x</span>])</span>;<br>                return parent;<br>            &#125;<br>            <span class="hljs-comment">// 三目运算符写法</span><br>            <span class="hljs-comment">// return fa[x] == x ? x : Find(fa[x]);</span><br>        &#125;<br><br>        void <span class="hljs-constructor">Union(<span class="hljs-params">int</span> <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> pa_a = <span class="hljs-constructor">Find(<span class="hljs-params">a</span>)</span>;<br>            <span class="hljs-built_in">int</span> pa_b = <span class="hljs-constructor">Find(<span class="hljs-params">b</span>)</span>;<br>            <span class="hljs-keyword">if</span>(rank<span class="hljs-literal">[<span class="hljs-identifier">pa_a</span>]</span> &gt; rank<span class="hljs-literal">[<span class="hljs-identifier">pa_b</span>]</span>)<br>            &#123;<br>            fa<span class="hljs-literal">[<span class="hljs-identifier">pa_b</span>]</span> = pa_a;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>            fa<span class="hljs-literal">[<span class="hljs-identifier">pa_a</span>]</span> = pa_b;<br>            <span class="hljs-keyword">if</span>(rank<span class="hljs-literal">[<span class="hljs-identifier">pa_a</span>]</span><span class="hljs-operator"> == </span>rank<span class="hljs-literal">[<span class="hljs-identifier">pa_b</span>]</span>)<br>            rank<span class="hljs-literal">[<span class="hljs-identifier">pa_b</span>]</span>++;<br>            &#125;<br>        &#125;<br>&#125;;<br><br><br><span class="hljs-comment">// 路径压缩</span><br><span class="hljs-keyword">class</span> Disjointset&#123;<br><span class="hljs-keyword">private</span>: <br>vector&lt;<span class="hljs-built_in">int</span>&gt; fa;<br>    <span class="hljs-constructor">Disjointset(<span class="hljs-params">int</span> <span class="hljs-params">max_size</span>)</span>: fa(vector&lt;<span class="hljs-built_in">int</span>&gt;(max_size))<br>        &#123;<br>            <span class="hljs-comment">// 初始化fa数组</span><br>            iota(fa.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, fa.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>public:<br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">Find(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 三目运算符写法</span><br>            <span class="hljs-comment">// return fa[x] == x ? x : Find(fa[x]);</span><br>            <span class="hljs-comment">// 在向上查找根结点时，每个孙子结点都变为子结点，减小树高</span><br>            return fa<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span><span class="hljs-operator"> == </span>x ? x : fa<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span> = <span class="hljs-constructor">Find(<span class="hljs-params">fa</span>[<span class="hljs-params">x</span>])</span>;<br>        &#125;<br><br>        void <span class="hljs-constructor">Union(<span class="hljs-params">int</span> <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> pa_a = <span class="hljs-constructor">Find(<span class="hljs-params">a</span>)</span>;<br>            <span class="hljs-built_in">int</span> pa_b = <span class="hljs-constructor">Find(<span class="hljs-params">b</span>)</span>;<br>            <span class="hljs-keyword">if</span>(pa_a<span class="hljs-operator"> == </span>pa_b) <span class="hljs-comment">// 同属一个集合中，无需合并</span><br>                return;<br>            fa<span class="hljs-literal">[<span class="hljs-identifier">pa_a</span>]</span> = pa_b;<br>            <span class="hljs-comment">// 也可以无需判断，直接写成 fa[pa_a] = pa_b;</span><br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：<code>O(n+m×α(m))</code>，其中 n 是图中的顶点数，m 是图中边的数目，α 是反阿克曼函数，在n非常大的时候，α(n) &lt; 5。并查集的初始化需要 O(n)的时间，然后遍历 m 条边并执行 m 次合并操作，最后对 source 和 destination 执行一次查询操作，查询与合并的单次操作时间复杂度是 <code>O(α(m))</code>，因此合并与查询的时间复杂度是 <code>O(m×α(m))</code>，总时间复杂度是 <code>O(n+m×α(m))</code></p><h3 id="2316-统计无向图中无法互相到达点对数"><a href="#2316-统计无向图中无法互相到达点对数" class="headerlink" title="2316. 统计无向图中无法互相到达点对数"></a><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">2316. 统计无向图中无法互相到达点对数</a></h3><p>附加数组信息，保存节点数信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Disjointset</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        vector&lt;<span class="hljs-type">int</span>&gt; fa;<br>        vector&lt;<span class="hljs-type">int</span>&gt; rank;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Disjointset</span>(<span class="hljs-type">int</span> n): <span class="hljs-built_in">fa</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n)), <span class="hljs-built_in">rank</span>(n, <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">iota</span>(fa.<span class="hljs-built_in">begin</span>(), fa.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(x == fa[x])<br>                <span class="hljs-keyword">return</span> x;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>                <span class="hljs-keyword">return</span> fa[x];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-type">int</span> pa_a = <span class="hljs-built_in">find</span>(x);<br>            <span class="hljs-type">int</span> pa_b = <span class="hljs-built_in">find</span>(y);<br><br>            <span class="hljs-keyword">if</span>(pa_a == pa_b)<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(rank[pa_a] &gt; rank[pa_b])<br>            &#123;<br>                fa[pa_b] = pa_a;<br>                rank[pa_a] += rank[pa_b];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                fa[pa_a] = pa_b;<br>                rank[pa_b] += rank[pa_a];<br>            &#125;   <br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> rank[x];<br>        &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-function">Disjointset <span class="hljs-title">disjointset</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; edge : edges)<br>        &#123;<br>            disjointset.<span class="hljs-built_in">Union</span>(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            res += n - disjointset.<span class="hljs-built_in">get</span>(disjointset.<span class="hljs-built_in">find</span>(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树 Trie"></a>字典树 Trie</h2><h2 id="字符匹配算法"><a href="#字符匹配算法" class="headerlink" title="字符匹配算法"></a>字符匹配算法</h2><p>字符串匹配问题，即在给定的文本串string中寻找有无模式串pattern的存在，最朴素的解决方法是用<code>O(mn)</code>的复杂度，依次遍历string中是否有完整的pattern存在，也称做暴力匹配，其他常见算法还有Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunday 算法等。</p><h3 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h3><p>Sunday算法核心思想在于在匹配失败时，跳过尽可能多的字符以达到更高的效率，因此需要借助一个move数组，记录模式串匹配失败时需要移动的距离，move数组的建立规则:当遇到匹配失败情况时，如果该字符不存在于模式串中，需要将模式串向右 <code>移动模式串长度 + 1位</code>；如果该字符在模式串中存在，则将模式串向右移动 <code>模式串长度 - 该字符在模式串中最右边的位置 + 1位</code>，例如，在文本串<code>substring searching</code>中匹配模式串<code>search</code>过程如下，先对齐起始位置，发现字符i不存在于模式串中</p><p>![image-20240825120700691](C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240825120700691.png</p><p>那么需要将模式串向右移动7位，此时匹配失败，指向字符r，存在于模式串中， 那么只需要将模式串向右移动3位，然后就匹配成功了</p><p>![image-20240825120736268](C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240825120736268.png</p><p>算法实现如下，<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> strStr(string haystack, string needle) &#123;<br>        <span class="hljs-keyword">int</span> m = haystack.<span class="hljs-keyword">size</span>(), n = needle.<span class="hljs-keyword">size</span>();<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; umap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>        <span class="hljs-keyword">if</span>(umap.<span class="hljs-keyword">find</span>(needle[i]) != umap.end())<br>        <span class="hljs-keyword">continue</span>;<br>        umap[needle[i]] = n - i;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= m - n)<br>        &#123;<br><span class="hljs-keyword">if</span>(haystack.substr(i, n) == needle)<br><span class="hljs-keyword">return</span> i;<br><span class="hljs-keyword">if</span>(i + n &gt; m)<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(umap.<span class="hljs-keyword">find</span>(haystack[i + n]) != umap.end())<br>&#123;<br>                i += umap[haystack[i + n]];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>i += n + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Sunday算法平均时间复杂度为O(n)，但最坏情况时间复杂度可能达到O(mn)，特别是在文本串与模式串结构复杂或匹配不成功时。</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法性能最优，能达到<code>O(m + n)</code>的时间复杂度，其核心在于next数组，next数组保存的是pattern模式串的最长公共前后缀长度，例如<code>abcabf</code>所对应的next数组<code>[0, 0, 0, 1, 2, 0]</code>，前缀的应用在于匹配串，后缀的应用在于原字符串，那么我们就可以通过最长公共前后缀，也就是next数组，来帮助我们在匹配失败时快速找到下一个应该匹配的位置。例如，如果要在string&#x3D;<code>&#39;aabaabaaf&#39;</code>中，寻找pattern&#x3D;<code>&#39;aabaaf&#39;</code>，pattern对应的next数组是<code>[0, 1, 0, 2, 0]</code>，如果当前匹配的<code>string[i] == pattern[j]</code>，跟暴力匹配一样，直接i++,j++进入下一轮匹配</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408241107931.png" alt="image-20240824110732810"></p><p>但在匹配到<code>string[i] != pattern[j]</code>时，朴素算法将j回退到0，i也要回退到之前匹配的下一个位置，也就是i&#x3D;1，j&#x3D;0重新进行匹配，但这样明显不合理，因为我们已经知道这样匹配最后还是回到i的位置，而j会遍历到j&#x3D;2的位置，也就是下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kevin346-sc/figure/images/202408241117916.png" alt="image-20240824111757792"></p><p>而这就能够与next数组扯上了关系，在pattern匹配失败时，i不需要改变位置，只需要根据next[j - 1]的位置来调整j，再接着匹配string[i]是否等于pattern[j]。直观上讲，在匹配失败时，i&#x3D;5,j&#x3D;5,也就是<code>string.substr(0, 5) == pattern.substr(0, 5)</code>,那么下一个还能匹配成功的位置自然就是最长公共前后缀了，因此我们可以先计算出next数组，再利用next数组在我们匹配失败时快速调整新的匹配位置从而降低复杂度</p><p>那么应该如何来求next数组呢，最简单的办法自然也是<code>O(n^2)</code>，但还可以有<code>O(n)</code>的方法，那就是利用已计算出来的next数组，为了方便计算，next数组长度设为n+1，并令next[0] &#x3D; -1，这样在调整j的位置时可以直接将j &#x3D; next[j]，也就是把next数组整体向右移了一位</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs autoit">void get_next(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; <span class="hljs-keyword">next</span>, <span class="hljs-built_in">string</span> p)<br>&#123;<br><span class="hljs-built_in">int</span> n = p.size()<span class="hljs-comment">;</span><br><span class="hljs-keyword">next</span>.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br><span class="hljs-keyword">next</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span><span class="hljs-comment">;</span><br><span class="hljs-built_in">int</span> j = <span class="hljs-number">-1</span> , i = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">while</span>(i &lt; n)<br>&#123;<br><span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || p[i] == p[j])<br>&#123;<br>i++, j++<span class="hljs-comment">;</span><br><span class="hljs-keyword">next</span>[i] = j<span class="hljs-comment">;</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>j = <span class="hljs-keyword">next</span>[j]<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在计算next数组过程中，用i记录遍历过程， j表示最大公共前后缀的长度</p><p>next[i] 表示pattern[0,…,i - 1]的字符串最大公共前后缀长度</p><p>next[i - 1] 表示pattern[0,…,i - 2]的字符串最大公共前后缀长度</p><p>当遍历到pattern[i]时，从next[i]可知，当前pattern[0,…,i - 1]中长度为next[i]的前缀等于其长度为next[i]的后缀，也就是图中黄色区域，</p><p>![image-20240824152610683](C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240824152610683.png</p><p>那么接下来，就看pattern[i]是否与pattern[j]想等，如果相等，那么next[i+1]的最大公共前缀和更新为pattern[0,…,i]，最大公共前缀和长度更新为j+1;</p><p>![image-20240824152516181](C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240824152516181.png</p><p>如果不相等，就需要寻找新的最大公共前后缀位置，而新的公共前后缀必然更小，就比如图中的红色区域</p><p>![image-20240824152940102](C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240824152940102.png</p><p>又因为pattern[0,…,i - 1]的前后缀相同，也就是黄色区域相同，所以新的公共前后缀其实就是原来公共前后缀的公共前后缀，如图中红色区域，代码中体现就是j&#x3D;next[j]</p><p>![image-20240824153408193](C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240824153408193.png</p><p>在得到next数组后，就可以在一次遍历中匹配模式串</p><p>例如，<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">void</span> get_next(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; <span class="hljs-keyword">next</span>, string p)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n = p.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">next</span>.assign(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">next</span>[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = -<span class="hljs-number">1</span> , i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == -<span class="hljs-number">1</span> || p[i] == p[j])<br>            &#123;<br>                i++, j++;<br>                <span class="hljs-keyword">next</span>[i] = j;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                j = <span class="hljs-keyword">next</span>[j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> strStr(string haystack, string needle) &#123;<br>        <span class="hljs-keyword">int</span> m = haystack.<span class="hljs-keyword">size</span>(), n = needle.<span class="hljs-keyword">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">next</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        get_next(<span class="hljs-keyword">next</span>, needle);<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == -<span class="hljs-number">1</span> || haystack[i] == needle[j])<br>            &#123;<br>                i++, j++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                j = <span class="hljs-keyword">next</span>[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j == n)<br>            <span class="hljs-keyword">return</span> i - j;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>综上，Sunday算法适用在较短文本、单词分布均匀的字符串匹配中，而KMP算法更适用在复杂的长文本中，同时KMP有更稳定的性能保持在O(m + n)的时间复杂度</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cs144</title>
    <link href="/2023/09/26/cs144/"/>
    <url>/2023/09/26/cs144/</url>
    
    <content type="html"><![CDATA[<h1 id="LAB0文档"><a href="#LAB0文档" class="headerlink" title="LAB0文档"></a>LAB0<a href="https://cs144.github.io/assignments/check0.pdf">文档</a></h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>选择 VirtualBox + <a href="https://stanford.edu/class/cs144/vm_files/cs144-intel-2023.ova">CS144 Image</a> + Xshell 远程连接 + vscode remote插件远程开发环境</p><p>安装好VirtualBox后，导入下载的实验虚拟电脑.ova文件，以cs144为账号和密码登录至虚拟机，首次登录需要修改密码</p><p>Xshell中建立以localhost为ip，2222为端口号的ssh连接，输入账号密码即可进行连接</p><p>在vscode中安装remote explorer插件，如图打开config配置文件，</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202309262117800.png"></p><p>写上ssh连接信息</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202309262117167.png"></p><p>或者点击加号新建一个ssh连接，并输入命令行</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202309262117837.png"></p><p>还可以在虚拟机中添加本地电脑的ssh公钥，从而实现免密码的登录</p><h2 id="实验Networking-by-hand"><a href="#实验Networking-by-hand" class="headerlink" title="实验Networking  by hand"></a>实验Networking  by hand</h2><h3 id="Fetch-a-Web-page"><a href="#Fetch-a-Web-page" class="headerlink" title="Fetch a Web page"></a>Fetch a Web page</h3><p>访问<a href="http://cs144.keithw.org/hello">网页</a>并获取结果</p><p>依次输入<code>telnet cs144.keithw.org http</code> 表明telnet程序通过http服务访问</p><p><code>GET /hello HTTP/1.1</code> 表明GET方法获取URL下的路径</p><p><code>Host: cs144.keithw/org</code> 表明URL中的主机名</p><p><code>Connection: close</code> 表明在服务器完成响应后关闭连接</p><p>需要在较短时间内完成命令输入，否则会出现408超时</p><h3 id="Send-yourself-an-email"><a href="#Send-yourself-an-email" class="headerlink" title="Send yourself an email"></a>Send yourself an email</h3><p>使用telnet还可以指定让telnet程序通过smtp进行邮件发送</p><h3 id="Listening-and-connecting"><a href="#Listening-and-connecting" class="headerlink" title="Listening and connecting"></a>Listening and connecting</h3><p><code>netcat -v -l -p 9090</code>即可以对端口9090进行监听，开启另一个终端输入<code>telnet localhost 9090</code>对9090端口进行访问，此时可以在两个终端上互相发送消息并立即显示到另一个终端上</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode链表章节</title>
    <link href="/2023/05/17/LeetCode%E9%93%BE%E8%A1%A8%E7%AB%A0%E8%8A%82/"/>
    <url>/2023/05/17/LeetCode%E9%93%BE%E8%A1%A8%E7%AB%A0%E8%8A%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode数组章节</title>
    <link href="/2023/04/24/Leetcode%E6%95%B0%E7%BB%84%E7%AB%A0%E8%8A%82/"/>
    <url>/2023/04/24/Leetcode%E6%95%B0%E7%BB%84%E7%AB%A0%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h1 id="数组章节"><a href="#数组章节" class="headerlink" title="数组章节"></a>数组章节</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找模板题"><a href="#二分查找模板题" class="headerlink" title="二分查找模板题"></a><a href="https://leetcode.cn/problems/binary-search/">二分查找模板题</a></h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> search(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r)<br>        &#123;<br>            <span class="hljs-built_in">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; <span class="hljs-keyword">target</span>)<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; <span class="hljs-keyword">target</span>)<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，变形题可根据不同的判断条件进行判断，如将三种情况重新分成两种等</p><h3 id="lower-bound和upper-bound的实现"><a href="#lower-bound和upper-bound的实现" class="headerlink" title="lower_bound和upper_bound的实现"></a><code>lower_bound</code>和<code>upper_bound</code>的实现</h3><p><code>lower_bound</code>—返回第一个 大于等于 的元素</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> search(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r)<br>        &#123;<br>            <span class="hljs-built_in">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= <span class="hljs-keyword">target</span>)<br>            &#123;<br>                r = mid - <span class="hljs-number">1</span>; // 可能左边还有值等于<span class="hljs-keyword">target</span>的元素<br>                ans = mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>upper_bound</code>—返回第一个 大于 的元素</p><p>类似，第一个 大于 的元素则判断条件中 遇到 小于等于 的元素时执行<code>l = mid + 1</code>， 遇到大于的元素 记录<code>ans</code>的同时<code>r = mid - 1</code>，因为左边可能还有值 大于 的元素</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> search(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r)<br>        &#123;<br>            <span class="hljs-built_in">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= <span class="hljs-keyword">target</span>)<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>            r = mid - <span class="hljs-number">1</span>;<br>            ans =mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="找到值等于target的区间"><a href="#找到值等于target的区间" class="headerlink" title="找到值等于target的区间"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">找到值等于target的区间</a></h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> binary<span class="hljs-constructor">_search(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">target</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = nums.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r)<br>        &#123;<br>            <span class="hljs-built_in">int</span> mid = (l + r)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">mid</span>]</span> &gt;= target)<br>            &#123;<br>                r = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 可能左边还有值等于target的元素</span><br>                ans = mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        return ans;<br>    &#125;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; search<span class="hljs-constructor">Range(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">target</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = nums.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)   return &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-built_in">int</span> st = -<span class="hljs-number">1</span>, en = -<span class="hljs-number">1</span>;<br>        st = binary<span class="hljs-constructor">_search(<span class="hljs-params">nums</span>, <span class="hljs-params">target</span>)</span>;<br>        en = binary<span class="hljs-constructor">_search(<span class="hljs-params">nums</span>, <span class="hljs-params">target</span> + 1)</span>;<br>        <span class="hljs-keyword">if</span>(st<span class="hljs-operator"> == </span>en) <span class="hljs-comment">// 数组中找不到相等的元素</span><br>            return &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(en<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>) <span class="hljs-comment">// 找到相等的元素但没有比target更大的元素</span><br>            return &#123;st, n&#125;;<br>        <span class="hljs-keyword">else</span><br>            return &#123;st, en - <span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>应用 <code>lower_bound</code>的实现（找到第一个 大于等于 的元素），通过寻找区间首元素和尾元素的位置判断，传入不同的target值， 即可实现；但不能用 <code>upper_bound</code>来实现，因为<code>st = binary_search(nums, target - 1), en = binary_search(nums, target)</code>中，想要得知数组中 是否存在与target值相等的元素 与 当en为尾后元素时 冲突，例如<code>[5,7,7], target = 6</code>和<code>[2,2], target = 2</code></p><h3 id="找到第一个-逆序排序-小于等于-的元素"><a href="#找到第一个-逆序排序-小于等于-的元素" class="headerlink" title="找到第一个(逆序排序) 小于等于 的元素"></a>找到第一个(逆序排序) 小于等于 的元素</h3><h3 id="x的平方根"><a href="#x的平方根" class="headerlink" title="x的平方根"></a><a href="https://leetcode.cn/problems/sqrtx/">x的平方根</a></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = x, ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)mid * mid &lt;= x) &#123;<br>                ans = mid;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>(当从小到大排序时)与上述不同，这一题要求的是 小于等于 的元素，则判断条件中当遇到 小于等于 的元素时，记录该元素同时<code>l = mid + 1</code>，因为右边可能还有 小于等于 的元素；而当遇到大于的元素，则直接<code>r = mid - 1</code>不用记录</p><h2 id="双指针——滑动窗口"><a href="#双指针——滑动窗口" class="headerlink" title="双指针——滑动窗口"></a>双指针——滑动窗口</h2><h3 id="移动元素"><a href="#移动元素" class="headerlink" title="移动元素"></a><a href="https://leetcode.cn/problems/remove-element/">移动元素</a></h3><p>使用双指针在O(n)时间复杂度和O(1)空间复杂度下实现</p><p>同向遍历，即快慢指针实现，r指针遍历数组，不断的将r遍历到的不需要删除的元素赋值到l中，同时l++，当r遇到需要删除的元素则跳过，再次遇到不需要删除元素时，覆盖到l上，并逐一将后续需要的元素按顺序覆盖</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-comment">// 同向遍历</span><br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(r; r &lt; nums.size<span class="hljs-literal">()</span>; r++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span> != <span class="hljs-keyword">val</span>) <span class="hljs-comment">// 需要删除的元素</span><br>            &#123;<br>                nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span>;<br>                l++;<br>            &#125;<br>        &#125;<br>        return l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对向遍历，当l指针遇到需要删除的元素时与r指针交换，同时r–，此时，有可能r指针也指向需要删除的元素，因此这一轮中l指针不动，只移动r指针，也就在下一轮中再次判断l指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 对向遍历</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[l] == val) <span class="hljs-comment">// 需要删除的元素</span><br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums[l], nums[r--]);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                l++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方</a></h3><p>首先利用有序性，找到负数与非负数的分界线，从分界线开始向左右两边使用双指针遍历，其中，寻找分界线时可以使用二分法进行加速查找；或者从数组两端开始遍历并比较，最后则需要将数组逆序输出</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 从分界线开始遍历</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; sorted<span class="hljs-constructor">Squares(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.size<span class="hljs-literal">()</span>==<span class="hljs-number">1</span>)<br>            return &#123;nums<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>*nums<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>&#125;;<br>        <span class="hljs-comment">// 先找零 或者最小的正数</span><br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = nums.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> ind = nums.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r)<br>        &#123;<br>            <span class="hljs-built_in">int</span> mid = (l + r)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">mid</span>]</span> &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                ind = mid;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        l = ind - <span class="hljs-number">1</span>, r = ind;<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; res;<br><br>        <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>r &lt; nums.size<span class="hljs-literal">()</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span>*nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> &lt; nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span>*nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span>)<br>            &#123;<br>                res.push<span class="hljs-constructor">_back(<span class="hljs-params">nums</span>[<span class="hljs-params">l</span>]<span class="hljs-operator">*</span><span class="hljs-params">nums</span>[<span class="hljs-params">l</span>])</span>;<br>                l--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res.push<span class="hljs-constructor">_back(<span class="hljs-params">nums</span>[<span class="hljs-params">r</span>]<span class="hljs-operator">*</span><span class="hljs-params">nums</span>[<span class="hljs-params">r</span>])</span>;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            res.push<span class="hljs-constructor">_back(<span class="hljs-params">nums</span>[<span class="hljs-params">l</span>]<span class="hljs-operator">*</span><span class="hljs-params">nums</span>[<span class="hljs-params">l</span>])</span>;<br>            l--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(r &lt; nums.size<span class="hljs-literal">()</span>)<br>        &#123;<br>            res.push<span class="hljs-constructor">_back(<span class="hljs-params">nums</span>[<span class="hljs-params">r</span>]<span class="hljs-operator">*</span><span class="hljs-params">nums</span>[<span class="hljs-params">r</span>])</span>;<br>            r++;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-comment">// 从两端开始遍历</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; sorted<span class="hljs-constructor">Squares(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>)</span> &#123;<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; res;<br>        <span class="hljs-built_in">int</span> n = nums.size<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(abs(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) &gt; nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)<br>            &#123;<br>                res.push<span class="hljs-constructor">_back(<span class="hljs-params">nums</span>[<span class="hljs-params">i</span>] <span class="hljs-operator">*</span> <span class="hljs-params">nums</span>[<span class="hljs-params">i</span>])</span>;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res.push<span class="hljs-constructor">_back(<span class="hljs-params">nums</span>[<span class="hljs-params">j</span>] <span class="hljs-operator">*</span> <span class="hljs-params">nums</span>[<span class="hljs-params">j</span>])</span>;<br>                j--;<br>            &#125;<br>        &#125;<br>        res.push<span class="hljs-constructor">_back(<span class="hljs-params">nums</span>[<span class="hljs-params">i</span>]<span class="hljs-operator">*</span><span class="hljs-params">nums</span>[<span class="hljs-params">i</span>])</span>;<br>        reverse(res.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, res.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h4><p>通常，在使用快慢指针时，用快指针遍历数组并判断是否符合条件，而不是用慢指针，因此是判断<code>if(nums[r] != val)</code>而不是<code>if(val == nums[l]</code>，否则会miss掉一些值</p><h3 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; r &lt; nums.<span class="hljs-built_in">size</span>(); r++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[r] &gt; nums[r - <span class="hljs-number">1</span>])<br>                nums[l++] = nums[r];<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="删除有序数组中的重复项-II"><a href="#删除有序数组中的重复项-II" class="headerlink" title="删除有序数组中的重复项 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">删除有序数组中的重复项 II</a></h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> removeDuplicates(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        for(<span class="hljs-built_in">int</span> r = <span class="hljs-number">2</span>; r &lt; nums.<span class="hljs-built_in">size</span>(); r++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[r] <span class="hljs-comment">!= nums[l - 2])</span><br>                nums[l++] = nums[r];<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="总结2"><a href="#总结2" class="headerlink" title="总结2"></a>总结2</h4><p>都使用快慢指针，但当允许有两个重复值时，应该比较的是 <strong>快指针和慢指针-2</strong>，<strong>而不是 快指针和快指针-2</strong>，因为快慢指针都被初始化为2，当相等时，则快指针（&#x3D;慢指针）当前值多余，快指针继续遍历；遍历至当快指针遇到与慢指针-2不相等时，则可以将快指针的值赋值到慢指针，此时慢指针 &#x3D; 慢指针 - 1 &#x3D; 慢指针 - 2，需要删除的是慢指针而不是快指针。</p><p>同理，I中也可以将判断条件改为<code>if(nums[r] != nums[l - 1])</code>，也可以延伸到重复项数量为k</p><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title=" 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/"> 长度最小的子数组</a></h3><p>右指针遍历整个数组，并不断扩大窗口，直至满足条件后，while循环中不断缩小窗口并更新结果，维持动态窗口满足条件</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> minSubArrayLen(<span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        long long <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> res = nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>        for(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++)<br>        &#123;<br>            <span class="hljs-built_in">sum</span> += nums[j];<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">sum</span> &gt;= <span class="hljs-keyword">target</span>)<br>            &#123;<br>                res = <span class="hljs-built_in">min</span>(res, j - i + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">sum</span> -= nums[i];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title=" 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/"> 最小覆盖子串</a></h3><p>同样地，右指针遍历整个数组，而左指针不断缩小窗口，同时更新结果。此外，需要用哈希表记录窗口的访问记录并判断是否符合条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; store, vis;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; it : store)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((vis.<span class="hljs-built_in">find</span>(it.first) == vis.<span class="hljs-built_in">end</span>()) || (vis.<span class="hljs-built_in">find</span>(it.first) != vis.<span class="hljs-built_in">end</span>() &amp;&amp; vis[it.first] &lt; it.second))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : t)<br>        &#123;<br>            store[c]++;<br>        &#125;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ind = i;<br>        <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            vis[s[j]]++;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>()) <span class="hljs-comment">// 已覆盖t字符串，则尝试缩小左边范围</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(res &gt; j - i + <span class="hljs-number">1</span>)<br>                &#123;<br>                    res = j - i + <span class="hljs-number">1</span>;<br>                    ind = i;<br>                &#125;<br>                vis[s[i++]]--;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(ind, res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">水果成篮</a></h3><p>同样，右指针遍历数组，并扩大窗口，在不满足条件后，左指针不断缩小窗口，直至满足条件后更新结果。另外，还需要用哈希表来判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; vis;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; fruits.<span class="hljs-built_in">size</span>(); j++)<br>        &#123;<br>            vis[fruits[j]]++;<br>            <span class="hljs-keyword">while</span>(vis.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>)<br>            &#123;<br>                vis[fruits[i]]--;<br>                <span class="hljs-keyword">if</span>(vis[fruits[i]] == <span class="hljs-number">0</span>)<br>                    vis.<span class="hljs-built_in">erase</span>(fruits[i]);<br>                i++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, j - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h3><p>同样地思路，右指针不断扩大窗口，为了在扩大的时候不重复包含已有的元素，在添加元素到窗口之前把窗口中已有的对应元素删除掉，即左指针缩小窗口的过程，然后再更新结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span> , i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; store;<br>        <span class="hljs-keyword">for</span>(j; j &lt; s.<span class="hljs-built_in">size</span>(); j++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(store.<span class="hljs-built_in">find</span>(s[j]) != store.<span class="hljs-built_in">end</span>())<span class="hljs-comment">// 如果出现重复则先删除</span><br>            &#123;<br>                store.<span class="hljs-built_in">erase</span>(s[i++]);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(store.<span class="hljs-built_in">find</span>(s[j]) == store.<span class="hljs-built_in">end</span>()) <span class="hljs-comment">// 没有重复则加入</span><br>                store.<span class="hljs-built_in">insert</span>(s[j]);<br>            res = <span class="hljs-built_in">max</span>(res, j - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="总结3"><a href="#总结3" class="headerlink" title="总结3"></a>总结3</h4><p><u>水果成篮和无重复字符的最长子串所求的是<strong>最大窗口长度</strong></u>，<u>而长度最小的子数组和最小覆盖子串求的是<strong>最小窗口长度</strong></u>，因此同样的遍历循环下，要在不同位置对结果进行更新，即求最大窗口长度时要在<strong>左指针</strong>遍历结束后更新，求最小窗口长度则是在<strong>右指针</strong>遍历过程中更新</p><h2 id="双指针——固定窗口"><a href="#双指针——固定窗口" class="headerlink" title="双指针——固定窗口"></a>双指针——固定窗口</h2><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title=" 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/"> 螺旋矩阵</a></h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; spiral<span class="hljs-constructor">Order(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&gt;&amp; <span class="hljs-params">matrix</span>)</span> &#123;<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; res;<br>        <span class="hljs-built_in">int</span> m = matrix.size<span class="hljs-literal">()</span>, n = matrix<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.size<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> up = <span class="hljs-number">0</span>, down = m-<span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = n-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (up &lt;= down<span class="hljs-operator"> &amp;&amp; </span>left &lt;= right)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = left; j &lt;= right; j++)<br>            &#123;<br>                res.push<span class="hljs-constructor">_back(<span class="hljs-params">matrix</span>[<span class="hljs-params">up</span>][<span class="hljs-params">j</span>])</span>;<br>            &#125;<br>            up++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = up; i &lt;= down; i++)<br>            &#123;<br>                res.push<span class="hljs-constructor">_back(<span class="hljs-params">matrix</span>[<span class="hljs-params">i</span>][<span class="hljs-params">right</span>])</span>;<br>            &#125;<br>            right--;<br>            <span class="hljs-keyword">if</span>(up &gt; down<span class="hljs-operator"> || </span>left &gt; right)<br>                break;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = right; j &gt;= left; j--)<br>            &#123;<br>                res.push<span class="hljs-constructor">_back(<span class="hljs-params">matrix</span>[<span class="hljs-params">down</span>][<span class="hljs-params">j</span>])</span>;<br>            &#125;<br>            down--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = down; i &gt;= up; i--)<br>            &#123;<br>                res.push<span class="hljs-constructor">_back(<span class="hljs-params">matrix</span>[<span class="hljs-params">i</span>][<span class="hljs-params">left</span>])</span>;<br>            &#125;<br>            left++;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵 II</a></h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; generateMatrix(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>        <span class="hljs-built_in">int</span> cnt = <span class="hljs-built_in">n</span> * <span class="hljs-built_in">n</span>;<br>        <span class="hljs-built_in">int</span> tmp = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> up = <span class="hljs-number">0</span>, down = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>, <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; res(<span class="hljs-built_in">n</span>, vector&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-built_in">n</span>));<br>        while (tmp &lt;= cnt)<br>        &#123;<br>            for (<span class="hljs-built_in">int</span> j = <span class="hljs-built_in">left</span>; j &lt;= <span class="hljs-built_in">right</span>; j++)<br>            &#123;<br>                res[up][j] = tmp++;<br>            &#125;<br>            up++;<br>            for (<span class="hljs-built_in">int</span> i = up; i &lt;= down; i++)<br>            &#123;<br>                res[i][<span class="hljs-built_in">right</span>] = tmp++;<br>            &#125;<br>            <span class="hljs-built_in">right</span>--;<br>            <span class="hljs-built_in">if</span> (tmp &gt; cnt)<br>                break;<br>            for (<span class="hljs-built_in">int</span> j = <span class="hljs-built_in">right</span>; j &gt;= <span class="hljs-built_in">left</span>; j--)<br>            &#123;<br>                res[down][j] = tmp++;<br>            &#125;<br>            down--;<br>            for (<span class="hljs-built_in">int</span> i = down; i &gt;= up; i--)<br>            &#123;<br>                res[i][<span class="hljs-built_in">left</span>] = tmp++;<br>            &#125;<br>            <span class="hljs-built_in">left</span>++;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/04/24/create_blog/"/>
    <url>/2023/04/24/create_blog/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo-github部署个人博客"><a href="#hexo-github部署个人博客" class="headerlink" title="hexo+github部署个人博客"></a>hexo+github部署个人博客</h1><h2 id="环境与软件需求"><a href="#环境与软件需求" class="headerlink" title="环境与软件需求"></a>环境与软件需求</h2><ul><li>win10</li><li>git<br><em><strong>本教程需要先安装好git</strong></em><br><em><strong>本教程需要先安装好git</strong></em><br><em><strong>本教程需要先安装好git</strong></em></li></ul><ol><li><p>在<a href="http://nodejs.org/">node.js官网</a>下载对应版本</p><p><img src="/create_blog/node_js.png" alt="nodejs"></p></li><li><p>安装完成后打开Git Bash.exe，输入<code>node -v</code>可查看node.js安装版本，输入<code>npm -v</code>可查看npm安装版本</p><p><img src="/create_blog/-v.png" alt="查看版本"></p></li><li><p>利用npm安装cnpm，同时使用镜像源</p><p><code>npm install -g cnpm --registry=https://registry.nmp.taobao.org</code></p></li><li><p>同样地，可以输入<code>cnpm</code>查看cnpm版本</p></li><li><p>这时，就可利用cnpm安装hexo，输入<code>cnpm install -g hexo-cli</code></p><p><img src="/create_blog/hexo.png" alt="hexo"></p></li><li><p>至此，创建博客前序步骤全部完成，在bash中指定一个路径，输入<code>mkdir </code>+文件夹名称，如blog，作为博客的根目录，进入该目录路径（有关博客操作都要在博客的根目录下进行），输入<code>hexo init</code>即完成博客的初始化。此时，输入<code>hexo s</code>即可通过<a href="localhost:4000">localhost:4000</a>对博客进行访问</p></li><li><p>在github中新建一个仓库待用，仓库名字通常为github名.github.io</p></li><li><p>安装git部署插件，输入<code>npm install hexo-deployer-git --save</code>，每次新建一个blog都要安装一次插件</p></li><li><p>更改配置文件（很多时候都会用到配置文件），输入<code>vim _config.yml</code>，先输入<code>i</code>使改为<code>insert</code>模式，找到<code>Deployment</code>进行配置修改，修改成如下</p><p><img src="/create_blog/deployment.png" alt="deployment"></p><p>即修改<code>type</code>属性为<code>git</code>，在<code>repo</code>下输入在github新建仓库的地址，并加上<code>branch:master</code>指定分支为master，然后即可退出vim，按下esc再按两次大写Z</p></li><li><p>此时即可对博客进行在github上的部署，在输入<code>hexo d</code>之前需要先输入<code>git config --global user.email &quot;18khhuang2@stu.edu.cn&quot;</code>和<code>git config --global user.name &quot;kevin346-sc&quot;</code>进行认证，否则将会无法进行远端部署</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/24/hello-world/"/>
    <url>/2023/04/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>collection</title>
    <link href="/2023/04/19/collection/"/>
    <url>/2023/04/19/collection/</url>
    
    <content type="html"><![CDATA[<p>1. </p>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PriceInfo</span> &#123; <span class="hljs-type">double</span> price; &#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt; data &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; ++i)<br>    &#123;<br>        <span class="hljs-comment">// Search first element that is greater than i</span><br>        <span class="hljs-keyword">auto</span> upper = std::<span class="hljs-built_in">upper_bound</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), i);<br> <br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &lt; &quot;</span>;<br>        upper != data.<span class="hljs-built_in">end</span>()<br>            ? std::cout &lt;&lt; *upper &lt;&lt; <span class="hljs-string">&quot; at index &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(data.<span class="hljs-built_in">begin</span>(), upper)<br>            : std::cout &lt;&lt; <span class="hljs-string">&quot;not found&quot;</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br> <br>    std::vector&lt;PriceInfo&gt; prices &#123;&#123;<span class="hljs-number">100.0</span>&#125;, &#123;<span class="hljs-number">101.5</span>&#125;, &#123;<span class="hljs-number">102.5</span>&#125;, &#123;<span class="hljs-number">102.5</span>&#125;, &#123;<span class="hljs-number">107.3</span>&#125;&#125;;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> to_find : &#123;<span class="hljs-number">102.5</span>, <span class="hljs-number">110.2</span>&#125;)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> prc_info = std::<span class="hljs-built_in">lower_bound</span>(prices.<span class="hljs-built_in">begin</span>(), prices.<span class="hljs-built_in">end</span>(), to_find,<br>            [](<span class="hljs-type">double</span> va,<span class="hljs-type">const</span> PriceInfo&amp; info)<br>            <span class="hljs-comment">// no known conversion for argument 1 from &#x27;PriceInfo&#x27; to &#x27;double&#x27;</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> va &gt; info.price;<br>            &#125;);<br> <br>        prc_info != prices.<span class="hljs-built_in">end</span>()<br>            ? std::cout &lt;&lt; prc_info-&gt;price &lt;&lt; <span class="hljs-string">&quot; at index &quot;</span> &lt;&lt; prc_info - prices.<span class="hljs-built_in">begin</span>()<br>            : std::cout &lt;&lt; to_find &lt;&lt; <span class="hljs-string">&quot; not found&quot;</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">需要将lambda函数 捕获列表中参数位置互换</code></pre>   <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">auto prc_info = std::lower_bound(prices.<span class="hljs-keyword">begin</span>(), prices.<span class="hljs-keyword">end</span>(), to_find,<br>            [](const PriceInfo&amp; <span class="hljs-keyword">info</span>, <span class="hljs-type">double</span> va)<br>            &#123;<br>                <span class="hljs-keyword">return</span> va &gt; <span class="hljs-keyword">info</span>.price;<br>            &#125;);<br></code></pre></td></tr></table></figure><p>2. </p>   <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 修改时间<br>   char* t = ctime(&amp;st.st_mtime); <span class="hljs-regexp">//</span> 这个字符串包含最后的换行符<br>   <span class="hljs-regexp">//</span> printf(<span class="hljs-string">&quot;%s\n&quot;</span>, t);<br>   <br>   char* tt;<br>   strncpy(tt, t, strlen(t) - <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> 发生段错误<br>   <br>   char tt[<span class="hljs-number">1024</span>];<br>   <span class="hljs-regexp">//</span> strncpy(tt, t, sizeof(t) - <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> Tue May<br>   strncpy(tt, t, strlen(t) - <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> Tue May  <span class="hljs-number">2</span> <span class="hljs-number">10</span>:<span class="hljs-number">15</span>:<span class="hljs-number">54</span> <span class="hljs-number">2023</span><br>   printf(<span class="hljs-string">&quot;%s\n&quot;</span>, tt);<br>   <br></code></pre></td></tr></table></figure><pre><code class="hljs">`dest`不能用`char*`的`tt`，只能用`char tt[1024]`；</code></pre><p>   <code>sizeof</code>只有前半段字符串，<code>strlen</code>才能全部复制</p><p>   并且<code>char tt[1024]</code>会改变前面变量<code>quanxian</code>的值，在后面加上了<code>tt</code>，而修改成更大的值则正常</p><p>3. </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2023/04/11/Nginx/"/>
    <url>/2023/04/11/Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="在Ubuntu18中使用Nginx"><a href="#在Ubuntu18中使用Nginx" class="headerlink" title="在Ubuntu18中使用Nginx"></a>在Ubuntu18中使用Nginx</h1><p>准备Nginx所需的库</p><ol><li><p>GCC编译器</p><p>Nginx不直接提供二进制可执行程序</p></li><li><p>PCRE库</p><p><code>sudo apt-get install libpcre3-dev</code></p><p>安装完成后用 <code>pcre-config --version</code>查看是否安装成功</p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927013.png" style="zoom: 50%;" /></li><li><p>zlib库</p><p><code>zlib</code>库主要用于对HTTP包的内容进行压缩，进而减少网络传输量</p><p><code>sudo apt install zlib1g</code></p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927790.png" style="zoom: 80%;" /><p><code>zlib</code>是直接使用的库，<code>zlib-devel</code>是二次开发所需要的库</p><p><code>sudo apt install zlib1g-dev</code></p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927372.png" style="zoom: 80%;" /></li><li><p>OpenSSL开发库</p><p>通过OpenSSL库，可以使用SSL协议传输HTTP，另外，使用MD5、SHA1等散列函数也需要该库</p><p>在Ubuntu系统中，<code>openssl-devel</code>库需要分开来安装</p><p><code>sudo apt-get install openssl</code></p><p><code>sudo apt-get install libssl-dev</code></p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927704.png" style="zoom: 50%;" /></li></ol><h1 id="在centos-7-中使用Nginx"><a href="#在centos-7-中使用Nginx" class="headerlink" title="在centos 7 中使用Nginx"></a>在centos 7 中使用Nginx</h1><h2 id="安装所需要的库"><a href="#安装所需要的库" class="headerlink" title="安装所需要的库"></a>安装所需要的库</h2><ol><li><p>gcc 和 g++</p><p><code>yum installl -y gcc</code></p><p><img src="D:\hexo_blog\source_posts\Nginx\gcc_c.png"></p><p><code>yum install -y gcc-c++</code></p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010926366.png"></p></li><li><p>pcre</p><p><code>yum install -y pcre pcre-devel</code></p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927886.png" style="zoom: 50%;" /></li><li><p>zlib</p><p><code>yum install -y zlib zlib-devel</code></p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927713.png" style="zoom: 50%;" /></li><li><p>openssl</p><p><code>yum install -y openssl openssl-devel</code></p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010925548.png"></p></li></ol><h2 id="让centos7实现联网"><a href="#让centos7实现联网" class="headerlink" title="让centos7实现联网"></a>让centos7实现联网</h2><p>默认情况下是不联网，而我们通常需要赋予静态IP让虚拟机联网</p><p>centos 系统默认没有<code>ifconfig</code>命令，需要先下载<code>yum install -y  net-tools.x86_64</code>或者使用<code>ip addr</code>命令，关注<code>ens33</code></p><ol><li><p>修改ens33的配置文件</p><p><code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010925247.png"></p><p>将<code>BOOTPROTO</code>由原来的dhcp改为static，表明使用静态IP地址，将<code>ONBOOT</code>由原来的no改为yes，启动网络连接，再给出IP地址、子网掩码、网关和DNS服务器。以上DNS服务器是免费的</p></li><li><p>重启网络服务</p><p><code>systemctl restart network</code></p></li><li><p>输入<code>ip addr</code>命令可以看到网络配置完成，可以通过<code>ping www.baidu.com</code>进行测试，完成联网</p></li></ol><h2 id="编译Nginx源码"><a href="#编译Nginx源码" class="headerlink" title="编译Nginx源码"></a>编译Nginx源码</h2><p>上一步中联网的目的是获取虚拟机的IP地址，通过xshell以及xftp连接进行Nginx源码的传输</p><p>准备好以下的目录</p><ol><li>Nginx源码的存放目录，存放Nginx源码文件，非官方的模块源代码文件</li><li>编译阶段产生的中间文件存放目录，默认情况下编译过程中自动生成objs目录，存放在源码目录下</li><li>部署目录，存放实际Nginx运行所需要的二进制文件、配置文件，默认情况下为 <code>/usr/local/nginx</code></li><li>日志文件存放目录</li></ol><p>默认情况下，linux内核参数考虑最通用的场景，不符合用于高并发访问的web服务器的定义，所以通过修改内核参数，使得Nginx拥有更高性能</p><p>修改<code>/etc/sysctl.conf</code>来更改内核参数</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">fs .file-max</span> = <span class="hljs-number">999999</span><br><span class="hljs-attr">net.ipv4.tcp_tw_reuse</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">net.ipv4.tcp_keepalive_time</span> = <span class="hljs-number">600</span><br><span class="hljs-attr">net.ipv4.tcp_fin_timeout</span> = <span class="hljs-number">30</span><br><span class="hljs-attr">net.ipv4.tcp_max_tw_buckets</span> = <span class="hljs-number">5000</span><br><span class="hljs-attr">net.ipv4.ip_local_port_range</span> = <span class="hljs-number">1024</span><span class="hljs-number">61000</span><br><span class="hljs-attr">net.ipv4.tcp_rmem</span> = <span class="hljs-number">4096</span> <span class="hljs-number">32768</span> <span class="hljs-number">262142</span><br><span class="hljs-attr">net.ipv4.tcp_wmem</span> = <span class="hljs-number">4096</span> <span class="hljs-number">32768</span> <span class="hljs-number">262142</span><br><span class="hljs-attr">net.core.netdev_max_backlog</span> = <span class="hljs-number">8096</span><br><span class="hljs-attr">net.core.rmem_default</span> = <span class="hljs-number">262144</span><br><span class="hljs-attr">net.core.wmem_default</span> = <span class="hljs-number">262144</span><br><span class="hljs-attr">net.core.rmem_max</span> = <span class="hljs-number">2097152</span><br><span class="hljs-attr">net.core.wmem_max</span> = <span class="hljs-number">2097152</span><br><span class="hljs-attr">net.ipv4.tcp_syncookies</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">net.ipv4.tcp_max_syn.backlog</span>=<span class="hljs-number">1024</span><br></code></pre></td></tr></table></figure><p>然后执行<code>sysctl -p</code>命令，使上述修改生效</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">file-max: 这个参数表示进程 (比如一个 worker 进程) 可以同时打开的最大句柄数这个参数直接限制最大并发连接数，需根据实际情况配置。</span><br><span class="hljs-section">tcp_tw_reuse: 这个参数设置为 1，表示允许将 TIME-WAIT 状态的 socket 重新用于新的 TCP 连接，这对于服务器来说很有意义，因为服务器上总会有大量 TIME-WAIT 状态的连接</span><br><span class="hljs-section">tcp_keepalive_time: 这个参数表示当 keepalive 启用时，TCP 发送 keepalive 消息的频度。默认是 2 小时，若将其设置得小一些，可以更快地清理无效的连接。</span><br><span class="hljs-section">tcp_fin_timeout:这个参数表示当服务器主动关闭连接时，socket 保持在 FIN-WAIT-2状态的最大时间。</span><br><span class="hljs-section">tcp_max_tw_buckets: 这个参数表示操作系统允许 TIME WAIT 套接字数量的最大值如果超过这个数字，TIME WAIT 套接字将立刻被清除并打印警告信息。该参数默认为 180 000，过多的 TIME WAIT 套接字会使 Web 服务器变慢。</span><br><span class="hljs-section">tcp_max_syn_backlog: 这个参数表示 TCP 三次握手建立阶段接收 SYN 请求队列的最大长度，默认为 1024，将其设置得大一些可以使出现 Nginx 繁忙来不及 accept 新连接的情况时，Linux 不至于丢失客户端发起的连接请求。</span><br><span class="hljs-section">ip_local_port_range:这个参数定义了在 UDP 和TCP 连接中本地 (不括连接的远端)端口的取值范围。</span><br>net.ipv4.tcp_rmem : 这个参数定义了 TCP 接收缓存 (用于 TCP 接收滑动窗口)的最小值、默认值、最大值。<br><span class="hljs-section">net.ipv4.tcp_wmem: 这个参数定义了 TCP 发送缓存 (用于 TCP 发送滑动窗口)的最小值、默认值、最大值。</span><br><span class="hljs-section">netdev_max_backlog: 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。这个参数表示该队列的最大值。</span><br><span class="hljs-section">rmem_default: 这个参数表示内核套接字接收缓存区默认的大小。</span><br><span class="hljs-section">wmem_default: 这个参数表示内核套接字发送缓存区默认的大小</span><br><span class="hljs-section">rmem_max: 这个参数表示内核套接字接收缓存区的最大大小。</span><br><span class="hljs-section">wmem_max: 这个参数表示内核套接字发送缓存区的最大大小。</span><br>tcp_syncookies：该参数与性能无关，用于解决 TCP 的 SYN 攻击<br></code></pre></td></tr></table></figure><p>进入到Nginx源码目录，执行以下3行命令：</p><p><code>./configure</code>——检测操作系统内核和已经安装的软件，参数的解析，中间目录的生成以及根据各种参数生成一些 C 源码文件、Makefile 文件等</p><p><code>make</code>——根据 configure 命令生成的 Makefile 文件编译Nginx 工程，并生成目标文件最终的二进制文件</p><p><code>make install</code>——根据configure 执行时的参数将Nginx 部署到指定的安装目录，包括相关目录的建立和二进制文件、配置文件的复制</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webserver</title>
    <link href="/2023/03/12/webserver/"/>
    <url>/2023/03/12/webserver/</url>
    
    <content type="html"><![CDATA[<h1 id="webserver高性能服务器"><a href="#webserver高性能服务器" class="headerlink" title="webserver高性能服务器"></a>webserver高性能服务器</h1><p>系统：Linux</p><p>发行版：Ubuntu18</p><p>涉及知识点：</p><p>软件：VMware Station、Visual Studio Code、Xshell、Xftp</p><p>linux发行版中，有两个主流，CentOs和Ubuntu，分别是基于红帽企业和Debian，Ubuntu需要经常更新，用到.deb和apt软件包；而CentOS不常更新，使用.rpm和flatpak软件包。这说明了CentOS会更稳定。在此项目中，因为Ubuntu有一个庞大的社区，有更多的文档和免费的问题信息支持，并且Ubuntu上手更为简单，因此选择的发行版为Ubuntu18</p><h1 id="0、搭建linux虚拟机开发环境"><a href="#0、搭建linux虚拟机开发环境" class="headerlink" title="0、搭建linux虚拟机开发环境"></a>0、搭建linux虚拟机开发环境</h1><h2 id="Ubuntu-18安装"><a href="#Ubuntu-18安装" class="headerlink" title="Ubuntu 18安装"></a>Ubuntu 18安装</h2><p>下载Ubuntu18光驱，在VMware Station中创建Ubuntu 64位虚拟机并导入光驱进行安装，推荐安装VMware Tools，能够自适应虚拟机屏幕大小和实现在主机拖拽文件到虚拟机中等功能。</p><p>终端安装ssh，输入<code>sudo apt install openssh-server</code></p><p>[报错]暂时不能解析域名“sercurity.ubuntu.com”——这是因为虚拟机没有连上网，可以打开虚拟机设置选择桥接模式，并勾上复制物理网络连接状态（复习桥接模式和NAT）<img src="C:\myblog\source\_posts\webserver\ubuntu_net.png" style="zoom:60%;" /></p><p>为连接虚拟机，需要获取虚拟机的IP地址，在终端输入<code>sudo apt install net-tools</code>安装<code>net-tools</code>后即可通过<code>ifconfig</code>命令获取IP地址</p><p>[报错]没有可安装的候选——执行<code>sudo apt install net-tools</code>之后再次安装即可</p><h2 id="用xshell连接虚拟机"><a href="#用xshell连接虚拟机" class="headerlink" title="用xshell连接虚拟机"></a>用xshell连接虚拟机</h2><p>复制虚拟机的IP地址，在xshell中新建会话，填写会话名称和主机号（虚拟机IP地址），协议选择ssh，其余默认即可</p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003845.png" style="zoom:60%;" /><p>输入用户名，密码就可以连接上</p><h2 id="在vscode中连接虚拟机"><a href="#在vscode中连接虚拟机" class="headerlink" title="在vscode中连接虚拟机"></a>在vscode中连接虚拟机</h2><p>在扩展中下载remote development，可以看到左侧栏多出的“远程资源管理器”图标，进入远程资源管理器，选择ssh并打开ssh配置文件，填写正确参数</p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302001098.png" style="zoom: 80%;" /><p>之后，能看到左侧ssh栏下有对应的主机连接信息，选择再新窗口中打开，输入密码就能在vscode实现对虚拟机的操作</p><h1 id="1、linux-系统编程入门"><a href="#1、linux-系统编程入门" class="headerlink" title="1、linux 系统编程入门"></a>1、linux 系统编程入门</h1><h2 id="静态库创建和使用"><a href="#静态库创建和使用" class="headerlink" title="静态库创建和使用"></a>静态库创建和使用</h2><ol><li><code>gcc -c *.c</code>编译生成<code>.o</code>类型文件</li><li><code>ar rcs libxxx.a *.o</code>利用ar工具将<code>.o</code>文件生成名为xxx的静态库，其中，<code>lib</code>和<code>.a</code>为固定命名</li></ol><p>编译<code>main.c</code>文件时，需要包含函数声明的头文件，以及函数定义的静态库文件 </p><p>文件结构如下时，</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003238.png"></p><p><code>gcc -o app main.c -I ./include -l calc -L ./lib</code>生成 可执行文件<code>app</code></p><h2 id="动态库创建和使用"><a href="#动态库创建和使用" class="headerlink" title="动态库创建和使用"></a>动态库创建和使用</h2><ol><li><code>gcc -fpic -c *.c </code>编译生成与位置无关的<code>.o</code>文件</li><li><code>gcc -shared *.o -o libxxx.so</code>生成名为xxx的动态库，其中，<code>lib</code>和<code>.so</code>为固定命名</li></ol><p>在dynamic文件夹下生成动态库文件如下：</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003732.png"></p><p>在使用动态库时，如果直接像静态库那样使用，则在运行生成的可执行文件<code>app</code>时会报错</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003380.png"></p><p>使用<code>ldd(list dynamic dependencies)</code>命令查看动态库的依赖关系</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003737.png"></p><p>可以看到，最终生成的可执行文件不能运行的原因在于其对应的动态库<code>libcalc.so</code>缺失</p><p>而文件在定位共享库时，对应ELF格式的可执行程序，先后搜索 DT_RPATH段 -&gt; 环境变量LD_LIBRARY_PATH -&gt; &#x2F;etc&#x2F;ld.so.cache 文件列表 -&gt; &#x2F;lib&#x2F;, &#x2F;usr&#x2F;lib 目录找到库文件后将其载入内存</p><p>因此，第一种方法可以在环境变量LD_LIBRARY_PATH中加入动态库路径</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004567.png"></p><p><strong>但环境变量在每次关闭终端后都会恢复到打开终端之前</strong></p><p>第二种方法则可以在用户级别下配置文件 <code>~/.bashrc</code> 中保存该环境变量</p><p><code>vim .bashrc</code>敲入<code>shift+g</code>移动到最后一行，敲入<code>o</code>在下一行中插入编辑</p><p>输入相同的<code>export</code>语句，保存并退出，<code>. .bashrc</code>或<code>source .bashrc</code>重新运行配置文件使其生效</p><p>第三种方法在系统级别下配置文件 <code>/etc/profile</code> 中加入同样的<code>export</code>语句</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004159.png"></p><p>以上是通过环境变量来找到路径</p><p>另外，还可以修改<code>/etc/ld.so.cache </code>文件，<code>sudo vim /etc/ld.so.conf</code>在文件中加入路径，间接修改<code>.cache</code>文件，保存退出，<code>sudo ldconfig</code>进行更新</p><p>最后，不推荐将动态库文件放到 <code>/lib/</code>,<code>/usr/lib/</code>目录中，因为这两个目录下有很多文件，可能会有重复命名问题</p><h2 id="静态库vs动态库"><a href="#静态库vs动态库" class="headerlink" title="静态库vs动态库"></a>静态库vs动态库</h2><p>静态库</p><ul><li>加载速度快</li><li>程序发布不需要提供静态库，移植方便</li><li>但浪费内存</li><li>不利于更新部署</li></ul><p>动态库</p><ul><li>实现进程间资源共享</li><li>更新部署简单</li><li>何时加载可控</li><li>但加载速度慢</li><li>程序发布需要提供动态库</li></ul><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>目标 ： 依赖</p><p>​(tab)命令</p><p>其他规则通常为第一条规则服务</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">app : sub<span class="hljs-selector-class">.c</span> add<span class="hljs-selector-class">.c</span> mult<span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>gcc sub<span class="hljs-selector-class">.c</span> add<span class="hljs-selector-class">.c</span> mult<span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o app<br></code></pre></td></tr></table></figure><p>依赖存在，则执行命令；否则向下检查其他规则，寻找生成依赖的命令</p><p>依赖生成时间比目标晚，则需要执行命令对目标进行更新</p><p>变量定义：变量名&#x3D;变量值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">AR : 归档维护程序的名称，默认值为 ar<br>CC : C 编译器的名称，默认值为 cc<br>CXX : C++ 编译器的名称，默认值为 g++<br>$@ : 目标的完整名称<br>$&lt; : 第一个依赖文件的名称<br>$^ : 所有的依赖文件<br><br>%.o : %.c 匹配同一个字符串<br><br><span class="hljs-constructor">$(<span class="hljs-params">wildcard</span> .<span class="hljs-operator">/</span><span class="hljs-operator">*</span>.<span class="hljs-params">c</span> .<span class="hljs-operator">/</span>PATH<span class="hljs-operator">/</span><span class="hljs-operator">*</span>.<span class="hljs-params">c</span>)</span><br>返回 a.c b.c c.c<br>src=<span class="hljs-constructor">$(<span class="hljs-params">wildcard</span> .<span class="hljs-operator">/</span><span class="hljs-operator">*</span>.<span class="hljs-params">c</span>)</span><br><br><span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> %.<span class="hljs-params">c</span> %.<span class="hljs-params">o</span> <span class="hljs-params">a</span>.<span class="hljs-params">c</span> <span class="hljs-params">b</span>.<span class="hljs-params">c</span>)</span><br>返回替换a.c, b.c 后的字符串 a.o, b.o<br>objs=<span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> %.<span class="hljs-params">c</span>, %.<span class="hljs-params">o</span>, $(<span class="hljs-params">src</span>)</span>)<br><br>.PHONY:clean<br>clean:<br>rm <span class="hljs-constructor">$(<span class="hljs-params">objs</span>)</span> -f<br></code></pre></td></tr></table></figure><h2 id="GDB调试工具"><a href="#GDB调试工具" class="headerlink" title="GDB调试工具"></a>GDB调试工具</h2><p>gcc -g -Wall a.c -o test</p><p>-g作用是在可执行文件中加入源代码信息，-wall打开所有warning</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs gams">list/l (行号)<br>list/l (文件名:函数名)<br>show list<br><span class="hljs-keyword">set</span> list <span class="hljs-comment">(</span>要显示的行数大小<span class="hljs-comment">)</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">args (</span>给程序输入的参数<span class="hljs-comment">1) (</span>给程序输入的参数<span class="hljs-comment">2)</span><br>show <span class="hljs-comment">args</span><br>b <span class="hljs-comment">(</span>行号<span class="hljs-comment">)</span><br>b <span class="hljs-comment">(</span>文件名<span class="hljs-comment">:</span>函数名<span class="hljs-comment">)</span><br>b <span class="hljs-comment">(</span>行号<span class="hljs-comment">) if (</span>条件<span class="hljs-comment">)</span><br>i <span class="hljs-comment">b</span><br>d <span class="hljs-comment">(</span>断点编号<span class="hljs-comment">)</span><br>dis <span class="hljs-comment">(</span>断点编号<span class="hljs-comment">)</span><br>ena <span class="hljs-comment">(</span>断点编号<span class="hljs-comment">)</span><br>run  ——遇到断点才停<br>start ——停在第一行<br>c ——到下一个断点<br>n ——下一行<span class="hljs-comment">(</span>不进入函数体<span class="hljs-comment">)</span><br>s ——下一步<span class="hljs-comment">(</span>进入函数体<span class="hljs-comment">)</span><br>finish ——调出函数体<br>p <span class="hljs-comment">(</span>变量名<span class="hljs-comment">)</span> ——打印变量值<br>ptype <span class="hljs-comment">(</span>变量名<span class="hljs-comment">)</span> ——打印变量类型<br>display <span class="hljs-comment">(</span>变量名<span class="hljs-comment">)</span> ——自动打印变量名<br>undisplay(变量名) ——取消自动打印<br>i <span class="hljs-comment">display</span> ——显示自动打印信息<br><span class="hljs-keyword">set</span> <span class="hljs-comment">var (</span>变量名<span class="hljs-comment">)=(</span>变量值<span class="hljs-comment">)</span><br></code></pre></td></tr></table></figure><h2 id="文件I-x2F-O函数"><a href="#文件I-x2F-O函数" class="headerlink" title="文件I&#x2F;O函数"></a>文件I&#x2F;O函数</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs perl">/* <span class="hljs-keyword">open</span> 函数<br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">#include &lt;fcntl.h&gt;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">open</span>(const char *pathname, <span class="hljs-keyword">int</span> flags);<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">open</span>(const char *pathname, <span class="hljs-keyword">int</span> flags, mode_t mode);<br>- flags: O_RDONLY, O_WRONLY, O_RDWR, O_CREAT...<br>- mode: 八进制，最终文件权限值为 mode &amp; ~<span class="hljs-keyword">umask</span>, <span class="hljs-keyword">umask</span> 默认 <span class="hljs-number">0002</span>， 也可以使用宏，如 S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)<br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*<span class="hljs-keyword">read</span> 函数<br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>ssize_t <span class="hljs-keyword">read</span>(<span class="hljs-keyword">int</span> fd, void *buf, size_t count);<br>从fd指向的文件中读取 count字节，存到buf中<br>返回-<span class="hljs-number">1</span>则读取失败，<span class="hljs-number">0</span>则表示读取到文件末尾，否则返回读取到的字节数<br>size_t <span class="hljs-keyword">and</span> ssize_t are,  respectively,  unsigned  <span class="hljs-keyword">and</span>  signed<br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*<span class="hljs-keyword">write</span> 函数<br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>ssize_t <span class="hljs-keyword">write</span>(<span class="hljs-keyword">int</span> fd, const void *buf, size_t count);<br>将buf中的count字节写入到文件fd中<br>返回写入的字节数，有可能小于count，因为写入空间不够。-<span class="hljs-number">1</span>或<span class="hljs-number">0</span>则写入失败<br>*/<br><br></code></pre></td></tr></table></figure><h2 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h2> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>/*lseek 函数<br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>off_t lseek(int fd, off_t offset, int whence);<br>改变文件 fd 中的读写指针位置<br>- whence 可选参数 <br>宏定义 SEEK_SET, 文件开始位置<br>SEEK_CUR, 文件指针当前位置<br>SEEK_END, 文件结束位置<br>返回从文件开头开始的指针位置，-<span class="hljs-number">1</span>则报错，并将报错记录在perrno中<br>*/<br><br>/*stat 函数<br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>int stat(const char *pathname, struct stat *statbuf);<br>获取文件信息，记录在statbuf当中<br>- struct stat &#123;<br>              dev_t     st_dev;         <span class="hljs-regexp">/* ID of device containing file */</span><br>              ino_t     st_ino;         <span class="hljs-regexp">/* Inode number */</span><br>              mode_t    st_mode;        <span class="hljs-regexp">/* File type and mode */</span><br>              nlink_t   st_nlink;       <span class="hljs-regexp">/* Number of hard links */</span><br>              uid_t     st_uid;         <span class="hljs-regexp">/* User ID of owner */</span><br>              gid_t     st_gid;         <span class="hljs-regexp">/* Group ID of owner */</span><br>              dev_t     st_rdev;        <span class="hljs-regexp">/* Device ID (if special file) */</span><br>              off_t     st_size;        <span class="hljs-regexp">/* Total size, in bytes */</span><br>              blksize_t st_blksize;     <span class="hljs-regexp">/* Block size for filesystem I/</span>O */<br>              blkcnt_t  st_blocks;      <span class="hljs-regexp">/* Number of 512B blocks allocated */</span><br>              time_t st_atime;<span class="hljs-regexp">/* Time of last access */</span><br>              time_t st_mtime;<span class="hljs-regexp">/* Time of last modification */</span><br>              time_t st_ctime;<span class="hljs-regexp">/* Time of last status change */</span><br>          &#125;;<br>- 返回<span class="hljs-number">0</span>则成功，否则返回-<span class="hljs-number">1</span><br>*/<br></code></pre></td></tr></table></figure><p>其中，st_mode 变量如下：</p><p>setGID - 设置组id，setUID - 设置用户id，Sticky - 粘住位</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004423.png" alt="st_mode"></p><p>根据文件类型位，与相应位的宏定义 相与 运算即可，</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004953.png"></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">/*<span class="hljs-keyword">lstat</span> 函数<br>    <span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br>    <span class="hljs-comment">#include &lt;sys/stat.h&gt;</span><br>    <span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">lstat</span>(const char *pathname, struct <span class="hljs-keyword">stat</span> *statbuf);<br>    <span class="hljs-keyword">stat</span>函数如果传入的是软连接，则返回链接文件信息而非链接指向的文件，而<span class="hljs-keyword">lstat</span>函数返回链接指向文件的信息<br>*/<br></code></pre></td></tr></table></figure><p>利用上述函数实现<code>ls -l</code> 命令</p><p>接受一个文件名当做函数参数，输出该文件的信息</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305011616507.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//ls-l.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pwd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-comment">// 类型权限 硬链接数 用户名 组名 文件大小 修改时间 文件名</span><br><span class="hljs-comment">//-rw-rw-r-- 1 kevin kevin 0 5月   1 16:07 ls-l.c</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;too few arguments&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> st;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-built_in">stat</span>(argv[<span class="hljs-number">1</span>], &amp;st);<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;stat&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> filetype;<br>    <span class="hljs-keyword">switch</span>(st.st_mode &amp; __S_IFMT)<br>    &#123;<br>        <span class="hljs-keyword">case</span> __S_IFLNK:<br>            filetype = <span class="hljs-string">&#x27;l&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> __S_IFSOCK:<br>            filetype = <span class="hljs-string">&#x27;s&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> __S_IFREG:<br>            filetype = <span class="hljs-string">&#x27;-&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> __S_IFDIR:<br>            filetype = <span class="hljs-string">&#x27;d&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> __S_IFBLK:<br>            filetype = <span class="hljs-string">&#x27;b&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> __S_IFCHR:<br>            filetype = <span class="hljs-string">&#x27;c&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> __S_IFIFO:<br>            filetype = <span class="hljs-string">&#x27;f&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            filetype = <span class="hljs-string">&#x27;?&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> quanxian[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">memset</span>(quanxian, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-built_in">sizeof</span>(quanxian));<br>    <span class="hljs-comment">// user</span><br>    <span class="hljs-keyword">if</span>(st.st_mode &amp; S_IRUSR)<br>        quanxian[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;R&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(st.st_mode &amp; S_IWUSR)<br>        quanxian[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(st.st_mode &amp; S_IXUSR)<br>        quanxian[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>    <br>    <span class="hljs-comment">// group</span><br>    <span class="hljs-keyword">if</span>(st.st_mode &amp; S_IRGRP)<br>        quanxian[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;R&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(st.st_mode &amp; S_IWGRP)<br>        quanxian[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(st.st_mode &amp; S_IXGRP)<br>        quanxian[<span class="hljs-number">6</span>] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>    <br>    <span class="hljs-comment">// other</span><br>    <span class="hljs-keyword">if</span>(st.st_mode &amp; S_IROTH)<br>        quanxian[<span class="hljs-number">7</span>] = <span class="hljs-string">&#x27;R&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(st.st_mode &amp; S_IWOTH)<br>        quanxian[<span class="hljs-number">8</span>] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(st.st_mode &amp; S_IXOTH)<br>        quanxian[<span class="hljs-number">9</span>] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>    <span class="hljs-comment">// printf(&quot;%c%s\n&quot;, filetype,quanxian);</span><br><br>    <span class="hljs-comment">// 硬链接数</span><br>    <span class="hljs-type">int</span> linknum = st.st_nlink;<br><br>    <span class="hljs-comment">// 组名 用户名</span><br>    <span class="hljs-type">char</span>* u = <span class="hljs-built_in">getpwuid</span>(st.st_uid)-&gt;pw_name;<br>    <span class="hljs-type">char</span>* g = <span class="hljs-built_in">getgrgid</span>(st.st_gid)-&gt;gr_name;<br>    <br>    <span class="hljs-comment">// 文件大小</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> fsize = st.st_size;<br><br>    <span class="hljs-comment">// 文件名</span><br>    <span class="hljs-type">char</span>* file_name = argv[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 修改时间</span><br>    <span class="hljs-type">char</span>* t = <span class="hljs-built_in">ctime</span>(&amp;st.st_mtime); <span class="hljs-comment">// 这个字符串包含最后的换行符</span><br>    <span class="hljs-comment">// printf(&quot;%s\n&quot;, t);</span><br>    <span class="hljs-type">char</span> tt[<span class="hljs-number">100</span>];<br>    <span class="hljs-comment">// strncpy(tt, t, sizeof(t) - 1); // Tue May</span><br>    <span class="hljs-built_in">strncpy</span>(tt, t, <span class="hljs-built_in">strlen</span>(t) - <span class="hljs-number">1</span>); <span class="hljs-comment">// Tue May  2 10:15:54 2023</span><br>    <span class="hljs-comment">// printf(&quot;%s\n&quot;, tt);</span><br><br>    <span class="hljs-comment">// 最终输出结果</span><br>    <span class="hljs-type">char</span> disp[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-built_in">sprintf</span>(disp, <span class="hljs-string">&quot;%c%s %d %s %s %ld %s %s\n&quot;</span>, filetype, quanxian, linknum, u, g, fsize, tt, file_name);<br>    <span class="hljs-comment">// --RW-RW-R--Tue May  2 10:23:42 2023 1 kevin kevin 2590 Tue May  2 10:23:42 2023 ls-l.c</span><br>    <span class="hljs-comment">// -rw-rw-r-- 1 kevin kevin  2668 5月   2 10:26 ls-l.c</span><br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, disp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件属性操作函数"><a href="#文件属性操作函数" class="headerlink" title="文件属性操作函数"></a>文件属性操作函数</h2> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs perl">/*access 函数<br> <span class="hljs-comment">#include&lt;unistd.h&gt;</span><br> <span class="hljs-keyword">int</span> access(const char * pathname, <span class="hljs-keyword">int</span> mode)<br> 判断文件的权限或是否存在<br> -mode, R_OK, W_OK, X_OK, F_OK<br> 成功返回<span class="hljs-number">0</span>，否则返回-<span class="hljs-number">1</span><br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*<span class="hljs-keyword">chmod</span> 函数<br><span class="hljs-comment">#include &lt;sys/stat.h&gt;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">chmod</span>(const char *pathname, mode_t mode);<br>改变文件权限<br>-mode, 八进制数，使用不同用户宏定义<br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*<span class="hljs-keyword">truncate</span> 函数<br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">truncate</span>(const char *path, off_t <span class="hljs-keyword">length</span>);<br>截断或扩展文件长度<br>*/<br></code></pre></td></tr></table></figure><h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs perl">/*<span class="hljs-keyword">mkdir</span> 函数<br><span class="hljs-comment">#include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">mkdir</span>(const char *pathname, mode_t mode);<br>- 创建目录，赋予mode权限，mode是八进制数，最终权限 = mode &amp; ~<span class="hljs-keyword">umask</span> &amp; <span class="hljs-number">0777</span><br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*<span class="hljs-keyword">rmdir</span> 函数<br>     <span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>     <span class="hljs-keyword">int</span> <span class="hljs-keyword">rmdir</span>(const char *pathname);<br>         - 删除目录，目录要求是空目录<br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*raname 函数<br>    <span class="hljs-comment">#include &lt;stdio.h&gt;</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">rename</span>(const char *oldpath, const char *newpath);<br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*<span class="hljs-keyword">chdir</span> 函数<br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">chdir</span>(const char *path);<br><br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*getcwd 函数<br>    <span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>    char *getcwd(char *buf, size_t size);<br>    - 获得当前工作目录<br>    - buf 用于存储路径的数组，size 是数组的大小<br>    - 返回值就是buf<br>*/<br></code></pre></td></tr></table></figure><h2 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs perl">/*<span class="hljs-keyword">opendir</span> 函数<br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br>    <span class="hljs-comment">#include &lt;dirent.h&gt;</span><br>    DIR *<span class="hljs-keyword">opendir</span>(const char *name);<br>    - name 目录的名称<br>    - 返回 DIR* 类型，目录流，失败返回null<br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*<span class="hljs-keyword">readdir</span> 函数<br>    <span class="hljs-comment">#include &lt;dirent.h&gt;</span><br>    struct dirent *<span class="hljs-keyword">readdir</span>(DIR *dirp);<br>        - dirp是<span class="hljs-keyword">opendir</span>返回值<br>        - 返回struct dirent，代表读取到的文件的信息<br>          读取到了末尾或者失败则返回NULL<br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*<span class="hljs-keyword">closedir</span> 函数<br>    <span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br>    <span class="hljs-comment">#include &lt;dirent.h&gt;</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">closedir</span>(DIR *dirp);<br>*/<br></code></pre></td></tr></table></figure><p>利用上述函数实现对目录的遍历和对该目录下普通文件数量的统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _DEFAULT_SOURCE</span><br><span class="hljs-comment">// #define _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tongji</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * path)</span></span><br><span class="hljs-function"></span>&#123;<br>    DIR* dir = <span class="hljs-built_in">opendir</span>(path);<br>    <span class="hljs-keyword">if</span>(dir == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;opendir&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span>* dent;<br>    <span class="hljs-keyword">while</span>((dent = <span class="hljs-built_in">readdir</span>(dir)) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-type">char</span>* dirname = dent-&gt;d_name;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(dirname, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span>|| <span class="hljs-built_in">strcmp</span>(dirname, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(dent-&gt;d_type == DT_DIR)<br>        &#123;<br>            <span class="hljs-type">char</span> newpath[<span class="hljs-number">1024</span>];<br>            <span class="hljs-built_in">sprintf</span>(newpath, <span class="hljs-string">&quot;%s/%s&quot;</span>, path, dirname);<br>            cnt += <span class="hljs-built_in">tongji</span>(newpath);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dent-&gt;d_type == DT_REG)<br>            cnt += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">closedir</span>(dir);<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;too few args.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">tongji</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;普通文件个数为：%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件描述符复制函数"><a href="#文件描述符复制函数" class="headerlink" title="文件描述符复制函数"></a>文件描述符复制函数</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs perl">/*dup 函数<br>    <span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>    <span class="hljs-keyword">int</span> dup(<span class="hljs-keyword">int</span> oldfd);<br>    复制旧的文件描述符，返回一个新的最小空闲描述符<br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*dup2 函数<br>    <span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>    <span class="hljs-keyword">int</span> dup2(<span class="hljs-keyword">int</span> oldfd, <span class="hljs-keyword">int</span> newfd);<br>    重定向文件描述符，将原本指向文件a的描述符oldfd 转向成指向文件b的描述符 newfd<br>*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*<span class="hljs-keyword">fcntl</span> 函数<br>    <span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>    <span class="hljs-comment">#include &lt;fcntl.h&gt;</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">fcntl</span>(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> cmd, ...);<br>    对需要操作的文件fd进行cmd操作<br>    - F_DUPFD : 复制文件描述符,复制fd，返回一个新的文件描述符<br>    - F_GETFL : 获取指定的文件描述符文件状态flag，类似<span class="hljs-keyword">open</span>函数传递的flag<br>    - F_SETFL : 设置文件描述符文件状态flag<br>              必选：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改<br>              可选：O_APPEND, O_NONBLOCK非阻塞<br>*/<br></code></pre></td></tr></table></figure><h1 id="2、Linux多进程开发"><a href="#2、Linux多进程开发" class="headerlink" title="2、Linux多进程开发"></a>2、Linux多进程开发</h1><h2 id="进程创建与查看"><a href="#进程创建与查看" class="headerlink" title="进程创建与查看"></a>进程创建与查看</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br>成功：子进程返回<span class="hljs-number">0</span>，父进程返回子进程ID<br>失败则返回<span class="hljs-number">-1</span><br>- 当前系统的进程数达到系统规定上限，errno置为EAGAIN<br>- 系统内存不足，errno置为ENOMEM<br></code></pre></td></tr></table></figure><p><code>ps aux</code>、<code>ps ajx</code>列出与作业控制相关的信息、<code>ps -ef</code></p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305041430373.png"></p><p><code>top</code>命令实时显示进程动态 <code>-d</code>指定更新时间间隔</p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305041434410.png"></p><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305041437661.png"></p><h2 id="多进程GDB调试"><a href="#多进程GDB调试" class="headerlink" title="多进程GDB调试"></a>多进程GDB调试</h2><p>GDB默认只跟踪一个进程，调试当前进程时，其他进程继续运行</p><p><code>set follow-fork-mode [parent | child]</code>设置当前调试父进程或子进程</p><p><code>set detach-on-fork [on | off]</code> off表示调试当前进程时，其他进程被挂起，否则继续运行</p><p><code>info inferiors</code>查看调试的进程</p><p><code>inferior id</code>切换当前调试的进程</p><p><code>detach inferiors id</code>使进程脱离GDB调试</p><h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><p>exec函数族的作用是根据指定的文件名找到可执行文件，调用后直接取代当前进程的内容，调用进程覆盖原来的内存</p><p>调用成功不返回，调用失败则返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...<span class="hljs-comment">/* (char *) NULL */</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ... <span class="hljs-comment">/* (char *) NULL */</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...<span class="hljs-comment">/*, (char *) NULL, char *const envp[] */</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><p>l(list)——参数地址列表，以空指针结尾<br>v(vector)——存有各参数地址的指针数组的地址<br>p(path)——按 PATH 环境变量指定的目录搜索可执行文件<br>e(environment)——存有环境变量字符串地址的指针数组的地址</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>标准C库<code>exit</code>与Linux标准库<code>_exit</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br>void <span class="hljs-keyword">exit</span>(int status);<br>在终止进程之前会刷新I/O缓冲区，而_exit则不会<br><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br>void _exit(int status);<br></code></pre></td></tr></table></figure><p>孤儿进程：父进程在子进程之前退出，子进程就被称为孤儿进程，将成为init进程的子进程，孤儿进程没有危害</p><p>僵尸进程：子进程在父进程之前退出，内核会在子进程退出后会保留一定的信息，而父进程没有进行处理，则产生僵尸进程，大量僵尸进程占用进程号，导致无法创建新的进程</p><h2 id="僵尸进程的解决"><a href="#僵尸进程的解决" class="headerlink" title="僵尸进程的解决"></a>僵尸进程的解决</h2><ol><li><p>干掉父进程，让子进程变为孤儿进程，由init进程负责释放</p></li><li><p>父进程调用<code>wait()</code>或<code>waitpid()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *wstatus)</span></span>;<br>- wstatus 储存子进程退出状态，使用相关宏函数可以获取退出状态信息<br>- 返回值 &gt; <span class="hljs-number">0</span> 返回的是子进程ID号, &lt; <span class="hljs-number">0</span> 失败，所有子进程结束<br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *wstatus, <span class="hljs-type">int</span> options)</span></span>;<br>- pid = <span class="hljs-number">-1</span>, options = WNOHANG时等同于<span class="hljs-built_in">wait</span>()<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305061511601.png" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305061513010.png" style="zoom:50%;" /></li><li><p><code>fork</code>两次</p><p>父进程fork子进程，子进程fork孙进程后退出，则孙进程被init接管，但需要父进程回收子进程</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;errno.h&gt;</span><br><br>int main()<br>&#123;<br>    pid_t  pid;<br>    <span class="hljs-regexp">//</span>创建第一个子进程<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-regexp">//</span>第一个子进程<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-regexp">//</span>子进程再创建子进程<br>        printf(<span class="hljs-string">&quot;I am the first child process.pid:%d\tppid:%d\n&quot;</span>,getpid(),getppid());<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-regexp">//</span>第一个子进程退出<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            printf(<span class="hljs-string">&quot;first procee is exited.\n&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-regexp">//</span>第二个子进程<br>        <span class="hljs-regexp">//</span>睡眠<span class="hljs-number">3</span>s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里<br>        sleep(<span class="hljs-number">3</span>);<br>        printf(<span class="hljs-string">&quot;I am the second child process.pid: %d\tppid:%d\n&quot;</span>,getpid(),getppid());<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-regexp">//</span>父进程处理第一个子进程退出<br>    <span class="hljs-keyword">if</span> (waitpid(pid, NULL, <span class="hljs-number">0</span>) != pid)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;waitepid error:&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>signal</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sig_child</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-comment">//创建捕捉子进程退出信号</span><br>    <span class="hljs-built_in">signal</span>(SIGCHLD,sig_child);<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process,pid id %d.I am exiting.\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am father process.I will sleep two seconds\n&quot;</span>);<br>    <span class="hljs-comment">//等待子进程先退出</span><br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//输出进程信息</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;ps -o pid,ppid,state,tty,command&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father process is exiting.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sig_child</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-type">pid_t</span>        pid;<br>     <span class="hljs-type">int</span>        stat;<br>     <span class="hljs-comment">//处理僵尸进程</span><br>     <span class="hljs-keyword">while</span> ((pid = <span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>, &amp;stat, WNOHANG)) &gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d terminated.\n&quot;</span>, pid);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间通讯的目的：</p><ol><li>数据传输</li><li>通知事件</li><li>资源共享</li><li>进程控制</li></ol><p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305061537759.png"></p><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>管道即匿名管道，没有文件实体，但有名管道有文件实体</p><p>管道是字节流，能够读取任意大小的数据块</p><p>匿名管道只能在<strong>具有公共祖先</strong>的进程中使用</p><p>使用命令<code>ulimit -a</code>可以查看管道缓冲大小</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> pipe(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>])<br>- 创建管道<br>- pipefd数组中，pipefd[<span class="hljs-number">0</span>]表示管道读端， pipefd[<span class="hljs-number">1</span>]表示写端，相当于管道两端的文件描述符<br><br><span class="hljs-type">int</span> pipe2(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>], <span class="hljs-type">int</span> flags)<br>- flags参数O_NONBLOCK可以将管道设为非阻塞<br><br><span class="hljs-type">long</span> fpathconf(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> name)<br>- 查看管道缓冲大小函数<br>- fd是管道的读端或者写端，根据name所对应的宏定义可以获取管道的相关信息，_PC_PIPE_BUF最大缓冲区大小<br></code></pre></td></tr></table></figure><h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><p>有名管道克服了匿名管道只能在有亲缘关系的进程间通信的缺点，以FIFO文件形式存在于文件系统中，只要能够访问该文件，就能彼此进行通信</p><p>作为一个特殊文件存在，但FIFO中的内容存放在内存中</p><p>与匿名管道一样，都不支持<code>lseek()</code>文件定位操作</p><p>可以通过<code>mkfifo</code>命令创建有名管道</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>- mode 与 open中一样，八进制数<br></code></pre></td></tr></table></figure><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;sys/mman.</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span></span>;<br>- addr = <span class="hljs-literal">NULL</span>, 由内核指定<br>- length是要映射的数据长度，可以用lseek、stat获取文件的长度<br>- prot是映射内存的操作权限，<br>  PROT_EXEC,PROT_WRITE,PROT_READ,PROT_NONE，通常要小于等于磁盘文件open的权限<br>- flags， MAP_SHARED：映射区数据自动与磁盘文件同步MAP_PRIVATE：不同步<br>- fd 映射的文件描述符<br>- offset 偏移量，要求是<span class="hljs-number">4</span>k的整数倍，通常是<span class="hljs-number">0</span><br>- 返回创建的内存的首地址，失败则返回MAP_FAILD，即<span class="hljs-number">-1</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">munmap</span>(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length);<br>- 释放内存映射，参数需要与mmap对应<br></code></pre></td></tr></table></figure><p>也可以使用<code>flags=MAP_ANONYMOUS</code>不依赖磁盘文件，使用匿名内存映射</p><p><code>void* ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</code></p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是在软件层次上对中断机制的一种模拟，属于异步通信</p><p>命令<code>kill -l</code>查看系统定义的信号列表，前31个为常规信号，其余为实时信号</p><p><code>SIGINT</code>——用户按下<code>&lt;Ctrl+C&gt;</code>组合键引发——终止进程</p><p><code>SIGQUIT</code>——用户按下<code>&lt;Ctrl+C&gt;</code>组合键引发——终止进程</p><p><code>SIGKILL</code>——无条件终止进程，不能被忽略，处理和阻塞——终止除了僵尸以外的所有进程</p><p><code>SIGPIPE</code>——管道破裂，向一个没有读端的管道写数据——终止进程</p><p><code>SIGSEGV</code>——段错误，无效内存访问——终止进程并产生core文件</p><p><code>SIGCHLD</code>——子进程结束时，父进程收到该信号——忽略</p><p><code>SIGCONT</code>——进程停止则继续运行——忽略</p><p><code>SIGSTOP</code>——停止进程的执行，不能被忽略，处理和阻塞——暂停进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span></span>;<span class="hljs-comment">// 产生任意信号sig给进程pid</span><br>- pid = <span class="hljs-number">0</span>, 当前组；pid &gt; <span class="hljs-number">0</span>, 进程号为pid的进程；pid = <span class="hljs-number">-1</span>, 所有能接受sig信号的进程，除了init进程；pid &lt; <span class="hljs-number">0</span>，组号为pid绝对值的进程<br><br><span class="hljs-type">int</span> <span class="hljs-built_in">raise</span>(<span class="hljs-type">int</span> sig);<span class="hljs-comment">// 相当于kill(getpid(), sig)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">// 相当于kill(getpid(), SIGABRT)</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span></span>;<br>- 传入<span class="hljs-number">0</span>取消闹钟，传入任何值都会取消之前的闹钟<br>- 返回上一个闹钟剩余时间， <span class="hljs-number">0</span> 则没有闹钟<br>- 非阻塞，产生SIGALARM信号，默认终止当前进程<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval *new_val,<span class="hljs-keyword">struct</span> itimerval *old_value)</span></span>;<br>- which参数：ITIMER_REAL指真实时间，同<span class="hljs-built_in">alarm</span>()，产生SIGALRM信号；ITIMER_VIRTUAL指内核态CPU执行时间，包括所有线程消耗的时间，产生SIGVTALRM信号；ITIMER_PROF指该进程在用户态和内核态CPU消耗的时间，产生SIGPROF信号<br>- <span class="hljs-keyword">struct</span> <span class="hljs-title class_">itimerval</span> &#123;<br>               <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> it_interval; <span class="hljs-comment">/* Interval for periodic timer */</span><br>               <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> it_value;    <span class="hljs-comment">/* Time until next expiration */</span><br>           &#125;;<br>           <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> &#123;<br>               <span class="hljs-type">time_t</span>      tv_sec;         <span class="hljs-comment">/* seconds */</span><br>               <span class="hljs-type">suseconds_t</span> tv_usec;        <span class="hljs-comment">/* microseconds */</span><br>           &#125;;<br>- old_value 即<span class="hljs-built_in">getitimer</span>()返回的指针，用于返回先前设定的值，为<span class="hljs-literal">NULL</span>则不需要返回先前值<br><br></code></pre></td></tr></table></figure><h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*ANSI C 标准*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span></span>;<br>- signum 捕捉的信号，整型数或宏定义<br>- handler 设为SIG_IGN则忽略信号；SIG_DFL则默认动作；也可以传入函数指针自定义动作<br>- 返回先前的信号处理函数指针，SIG_ERR则捕捉不成功<br>- SIGKILL和SIGSTOP不能被捕捉和忽略<br><br><span class="hljs-comment">/*POSIX标准*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act,<span class="hljs-keyword">struct</span> sigaction *oldact)</span></span>;<br>- signum 捕捉的信号<br>-  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> &#123;<br>               <span class="hljs-built_in">void</span> (*sa_handler)(<span class="hljs-type">int</span>);<span class="hljs-comment">// 自定义的操作函数指针，也可以是SIG_IGN或SIG_DFL</span><br>               <span class="hljs-built_in">void</span> (*sa_sigaction)(<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *);<span class="hljs-comment">// 只有在sa_flags指定时才定义，与sa_handler只定义一个</span><br>               <span class="hljs-type">sigset_t</span>  sa_mask;<span class="hljs-comment">//自定义临时阻塞信号集</span><br>               <span class="hljs-type">int</span> sa_flags;<span class="hljs-comment">// 设为0时使用sa_handler；设为SA_SIGINFO时使用sa_sigaction</span><br>               <span class="hljs-built_in">void</span> (*sa_restorer)(<span class="hljs-type">void</span>);<span class="hljs-comment">// 已废弃</span><br>       &#125;;<br></code></pre></td></tr></table></figure><h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h2><p>未决信号集：未决是一种状态，指从信号产生到信号被处理前的时间</p><p>阻塞信号集：阻塞是一种动作，阻止信号被处理，但不阻止信号产生</p><p>信号集在内核使用位图实现，数据类型为<code>sigset_t</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*对自定义的信号集进行操作*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br>- 初始化信号集set所有信号为<span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br>- 初始化信号集set所有信号为<span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signum)</span></span>;<br>- 置单个信号为<span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signum)</span></span>;<br>- 置单个信号为<span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signum)</span></span>;<br>- 查询单个信号是否为<span class="hljs-number">1</span><br>- 返回<span class="hljs-number">1</span>则是，<span class="hljs-number">0</span>则不是，<span class="hljs-number">-1</span>查询失败<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">sigset_t</span> *oldset)</span></span>;<br>- 用于获取或者改变信号掩码，即阻塞信号集<br>- how 设为SIG_BLOCK，阻塞信号集则是与set相或的结果，即并集；设为SIG_UNBLOCK，阻塞信号集则是与~set相与的结果；设为SIG_SETMASK，阻塞信号集则是set<br>- oldset如果非<span class="hljs-literal">NULL</span>，则用来存储修改之前的阻塞信号集<br>- 返回<span class="hljs-number">0</span>成功，<span class="hljs-number">-1</span>失败<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br>- 获取当前线程的未决信号集，存储在set中<br></code></pre></td></tr></table></figure><h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h2><p><code>SIGCHLD</code>信号产生的条件：子进程终止；子进程收到<code>SIGSTOP</code>信号停止；子进程停止后收到<code>SIGCONT</code>信号被唤醒。父进程接收到信号后默认忽略该信号</p><p>因为信号是异步通信，使用<code>waitpid(-1, NULL, WNOHANG)</code>实现不阻塞父进程情况下完成对子进程的回收，以及获取到子进程的状态信息</p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是在物理内存中创建一块可以由多个进程共享的区域，需要其他机制实现同步对共享内存的访问，共享内存无需内核介入，因此速度更快</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span></span>;<br>- key表示一个共享内存的标志，十六进制，设为IPC_PRIVATE 或者 不为IPC_PRIVATE，同时没有key对应的共享内存段，并且shmflg中指定IPC_CREAT，则创建新的共享内存段<br>- size共享内存的大小，向上取整到PAGE_SIZE的整数倍<br>- shmflg设为IPC_CREAT新建共享内存段；设为IPC_EXCL|IPC_CREAT如果已经存在，则返回错误号EEXIST<br>- 成功则返回共享内存id号，失败返回<span class="hljs-number">01</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span></span>;<br>- 将共享内存与当前进程关联<br>- shmaddr设为<span class="hljs-literal">NULL</span>，系统安排段地址<br>- shmflg设为SHM_EXEC，共享内存可以被执行；设为SHM_RDONLY,共享内存只读；不指定（<span class="hljs-number">0</span>）则为读写<br>- 成功则返回共享内存的首地址，失败返回<span class="hljs-number">-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span></span>;<br>- 将共享内存与当前进程取消关联，更新共享内存的shmid_ds结构体<br>- 成功则返回<span class="hljs-number">0</span>，失败返回<span class="hljs-number">-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span></span>;<br>- 对共享内存进行cmd操作，设为IPC_STAT，获取当前共享内存状态；设为IPC_SET,设置共享内存状态；设为IPC_RMID,标记共享内存为销毁<br>- buf需要设置或者获取的共享内存的属性信息，当cmd为IPC_STAT时指定在buf中存储信息；IPC_SET根据buf指定的信息修改共享内存属性；IPC_RMID为<span class="hljs-literal">NULL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">key_t</span> <span class="hljs-title">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname， <span class="hljs-type">int</span> proj_id)</span></span>;<br>- 根据存在的路径名pathname和八位的整型数proj_id，生成一个共享内存的key值，相同路径名和proj_id相同时返回相同的key值<br></code></pre></td></tr></table></figure><p>共享内存操作命令</p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305121456792.png" style="zoom:67%;" /><p>内存映射与共享内存的区别</p><ol><li>共享内存直接创建，内存映射需要磁盘文件</li><li>共享内存速度更快</li><li>进程操作的是同一块共享内存，内存映射在每个进程虚拟空间中有独立内存</li><li>进程突然退出共享内存依然存在，内存映射区消失；电脑死机共享内存消失，内存映射磁盘文件存在</li><li>进程退出共享内存区标记为删除，内存映射区销毁</li></ol><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><ul><li><p>守护进程运行在后台，独立于控制终端，内核不为守护进程自动生成任何控制信号以及终端相关的信号</p></li><li><p>会周期性执行某种任务，一般采用以d结尾的名字</p></li><li><p>守护进程的父进程是init进程，是孤儿进程</p></li></ul><p>创建守护进程步骤</p><ol><li>在父进程中fork并退出父进程，使子进程成为孤儿进程，此时子进程继承父进程的会话、进程组、控制终端、文件描述符等</li><li>在子进程中调用setsid创建新会话，脱离原来的进程组，会话以及终止终端。但此时可能会申请一个控制终端，因此可以再fork出子进程2，这样子进程2就不是会话组长，就不能申请控制终端了</li><li>更改当前工作目录，因为守护进程运行到系统关机，这就要求其所在目录不能被卸载</li><li>设置掩码，不受父进程的umask影响，可以设为0</li><li>关闭文件描述符，将0,1,2三个文件描述符重定向到”&#x2F;dev&#x2F;null”</li></ol><p>另外，也可以利用库函数daemon()创建守护进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">daemon</span><span class="hljs-params">(<span class="hljs-type">int</span> nochdir, <span class="hljs-type">int</span> noclose)</span></span>;<br>- nochdir 设为<span class="hljs-number">0</span>时将当前目录更改为<span class="hljs-string">&quot;/&quot;</span><br>- noclose 设为<span class="hljs-number">0</span>时将标准输入、标准输出、标准错误重定向至<span class="hljs-string">&quot;/dev/null&quot;</span><br>- 成功返回<span class="hljs-number">0</span>，失败返回<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h1 id="3、Linux多线程开发"><a href="#3、Linux多线程开发" class="headerlink" title="3、Linux多线程开发"></a>3、Linux多线程开发</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程当中的一条执行流程</p><p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源</p><p>每个线程各自有一套独立的寄存器和栈，确保线程的控制流相对独立</p><p>使用命令<code>ps -Lf pid</code>查看指定进程的LWP号</p><h2 id="线程vs进程"><a href="#线程vs进程" class="headerlink" title="线程vs进程"></a>线程vs进程</h2><p>进程是分配资源的基本单位，线程是调度的基本单位</p><p>进程间不共享内存，需要采用进程通信方式，线程共享内存和文件资源</p><p>进程创建需要资源管理信息，内存、文件管理信息等，线程创建共享它们</p><p>进程上下文切换开销大，切换时要把页表切换掉，同一个进程内的线程切换只需要切换私有数据、寄存器等不共享数据</p><h2 id="线程操作函数"><a href="#线程操作函数" class="headerlink" title="线程操作函数"></a>线程操作函数</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;pthread.h&gt;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_create(<span class="hljs-params">pthread_t</span> <span class="hljs-operator">*</span><span class="hljs-params">thread</span>, <span class="hljs-params">const</span> <span class="hljs-params">pthread_attr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">attr</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span>(<span class="hljs-operator">*</span><span class="hljs-params">start_routine</span>)</span> (void *), void *arg);<br>- 以执行函数指针start_routine指向的函数创建线程，并且向函数传递arg参数，创建的线程属性由attr指定<br>- thread存储新建线程的线程ID<br>pthread_t pthread<span class="hljs-constructor">_self(<span class="hljs-params">void</span>)</span>;<br>- 成功返回<span class="hljs-number">0</span><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_equal(<span class="hljs-params">pthread_t</span> <span class="hljs-params">t1</span>, <span class="hljs-params">pthread_t</span> <span class="hljs-params">t2</span>)</span>;<br>- 判断两个线程ID是否相同 <br>void pthread<span class="hljs-constructor">_exit(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">retval</span>)</span>;<br>- 当前线程退出，返回retval，能够在pthread_join函数中使用<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_join(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">retval</span>)</span>;<br>- 以阻塞的方式等待一个线程结束<br>- retval接受线程退出传递参数的地址<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_detach(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span>;<br>- 分离一个线程，被分离的线程在终止时自动释放资源，不能连接一个分离的线程<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cancel(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span>;<br>- 当线程到达一个取消点时取消<br>- 线程取消取决于 cancelability state <span class="hljs-keyword">and</span> <span class="hljs-keyword">type</span><br>- cancelability state由pthread_setcancelstate决定，新线程默认启用(enabled)，启用后由cancelability <span class="hljs-keyword">type</span>决定线程取消时机<br>- cancelability <span class="hljs-keyword">type</span>由pthread_setcanceltype决定，新线程默认为deferred,也可以是asynchronous，deferred意味着直到下一次取消点线程才会取消<br>- 只有连接线程才能获取PTHREAD_CANCELED退出状态码，才能知道线程取消成功<br></code></pre></td></tr></table></figure><h2 id="线程属性操作函数"><a href="#线程属性操作函数" class="headerlink" title="线程属性操作函数"></a>线程属性操作函数</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;pthread.h&gt;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_attr_init(<span class="hljs-params">pthread_attr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">attr</span>)</span>;<br>- 初始化线程属性attr<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_attr_destroy(<span class="hljs-params">pthread_attr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">attr</span>)</span>;<br>- 释放线程属性资源<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_attr_getdetachstate(<span class="hljs-params">const</span> <span class="hljs-params">pthread_attr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">attr</span>, <span class="hljs-params">int</span><span class="hljs-operator">*</span> <span class="hljs-params">detachstate</span>)</span>;<br>- 获取线程分离状态的属性<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_attr_setdetachstate(<span class="hljs-params">pthread_attr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">attr</span>, <span class="hljs-params">int</span> <span class="hljs-params">detachstate</span>)</span>;<br>- 设置线程分离状态的属性<br>- detachstate可设为 PTHREAD_CREATE_DETACHED或者<span class="hljs-constructor">PTHREAD_CREATE_JOINABLE(默认)</span><br></code></pre></td></tr></table></figure><h2 id="互斥与同步"><a href="#互斥与同步" class="headerlink" title="互斥与同步"></a>互斥与同步</h2><p>互斥：一个线程在临界区执行时，其他线程应该被阻止进入临界区</p><p>同步：并发线程或进程在一些关键点上需要相互等待与互通信息</p><p>加锁解锁操作可以实现互斥，信号量可以实现互斥和同步</p><h2 id="互斥锁Mutex"><a href="#互斥锁Mutex" class="headerlink" title="互斥锁Mutex"></a>互斥锁Mutex</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">互斥量的类型 pthread_mutex_t<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_mutex_init(<span class="hljs-params">pthread_mutex_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">mutex</span>,<span class="hljs-params">const</span> <span class="hljs-params">pthread_mutexattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">attr</span>)</span>;<br>-初始化互斥锁<br>- attr互斥锁相关属性，可以为NULL<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_mutex_destroy(<span class="hljs-params">pthread_mutex_t</span> <span class="hljs-operator">*</span><span class="hljs-params">mutex</span>)</span>;<br>- 释放互斥锁资源<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_mutex_lock(<span class="hljs-params">pthread_mutex_t</span> <span class="hljs-operator">*</span><span class="hljs-params">mutex</span>)</span>;<br>- 加锁，并且阻塞当前线程<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_mutex_trylock(<span class="hljs-params">pthread_mutex_t</span> <span class="hljs-operator">*</span><span class="hljs-params">mutex</span>)</span>;<br>- 尝试加锁，如果加锁失败则返回<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_mutex_unlock(<span class="hljs-params">pthread_mutex_t</span> <span class="hljs-operator">*</span><span class="hljs-params">mutex</span>)</span>;<br>- 解锁<br></code></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>如果有其他线程读数据，则允许其他线程执行读操作，但不允许写操作</p><p>如果有其他线程写数据，则其他线程不允许读或写操作</p><p>写独占，优先级更高</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">读写锁的类型 pthread_rwlock_t<br><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_init(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">rwlock</span>, <span class="hljs-params">const</span> <span class="hljs-params">pthread_rwlockattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">attr</span>)</span>;<br>- <br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_destroy(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_rdlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_tryrdlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_wrlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_trywrlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_unlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">条件变量的类型 pthread_cond_t<br><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_init(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">cond</span>, <span class="hljs-params">const</span> <span class="hljs-params">pthread_condattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">attr</span>)</span>;<br>- 初始化条件变量<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_destroy(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br>- 释放条件变量资源<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_wait(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">cond</span>, <span class="hljs-params">pthread_mutex_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">mutex</span>)</span>;<br>- 解除互斥锁并阻塞等待，直到条件变量发出信号；当接收到信号时将会重新加上互斥锁<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_timedwait(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">cond</span>, <span class="hljs-params">pthread_mutex_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">mutex</span>, <span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">timespec</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">abstime</span>)</span>;<br>- 解除互斥锁并阻塞等待指定时间<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_signal(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br>- 唤醒等待的线程<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_broadcast(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br>- 唤醒所有等待的线程<br></code></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">信号量的类型 sem_t<br>#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_init(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-params">pshared</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">value</span>)</span>;<br>- 初始化信号量<br>- pshared设为<span class="hljs-number">0</span>，表示线程；否则表示进程<br>- value信号量的初始值<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_destroy(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br>- 释放信号量资源<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_wait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br>- 加锁，相当于P操作，信号量值value减一，如果值为<span class="hljs-number">0</span>则阻塞<br>- 返回<span class="hljs-number">0</span>成功<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_trywait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br>- 如果无法加锁，返回-<span class="hljs-number">1</span>，errorno为EAGAIN而不阻塞<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_timedwait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">timespec</span> <span class="hljs-operator">*</span><span class="hljs-params">abs_timeout</span>)</span>;<br>- 超过时长abs_timeout无法加锁，返回-<span class="hljs-number">1</span>，errorno为ETIMEOUT而不阻塞<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_post(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br>- 释放锁，相当于V操作，信号量值value加一<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_getvalue(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">sval</span>)</span>;<br>- 获取信号量sem的value<br></code></pre></td></tr></table></figure><h1 id="4、Linux网络编程"><a href="#4、Linux网络编程" class="headerlink" title="4、Linux网络编程"></a>4、Linux网络编程</h1><h2 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//主机字节序转换成网络字节序</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">// 端口号转换</span><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span></span><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// IP地址转换</span></span><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span></span><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span></span><br></code></pre></td></tr></table></figure><h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;arpa/inet.h&gt;<br><span class="hljs-comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span><br><span class="hljs-built_in">int</span> inet<span class="hljs-constructor">_pton(<span class="hljs-params">int</span> <span class="hljs-params">af</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">src</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">dst</span>)</span>;<br>- af:地址族： AF_INET AF_INET6<br>- src:需要转换的点分十进制的IP字符串<br>- dst:转换后的结果保存在这个里面<br><span class="hljs-comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span><br>const <span class="hljs-built_in">char</span> *inet<span class="hljs-constructor">_ntop(<span class="hljs-params">int</span> <span class="hljs-params">af</span>, <span class="hljs-params">const</span> <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">src</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">dst</span>, <span class="hljs-params">socklen_t</span> <span class="hljs-params">size</span>)</span>;<br>- af:地址族： AF_INET AF_INET6<br>- src: 要转换的ip的整数的地址<br>- dst: 转换成IP地址字符串保存的地方<br>- size：第三个参数的大小（数组的大小）<br>- 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的<br></code></pre></td></tr></table></figure><h2 id="套接字函数"><a href="#套接字函数" class="headerlink" title="套接字函数"></a>套接字函数</h2><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305221047814.png" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span> <span class="hljs-comment">// 包含了这个头文件，上面两个就可以省略</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span></span>;<br>    - 功能：创建一个套接字<br>    - domain: 协议族 ，AF_INET : ipv4、AF_INET6 : ipv6、AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）<br>    - type: 通信过程中使用的协议类型<br>        SOCK_STREAM : 流式协议<br>        SOCK_DGRAM : 报式协议<br>    - protocol : 具体的一个协议。一般写<span class="hljs-number">0</span>，流式协议默认使用 TCP；报式协议默认使用 UDP<br>    - 成功：返回文件描述符，操作的就是内核缓冲区，失败：<span class="hljs-number">-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>; <span class="hljs-comment">// socket命名</span><br>    - 功能：绑定，将fd 和本地的IP + 端口进行绑定<br>    - sockfd : 通过socket函数得到的文件描述符<br>    - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息<br>    - addrlen : 第二个参数结构体占的内存大小<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span></span>; <span class="hljs-comment">// /proc/sys/net/core/somaxconn</span><br>    - 功能：监听这个socket上的连接<br>    - sockfd : 通过<span class="hljs-built_in">socket</span>()函数得到的文件描述符<br>    - backlog : 未连接的和已经连接的和的最大值， <span class="hljs-number">5</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span></span>;<br>    - 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接<br>    - sockfd : 用于监听的文件描述符<br>    - addr : 传出参数，记录了连接成功后客户端的地址信息（ip + port）<br>    - addrlen : 指定第二个参数的对应的内存大小<br>    - 成功返回用于通信的文件描述符，失败返回<span class="hljs-number">-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<br>    - 功能： 客户端连接服务器<br>    - sockfd : 用于通信的文件描述符<br>    - addr : 客户端要连接的服务器的地址信息<br>    - addrlen : 第二个参数的内存大小<br>    - 返回值：成功 <span class="hljs-number">0</span>， 失败 <span class="hljs-number">-1</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>; <span class="hljs-comment">// 写数据</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>; <span class="hljs-comment">// 读数据</span><br></code></pre></td></tr></table></figure><h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><p>端口复用允许一个程序中多个套接字在一个端口号上绑定，但只有最后一个套接字能够接受信息；程序退出而系统没有释放端口，跳过TIME_WAIT状态</p><p>使用<code>setsockopt</code>函数中的<code>SO_REUSEADDR</code>选项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-comment">// 设置套接字的属性（不仅仅能设置端口复用）,在服务器绑定端口之前设置，绑定到同一个端口的所有套接字都得设置复用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> optlen)</span></span>;<br>- sockfd : 要操作的文件描述符<br>- level : 级别 设为SOL_SOCKET <br>- optname : 选项的名称 设为SO_REUSEADDR<br>- optval : 端口复用的值（整形），设为<span class="hljs-number">1</span>可以复用，<span class="hljs-number">0</span>则不可以<br>- optlen : optval参数的大小<br></code></pre></td></tr></table></figure><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用使程序能够同时监听多个文件描述符，能够提高程序的性能</p><p>select函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span></span>;<br>- 允许程序监听多个文件描述符，直到一个或多个文件描述符有数据改动，监听数量小于 <span class="hljs-built_in">FD_SETSIZE</span>(<span class="hljs-number">1024</span>)<br>- readfds 指向fd_set结构的指针，监听读缓冲区是否有数据可以读入（不被阻塞）如果有则返回大于<span class="hljs-number">0</span>的值，如果超出timeout的时间返回<span class="hljs-number">0</span>，错误返回<span class="hljs-number">-1</span>；writefds 指向fd_set结构的指针，监听写缓冲区是否可以写入，如果有则返回大于<span class="hljs-number">0</span>的值，如果超出timeout的时间返回<span class="hljs-number">0</span>，错误返回<span class="hljs-number">-1</span>；execptfds 指向fd_set结构的指针，用来监听文件错误异常<br>- nfds设为最大文件描述符+<span class="hljs-number">1</span><br>- timeout指定阻塞监听文件描述符的时长，<span class="hljs-literal">NULL</span>则阻塞直到文件描述符有变化<br>- 监听成功返回sets中的文件描述符数量<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_CLR</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>;<br>- 从set中移除fd指定的文件描述符<br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>;<br>- 判断select返回的set中fd文件描述符是否为<span class="hljs-number">1</span>，即有改动<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_SET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>;<br>- 从set中添加fd指定的文件描述符<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_ZERO</span><span class="hljs-params">(fd_set *set)</span></span>;<br>- 清除set中所有文件描述符<br></code></pre></td></tr></table></figure><p>缺点：</p><ol><li>每次调用 select ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大</li><li>同时每次调用 select 都需要在内核遍历传递进来的所有 fd ，这个开销在 fd 很多时也很大</li><li>select支持的文件描述符数量太小了，默认是 1024</li><li>fds集合不能重用，每次都需要重置</li></ol><p>poll函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd* fds, <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span></span>;<br>- <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> &#123;<br>               <span class="hljs-type">int</span>   fd;         <span class="hljs-comment">/* file descriptor */</span><br>               <span class="hljs-type">short</span> events;     <span class="hljs-comment">/* requested events */</span><br>               <span class="hljs-type">short</span> revents;    <span class="hljs-comment">/* returned events */</span><br>      &#125;;<br>     - events 输入参数，指定对文件描述符fd监听的位掩码，revents 输出参数，由内核填充，与实际发生事件联系<br>     - timeout 指定监听文件描述符应该阻塞的毫秒数，<span class="hljs-number">-1</span>则一直阻塞直到有变化<br>     - 返回<span class="hljs-number">0</span>则超时且无文件描述符有变化；大于<span class="hljs-number">0</span>返回变化的文件描述符数；<span class="hljs-number">-1</span>错误<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305271009920.png" style="zoom:80%;" /><p>解决了select的3、4缺点，但依然存在1、2缺点</p><p>epoll函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;sys/epoll.h&gt;<br><br><span class="hljs-built_in">int</span> epoll<span class="hljs-constructor">_create(<span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span>;<br>- 创建一个保证能够正确处理的size大小的epoll句柄，已放弃使用<br>- 创建后占用一个文件描述符，将文件描述符作为返回值，失败返回-<span class="hljs-number">1</span><br><span class="hljs-built_in">int</span> epoll<span class="hljs-constructor">_ctl(<span class="hljs-params">int</span> <span class="hljs-params">epfd</span>, <span class="hljs-params">int</span> <span class="hljs-params">op</span>, <span class="hljs-params">int</span> <span class="hljs-params">fd</span>, <span class="hljs-params">struct</span> <span class="hljs-params">epoll_event</span> <span class="hljs-operator">*</span><span class="hljs-params">event</span>)</span>;<br>- 操作创建的epoll，注册要监听的事件类型<br>- op表示动作，EPOLL_CTL_ADD添加新的fd到epfd中；EPOLL_CTL_MOD修改已注册的fd的监听事件；EPOLL_CTL_DEL从epfd中删除一个fd<br>- fd 表示需要监听的文件描述符<br>- <span class="hljs-keyword">struct</span> epoll_event &#123;<br>  __uint32_t events;  <span class="hljs-comment">/* Epoll events */</span><br>  epoll_data_t data;  <span class="hljs-comment">/* User data variable */</span><br>  &#125;;<br>  其中，events监听事件有EPOLLIN对应的文件描述符可读；EPOLLOUT可写；EPOLLERR发生错误；EPOLLLET边缘触发模式（默认为水平触发模式）<br>- typedef union epoll_data &#123;<br>        void *ptr;<br>        <span class="hljs-built_in">int</span> fd;<br>        uint32_t u32;<br>        uint64_t u64;<br>        &#125; epoll_data_t;<br><span class="hljs-built_in">int</span> epoll<span class="hljs-constructor">_wait(<span class="hljs-params">int</span> <span class="hljs-params">epfd</span>, <span class="hljs-params">struct</span> <span class="hljs-params">epoll_event</span> <span class="hljs-operator">*</span><span class="hljs-params">events</span>, <span class="hljs-params">int</span> <span class="hljs-params">maxevents</span>, <span class="hljs-params">int</span> <span class="hljs-params">timeout</span>)</span>;<br>- 等待监听事件的发生<br>- events 传出参数，从内核得到事件的集合<br>- maxevents 结构体数组events的大小<br>- timeout 阻塞时间，设为<span class="hljs-number">0</span>不阻塞；-<span class="hljs-number">1</span>一直阻塞；&gt; <span class="hljs-number">0</span> 阻塞的时长（毫秒）<br>- 返回发生变化的文件描述符个数，失败返回-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="库CentOS与Ubuntu哪个更适合做服务器系统"><a href="#库CentOS与Ubuntu哪个更适合做服务器系统" class="headerlink" title="库CentOS与Ubuntu哪个更适合做服务器系统"></a><a href="https://www.jb51.net/article/110710.htm">库CentOS与Ubuntu哪个更适合做服务器系统</a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lab</title>
    <link href="/2023/03/10/lab/"/>
    <url>/2023/03/10/lab/</url>
    
    <content type="html"><![CDATA[<h1 id="0、docker搭建linux环境（for-Windows）"><a href="#0、docker搭建linux环境（for-Windows）" class="headerlink" title="0、docker搭建linux环境（for Windows）"></a>0、docker搭建linux环境（for Windows）</h1><h2 id="docker官网下载-docker-desktop"><a href="#docker官网下载-docker-desktop" class="headerlink" title="docker官网下载 docker desktop"></a><a href="https://www.docker.com/">docker官网</a>下载 docker desktop</h2><p>右上角点击Get Started，选择Download for Windows进行下载并安装</p><img src="C:\myblog\source\_posts\lab\docker_download.png" style="zoom:50%;" /><p>打开cmd，通过<code>docker --version</code> 命令查看是否安装成功</p><h2 id="配置docker镜像"><a href="#配置docker镜像" class="headerlink" title="配置docker镜像"></a>配置docker镜像</h2><p>打开docker desktop，在设置中找到Docker Engine，将原有文本修改成如下并Apply &amp; restart</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;experimental&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;features&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;buildkit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><img src="C:\myblog\source\_posts\lab\docker_engine.png" style="zoom:50%;" /><p>cmd中输入<code>docker info</code>并显示有如下信息即可</p><p><img src="C:\myblog\source_posts\lab\docker_info.png"></p><h2 id="拉取Linux镜像并新建容器"><a href="#拉取Linux镜像并新建容器" class="headerlink" title="拉取Linux镜像并新建容器"></a>拉取Linux镜像并新建容器</h2><p>这里选择CentOS系统，当然也可以使用其他系统，只需要修改命令参数</p><p>输入<code>docker pull centos</code>即可拉取最新的centos镜像，如果需要特定版本的镜像，则在系统名字后加上版本参数如<code>docker pull centos:7</code></p><p>还可以输入<code>docker images</code>查看本地主机上的镜像</p><p><img src="C:\myblog\source_posts\lab\docker_images.png"></p><p>其中，</p><p>RESPOSITORY 是镜像的仓库源，TAG 是镜像的标签，代表不同版本，IMAGE ID 是镜像ID，CREATED 是镜像的创建时间，SIZE是镜像的大小</p><p>docker中镜像相当于一个类，如果运行还需要将类进行实例化，也就是新建一个容器</p><p><code>docker run -it centos /bin/bash</code></p><p>其中，</p><p>选项-i 指交互式操作，-t 指终端，it通常一起使用，&#x2F;bin&#x2F;bash 表面希望有个交互式shell，centos不指定版本则默认使用最新版本即lastest</p><p><code>[root@9c2ab6d80ac1 /]#</code>即进入centos系统界面</p><h2 id="打开原有容器而非创建"><a href="#打开原有容器而非创建" class="headerlink" title="打开原有容器而非创建"></a>打开原有容器而非创建</h2><p>以刚新建的centost容器为例，</p><img src="C:\myblog\source\_posts\lab\docker_name.png" style="zoom:80%;" /><ul><li>从docker desktop复制其name或者ID号</li><li><code>docker start 9c2ab6d80ac14f1edf1dec3f89c9b6f759018913f2e13a8086c3c30c24ba0dd9</code>或者<code>docker start csapp_env</code>让容器启动</li><li><code>docker exec -it 9c2ab6d80ac14f1edf1dec3f89c9b6f759018913f2e13a8086c3c30c24ba0dd9 /bin/bash</code>以交互式操作进入容器</li><li><code>[root@9c2ab6d80ac1 /]#</code>centos系统界面</li><li>退出容器则输入<code>exit</code></li></ul><p>这里，除了<code>exec</code>也可以使用<code>attach</code>命令进入容器，<code>attach</code>如果从这个容器退出，就会导致容器的停止</p><h1 id="1、datalab"><a href="#1、datalab" class="headerlink" title="1、datalab"></a>1、datalab</h1><h2 id="挂载目录实现Linux机与主机文件同步"><a href="#挂载目录实现Linux机与主机文件同步" class="headerlink" title="挂载目录实现Linux机与主机文件同步"></a>挂载目录实现Linux机与主机文件同步</h2><ul><li>首先在主机中建立要共享的文件夹，复制其绝对路径，如C:\Users\amour\csapp\lab</li><li>运行<code>docker container run -it -v &quot;C:\Users\amour\csapp\lab&quot;:/csapp --name=csapp_env contos /bin/bash</code>，实现挂载，其中，在容器中的目录名为<code>csapp</code>，容器名为<code>csapp_env</code></li><li>验证挂载情况，进入容器中的目录<code>cd csapp</code>，再用<code>ls</code>指令查看子文件是否与主机中的一致</li></ul><h2 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h2><ul><li><p>更新yum源，<code>yum -y update</code></p><p>[报错1] 由于本地语言环境不适配可能会出现<code>Failed to set locale, defaulting to C.UTF-8</code>报错，则需要先安装响应的语言包和语言环境</p><ul><li><p><code>locale -a</code>查看目前已安装的语言包</p></li><li><p><code>yum install glibc-langpack-zh</code>安装中文语言包</p><p>[报错2] 这一步可能又会出现<code>Failed to download metadata for repo &#39;appstream&#39;</code>,需要将软件包修改源，在<code>/etc/yum.repos</code>中更新<code>repos.d</code>使用<code>vault.centos.org</code>代替<code>mirror.centos.org</code></p><ul><li><p>cd &#x2F;etc&#x2F;yum.repos.d</p></li><li><p>vi CentOS-Linux-BaseOS.repo</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">[baseos]<br>name=CentOS Linux <span class="hljs-variable">$releasever</span> - BaseOS<br><span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/release=$releasever&amp;arch=$basearch&amp;repo=BaseOS&amp;infra=$infra</span><br><span class="hljs-comment">#baseurl=http://mirror.centos.org/$contentdir/$releasever/BaseOS/$basearch/os/</span><br>baseurl=https:<span class="hljs-regexp">//</span>vault.centos.org<span class="hljs-regexp">/centos/</span><span class="hljs-variable">$releasever</span><span class="hljs-regexp">/BaseOS/</span><span class="hljs-variable">$basearch</span><span class="hljs-regexp">/os/</span><br>gpgcheck=<span class="hljs-number">1</span><br>enabled=<span class="hljs-number">1</span><br>gpgkey=file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/etc/</span>pki<span class="hljs-regexp">/rpm-gpg/</span>RPM-GPG-KEY-centosofficial<br></code></pre></td></tr></table></figure></li><li><p>vi CentOS-Linux-AppStream.repo</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">[appstream]<br>name=CentOS Linux <span class="hljs-variable">$releasever</span> - AppStream<br><span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=AppStream&amp;infra=$infra</span><br><span class="hljs-comment">#baseurl=http://mirror.centos.org/$contentdir/$releasever/AppStream/$basearch/os/</span><br>baseurl=https:<span class="hljs-regexp">//</span>vault.centos.org<span class="hljs-regexp">/centos/</span><span class="hljs-variable">$releasever</span><span class="hljs-regexp">/AppStream/</span><span class="hljs-variable">$basearch</span><span class="hljs-regexp">/os/</span> <br>gpgcheck=<span class="hljs-number">1</span><br>enabled=<span class="hljs-number">1</span><br>gpgkey=file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/etc/</span>pki<span class="hljs-regexp">/rpm-gpg/</span>RPM-GPG-KEY-centosofficial<br></code></pre></td></tr></table></figure></li></ul></li><li><p>dnf install glibc-langpack-en</p></li><li><p>此时再输入<code>locale -a</code>查看目前的语言包，发现除了原有的<code>C.utf8</code>之外，还有其他的<code>en_utf8</code>和<code>zh_utf8</code>，至此，已解决语言环境不适配导致无法使用yum更新下载的问题</p></li></ul></li><li><p><code>yum install sudo</code>安装sudo</p></li><li><p><code>yum install make automake gcc gcc-c++ kernel-devel</code>安装c&#x2F;c++编译环境</p></li><li><p><code>yum install gdb</code>安装gdb调试器</p></li><li><p><code>yum install glibc-debel.i686</code>安装32位嵌入式C库</p></li><li><p>完成配置</p></li></ul><p>至此，可以在主机的编译器中编写代码保存到共享目录中，在docker的虚拟centos容器中编译和运行代码</p><p>如：在共享目录中创建<code>hello.c</code>文件并编写好，进入容器中的共享文件夹<code>cd csapp/L0/</code>，使用<code>make hello</code>进行编译，<code>./hello</code>即可运行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>改造计划</title>
    <link href="/2023/03/05/%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/"/>
    <url>/2023/03/05/%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="面向招聘要求和面经学习"><a href="#面向招聘要求和面经学习" class="headerlink" title="面向招聘要求和面经学习"></a>面向招聘要求和面经学习</h1><h2 id="基础语法-面经"><a href="#基础语法-面经" class="headerlink" title="基础语法 + 面经"></a>基础语法 + 面经</h2><p>利用宿舍时间10:00-11:00 C++ Primer</p><p>牛客网面经、习题</p><h2 id="操作系统（重点）"><a href="#操作系统（重点）" class="headerlink" title="操作系统（重点）"></a>操作系统（重点）</h2><p>网课：CMU15-413</p><p>书籍：CSAPP + 现代操作系统</p><p>项目相关：labs</p><p>牛客网习题</p><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><p>网课：王道</p><p>小林coding</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>网课：CMU15-445</p><p>书籍：MySQL必知必会（REDIS？）</p><p>小林coding</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>蓝桥杯真题库 + 代码随想录LeetCode + CODETOP</p><p>每日两题</p><h2 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h2><p>Linux原子哥</p><h2 id="webserver项目"><a href="#webserver项目" class="headerlink" title="webserver项目"></a>webserver项目</h2><p>C++ set自定义排序问题</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-keyword">int</span> stime;<br>    <span class="hljs-keyword">int</span> fintime;<br><br>    node(<span class="hljs-keyword">int</span> xx, <span class="hljs-keyword">int</span> yy, <span class="hljs-keyword">int</span> st ,<span class="hljs-keyword">int</span> ot) : x(xx), y(yy), stime(st), fintime(st + ot) &#123;&#125;<br><br>    <span class="hljs-keyword">bool</span> operator &lt; (node n) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (n.fintime != fintime)<br>            <span class="hljs-keyword">return</span> fintime &lt; n.fintime;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x != n.x)<br>            <span class="hljs-keyword">return</span> x &lt; n.x;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> y &lt; n.y;<br>    &#125;<br><br>    <span class="hljs-keyword">bool</span> operator &lt; (<span class="hljs-keyword">const</span> node* n) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (n-&gt;fintime != fintime)<br>            <span class="hljs-keyword">return</span> fintime &lt; n-&gt;fintime;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x != n-&gt;x)<br>            <span class="hljs-keyword">return</span> x &lt; n-&gt;x;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> y &lt; n-&gt;y;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>利用 <code>&lt;</code> 运算符重载，如果<code>set&lt;node*&gt; nodes</code>，此时排序会出现混乱</p><p>而定义<code>set&lt;node&gt; nodes</code>则不会，并且使用仿函数也正常</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">comp</span>&#123;<br><span class="hljs-keyword">public</span>:<br>bool <span class="hljs-keyword">operator</span>()( <span class="hljs-keyword">const</span> node&amp; l, <span class="hljs-keyword">const</span> node&amp; r) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (l.fintime != r.fintime)<br>        <span class="hljs-keyword">return</span> l.fintime &lt; r.fintime;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l.x != r.x)<br>        <span class="hljs-keyword">return</span> l.x &lt; r.x;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> l.y &lt; r.y;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>set&lt;node, comp&gt; nodes</code>或<code>set&lt;node*, comp&gt; nodes</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>plan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP章节</title>
    <link href="/2022/12/02/DP%E7%AB%A0%E8%8A%82/"/>
    <url>/2022/12/02/DP%E7%AB%A0%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h1 id="DP模板"><a href="#DP模板" class="headerlink" title="DP模板"></a>DP模板</h1><ol><li>确定数组<code>dp[i]</code>的含义，以及下标<code>i</code>的含义</li><li>确定数组<code>dp[i]</code>的递推公式</li><li>确定数组<code>dp[i]</code>的初始值</li><li>确定遍历顺序</li><li>举例推导</li></ol><h1 id="基础DP"><a href="#基础DP" class="headerlink" title="基础DP"></a>基础DP</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>容易想到递归的方法来实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> fib(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n!)，空间复杂度为O(n)</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>DP数组的含义是<code>i</code>位置的斐波那契数列值是<code>dp[i]</code></p><p>递推公式为<code>dp[i] = dp[i-1]+dp[i-2]</code></p><p>DP数组初始值<code>dp[0]=0,dp[1]=1</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> fib(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">vec</span>(n+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">vec</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">vec</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">vec</span>[i] = <span class="hljs-keyword">vec</span>[i - <span class="hljs-number">1</span>] + <span class="hljs-keyword">vec</span>[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">vec</span>[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n)，空间复杂度为O(n)</p><h3 id="DP优化"><a href="#DP优化" class="headerlink" title="DP优化"></a>DP优化</h3><p>因为<code>dp[i]</code>的值只与其前两个值，即<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，则可以不需要借助容器<code>vector</code>来记录，而是只用三个变量</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs smali">class Solution &#123;<span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in"> int </span>fib(int n) &#123;<br>        if(n == 0) <span class="hljs-built_in"> return </span>0;<br>       <span class="hljs-built_in"> int </span>v0 = 0, v1 = 1;<br>       <span class="hljs-built_in"> int </span>sum = 1;<br>        for(int i = 2; i &lt;= n; i++)<br>        &#123;<br>            sum = v0 + v1;<br>            v0 = v1;<br>            v1 = sum;<br>        &#125;<br>       <span class="hljs-built_in"> return </span>v1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n)，空间复杂度为O(1)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>由于<code> F(n)</code> 只和 <code>F(n-1)</code>与 <code>F(n-2)</code>有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <code>O(1)</code>，即只需要借助三个变量来完成</strong></p><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h2><p>该题允许向上攀爬一个或两个台阶，返回n级台阶总共有多少种不同的攀爬方法</p><h3 id="DP思路"><a href="#DP思路" class="headerlink" title="DP思路"></a>DP思路</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">当<span class="hljs-built_in">n</span>为<span class="hljs-number">1</span>时，有<span class="hljs-number">1</span>种方式<br>当<span class="hljs-built_in">n</span>为<span class="hljs-number">2</span>时，有<span class="hljs-number">2</span>种方式<br>当<span class="hljs-built_in">n</span>为<span class="hljs-number">3</span>时，有<span class="hljs-number">3</span>种方式<br>当<span class="hljs-built_in">n</span>为<span class="hljs-number">4</span>时，有<span class="hljs-number">5</span>种方式<br></code></pre></td></tr></table></figure><p>可以看出，当阶数为n时，是<code>n-1</code>和<code>n-2</code>级阶数方法的总和</p><ul><li><p>确定DP数组含义</p><p><code>DP[i]</code>表示在台阶<code>i</code>时的攀爬方法</p></li><li><p>确定递推公式</p><p><code>DP[i] = DP[i - 1] + DP[i - 2];</code></p></li><li><p>确定初始值</p><p><code>DP[1] = 1, DP[2] = 2</code></p></li><li><p>确定遍历顺序</p><p>遍历顺序为正序，从头到尾遍历数组</p></li></ul><h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>)  <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>        &#123;<br>            dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="DP优化-1"><a href="#DP优化-1" class="headerlink" title="DP优化"></a>DP优化</h3><p>与[上一题](# DP优化)优化方式类似，<strong>因为<code>dp[i]</code>的值只与其前两个值，即<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，因此可以使用滚动数组实现</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> climbStairs(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>)  <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> q = <span class="hljs-number">1</span>, w = <span class="hljs-number">2</span>, e = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>        &#123;<br>            e = q + w;<br>            q = w;<br>            w = e;<br>        &#125;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>由于<code> F(n)</code> 只和 <code>F(n-1)</code>与 <code>F(n-2)</code>有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <code>O(1)</code>，即只需要借助三个变量来完成</strong></p><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></h2><p>该题给出爬每层楼梯的花费，允许每次爬一个或两个阶梯，要求使用最低花费爬到楼梯顶部</p><h3 id="DP思路-1"><a href="#DP思路-1" class="headerlink" title="DP思路"></a>DP思路</h3><p>可以看出，当爬到第n层楼梯时，当前总共的花费与<code>n-1</code>级楼梯的花费有关，也就是说当前状态可以由之前的状态推导出来</p><ul><li><p>确定DP数组含义</p><p><code>DP[i]</code>表示在台阶<code>i</code>时的总共花费</p></li><li><p>确定递推公式</p><p><code>DP[i] = min(DP[i - 1] + costs[i - 1], DP[i-  2] + costs[i - 2];</code></p></li><li><p>确定初始值</p><p><code>DP[1] = 0, DP[2] = 0</code>，初始值应由递推公式中的<code>cost[i]</code>来决定</p></li><li><p>确定遍历顺序</p><p>遍历顺序为正序，从头到尾遍历数组</p></li></ul><h3 id="DP-2"><a href="#DP-2" class="headerlink" title="DP"></a>DP</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size()+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>] + cost[i<span class="hljs-number">-2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="DP优化-2"><a href="#DP优化-2" class="headerlink" title="DP优化"></a>DP优化</h3><p>类似的，<strong>因为<code>dp[i]</code>的值只与其前两个值，即<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，因此可以使用滚动数组实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> q = <span class="hljs-number">0</span>, w = <span class="hljs-number">0</span>, e = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            e = <span class="hljs-built_in">min</span>(q + cost[i<span class="hljs-number">-2</span>], w + cost[i<span class="hljs-number">-1</span>]);<br>            q = w;<br>            w = e;<br>        &#125;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>由于<code> F(n)</code> 只和 <code>F(n-1)</code>与 <code>F(n-2)</code>有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <code>O(1)</code>，即只需要借助三个变量来完成</strong></p><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h2><p>该题有一个<code>m*n</code>大小的网格图，要求只能一次向下或者向右移动一步，返回总共不同的路径数</p><h3 id="DP思路-2"><a href="#DP思路-2" class="headerlink" title="DP思路"></a>DP思路</h3><p>若为<code>1*1</code>的网格，则有1条路径</p><p><code>2*2</code>的网格，有2条路径</p><p><code>3*2</code>或者是<code>2*3</code>的网格，则有3条路径</p><p><code>3*3</code>的网格中，有6条路径</p><p>由上可知，<strong>在<code>m*n</code>的网格当中，其路径总数等于 <code>(m-1)*n</code>网格的路径总数加上<code>m*(n-1)</code>网格的路径总数</strong>，因此将使用DP算法</p><ul><li><p>确定数组<code>DP[i][j]</code>含义</p><p><code>DP[i][j]</code>表示的是在<code>i*j</code>的网格当中，总共有<code>DP[i][j]</code>条路径</p></li><li><p>确定初始值</p><p><strong>为了方便，数组<code>DP[i][j]</code>表示第<code>i</code>行第<code>j</code>列，且不影响结果</strong></p><p><code>DP[1][j]</code>均为1，即第一行中的数，代表着<code>1*n</code>的所有网格</p><p><code>DP[i][1]</code>均为1，同理</p></li><li><p>确定状态转移方程</p><p><code>DP[i][j] = DP[i - 1][j] + DP[i][j - 1]</code></p></li><li><p>确定遍历顺序</p><p>从<code>i=2</code>开始遍历到<code>n</code>，正向遍历</p></li></ul><h3 id="DP-3"><a href="#DP-3" class="headerlink" title="DP"></a>DP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>pubulic:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(m == <span class="hljs-number">1</span> || n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">row</span><span class="hljs-params">(n + <span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>,row);<br><span class="hljs-comment">//dp数组全部元素初始化为1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++)<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n^2)，遍历网格中的所有元素，空间复杂度为O(n^2)，为网格中的每个元素独立创建一份空间</p><h3 id="DP优化-3"><a href="#DP优化-3" class="headerlink" title="DP优化"></a>DP优化</h3><p>由上可知，当遍历时，当前位置下的元素只与同行上一列元素和同列上一行元素有关，因此可以只使用一维数组来进行空间的优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>||n==<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++)<br>                dp[j] += dp[j<span class="hljs-number">-1</span>];<br>            <br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>初始化中只需要对首行和首列元素进行初始化为1的操作</p><h2 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title=" 不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/"> 不同路径 II</a></h2><p>与<a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">I</a>比较，该题多了障碍的设置，要求所有需要经过障碍所在位置的路径都不能被通过</p><h3 id="DP思路-3"><a href="#DP思路-3" class="headerlink" title="DP思路"></a>DP思路</h3><p>如果在<code>dp[i-1][j]</code>位置上有障碍，那么需要通过该点通往任意位置都将无法通过，这样可以通过将<code>dp[i-1][j]=0</code>，而<code>dp[i][j] = dp[i-1][j] + dp[i][j-1] = dp[i][j-1]</code></p><ul><li><p>确定数组<code>DP[i][j]</code>含义</p><p><code>DP[i][j]</code>表示的是在<code>i*j</code>的网格当中，排除有障碍的，总共有<code>DP[i][j]</code>条路径</p></li><li><p>确定初始值</p><p><strong>该题中 数组<code>DP[i+1][j+1]</code>表示第<code>i</code>行第<code>j</code>列</strong>，并且只需要对首列和首行的元素进行初始化</p><p>数组所有元素初始化为0，<strong>遍历数组中第0行和第0列的元素，如果当前位置上的元素没有遇到障碍，则将当前元素初值设为1</strong>，同时，<strong>如果遇到有障碍，那么在障碍之后的所有元素值都应该初始化为0</strong></p><p>如数组<code>[[0,0],[1,1],[0,0]]</code>，这时，对应的<code>dp</code>数组最终应该被初始化为<code>[[1,1],[0,0],[0,0]]</code></p></li><li><p>确定状态转移方程</p><p><code>DP[i][j] = DP[i - 1][j] + DP[i][j - 1]</code>，与上题一致</p></li><li><p>确定遍历顺序</p><p>正向遍历，与上题遍历顺序一致，但该题因为下标代表的含义不同，所以应该从<code>i=1</code>开始遍历到<code>n-1</code></p></li></ul><h3 id="DP-4"><a href="#DP-4" class="headerlink" title="DP"></a>DP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>(), n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>||obstacleGrid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">row</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, row);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(obstacleGrid[i][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][j]==<span class="hljs-number">0</span>)<br>                dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j]==<span class="hljs-number">1</span>)<br>                    dp[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="DP优化-4"><a href="#DP优化-4" class="headerlink" title="DP优化"></a>DP优化</h3><p>同样地，该题也可以只使用一个一维滚动数组来减小空间开销</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>(), n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>||obstacleGrid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span> &amp;&amp; flag)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    dp[j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)<br>                        flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)<br>                    dp[j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[j] += dp[j<span class="hljs-number">-1</span>];<br>            &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因为不能另外用一个循环来进行<strong>首列的初始化</strong>，因此借助flag变量来标记是否遇到障碍，如果遇到，之后的元素都将初始化为0；而首行元素则不需要，因为所有元素都被初始化为0，并且当前元素的值，<strong>即<code>dp[i]</code>只与自身大小与左边元素大小有关</strong>，如<code>[[0,0,0,1,0,0]]</code>数组中，在遇到障碍之前的<code>dp</code>数组为<code>[1,1,1]</code>，遇到障碍则<code>dp[3]=0</code>，之后的元素<code>dp[i] += dp[i-1]</code>均为0</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>与<a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">上一题</a>对比，该题处理方法的不同主要在于 初始化中不能将首行和首列所有元素都初始化为1，因为可能会在首行或首列元素中放置了障碍，并且，<strong>遇到障碍之后的首行或首列元素都应该初始化为0</strong>，意味着<strong>在首行或首列遇到障碍之后的元素都将没有路径能够到达。</strong></p><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><strong><a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></strong></h2><p>该题中给定一个整数，需要由<code>1-n</code>不同结点值组成一颗二叉搜索树，返回最多能组成互不相同的种树</p><h3 id="DP思路-4"><a href="#DP思路-4" class="headerlink" title="DP思路"></a>DP思路</h3><p>当n为1，只有1种二叉搜索树</p><p>当n为2，有2种二叉搜索树</p><p>当n为3，有5种二叉搜索树。 再细分，当以1为根结点，有两个大于1的数在根结点右边，则此时右子树可以组成n为2情况下的2种二叉搜索树；当以2为结点，同理有1个小于2的数在左子树，有1个数在右子树；当以3为结点，有2个数在左子树。</p><p>综上，可得n&#x3D;3时，<code>二叉搜索树数量=(右子树n=2的数量 * 左子树n=0的数量) + (右子树n=1的数量 * 左子树n=1的数量) + (右子树n=0的数量 * 左子树n=2的数量)</code></p><ul><li><p>确定数组<code>dp[i]</code>含义</p><p><code>dp[i]</code>表示的是i个结点下能组成二叉搜索树的数量</p></li><li><p>确定初始值</p><p><code>dp[0]=1</code>，空结点时能组成1种二叉搜索树</p><p><code>dp[1]=1</code></p><p><code>dp[2]=2</code></p></li><li><p>确定状态转移方程</p><p><code>dp[i]=dp[j-1]*dp[i-j]</code>，需要嵌套一层循环</p></li><li><p>确定遍历顺序</p><p>正向遍历，从<code>i=3</code>开始遍历到<code>n</code>，从<code>j = 1</code>遍历到 <code>j = i</code></p></li></ul><h3 id="DP-5"><a href="#DP-5" class="headerlink" title="DP"></a>DP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i;j++)<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i-j];<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="数学解法"><a href="#数学解法" class="headerlink" title="数学解法"></a>数学解法</h3><p>卡特兰数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//公式：C0 = 1 , Cn+1 = 2(2n+1)/(n+2)*Cn </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> C = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            C = C * <span class="hljs-number">2</span> * (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>) / (i + <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)C;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>该题难以推出状态转移方程，不妨细分情况，尽可能将之前的状态套进当前状态来考虑</p><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><strong><a href="https://leetcode.cn/problems/integer-break/">整数拆分</a></strong></h2><p>该题给定一个正整数n，将其拆分为n个正整数的和，并返回这些和的最大化乘积</p><h3 id="DP思路-5"><a href="#DP思路-5" class="headerlink" title="DP思路"></a>DP思路</h3><p>算出前8个正整数的最大乘积为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span><span class="hljs-number">5</span><span class="hljs-number">6</span><span class="hljs-number">7</span><span class="hljs-number">8</span><br><span class="hljs-attribute">1</span><span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-number">4</span><span class="hljs-number">6</span><span class="hljs-number">9</span><span class="hljs-number">12</span><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>将8拆分成以下的情况，</p><p><code>8 = j + (i - j)</code>，此时，<code>j</code>和<code>i - j</code>不再拆分，那么 <code>n=8</code>的最大乘积 &#x3D; <code>i</code> * <code>(i - j)</code>；若继续拆分<code>i - j</code>，那么 <code>n=8</code>的最大乘积 &#x3D; <code>i</code> * (<code>n = (i - j)</code>的最大乘积)</p><p>综上，可以得到 <code>dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j))</code></p><ul><li><p>确定数组<code>dp[i]</code>含义</p><p><code>dp[i]</code>表示的是整数<code>i</code>拆分的正整数的最大乘积</p></li><li><p>确定初始值</p><p><code>dp[1]=1</code></p><p><code>dp[2]=1</code></p><p><code>dp[3]=2</code></p></li><li><p>确定状态转移方程</p><p><code>dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j))</code>，需要嵌套一层循环</p></li><li><p>确定遍历顺序</p><p>正向遍历，从<code>i=4</code>开始遍历到<code>n</code>，从<code>j = 1</code>遍历到<code>j = i</code></p></li></ul><h3 id="DP-6"><a href="#DP-6" class="headerlink" title="DP"></a>DP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i/<span class="hljs-number">2</span>; j++)<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j*(i-j), dp[i-j]*j));<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>数学证明：</p><blockquote><p>$$ {函数极值证明法}<br>函数极值证明法</p><p>显然，如果将给定的正整数拆分成尽可能多的某个特定的正整数，则这些正整数的乘积最大。</p><p>定义函数 f(x)f(x) 表示将给定的正整数 nn 拆分成尽可能多的正数 xx 的情况下的最大乘积，则可以将 nn 分成 \dfrac{n}{x}<br>x<br>n<br>​<br>  项，此时 f(x)&#x3D;x^{\frac{n}{x}}f(x)&#x3D;x<br>x<br>n<br>​</p><p> ，目标是求 f(x)f(x) 的最大值，即</p><p>\mathop{\max}\limits_{x}(f(x))<br>x<br>max<br>​<br> (f(x))</p><p>可以将 f(x)f(x) 写成如下形式：</p><p>f(x)&#x3D;x^{\frac{n}{x}}&#x3D;e^{\frac{n \ln x}{x}}<br>f(x)&#x3D;x<br>x<br>n<br>​</p><p> &#x3D;e<br>x<br>nlnx<br>​</p><p>令 g(t)&#x3D;e^tg(t)&#x3D;e<br>t<br> ，h(x)&#x3D;\dfrac{\ln x}{x}h(x)&#x3D;<br>x<br>lnx<br>​<br> ，则有 f(x)&#x3D;g(n \cdot h(x))f(x)&#x3D;g(n⋅h(x))。由于 g(t)g(t) 是单调递增的，n&gt;0n&gt;0，因此 h(x)h(x) 与 f(x)f(x) 的单调性相同。</p><p>计算 h(x)h(x) 的驻点，即 h’(x)&#x3D;\dfrac{1- \ln x}{x^2}&#x3D;0h<br>′<br> (x)&#x3D;<br>x<br>2</p><p>1−lnx<br>​<br> &#x3D;0 的点，得到驻点为 x&#x3D;ex&#x3D;e。</p><p>由于当 0&lt;x&lt;e0&lt;x&lt;e 时 h’(x)&gt;0h<br>′<br> (x)&gt;0，当 x&gt;ex&gt;e 时 h’(x)&lt;0h<br>′<br> (x)&lt;0，因此 x&#x3D;ex&#x3D;e 是 h(x)h(x) 的极大值点，也是 f(x)f(x) 的极大值点。由于函数 f(x)f(x) 的定义域连续，因此极大值点唯一，也是最大值点。</p><p>因此，当 x&#x3D;ex&#x3D;e 时，f(x)f(x) 取到最大值，\max f(x)&#x3D;f(e)&#x3D;e^{\frac{n}{e}}maxf(x)&#x3D;f(e)&#x3D;e<br>e<br>n<br>​</p><p> 。</p><p>由于 ee 不是整数，因此使用与 ee 最接近的整数作为 xx 的值，xx 可以是 22 或 33，此时需要比较 f(2)f(2) 与 f(3)f(3) 的大小，可以通过计算 \dfrac{f(3)}{f(2)}<br>f(2)<br>f(3)<br>​<br>  进行比较。</p><h1 id="dfrac-f-3-f-2-x3D-dfrac-e-n-cdot-h-3-e-n-cdot-h-2-x3D-e-n-cdot-h-3-n-cdot-h-2-x3D-e-n-cdot-frac-ln-3-3-frac-ln-2-2-x3D-e-frac-n-6-cdot-2-ln-3-3-ln-2-x3D-e-frac-n-6-cdot-ln-9-ln-8-f-2-f-3-​"><a href="#dfrac-f-3-f-2-x3D-dfrac-e-n-cdot-h-3-e-n-cdot-h-2-x3D-e-n-cdot-h-3-n-cdot-h-2-x3D-e-n-cdot-frac-ln-3-3-frac-ln-2-2-x3D-e-frac-n-6-cdot-2-ln-3-3-ln-2-x3D-e-frac-n-6-cdot-ln-9-ln-8-f-2-f-3-​" class="headerlink" title="\dfrac{f(3)}{f(2)}&#x3D;\dfrac{e^{n \cdot h(3)}}{e^{n \cdot h(2)}}&#x3D;e^{n \cdot h(3)-n \cdot h(2)}&#x3D;e^{n \cdot (\frac{\ln 3}{3} - \frac{\ln 2}{2})}&#x3D;e^{\frac{n}{6} \cdot (2 \ln 3 - 3 \ln 2)}&#x3D;e^{\frac{n}{6} \cdot (\ln 9 - \ln 8)}f(2)f(3)​"></a>\dfrac{f(3)}{f(2)}&#x3D;\dfrac{e^{n \cdot h(3)}}{e^{n \cdot h(2)}}&#x3D;e^{n \cdot h(3)-n \cdot h(2)}&#x3D;e^{n \cdot (\frac{\ln 3}{3} - \frac{\ln 2}{2})}&#x3D;e^{\frac{n}{6} \cdot (2 \ln 3 - 3 \ln 2)}&#x3D;e^{\frac{n}{6} \cdot (\ln 9 - \ln 8)}<br>f(2)<br>f(3)<br>​</h1><p>e<br>n⋅h(2)</p><p>e<br>n⋅h(3)</p><p>​<br> &#x3D;e<br>n⋅h(3)−n⋅h(2)<br> &#x3D;e<br>n⋅(<br>3<br>ln3<br>​<br> −<br>2<br>ln2<br>​<br> )<br> &#x3D;e<br>6<br>n<br>​<br> ⋅(2ln3−3ln2)<br> &#x3D;e<br>6<br>n<br>​<br> ⋅(ln9−ln8)</p><p>由于 \ln 9 &gt; \ln 8ln9&gt;ln8，因此 \dfrac{f(3)}{f(2)}&gt;1<br>f(2)<br>f(3)<br>​</p><blockquote><p>1，即 f(3)&gt;f(2)f(3)&gt;f(2)。当 x&#x3D;3x&#x3D;3 时，可以得到最大乘积。因此，应该将给定的正整数拆分成尽可能多的 33。</p></blockquote><p>根据 nn 除以 33 的余数进行分类讨论：</p><p>如果余数为 00，即 n&#x3D;3m(m \ge 2)n&#x3D;3m(m≥2)，则将 nn 拆分成 mm 个 33；</p><p>如果余数为 11，即 n&#x3D;3m+1(m \ge 1)n&#x3D;3m+1(m≥1)，由于 2 \times 2 &gt; 3 \times 12×2&gt;3×1，因此将 nn 拆分成 m-1m−1 个 33 和 22 个 22；</p><p>如果余数为 22，即 n&#x3D;3m+2(m \ge 1)n&#x3D;3m+2(m≥1)，则将 nn 拆分成 mm 个 33 和 11 个 22。</p><p>上述拆分的适用条件是 n \ge 4n≥4。如果 n \le 3n≤3，则上述拆分不适用，需要单独处理。</p><p>如果 n&#x3D;2n&#x3D;2，则唯一的拆分方案是 2&#x3D;1+12&#x3D;1+1，最大乘积是 1 \times 1&#x3D;11×1&#x3D;1；</p><p>如果 n&#x3D;3n&#x3D;3，则拆分方案有 3&#x3D;1+2&#x3D;1+1+13&#x3D;1+2&#x3D;1+1+1，最大乘积对应方案 3&#x3D;1+23&#x3D;1+2，最大乘积是 1 \times 2&#x3D;21×2&#x3D;2。</p><p>这两种情形可以合并为：当 n \le 3n≤3 时，最大乘积是 n-1n−1。<br>$$</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>egerBreak(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> quotient = n / <span class="hljs-number">3</span>;<br>        <span class="hljs-built_in">int</span> remainder = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> (remainder == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)pow(<span class="hljs-number">3</span>, quotient);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (remainder == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)pow(<span class="hljs-number">3</span>, quotient - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)pow(<span class="hljs-number">3</span>, quotient) * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>DP思路考虑状态转移方程时，把正整数n拆分成 <code>j</code>和<code>n-j</code>来考虑，自然得到拆分的一种乘积为<code>j * (n - j)</code>，考虑到上一个的状态，拆分为<code>n - j</code>还可以继续拆分，此时，另一种乘积则为<code>j * dp[n - j]</code></p><p>贪心思路需要用到复杂数学证明的结论——尽可能将数拆分成2或3时的乘积最大。</p><blockquote><p>If an optimal product contains a factor f &gt;&#x3D; 4, then you can replace it with factors 2 and f-2 without losing optimality, as 2*(f-2) &#x3D; 2f-4 &gt;&#x3D; f. So you never need a factor greater than or equal to 4, meaning you only need factors 1, 2 and 3 (and 1 is of course wasteful and you’d only use it for n&#x3D;2 and n&#x3D;3, where it’s needed).</p><p>For the rest I agree, 3<em>3 is simply better than 2</em>2*2, so you’d never use 2 more than twice.、</p></blockquote><h1 id="股票系列-状态机DP"><a href="#股票系列-状态机DP" class="headerlink" title="股票系列(状态机DP)"></a>股票系列(状态机DP)</h1><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><strong><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></strong></h2><p>单笔交易的最大利润</p><h3 id="DP-7"><a href="#DP-7" class="headerlink" title="DP"></a>DP</h3><p>用二维数组<code>dp</code>储存持有股票和非持有股票两种状态下的最大利润，</p><ul><li><p><code>dp[i][0]</code>表示当前不持有股票的最大利润，可得<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code>，即继续保持前一天不持股的最大利润，或者是将前一天的股票卖出得今天的最大利润</p></li><li><p><code>dp[i][1]</code>表示当前持有股票的最大利润，可得<code>dp[i][1] = max(dp[i - 1][1], -prices[i])</code>，即继续保持前一天持股或持当天股的最大值，也就是保持最低买入股价</p></li><li><p>根据状态转移方程将<code>dp[0][0] = 0, dp[0][1] = -price[0]</code>作为初始值</p></li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;<br>        int n = prices.size();<br>        int dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[2]</span>;<br>        memset(dp, 0, sizeof dp);<br>        dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 0, dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> = -prices<span class="hljs-comment">[0]</span>;<br>        for(int i = 1; i &lt; n; i++)<br>        &#123;<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>);<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[1]</span>, - prices<span class="hljs-comment">[i]</span>);<br>        &#125;<br>        return dp<span class="hljs-comment">[n - 1]</span><span class="hljs-comment">[0]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="优化DP"><a href="#优化DP" class="headerlink" title="优化DP"></a>优化DP</h3><p>两种状态更新过程中，只需要<code>dp[i - 1][0]</code>和<code>dp[i - 1][1]</code>两个值，那么即可用两个变量代替二维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> f0 = <span class="hljs-number">0</span>, f1 = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; price : prices)<br>        &#123;<br>        f1 = <span class="hljs-built_in">max</span>(f1, -price);<br>        f0 = <span class="hljs-built_in">max</span>(f0, f1 + price);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f0;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="### 买卖股票的最佳时机 II"></a>### <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h2><p>多笔交易的最大利润</p><h3 id="DP-8"><a href="#DP-8" class="headerlink" title="DP"></a>DP</h3><p>用二维数组<code>dp</code>储存持有股票和非持有股票两种状态下的最大利润</p><ul><li><p><code>dp[i][0]</code>表示当前不持有股票的最大利润，可得<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code>，即继续保持前一天不持股的最大利润，或者是将前一天的股票卖出得今天的最大利润</p></li><li><p><code>dp[i][1]</code>表示当前持有股票的最大利润，可得<code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code>，即继续保持前一天持股，或者将前一天持的股卖出获得利润，同一天入股的最大利润</p></li><li><p>根据状态转移方程将<code>dp[0][0] = 0, dp[0][1] = -price[0]</code>作为初始值</p></li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;<br>        int n = prices.size();<br>        int dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[2]</span>;<br>        memset(dp, 0, sizeof dp);<br>        dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 0, dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> = -prices<span class="hljs-comment">[0]</span>;<br>        for(int i = 1; i &lt; n; i++)<br>        &#123;<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>);<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i]</span>);<br>        &#125;<br>        return dp<span class="hljs-comment">[n - 1]</span><span class="hljs-comment">[0]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="优化DP-1"><a href="#优化DP-1" class="headerlink" title="优化DP"></a>优化DP</h3><p>同样地，在更新过程中只用到了<code>dp[i - 1][0]</code>和<code>dp[i - 1][1]</code>两个值，用两个变量代替二维数组，另外还需要一个变量保存中间值</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        f0 = <span class="hljs-number">0</span>, f1 = -prices[<span class="hljs-number">0</span>], tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; price : prices)<br>        &#123;<br>        tmp = f0;<br>        f0 = <span class="hljs-built_in">max</span>(f0, f1 + price);<br>        f1 = <span class="hljs-built_in">max</span>(f1, tmp - price);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f0;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(prices[i + <span class="hljs-number">1</span>] &gt; prices[i])<br>                res += prices[i + <span class="hljs-number">1</span>] - prices[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机含冷冻期"><a href="#买卖股票的最佳时机含冷冻期" class="headerlink" title="买卖股票的最佳时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">买卖股票的最佳时机含冷冻期</a></h2><p>卖出股票后不能在第二天买入股票</p><h3 id="DP-9"><a href="#DP-9" class="headerlink" title="DP"></a>DP</h3><p>用二维数组<code>dp</code>储存持有股票和非持有股票两种状态下的最大利润</p><ul><li><p><code>dp[i][0]</code>表示当前不持有股票的最大利润，可得<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code>，即继续保持前一天不持股的最大利润，或者是将前一天的股票卖出得今天的最大利润</p></li><li><p><code>dp[i][1]</code>表示当前持有股票的最大利润，由题意有一天的冷冻期可得<code>dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i])</code>，即继续保持前一天持股，或者将两天前持的股卖出获得利润，然后在当天入股的最大利润</p></li><li><p>根据状态转移方程将<code>dp[0][0] = 0, dp[0][1] = -price[0]</code>作为初始值</p></li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-comment">/*BUGGY*/</span><br>class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;<br>        int n = prices.size();<br>        int dp[n][<span class="hljs-number">2</span>];<br>        memset(dp, <span class="hljs-number">0</span>, sizeof dp);<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        for (int i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>] = max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            if (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span>)<br>                dp[i][<span class="hljs-number">1</span>] = max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            else<br>                dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>        &#125;<br>        return dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在考虑一个长度为3的数组作输入时，如[2, 1, 4]，初始值被设为第一天的利润，当i&#x3D;1时并没有更新，显然不合理，对此，可以将else 语句改为<code>dp[i][1] = max(dp[i - 1][1], prices[i])</code>；另外，也可以不增加额外的判断语句，将二维数组长度更改为<code>dp[n + 1][2]</code>或者<code>dp[n + 2][2]</code></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs inform7">-----dp<span class="hljs-comment">[n+1]</span><span class="hljs-comment">[2]</span>-----<br>class Solution &#123;<br>public:<br>    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;<br>        int n = prices.size();<br>        int dp<span class="hljs-comment">[n + 1]</span><span class="hljs-comment">[2]</span>;<br>        memset(dp, 0, sizeof dp);<br>        dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 0, dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> = -prices<span class="hljs-comment">[0]</span>;<br>        for (int i = 0; i &lt; n; i++)<br>        &#123;<br>            dp<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>);<br>            if(i - 1 &gt;= 0)<br>                dp<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i]</span>);<br>            else<br>                dp<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[1]</span> = dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>;<br>        &#125;<br>        return dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[0]</span>;<br>    &#125;<br>&#125;;<br><br>-----dp<span class="hljs-comment">[n+2]</span><span class="hljs-comment">[2]</span>-----<br>class Solution &#123;<br>public:<br>    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;<br>        int n = prices.size();<br>        int dp<span class="hljs-comment">[n + 2]</span><span class="hljs-comment">[2]</span>;<br>        memset(dp, 0, sizeof dp);<br>        dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 0, dp<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> = -prices<span class="hljs-comment">[0]</span>;<br>        for (int i = 0; i &lt; n; i++)<br>        &#123;<br>            dp<span class="hljs-comment">[i + 2]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>);<br>            dp<span class="hljs-comment">[i + 2]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i]</span>);<br>        &#125;<br>        return dp<span class="hljs-comment">[n + 1]</span><span class="hljs-comment">[0]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="优化DP-2"><a href="#优化DP-2" class="headerlink" title="优化DP"></a>优化DP</h3><p>可以观察到，更新二维数组时，只用到<code>dp[i - 1][0]</code>,<code>dp[i - 1][1]</code>和<code>dp[i - 2][0]</code>三个值，即可以用三个变量代替二维数组</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices) &#123;<br>        <span class="hljs-type">int</span> f0 = <span class="hljs-number">0</span>, f1 = -prices[<span class="hljs-number">0</span>], last = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>, <span class="hljs-built_in">second</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> auto&amp; price : prices)<br>        &#123;<br>            tmp = f0;<br>            f0 = <span class="hljs-built_in">max</span>(f0, f1 + price);<br>            f1 = <span class="hljs-built_in">max</span>(f1, <span class="hljs-built_in">second</span> - price);<br>            <span class="hljs-built_in">second</span> = last;<br>            last = f0;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f0;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h2><p>无限制次数交易，但每笔交易需要手续费，是买卖股票的最佳时机II的变形题</p><h3 id="DP-10"><a href="#DP-10" class="headerlink" title="DP"></a><strong>DP</strong></h3><p>用二维数组<code>dp</code>储存持有股票和非持有股票两种状态下的最大利润</p><ul><li><p><code>dp[i][0]</code>表示当前不持有股票的最大利润，可得<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code>，即继续保持前一天不持股的最大利润，或者是将前一天的股票卖出得今天的最大利润</p></li><li><p><code>dp[i][1]</code>表示当前持有股票的最大利润，可得<code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code>，即继续保持前一天持股，或者将前一天持的股卖出获得利润，当天入股的最大利润</p></li><li><p>根据状态转移方程将<code>dp[0][0] = 0, dp[0][1] = -price[0]</code>作为初始值</p></li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;<br>        int n = prices.size();<br>        int dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[2]</span>;<br>        memset(dp, 0, sizeof dp);<br>        dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 0, dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> = -prices<span class="hljs-comment">[0]</span>;<br>        for(int i = 1; i &lt; n; i++)<br>        &#123;<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span> - fee);<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i]</span>);<br>        &#125;<br>        return dp<span class="hljs-comment">[n - 1]</span><span class="hljs-comment">[0]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a></h2><p>最多完成k笔交易，需要增加一种状态表示交易数</p><h3 id="DFS递归-记忆化"><a href="#DFS递归-记忆化" class="headerlink" title="DFS递归+记忆化"></a>DFS递归+记忆化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> memo[n+<span class="hljs-number">1</span>][k+<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">memset</span>(memo, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> memo);<br><br>        function&lt;<span class="hljs-type">int</span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">bool</span> flag)-&gt; <span class="hljs-type">int</span>&#123;<br>            <span class="hljs-keyword">if</span>(j &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 交易次数为负，返回INT_MIN</span><br>                <span class="hljs-keyword">return</span> INT_MIN;<br>            <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 初始化时并没有利润，返回INT_MIN或0</span><br>                <span class="hljs-keyword">return</span> flag ? INT_MIN : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(memo[i][j][flag] != <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> memo[i][j][flag];<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-comment">// 持有股票</span><br>            &#123;<br>                memo[i][j][flag] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j, <span class="hljs-number">1</span>), <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j, <span class="hljs-number">0</span>) - prices[i]);<br>                <span class="hljs-keyword">return</span> memo[i][j][flag];<br>            &#125;<br>            memo[i][j][flag] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j, <span class="hljs-number">0</span>), <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) + prices[i]);<br>            <span class="hljs-keyword">return</span> memo[i][j][flag];<br>        &#125;;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, k, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>递归结束条件：交易次数不足 或 遍历完所有天数的股票，前者返回负无穷，后者返回0或负无穷作为从头开始搜索的初始条件——不持股票状态下，最大利润为0；持股票时，最大利润为负无穷</p><h3 id="DP-11"><a href="#DP-11" class="headerlink" title="DP"></a><strong>DP</strong></h3><p>用三维数组<code>dp</code>储存持股和交易次数两大类状态下的最大利润</p><ul><li><p><code>dp[i][j][0]</code>表示当前<strong>不持有股票</strong>，<strong>交易次数为j (j &lt;&#x3D; k)<strong>时的最大利润，可得<code>dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j - 1][1] + prices[i])</code>，即继续保持前一天的最大利润，</strong>不持股也不交易</strong>，或者是<strong>在前一天持股，当天卖出状态下</strong>的最大利润</p></li><li><p><code>dp[i][j][1]</code>表示当前**持有股票，交易次数为j (j &lt;&#x3D; k)**的最大利润，可得<code>dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j][0] - prices[i])</code>，即继续保持前一天持股不交易，或者**在前一天不持股，当天购入状态下的最大利润**。<u>统一将卖出股票时才算交易完成，交易次数+1</u></p></li><li><p>根据状态转移方程，三维数组元素初始化为大负数（由题目数据量可知&lt;1000），再将<code>dp[0][j][0] = 0</code>作为初始值</p></li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;<br>        int n = prices.size();<br>        int dp<span class="hljs-comment">[n + 1]</span><span class="hljs-comment">[k + 2]</span><span class="hljs-comment">[2]</span>; // <span class="hljs-comment">[-1, k]</span> 避免 k = -1 情况，整体右移； i同理<br>        memset(dp, -0x7f, sizeof dp);// 全都初始化为INT_MIN<br>        // fill_n(dp, (n+1)*2*(k+2), INT_MIN); <br>        for(int j = 0; j &lt; k + 2; j++) // 在交易次数为0且不持股时，最大利润初始化为0<br>        // &#123;<br>            // dp<span class="hljs-comment">[1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> = 0;<br>            // dp<span class="hljs-comment">[1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span> = -prices<span class="hljs-comment">[0]</span>;<br>        // &#125;<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> = 0;<br>        // dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span>? ---&gt; 需要 i 从 0 开始遍历<br>        for(int i = 0; i &lt; n; i++)<br>        &#123;<br>            for(int j = 1; j &lt; k + 2; j++)<br>            &#123;<br>                dp<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>);<br>                dp<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i]</span>);<br>            &#125;<br>        &#125;<br>        return dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[k + 1]</span><span class="hljs-comment">[0]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由DFS翻译成递推，可得初始条件为<code>dp[0][j][0] = 0, dp[0][j][1] = -prices[0]</code>，可以从<code>i=1</code>开始遍历而不是<code>i=0</code></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;<br>        int n = prices.size();<br>        int dp<span class="hljs-comment">[n + 1]</span><span class="hljs-comment">[k + 2]</span><span class="hljs-comment">[2]</span>; // <span class="hljs-comment">[-1, k]</span> 避免 k = -1 情况，整体右移； i同理<br>        memset(dp, -0x7f, sizeof dp);// 全都初始化为INT_MIN<br>        // fill_n(dp, (n+1)*2*(k+2), INT_MIN); <br>        for(int j = 0; j &lt; k + 2; j++) // 在交易次数为0且不持股时，最大利润初始化为0<br>        &#123;<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> = 0;<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span> = -prices<span class="hljs-comment">[0]</span>;<br>        &#125;<br>            // dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> = 0;<br>        // dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span>? ---&gt; 需要 i 从 0 开始遍历<br>        for(int i = 1; i &lt;= n; i++)<br>        &#123;<br>            for(int j = 1; j &lt; k + 2; j++)<br>            &#123;<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i - 1]</span>);<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i - 1]</span>);<br>            &#125;<br>        &#125;<br>        return dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[k + 1]</span><span class="hljs-comment">[0]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a></h2><p>最多完成两笔交易，固定数组第三维为3，表示交易的次数</p><h3 id="DP-12"><a href="#DP-12" class="headerlink" title="DP"></a><strong>DP</strong></h3><p>用三维数组<code>dp</code>储存持股和交易次数两大类状态下的最大利润</p><ul><li><p><code>dp[i][j][0]</code>表示当前<strong>不持有股票</strong>，<strong>交易次数为j (j &lt;&#x3D; 2)<strong>时的最大利润，可得<code>dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j - 1][1] + prices[i])</code>，即继续保持前一天的最大利润，</strong>不持股也不交易</strong>，或者是<strong>在前一天持股，当天卖出状态下</strong>的最大利润</p></li><li><p><code>dp[i][j][1]</code>表示当前**持有股票，交易次数为j (j &lt;&#x3D; 2)**的最大利润，可得<code>dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j][0] - prices[i])</code>，即继续保持前一天持股不交易，或者**在前一天不持股，当天购入状态下的最大利润**。<u>统一将卖出股票时才算交易完成，交易次数+1</u></p></li><li><p>根据状态转移方程，三维数组元素初始化为大负数（由题目数据量可知&lt;100000），再将<code>dp[0][j][0] = 0</code>作为初始值</p></li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;<br>        int n = prices.size();<br>        int dp<span class="hljs-comment">[n + 1]</span><span class="hljs-comment">[4]</span><span class="hljs-comment">[2]</span>; // <span class="hljs-comment">[-1, k]</span> 避免 k = -1 情况，整体右移； i同理<br>        memset(dp, -0x7f, sizeof dp);// 全都初始化为INT_MIN<br>        // fill_n(dp, (n+1)*2*(k+2), INT_MIN); <br>        for(int j = 0; j &lt; 4; j++) // 在交易次数为0且不持股时，最大利润初始化为0<br>        // &#123;<br>            // dp<span class="hljs-comment">[1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> = 0;<br>            // dp<span class="hljs-comment">[1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span> = -prices<span class="hljs-comment">[0]</span>;<br>        // &#125;<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> = 0;<br>        // dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span>? ---&gt; 需要 i 从 0 开始遍历<br>        for(int i = 0; i &lt; n; i++)<br>        &#123;<br>            for(int j = 1; j &lt; 4; j++)<br>            &#123;<br>                dp<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>);<br>                dp<span class="hljs-comment">[i + 1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i]</span>);<br>            &#125;<br>        &#125;<br>        return dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[3]</span><span class="hljs-comment">[0]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode贪心算法章节</title>
    <link href="/2022/11/15/LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/"/>
    <url>/2022/11/15/LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode贪心算法章节"><a href="#LeetCode贪心算法章节" class="headerlink" title="LeetCode贪心算法章节"></a>LeetCode贪心算法章节</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>以每个人的胃口作为阈值，只有给够饼干才能满足，那么为了满足更多的人，则应根据胃口有小到大排序，在饼干数量一定情况下，先满足胃口小的可以让更多人得到满足</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> find<span class="hljs-constructor">ContentChildren(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">g</span>, <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.size<span class="hljs-literal">()</span>==<span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        sort(g.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>,g.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>        sort(s.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>,s.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>        <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;g.size<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>j&lt;s.size<span class="hljs-literal">()</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(g<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>&lt;=s<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)<br>            &#123;<br>                res++;<br>                i++;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>&gt;s<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)<br>                j++;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目中用到的贪心算法思想，局部最优就是<strong>小饼干先喂饱小胃口</strong>，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**</p><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><strong>摆动序列</strong></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>根据数组前后差值关系，求出最长的摆动子序列，其中，子序列也可以删除原序列的某个元素。也就是说，不改变序列顺序，忽略非摆动的子序列，从中找到摆动子序列并拼接，求出最大的长度。</p><p>局部最优就是通过删除在单一坡度（单调序列）上的元素，使其出现两个峰值，如在<code>5,1,4,6,3</code>中，<code>1,4,6</code>为单一坡度，在删除元素4之后，就变成摆动序列，或者延长了摆动序列。实际操作中，可以忽略掉单调坡上的元素，只取两端，统计使出现峰值的转折点元素</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p><code>res</code>初始为1（默认最右面有一个峰值），此时<code>cursub</code>&gt; 0 &amp;&amp;<code>presub</code>&lt;&#x3D; 0，那么res++（计算了左面的峰值），最后得到的<code>res</code>就是2（峰值个数为2即摆动序列长度为2）</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> wiggleMaxLength(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> presub = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> cursub = <span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++)<br>        &#123;  <br>            cursub = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-keyword">if</span>((cursub &gt; <span class="hljs-number">0</span> &amp;&amp; presub &lt;= <span class="hljs-number">0</span>)||(cursub &lt; <span class="hljs-number">0</span> &amp;&amp; presub &gt;= <span class="hljs-number">0</span>))<br>            &#123;<br>                res++;<br>                presub = cursub;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述版本中，判断条件为<code>presub &lt;= 0</code>和<code>presub&gt; = 0</code>，让<code>presub</code>等于0也进入结果集收集，是因为在一开始<code>presub</code>为0。另外，考虑到出现相邻相同元素时，此时<code>cursub=0</code>，不会被统计到结果中，并且，<code>presub</code>也不会更新成0，就是为了阻止非严格单调序列也会被统计到，如<code>1,5,3,3,2</code>，如果每次都更新<code>presub</code>，令<code>presub=cursub</code>，当遇到相同元素时，所有相同元素不被统计成摆动序列（因为<code>cursub=0</code>)，但相同元素的下一个元素无论是否符合摆动，都会被统计成摆动序列里（因为此时<code>presub=0</code>）</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> wiggleMaxLength(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;=<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> presub = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> cursub = <span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++)<br>        &#123;  <br>            cursub = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-keyword">if</span>(cursub==<span class="hljs-number">0</span>)   <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(cursub*presub &lt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                res++;<br>            &#125;<br>            presub = cursub;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上版本使用不同方法判断摆动，<code>cursub * presub &lt;= 0</code>，还要增加<code>if(cursub==0)   continue;</code>，当遇到相同元素时，<code>cursub=0</code>则直接跳过当次循环，也不会更新<code>presub</code>，直到遇到不同的元素。也就是相当于去重处理</p><h3 id="动规"><a href="#动规" class="headerlink" title="动规"></a>动规</h3><p>利用动态规划思想</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>保持区间波动，只需要把单调区间上的元素移除就可以了，通过局部最优达到全局最优</p><p>本题关键在于对摆动子序列的统计判断条件，即当遇到相同元素时如何处理</p><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><strong>最大子数组和</strong></h2><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>寻找相加和最大时的子数组，与上题不同，上题不允许排序但能删掉中间的元素，是一种拼凑的子序列，本题要求是连续的子数组，容易想到的是用两层for循环以及双指针解法，其中，双层for循环能够实现但会导致超时，时间复杂度为O(n^2)；双指针法其实并不能够在单次循环中实现，在有正负交错的情况下，不能找到最大子数组的边界点。</p><p>贪心算法的局部最优思路路是，在求和过程中，一旦求和值为负数，则应舍弃掉之前的子序列，再重新从下一个元素开始求和</p><p>整体代码如下</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> maxSubArray(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> res = INT_MIN;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">sum</span> += nums[i];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&gt;res)<br>                res = <span class="hljs-keyword">sum</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，</p><ul><li>当遇到连续正数时，<code>sum</code>一直增长并更新<code>res</code></li><li>当遇到连续负数时，第一个负数与<code>INT_MIN</code>对比肯定会更新到<code>res</code>中，后面的负数再更新到保持为0的<code>sum</code>中，最后跟已存到<code>res</code>的第一个负数做大小比较，取较大值</li><li>当遇到正数+负数+正数时，访问到负数时，只要<code>sum</code>值还没变为负数，都会一直扩大子序列，因为可能后面还会有正数使得子序列和更大，而当后面一直是负数直到<code>sum&lt;0</code>，那么就会重新开始计算子序列的最大和，因为从下一个正数开始的子序列和必然比负数大，这也是为何是<code>if(sum&lt;0)</code>而不是<code>if(nums[i]&lt;0)</code></li><li>时间复杂度为O(n)，遍历数组所有元素一次，空间复杂度为O(1)，占用常数级空间存放变量</li></ul><h3 id="动规-1"><a href="#动规-1" class="headerlink" title="动规"></a>动规</h3><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治的思想与递归回溯有些类似，通过划分子区间，直到区间元素个数为1，再回升合并，更新维护相应的变量，直到回到原始数组区间。因此，关键在于1. 要维护的信息 2. 如何在合并区间时更新这些信息</p><ol><li><code>lsum</code>维护包含左端点在内的最大子序列和</li><li><code>rsum</code>维护包含右端点在内的最大子序列和</li><li><code>isum</code>维护区间数组的最大子序列和</li><li><code>sum</code>维护区间数组的总和</li></ol><p>在合并<code>s1</code>和<code>s2</code>区间时，为了维护<code>isum</code>即最终求取的结果，都会用到以上的信息，这也是需要维护以上信息的原因</p><ol><li><code>sum = s1.sum + s2.sum</code>数组总和直接相加</li><li><code>lsum = max(s1.sum, s1.sum + s2.lsum)</code>取原左区间<code>lsum</code>和合并区间<code>lsum</code>即<code>s1.sum+s2.lsum</code>的最大值</li><li><code>rsum</code>同上</li><li><code>isum</code>有三种可能，可以是左区间的<code>isum</code>，也可能是右区间的<code>isum</code>，还有一种可能是合并之后跨越两个区间，此时<code>isum = s1.rsum + s2.lsum</code></li></ol><p>整体代码如下</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs maxima">class Solution &#123;<br>public:<br>    struct <span class="hljs-built_in">status</span>&#123;<br>        int <span class="hljs-built_in">lsum</span>, rsum, isum, <span class="hljs-built_in">sum</span>;<br>    &#125;;<br>    <span class="hljs-built_in">status</span> pushup(<span class="hljs-built_in">status</span>&amp;s1, <span class="hljs-built_in">status</span>&amp;s2)<br>    &#123;<br>        int <span class="hljs-built_in">sum</span> = s1.<span class="hljs-built_in">sum</span> + s2.<span class="hljs-built_in">sum</span>;<br>        int <span class="hljs-built_in">lsum</span> = <span class="hljs-built_in">max</span>(s1.<span class="hljs-built_in">lsum</span>, s1.<span class="hljs-built_in">sum</span>+s2.<span class="hljs-built_in">lsum</span>);<br>        int rsum = <span class="hljs-built_in">max</span>(s2.rsum, s2.<span class="hljs-built_in">sum</span>+s1.rsum);<br>        int isum = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(s1.isum,s2.isum), s1.rsum+s2.<span class="hljs-built_in">lsum</span>);<br>        <span class="hljs-built_in">return</span> (<span class="hljs-built_in">status</span>) &#123;<span class="hljs-built_in">lsum</span>, rsum, isum, <span class="hljs-built_in">sum</span>&#125;;<br>    &#125;<br>    <span class="hljs-built_in">status</span> <span class="hljs-built_in">get</span>(<span class="hljs-built_in">vector</span>&lt;int&gt;&amp; nums, int st, int en)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(st==en)<br>        &#123;<br>            <span class="hljs-built_in">return</span> (<span class="hljs-built_in">status</span>) &#123;nums[st],nums[st],nums[st],nums[st]&#125;;<br>        &#125;<br>        int mid = (st + en) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">status</span> s1 = <span class="hljs-built_in">get</span>(nums, st, mid);<br>        <span class="hljs-built_in">status</span> s2 = <span class="hljs-built_in">get</span>(nums, mid+<span class="hljs-number">1</span>, en);<br>        <span class="hljs-built_in">return</span> pushup(s1,s2);<br>    &#125;<br>    int maxSubArray(<span class="hljs-built_in">vector</span>&lt;int&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">return</span> <span class="hljs-built_in">get</span>(nums,<span class="hljs-number">0</span>,nums.size()-<span class="hljs-number">1</span>).isum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度O(n)，遍历数组所有元素一次，空间复杂度O(log n)，递归占用了栈空间</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>贪心算法能够在遍历数组的时候遇到子数组和为负数时及时舍弃，再重新从零开始，也是其贪的局部最优思想。</p><p>分治算法</p><ul><li>在于不断切割子区间，利用递归回溯思想把问题转化求解子区间的问题，<strong>最关键的地方在于合并区间时对信息的更新维护</strong></li><li>如果在合并区间上要存取的信息较多，函数参数冗杂，<strong>可以通过结构体来实现信息的传递</strong></li><li>虽然分治算法时间复杂度与贪心相同，且空间复杂度上由于递归比贪心要差，但分治算法<strong>构建了线段树</strong>，<strong>能做到快速访问任何子区间上的最大子序列和</strong>，访问的时间复杂度为O(log n)，对于<strong>大规模查询</strong>的情况下，这种方法的优势便体现了出来</li></ul><h2 id="买卖股票最佳时机II"><a href="#买卖股票最佳时机II" class="headerlink" title="买卖股票最佳时机II"></a>买卖股票最佳时机II</h2><h3 id="贪心-2"><a href="#贪心-2" class="headerlink" title="贪心"></a>贪心</h3><p>用贪心思想较为简单，由于没有买入卖出次数限制，只考虑每天的盈亏情况，再把所有盈余的情况相加即可</p><p>整体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; prices.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(prices[i+<span class="hljs-number">1</span>]-prices[i]&gt;<span class="hljs-number">0</span>)<br>                res += prices[i+<span class="hljs-number">1</span>] - prices[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="动规-2"><a href="#动规-2" class="headerlink" title="动规"></a>动规</h3><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>贪心算法中，局部最优是将最大利润划分成每天能获取的利润，贪在只获取盈余的部分，舍弃亏钱的部分</p><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><h3 id="贪心-3"><a href="#贪心-3" class="headerlink" title="贪心"></a>贪心</h3><p>通过for循环里从头开始遍历数组的所有元素，借助一个变量<code>tmp</code>记录当前元素下往前所能达到的最大范围，并且在遍历过程中不断更新这个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmp&lt;<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            tmp = <span class="hljs-built_in">max</span>(tmp, nums[i]);<br>            --tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>贪心算法思想中局部最优是 当前位置下能够到达的最远范围，即<code>tmp</code>变量，贪在了不断更新当前位置下的最远范围，通过这个来判断能否到达目的位置</p><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a><strong>跳跃游戏II</strong></h2><h3 id="贪心-4"><a href="#贪心-4" class="headerlink" title="贪心"></a>贪心</h3><p>贪心算法局部最优在于<strong>寻找当前能覆盖的最大范围</strong>，在遍历数组时遇到这个最大范围的边界点，则更新在遍历时遇到的最大范围以及更新跳数，即遇到了上一个最大范围则需要进行下一跳</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> en = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            tmp = <span class="hljs-built_in">max</span>(nums[i]+i,tmp);<br>            <span class="hljs-keyword">if</span>(i == en)<br>            &#123;<br>                en = tmp;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>与上一题解法相比，都是用一次的数组遍历，但上题中<strong>记录的是以当前位置作为基准，所能到达的最远距离</strong>，且在<strong>遍历每一个点时都会更新这个距离</strong>；而这一题中因为能确保到达数组的最后一个位置，<strong>记录的是能够覆盖的最大范围</strong>，且<strong>只在到达了上一个最大范围时才更新这个范围</strong></p><h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>不断通过排序，对最小的元素进行取反，直到剩余取反次数为0</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> largest<span class="hljs-constructor">SumAfterKNegations(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        sort(nums.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>,nums.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>        <span class="hljs-keyword">while</span>(k--)<br>        &#123;<br>            nums<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = -nums<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>            sort(nums.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>,nums.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>        &#125;<br>        return accumulate(nums.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>,nums.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="贪心1"><a href="#贪心1" class="headerlink" title="贪心1"></a>贪心1</h3><p>显然，有着很多的重复排序操作，考虑只进行一次遍历和排序</p><p>由于有正数和负数，可以通过由小到大排序数组并分类讨论</p><ul><li><strong>如果当前最小元素是正数，且剩余取反次数是偶数，则可以直接返回</strong></li><li><strong>如果当前最小元素是正数，且剩余取反次数是奇数，则重新排序对最小值进行取反再返回</strong></li><li>如果当前最小元素是负数，且剩余取反次数大于0，则直接取反并移动到下一个元素</li><li>如果移动到下一个元素超出数组范围，且剩余取反次数大于0，则移动到数组首元素，这种情况下，原数组全为负数而此时数组全为正数，则只需判断剩余取反次数的奇偶性。</li></ul><p>整体代码如下</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> largestSumAfterKNegations(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span> res = accumulate(nums.begin(),nums.end(),<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">sort</span>(nums.begin(),nums.end());<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>( k &amp;&amp; i&lt;nums.<span class="hljs-keyword">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; k % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">sort</span>(nums.begin(),nums.end());<br>                nums[<span class="hljs-number">0</span>] = -nums[<span class="hljs-number">0</span>];<br>                res += <span class="hljs-number">2</span>*nums[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            nums[i] = -nums[i];<br>            res += nums[i]*<span class="hljs-number">2</span>;<br>            ++i;<br>            --k;<br>            <span class="hljs-keyword">if</span>(k &amp;&amp; i == nums.<span class="hljs-keyword">size</span>())       <span class="hljs-comment">//全负数且k &gt;= num.size()</span><br>                i = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="贪心2"><a href="#贪心2" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种解法，用不同的方式排序，按照<strong>绝对值大小</strong>进行排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>( k &amp;&amp; i &lt; nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                nums[i] = -nums[i];<br>                res += <span class="hljs-number">2</span>*nums[i];<br>                --k;<br>            &#125;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k &amp;&amp; k%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)<br>        &#123;<br>            nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>] *= <span class="hljs-number">-1</span>;<br>            res += <span class="hljs-number">2</span>*nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>贪心算法局部最优是将最小的负数取反，最大化数组和。</p><p>取到最小的负数就需要对数组的排序，可以有两种不同的排序方式，按值从小到大排序和按绝对值从小到大排序。从小到大排序会导致在对所有负数取反 而剩余取反次数大于零时，额外需要排序来对最小的整数进行取反。按绝对值排序则可以解决这个问题，当数组全为正数时，可直接根据剩余取反次数是否对数组末尾元素或首元素进行取反</p><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><strong>加油站</strong></h2><p>容易想到的是暴力解法，判断能否循环一圈，只需要在循环中间油量不会变为负数即返回<code>true</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">bool</span> ok(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas,vector&lt;<span class="hljs-type">int</span>&gt;&amp; <span class="hljs-keyword">cost</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> times = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> tank = gas[<span class="hljs-keyword">index</span>];<br>        <span class="hljs-keyword">while</span>(times &lt;= gas.size())<br>        &#123;<br><br>            tank -= <span class="hljs-keyword">cost</span>[<span class="hljs-keyword">index</span>];<br>            <span class="hljs-keyword">if</span>(tank&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">index</span>++;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span>&gt;gas.size()<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>            tank += gas[<span class="hljs-keyword">index</span>];<br>            times++;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>遍历数组，判断以当前元素开始能否循环一圈，但时间复杂度会达到O(n^2)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    bool ok(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; gas,vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; cost, <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>)<br>    &#123;<br>        <span class="hljs-built_in">int</span> times = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> tank = gas[<span class="hljs-keyword">index</span>];<br>        <span class="hljs-keyword">while</span>(times &lt;= gas.size())<br>        &#123;<br><br>            tank -= cost[<span class="hljs-keyword">index</span>];<br>            <span class="hljs-keyword">if</span>(tank&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">index</span>++;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span>&gt;gas.size()<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>            tank += gas[<span class="hljs-keyword">index</span>];<br>            times++;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> canCompleteCircuit(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; cost) &#123;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">int</span> tank = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt;gas.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(gas[i] &lt; cost[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(ok(gas,cost,i))<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="暴力优化"><a href="#暴力优化" class="headerlink" title="暴力优化"></a>暴力优化</h3><p>在暴力法中，每次都会有重复的遍历，因此可以借助容器记录遍历过的元素，记录<strong>该元素能走到最远的地方</strong>以及<strong>剩余的油量</strong>，下一次当再次遍历到该元素时则直接跳到保存的最远地方同时加上剩余的油量</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(gas.size(),<span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(gas.size())</span></span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;gas.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-type">int</span> cur = gas[i];<br>            <span class="hljs-keyword">while</span>(cur-cost[j]&gt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                cur -= cost[j];<br>                j = (j+<span class="hljs-number">1</span>) % gas.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">if</span>(dist[j]!=<span class="hljs-number">-1</span>)<br>                &#123;<br>                    cur += tmp[j];<br>                    j = dist[j];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    cur += gas[j];<br>                <span class="hljs-keyword">if</span>(j==i &amp;&amp; cur&gt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            dist[i] = j;<br>            tmp[i] = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>虽然减少了重复访问的时间，利用了空间换取时间的思想，但对时间提升并不明显，依然是超出时间限制。</p><h3 id="暴力再优化"><a href="#暴力再优化" class="headerlink" title="暴力再优化"></a>暴力再优化</h3><p>进一步考虑，<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，也就是说，在遍历过程中，遍历完<code>i</code>之后即可直接跳转到<code>j+1</code>位置上</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(gas.size(),<span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(gas.size())</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;gas.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-type">int</span> cur = gas[i];<br>            <span class="hljs-keyword">while</span>(cur-cost[j]&gt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                cur -= cost[j];<br>                j = (j+<span class="hljs-number">1</span>)%gas.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">if</span>(dist[j]!=<span class="hljs-number">-1</span>)<br>                &#123;<br>                    cur += tmp[j];<br>                    j = dist[j];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    cur += gas[j];<br>                <span class="hljs-keyword">if</span>(i == j)<br>                    <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            dist[i] = j;<br>            tmp[i] = cur;<br>            <span class="hljs-keyword">if</span>(i&lt;j)<br>                i = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以不借助数组，只占用常数级空间，显得更为简洁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;gas.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-type">int</span> cur = gas[i];<br>            <span class="hljs-keyword">while</span>(cur-cost[j]&gt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                cur -= cost[j];<br>                j = (j+<span class="hljs-number">1</span>)%gas.<span class="hljs-built_in">size</span>();<br>                cur += gas[j];<br>                <span class="hljs-keyword">if</span>(i == j)<br>                    <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &lt; j)<br>                i = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="贪心-5"><a href="#贪心-5" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cursum = <span class="hljs-number">0</span>, tosum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;gas.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = gas[i] - cost[i];<br>            cursum += tmp;<br>            tosum += tmp;<br>            <span class="hljs-keyword">if</span>(cursum &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>            cursum = <span class="hljs-number">0</span>;<br>            res = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tosum &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>贪心算法<strong>局部最优在于找到符合当前油量足以到达下一站点的位置</strong>，借助<code>cursum</code>来记录，一旦<code>cursum</code>小于零，即在<code>i</code>站点出发不能够循环一圈，就马上从下一个站点重新出发，并把<code>cursum</code>置零</p><p>同样使用到上述的一个条件——<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，那么此时就应该从<code>j+1</code>继续遍历</p><p>同时记录总油量，来判断是否存在任何站点都无法循环一圈的情况</p><h3 id="贪心special"><a href="#贪心special" class="headerlink" title="贪心special"></a>贪心special</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> tosum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tmpsum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> mintmp = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;gas.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            tmpsum = gas[i] - cost[i];<br>            tosum += tmpsum;<br>            <span class="hljs-keyword">if</span>(tosum &lt; mintmp)<br>                mintmp = tosum;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tosum&lt;<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(mintmp &gt;= <span class="hljs-number">0</span>)     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = gas.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            tmpsum = gas[i] - cost[i];<br>            mintmp += tmpsum;<br>            <span class="hljs-keyword">if</span>(mintmp &gt;=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有如下几种情况：</p><ol><li>任何一个站点都无法循环一圈，遍历一遍数组后<code>tosum</code>小于0，则返回-1</li><li>从0开始遍历一遍数组后，<code>tosum</code>大于0且中途油箱最小值<code>mintmp</code>都大于0，则可以循环一圈，且从位置0开始，返回0</li><li>从0开始遍历一遍数组后，<code>tosum</code>大于0但中途油箱最小值<code>mintmp</code>小于0，则可以循环一圈，但不从位置0开始，逆向遍历数组，不断加上路径某个站点净获得油量，当<code>mintmp</code>大于等于0时，即从该位置开始可以循环一圈</li></ol><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>本题的关键点在于理解到<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，由暴力解法优化而来的方法，因为都是在遍历数组时要直接模拟一圈循环，因此时间复杂度上会比贪心算法只遍历一遍数组要慢，但却有很好的优化方向，<strong>通过减少重复过程优化</strong>以及<strong>通过空间换取时间优化</strong>。贪心算法贪在了<strong>从当前站点出发，累加<code>tmp</code>的和<code>curSum</code>一旦小于0就要舍弃，新的起始位置至少要是j+1</strong></p><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><strong>分发糖果</strong></h2><h3 id="贪心1-1"><a href="#贪心1-1" class="headerlink" title="贪心1"></a>贪心1</h3><p>尽可能少的分发糖果，则每个人初始化为1，<code>for</code>循环遍历一次数组，根据当前元素与其前后元素对比，有以下情况</p><ul><li><p>若一直递增或递减</p><ul><li><p>当前元素<code>i</code>大于<code>i-1</code>，那么<code>tmp++</code>表示当前分发的糖果数量要比<code>i-1</code>多一个</p></li><li><p>当前元素<code>i</code>小于<code>i-1</code>，则同样<code>tmp++</code>，只考虑总数量</p></li></ul></li><li><p>若遇到转折点，用<code>cur</code>记录当前的趋势，即<code>cur&gt;0</code>表示递增，<code>cur&lt;0</code>递减，<code>cur==0</code>表示第一个值或相等值</p><ul><li>从<code>cur&gt;=0</code>变成<code>cur&lt;0</code>，<code>tmp</code>重新置为1，<code>tmp++</code>后再加入到总数量中，即在转折点之后应该分发两个糖果</li><li>从<code>cur&lt;=0</code>变成<code>cur&gt;0</code>时，<code>tmp</code>就应该置为0，<code>tmp++</code>后再加入到总数量中，因为分数比前一个小，分发的糖果就应该重置为1，同时要区分<code>cur&lt;0</code>和<code>cur==0</code>的情况</li></ul></li></ul><p>代码如下</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> candy(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; ratings) &#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ratings.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || ratings[i] == ratings[i<span class="hljs-number">-1</span>])<br>            &#123;<br>                tmp = <span class="hljs-number">1</span>;<br>                res += tmp;<br>                cur = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(ratings[i] &gt; ratings[i<span class="hljs-number">-1</span>])</span></span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">if</span>(cur &lt;= <span class="hljs-number">0</span>)<br>                &#123;<br>                    cur = <span class="hljs-number">1</span>;<br>                    tmp = <span class="hljs-number">1</span>;<br>                &#125;<br>                ++tmp;<br>                res += tmp;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(ratings[i] &lt; ratings[i<span class="hljs-number">-1</span>])</span></span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">if</span>(cur &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    cur = <span class="hljs-number">-1</span>;<br>                    tmp = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(cur == <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">                </span>&#123;<br>                    cur = <span class="hljs-number">-1</span>;<br>                    tmp = <span class="hljs-number">1</span>;<br>                &#125;<br>                ++tmp;<br>                res += tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述忽略了一种特殊情况——<strong>当递增序列转折成递减序列，且递减序列长度大于等于递增序列后，转折点分发的糖果要再随递增序列增加而增加</strong>，因为转折点既属于递增也属于递减序列，<strong>它的糖果数量由两条序列中较长的一条决定</strong></p><p>因此，只是记录序列的转折情况是不足够的，**需要同时记录下递增序列<code>inc</code>和递减序列的长度<code>dec</code>**，以及当前序列的长度<code>tmp</code>，也相当于当前应分发的糖果数量</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">class Solution &#123;<br><span class="hljs-symbol">public:</span><br>    <span class="hljs-keyword">int</span> candy(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; ratings) &#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">inc</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">dec</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        for(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; ratings.size();i++)</span><br>        &#123;<br>            if(i == <span class="hljs-number">0</span> || ratings[i] == ratings[i-<span class="hljs-number">1</span>])<br>            &#123;<br>                tmp = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>                res += tmp<span class="hljs-comment">;</span><br>                <span class="hljs-keyword">inc</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>                <span class="hljs-keyword">dec</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>            &#125;<br>            else if (ratings[i] &gt; ratings[i-<span class="hljs-number">1</span>])<br>            &#123;<br>                ++tmp<span class="hljs-comment">;</span><br>                res += tmp<span class="hljs-comment">;</span><br>                <span class="hljs-keyword">dec</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>                <span class="hljs-keyword">inc</span> = tmp<span class="hljs-comment">;</span><br>            &#125;<br>            else if (ratings[i] &lt; ratings[i-<span class="hljs-number">1</span>])<br>            &#123;<br>                ++<span class="hljs-keyword">dec</span><span class="hljs-comment">;</span><br>                if(<span class="hljs-keyword">dec</span> == <span class="hljs-keyword">inc</span>)<br>                    ++<span class="hljs-keyword">dec</span><span class="hljs-comment">;</span><br>                res += <span class="hljs-keyword">dec</span><span class="hljs-comment">;               </span><br>                tmp = <span class="hljs-number">1</span><span class="hljs-comment">; </span><br>            &#125;<br>        &#125;<br>        return res<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="贪心2-1"><a href="#贪心2-1" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种思路是，分开两次从头至尾和从尾至头遍历数组，分别完成两条规则，从头至尾遍历保证右边分数高的糖果多于左边分数低的，从尾至头遍历保证左边分数高的糖果多于右边分数低的。</p><p>贪心算法局部最优在于保证当前糖果数量与上一个的糖果数量满足规则要求，但每次遍历只能满足一条规则</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">can</span><span class="hljs-params">(ratings.size(),<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;ratings.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i<span class="hljs-number">-1</span>])<br>                can[i] = can[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>; i&gt;= <span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>])<br>                can[i] = <span class="hljs-built_in">max</span>(can[i], can[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(can.<span class="hljs-built_in">begin</span>(),can.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>贪心1中思路更直接，但需要考虑的情况会更复杂，需要注意到<strong>转折序列中，递增和递减序列长度对转折点的影响</strong></p><p>贪心2分别使用了两次贪心策略，让题目要求更简洁明了</p><h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><strong>根据身高重建队列</strong></h2><p>本题中，数组<code>[h, k]</code>序号为<code>i</code>，这意味着 身高为<code>h</code>，并且在队列前面还有<code>k</code>个身高高于或等于<code>h</code>的人，要求在于对打乱的<code>i</code>重新排序成正确顺序，使得<code>h</code>和<code>k</code>排列符合规则</p><h3 id="贪心-6"><a href="#贪心-6" class="headerlink" title="贪心"></a>贪心</h3><p>在一次遍历中，并不能做到满足两条规则，需要分两步走，根据规则各自使用贪心策略。<strong>首先，对于数组的第0个元素，即身高，排列时的局部最优在于当前身高小于上一个身高，也就是按照降序排列身高</strong>。而对于第1个元素k，根据规则，应当按照升序排列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br></code></pre></td></tr></table></figure><p>排列过后，数组<code>people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</code>顺序变为<code>[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</code>，可知，根据规则，在空的结果集中插入数组，贪心策略局部最优在于优先插入身高较高（即遍历排列后的数组）且其k较低的，如下插入过程所示，这样可以满足插入后的数组满足要求</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[7,0]</span><br><span class="hljs-selector-attr">[7,0]</span>,<span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[7,0]</span>,<span class="hljs-selector-attr">[6,1]</span>,<span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[5,0]</span>,<span class="hljs-selector-attr">[7,0]</span>,<span class="hljs-selector-attr">[6,1]</span>,<span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[5,0]</span>,<span class="hljs-selector-attr">[7,0]</span>,<span class="hljs-selector-attr">[5,2]</span>,<span class="hljs-selector-attr">[6,1]</span>,<span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[5,0]</span>,<span class="hljs-selector-attr">[7,0]</span>,<span class="hljs-selector-attr">[5,2]</span>,<span class="hljs-selector-attr">[6,1]</span>,<span class="hljs-selector-attr">[4,4]</span>,<span class="hljs-selector-attr">[7,1]</span><br></code></pre></td></tr></table></figure><p><strong>第二步中的贪心优先处理身高较高的，在较高的排列完成后，就算再插入次高的元素也不会影响排列，依旧符合规则，在插入次高元素时，由于规则要求在此元素之前要有k个身高大于等于其身高的元素，因此，可以直接在位置k插入，使得局部上最优。</strong></p><p>整体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; v2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (v1[<span class="hljs-number">0</span>] != v2[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> v1[<span class="hljs-number">0</span>] &gt; v2[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> v1[<span class="hljs-number">1</span>] &lt; v2[<span class="hljs-number">1</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>() + people[i][<span class="hljs-number">1</span>],people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>在定义<code>cmp</code>函数时，将其定义为<code>static</code>静态函数是因为在类内定义函数，如果定义成非静态函数，则函数属于类的对象，而非类共有的函数，也就是说会隐式传递了<code>this</code>指针，那么类的对象在调用该函数的时候，就会通过指针隐式传递到函数参数列表中，来区分是哪一个对象调用函数，非静态函数实际参数为<code>bool cmp(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2, Solution* this)</code></strong></p><h3 id="贪心优化"><a href="#贪心优化" class="headerlink" title="贪心优化"></a>贪心优化</h3><p>在上一版本中的代码中，借助数组来记录结果，而数组在进行<code>insert</code>操作时，时间复杂度为O(n)，显得并不高效，因此可以借助链表来完成多次的插入操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; v2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (v1[<span class="hljs-number">0</span>] != v2[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> v1[<span class="hljs-number">0</span>] &gt; v2[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> v1[<span class="hljs-number">1</span>] &lt; v2[<span class="hljs-number">1</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> index = people[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">auto</span> iter = res.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">while</span>(index--)<br>            &#123;<br>                iter++;<br>            &#125;<br>            res.<span class="hljs-built_in">insert</span>(iter,people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; (res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>在调整迭代器位置时，还可以使用<code>advance</code>标准库函数，<code>advance(it,n)</code>可以让迭代器<code>it</code>往前移动<code>n</code>个位置</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">auto <span class="hljs-keyword">index</span> = people[i][<span class="hljs-number">1</span>];<br>auto iter = res.<span class="hljs-keyword">begin</span>();<br>advance(iter, <span class="hljs-keyword">index</span>);<br>res.<span class="hljs-keyword">insert</span>(iter, people[i]);<br></code></pre></td></tr></table></figure><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>与[上一题](# 分发糖果)比较，都是需要分两步走，把规则拆分成两步再分别使用贪心策略，这一题中最关键点在于在第二步中的贪心策略，<strong>局部最优在于插入一个元素时，只考虑当前规则是要求只有k个值在其前面，因此可以直接插入到第k个位置上，并且插入之后也不会影响已经插入的元素，符合规则</strong></p><h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><strong>用最少数量的箭引爆气球</strong></h2><p>这道题中，使用数量尽可能少的箭引爆更多的气球，首先，可以用过排序让带有重叠区间的数组分布在一起，而排序则又可以分为两种，分别是根据开始位置和结束位置，对应了不同方向的思路</p><h3 id="贪心1-2"><a href="#贪心1-2" class="headerlink" title="贪心1"></a>贪心1</h3><p>按照开始位置来进行排序，定义排序函数，开始位置小的会排在前面，如果开始位置相同，则结束位置更小的排在前面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，对于数组<code>[[10,16],[2,8],[1,6],[7,12]]</code>将会排序成<code>[[1,6],[2,8],[7,12],[10,16]]</code>，接着，为了追求最少数量的箭，在区间尽可能排序成重复的基础上，<strong>局部最优在于取重复数组区间的最小的结束位置</strong>，并在该位置上射出弓箭，这样就能尽可能覆盖到更多的不同区间，即引爆更多的气球</p><p>整体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]!=b[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = points.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-type">int</span> en = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(en &gt;= points[i][<span class="hljs-number">0</span>]) <span class="hljs-comment">//有重叠 </span><br>            &#123;<br>                res--;<br>                en = <span class="hljs-built_in">min</span>(points[i][<span class="hljs-number">1</span>], en); <br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                en = points[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用一个变量<code>en</code>来记录重复区间结束位置，<code>if(en &gt;= points[i][0])en = min(points[i][1], en)</code>当遇到有重叠区间时，应对<code>en</code>进行更新，令其等于 <strong>当前区间的结束位置</strong> 和 <strong>原结束位置</strong> 的最小值，而不是直接赋值等于当前区间的结束位置或上一个区间的结束位置。也因为不需要返回原数组，可以在原数组上直接修改结束位置，只需要判断上一个区间的结束位置，并不断对其进行维护<code>points[i][1] = min(points[i-1][1], points[i][1])</code></p><h3 id="贪心2-2"><a href="#贪心2-2" class="headerlink" title="贪心2"></a>贪心2</h3><p>另外一种方法是用不同的排序方法，按照区间的结束位置来进行排序，结束位置较小的则排在前面，如果结束位置相同则让开始位置较小的靠前（这一步不影响）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]==b[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>这种排序下，只需要判断<strong>当前区间的开始位置与重复区间的结束位置是否有重叠</strong>，用<code>en</code>来对重复区间的结束位置进行记录，如果没有则需要增加弓箭的数量，而如果开始位置小于等于上一个区间的结束位置，则无论如何两个区间都会有重叠，并且<strong>有重叠时不用对<code>en</code>进行更新，保持原来的重复区间结束位置</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-type">int</span> en = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(en &lt; points[i][<span class="hljs-number">0</span>]) <span class="hljs-comment">//无重叠 </span><br>            &#123;<br>                res++;<br>                en = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>两种排序方法引出两种对重叠区间不同的判断方式，且都是用到了贪心策略，<strong>尽可能让当前区间的开始元素与记录区间的结束元素有重叠，即通过排序再加上尽量去重叠区间的最大值，则可以覆盖到更多区间</strong></p><p>第一种排序方式，<strong>按区间的开始位置升序排列</strong>，借助变量<code>en</code>记录有重复区间的结束位置，不论是否有重叠区间，都要对<code>en</code>进行维护，<strong>当有重叠时，<code>en</code>取当前区间的结束位置和原结束位置的最小值</strong>；当没有重叠时，<code>en</code>则取当前区间的结束位置</p><p>第二种排序方式，<strong>按区间的结束位置升序排列</strong>，同样借助变量<code>en</code>对重叠区间的结束位置进行记录，因为是根据结束位置进行了排序，<strong>当有重叠时，对<code>en</code>不需要进行维护，因为<code>en</code>的值已经是当前包括之前所有区间的结束位置的最小值</strong>；在没有重叠时，<code>en</code>也同样取当前区间的结束位置</p><p>时间复杂度为O(n log n + n)，为排序消耗的时间和遍历数组的时间，空间复杂度为O(log n)，排序所占用的栈空间，最坏情况下为O(n)，需要n次的递归调用</p><h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>该题与[上一题](# 用最少数量的箭引爆气球)比较相像，都是有关于重叠的区间，而这题要求的是找出导致重叠的区间并将其删除，返回要删除的个数</p><h3 id="贪心-7"><a href="#贪心-7" class="headerlink" title="贪心"></a>贪心</h3><p>类似的，首先需要排序，让重叠的区间尽可能靠近，这里按照区间的结束位置升序排列，但对于相同的结束位置的区间，应该考虑到<strong>优先删除开始位置更小的区间</strong>，因为<strong>开始位置小，所覆盖的区间更大，出现与其他区间相互重叠的可能性也更大</strong>。因此遍历顺序应该是先确定区间结束位置更小，并且区间内所覆盖的范围也要更小，当遇到有重叠的区间则应该增加删除的数量</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    static <span class="hljs-built_in">bool</span> cmp(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]==b[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-built_in">int</span> eraseOverlapIntervals(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; <span class="hljs-built_in">int</span>ervals) &#123;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals.size()==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        sort(<span class="hljs-built_in">int</span>ervals.begin(),<span class="hljs-built_in">int</span>ervals.end(),cmp);<br>        <span class="hljs-built_in">int</span> en = <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">int</span>ervals.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(en &gt; <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>])<br>            &#123;<br>                res++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                en = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>该题中，<strong>局部优化在于按照区间的结束位置排序，并且要将范围更小的区间排列在先，是为了占用更小的空间，减少重叠的发生</strong></p><p>同样的，这题也可以<strong>按照区间的开始位置排序，这时要将范围更大的区间排列在先，并且是采用从右往左的遍历方式</strong>，也是出于相同的原因</p><h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><strong>划分字母区间</strong></h2><p>首先看到划分字符串想到的是回溯法，但在这题中并不需要暴力搜索。题目要求的是同一个字母只出现在一个分段中，而且只有分段最多的分法正确</p><p>首先需要遍历一次，得到所有字母对应的下标，借助可变数组来保存每个字母最后一次出现的下标位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hashmap</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>hashmap[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="贪心-8"><a href="#贪心-8" class="headerlink" title="贪心"></a>贪心</h3><p>在得到每个字母对应最远的下标后，使用贪心策略，局部最优在于<strong>一个分段尽可能小，但同时还要包含出现过的字母的所有范围</strong>，再对字符串进行遍历，对于一个片段，划分完成时，当前下标与哈希表中字母的最后一次出现的下标位置相同，并且，在遍历的过程中，对<code>tmp</code>更新为 <strong>当前字母的最远距离</strong> 和 <strong>原字母的最远距离</strong> 的较大值，也就是将<code>tmp</code>保持为该片段中含有的字母出现的最大位置或最远距离。也就是说，在一个片段中，划分只与该片段中有最长距离的字母有关，在遍历过程中，不断更新这个字母，当遍历到该字母的最长距离时，即一个片段的划分完成</p><p>整体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hashmap</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>, count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            hashmap[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            tmp = <span class="hljs-built_in">max</span>(tmp, hashmap[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span>(i==tmp)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(count);<br>                count = <span class="hljs-number">0</span>;<br>            &#125;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在该题中十分巧妙，贪在<strong>当前片段下，要让片段尽可能小的同时还要保证出现过的字母只在该片段中出现</strong>。这就需要借助哈希表来记录<strong>每个字母最后一次出现的位置</strong>，即它们各自的最大距离；在对字符串遍历过程中，还要维护<strong>保证每个出现过的字母的最远距离</strong>，这个距离就是这个片段长度的<strong>最小长度</strong></p><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>该题要求对有重叠的区间进行最大化合并，返回合并后的区间</p><p>类似于之前的有关重叠区间题目，该题也是将各区间进行排序后，再使用贪心策略，将尽可能多的区间进行合并</p><h3 id="贪心1-3"><a href="#贪心1-3" class="headerlink" title="贪心1"></a>贪心1</h3><p>先按照区间的结束位置升序排列，结束位置较小的排在前面。因为开始位置不影响结果，所以可不给出排序规则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><p>对于区间数组<code>[[1,10],[2,5],[6,9]]</code>则会排序变为<code>[[2,5],[6,9],[1,10]]</code>，接着，为了能够合并更多的区间，借助变量<code>tmp</code>取值为重叠区间的结束位置，<strong>正向遍历数组</strong>，当遇到<code>tmp &lt; intervals[i][0]</code>时代表没有重叠区间，则直接把该区间加入到结果集中，但当遍历到<code>[1,10]</code>时，该区间已将前面全部区间所包含，导致不正确的原因是遍历方式选择不正确，在该题中，<strong>如果按照区间的结束位置来排列，则遍历顺序应该是从尾到头的逆向遍历</strong></p><p>整体代码如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    static <span class="hljs-built_in">bool</span> cmp(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; b)<br>    &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; merge(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; <span class="hljs-built_in">int</span>ervals) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals;<br>        sort(<span class="hljs-built_in">int</span>ervals.begin(), <span class="hljs-built_in">int</span>ervals.end(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">int</span> st = <span class="hljs-built_in">int</span>ervals[<span class="hljs-built_in">int</span>ervals.size()<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], en = <span class="hljs-built_in">int</span>ervals[<span class="hljs-built_in">int</span>ervals.size()<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">int</span>ervals.size()<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st &lt;= <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]) <span class="hljs-comment">// 有重叠</span><br>            &#123;<br>                st = min(st, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res.push_back(vector&lt;<span class="hljs-built_in">int</span>&gt; &#123;st, en&#125;);<br>                st = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>];<br>                en = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        res.push_back(vector&lt;<span class="hljs-built_in">int</span>&gt; &#123;st,en&#125;);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="贪心2-3"><a href="#贪心2-3" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种方式则是<strong>按照开始位置升序排列，此时，应该正向遍历数组</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    static <span class="hljs-built_in">bool</span> cmp(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; b)<br>    &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; merge(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; <span class="hljs-built_in">int</span>ervals) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals;<br>        sort(<span class="hljs-built_in">int</span>ervals.begin(), <span class="hljs-built_in">int</span>ervals.end(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">int</span> st = <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], en = <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">int</span>ervals.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (en &gt;= <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>]) <span class="hljs-comment">// 有重叠</span><br>            &#123;<br>                en = max(<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>], en);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res.push_back(vector&lt;<span class="hljs-built_in">int</span>&gt; &#123;st, en&#125;);<br>                st = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>];<br>                en = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        res.push_back(vector&lt;<span class="hljs-built_in">int</span>&gt; &#123;st,en&#125;);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>该题与<a href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4">无重叠区间</a>相比有相反的感觉，都是要找到重叠区间的部分，但后者是优先寻找到范围更小的区间，是为了减少重叠的可能性；而这题是要优先找到范围更大的区间，就是为了要尽可能多的重叠区间。也因此，<strong>要根据不同的目的，针对不同排序方式下选用不同的遍历顺序</strong></p><h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>该题要求返回小于等于给定输入的尽可能大的数，并且返回值按位非严格递增，如给定<code>98</code>则返回<code>89</code></p><h3 id="贪心-9"><a href="#贪心-9" class="headerlink" title="贪心"></a>贪心</h3><p>要求返回的数尽可能大，那么局部最优在于先从低位修改，这也确定了遍历顺序是从右往左，如果<code>num[i]</code>大于<code>num[i+1]</code>，不符合按位递增规则，则<code>num[i]--; num[i+1]=&#39;9&#39;;</code>。但是如果给定输入为<code>1000</code>，只修改为<code>900</code>，而原本应该为<code>999</code>，因此，需要另外借助变量记录开始修改为9的位置，即<code>i+1</code>处，在<code>i+1</code>往后的位置都应该赋值为9</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>public:<br>    <span class="hljs-built_in">int</span> monotoneIncreasingDigits(<span class="hljs-built_in">int</span> n) &#123;<br>        string <span class="hljs-built_in">num</span> = to_string(n);<br>        <span class="hljs-built_in">int</span> flag = <span class="hljs-built_in">num</span>.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">num</span>.size() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">num</span>[i <span class="hljs-number">-1</span>] &gt; <span class="hljs-built_in">num</span>[i])<br>            &#123;<br>                <span class="hljs-built_in">num</span>[i - <span class="hljs-number">1</span>]--;<br>                flag = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = flag; i &lt; <span class="hljs-built_in">num</span>.size();i++)<br>        &#123;<br>            <span class="hljs-built_in">num</span>[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stoi(<span class="hljs-built_in">num</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(log n)，n为输入的数，log n对应其位数，空间复杂度为O(log n)，占用log n的空间来存放数的每一位</p><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在于 <strong>为了取到最大值，从数的低位开始修改</strong>，这就确定了从右往左的遍历顺序；还需要有标志位来记录需要变为9的所有位置</p><h2 id="买卖股票最佳时机I"><a href="#买卖股票最佳时机I" class="headerlink" title="买卖股票最佳时机I"></a><strong>买卖股票最佳时机I</strong></h2><p>与[同系列的上一题](# 买卖股票最佳时机II)相比，该题还增加了手续费，相当于限制了买卖次数，需要找到除去手续费后的最大利润，而不能像上一题那样无限制买入卖出</p><h3 id="贪心-10"><a href="#贪心-10" class="headerlink" title="贪心"></a>贪心</h3><p>思路依旧还是 希望能够在最低点买入，然后在最高点卖出，而因为有了手续费，还会有新的情况需要考虑到：<strong>如何知道当前点是最高点</strong></p><p>贪心策略就是用于解决这个问题，首先遍历寻找最低点进行买入，并维护<code>buy = prices[l]+fee</code>，此时<code>l</code>为最低点，如果遍历到该点利润大于零，可以虚拟地卖出了这只股票，利润值增加<code>profit += prices[sh] - buy = prices[sh] - prices[l] -fee</code>，此时<code>sh</code>为次高点，并且已经扣除了手续费，模拟在这个次高点虚拟卖出，同时还要更新买入价格为 <strong>当前股票价格</strong>，即<code>buy = prices[sh]</code>，如此一来，当遍历到下一个点发现股票价格还在上涨时<code>prices[h]&gt;prices[sh]</code>，则又虚拟的假设成在这个最高点上卖出了股票，由于买入价格的更新，利润值更新为<code>profit += prices[h] - buy = prices[h] -prices[sh] </code>，可以看出，根据这时候获得的利润，可以模拟出<strong>最低点买入而在最高点卖出</strong>的过程</p><p>整体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> buy = prices[<span class="hljs-number">0</span>] + fee;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(prices[i]+fee &lt; buy)<br>                buy = prices[i] + fee;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prices[i] &gt; buy)<br>            &#123;<br>                res += prices[i] - buy;<br>                buy = prices[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n)，空间复杂度为O(1)</p><p>相同思路，而不必将<code>buy</code>维护成最低买入点与手续费的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> buy = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(prices[i] &lt; buy)<br>                buy = prices[i] ;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prices[i] &gt; buy + fee)<br>            &#123;<br>                res += prices[i] - buy - fee;<br>                buy = prices[i]-fee;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在该题中体现在 <strong>遇到次高点时虚拟的卖出，更新利润的同时也更新买入价格，即虚拟地在该点买入</strong>，这也是局部最优的所在</p><p>遍历数组的时候，会有以下三种情况：</p><ul><li>该点比买入点更低，则更新买入的最低点</li><li>该点比买入点和手续费的和更高，即利润大于0，此时虚拟地卖出，更新利润以及更新买入点，也为后续更高点准备</li><li>该点在<code>[低买入点+手续费，高卖出点]</code>范围，即没有利润，则此时不会卖出，不进行任何操作</li></ul><h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a><strong>监控二叉树</strong></h2><p>题目要求添加最少的监控，覆盖到所有的二叉树结点</p><p>一开始，想到根据父结点的值来判断当前结点是否需要添加监控，如果父结点值为0，则为当前结点添加监控；反之亦然。同时使用层序迭代遍历二叉树即可完成</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    int minCameraCover(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(!root-&gt;<span class="hljs-built_in">left</span> &amp;&amp; !root-&gt;<span class="hljs-built_in">right</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        int res = <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;//还要存父结点<br>        //层序遍历<br>        TreeNode* pre, *cur;<br>        que.push(nullptr);<br>        que.push(root);<br>        while(!que.empty())<br>        &#123;<br>            <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; que.size(); i++)<br>            &#123;<br>                pre = que.front();<br>                que.pop();<br>                cur = que.front();<br>                que.pop();<br><br>                <span class="hljs-keyword">if</span>(pre &amp;&amp; pre-&gt;val == <span class="hljs-number">0</span> &amp;&amp; (cur-&gt;<span class="hljs-built_in">left</span>|<span class="hljs-type">|cur</span>-&gt;<span class="hljs-built_in">right</span>))<br>                &#123;<br>                    res++;<br>                    cur-&gt;val = <span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(cur-&gt;<span class="hljs-built_in">left</span>)<br>                &#123;<br>                    que.push(cur);<br>                    que.push(cur-&gt;<span class="hljs-built_in">left</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur-&gt;<span class="hljs-built_in">right</span>)<br>                &#123;<br>                    que.push(cur);<br>                    que.push(cur-&gt;<span class="hljs-built_in">right</span>);<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然而，这种方法下，当遇到的二叉树<strong>添加监控的结点的孙子结点是叶子结点时，则无法做到监控的全覆盖</strong></p><h3 id="贪心-11"><a href="#贪心-11" class="headerlink" title="贪心"></a>贪心</h3><p>采用贪心策略，局部最优在于<strong>为了添加的监控数量最少，则只给叶子结点的父结点添加监控</strong></p><p>针对以上，结点值会有三种状态：<strong>0表示无覆盖，1表示有监控，2表示被覆盖</strong>。增加结点值为 2 是为了方便表示叶子结点等的状态，进而，二叉树的遍历顺序应为<strong>后序遍历</strong>，先遍历子结点再遍历中间结点，由下至上的遍历顺序</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>int dfs(TreeNode* node, int&amp; res)<br>&#123;<br><span class="hljs-keyword">if</span>(!node)//遇到空结点应返回<span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>int l = dfs(node-&gt;<span class="hljs-built_in">left</span>, res);<br>int r = dfs(node-&gt;<span class="hljs-built_in">right</span>, res);<br><br><span class="hljs-keyword">if</span>(l == <span class="hljs-number">2</span> &amp;&amp; r == <span class="hljs-number">2</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span> |<span class="hljs-type">| r</span> == <span class="hljs-number">0</span>)<br>         &#123;<br>         res++;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>         &#125;<br>         <span class="hljs-keyword">if</span>(l == <span class="hljs-number">1</span> |<span class="hljs-type">| r</span> == <span class="hljs-number">1</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>         <br>         <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>    int minCameraCover(TreeNode* root) &#123;<br>        int res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(dfs(root, res) == <span class="hljs-number">0</span>)<br>        res++;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n)，空间复杂度为O(log n)，最坏情况下为O(n)</p><p>因为后序遍历中，中间结点的处理情况需要用到其左右子结点的值来判断，因此，<strong>将当前结点的值作为递归函数的返回值</strong>。</p><p>根据左右子结点的值来判断当前当前结点的值，有四种情况：</p><ul><li>左右子结点都是有覆盖，则当前结点返回0，表示无覆盖</li><li>左右子结点有任意一个无覆盖，则当前结点应添加监控，返回1</li><li>左右子结点有任意一个有监控，则当前结点返回2，表示有覆盖</li><li>在对除根结点外的所有结点遍历结束后，对于根结点，可能会出现根结点未覆盖的情况，因此还需要对根结点的返回值进行一次判断，若返回0则需要再添加一个监控</li></ul><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>该题中局部最优在于 <strong>不让叶子结点添加监控，而让叶子结点的父结点添加监控</strong>，在此基础上，推导出3种不同结点值的状况，并进行分类讨论</p><h2 id="通过最少操作次数使数组的和相等"><a href="#通过最少操作次数使数组的和相等" class="headerlink" title="通过最少操作次数使数组的和相等"></a><strong><a href="https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/">通过最少操作次数使数组的和相等</a></strong></h2><p>该题给定两个数组，限定数组元素值均为1~6，任意修改数组元素，使得两个数组和相等，返回操作次数</p><h3 id="贪心-12"><a href="#贪心-12" class="headerlink" title="贪心"></a>贪心</h3><p>采用贪心策略，局部最优在于优先让数组和大的数组元素改为1，数组和小的数组元素改为6，最快速逼近两个数组的和</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs perl">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> minOperations(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2) &#123;<br>        <span class="hljs-keyword">int</span> n1 = nums1.size();<br>        <span class="hljs-keyword">int</span> n2 = nums2.size();<br>        <span class="hljs-keyword">if</span>(n1*<span class="hljs-number">6</span> &lt; n2 || n2 * <span class="hljs-number">6</span> &lt; n1 )<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> = <span class="hljs-title">accumulate</span></span>(nums1.begin(), nums1.end(),0)-accumulate(nums2.begin(), nums2.end(),0);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-function"><span class="hljs-keyword">sub</span> &lt; 0)</span><br><span class="hljs-function">        </span>&#123;<br>            swap(nums1, nums2);<br>            <span class="hljs-function"><span class="hljs-keyword">sub</span> = -<span class="hljs-title">sub</span></span>;<br>        &#125;<br>        //要求nums1 减小， nums2 增大<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; cnt(<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">for</span>(auto n:nums1)<br>        &#123;<br>            cnt[n-<span class="hljs-number">1</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(auto n:nums2)<br>        &#123;<br>            cnt[<span class="hljs-number">6</span>-n]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>, res = <span class="hljs-number">0</span>;;i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i*cnt[i] &gt;= <span class="hljs-function"><span class="hljs-keyword">sub</span>)</span><br><span class="hljs-function">                <span class="hljs-title">return</span> <span class="hljs-title">res</span> + (<span class="hljs-title">sub</span>+<span class="hljs-title">i</span>-1)/<span class="hljs-title">i</span></span>;<br>            res += cnt[i];<br>            <span class="hljs-function"><span class="hljs-keyword">sub</span> -= <span class="hljs-title">i</span>*<span class="hljs-title">cnt</span>[<span class="hljs-title">i</span>]</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>让<code>nums1</code>的和比<code>nums2</code>的和大，即让<code>nums1</code>减小，<code>让nums2</code>增大；</p><p>分别遍历两个数组，借助<code>vector</code>容器记录两个数组中能够减小或增大的最大范围，如<code>cnt[4]</code>含义是数组中原始值为5或者为2的元素有<code>cnt[4]</code>个；</p><p>最后遍历<code>vector</code>容器，若当前减小或增大的最大范围能够覆盖两个数组的和的差，即<code>i*cnt[i] &gt;= sub</code>，意味着仅需要对当前<code>cnt[i]</code>个元素减小或增大<code>i</code>就能够让两个数组的和相等，否则，因为遍历顺序优先遍历修改范围更大的元素，所以先让这些元素对数组差进行填补，再遍历更小范围的元素；</p><p>返回值中<code>return res + (sub+i-1)/i;</code>而不是直接返回<code>return res + sub / i;</code>，若<code>sub</code>不能整除<code>i</code>，直接返回会有余数导致结果偏小不正确，若返回<code>return res + sub / i + 1</code>，此时若<code>sub</code>能整除<code>i</code>，没有余数又导致结果偏大不正确。因此<code>sub + i - 1</code>向上取整解决了这个问题</p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>局部最优在于<strong>优先让数组中修改范围更大的元素进行修改，以最快速度填补数组和之差</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C3P第三部分</title>
    <link href="/2022/11/09/C3P%E7%AC%AC%E4%B8%89%E3%80%81%E5%9B%9B%E9%83%A8%E5%88%86/"/>
    <url>/2022/11/09/C3P%E7%AC%AC%E4%B8%89%E3%80%81%E5%9B%9B%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是<strong>自身类类型的引用</strong>，且任何额外参数都有默认值，则此构造函数是<strong>拷贝构造函数</strong></p><p>合成拷贝构造函数可以用来阻止拷贝该类类型的对象</p><p><code>class Foo&#123; public: Foo(const Foo&amp;); &#125;</code></p><p><strong>合成的拷贝构造函数</strong>：会将参数的成员逐个拷贝到正在创建的对象中，内置类型直接拷贝，虽然不能直接拷贝一个数组，但会逐个元素进行拷贝，类类型则使用元素的拷贝函数</p><p>拷贝初始化通常使用拷贝构造函数来完成</p><ul><li>用<code>=</code>定义变量时。</li><li>将一个对象作为实参传递给一个非引用类型的形参。</li><li>从一个返回类型为非引用类型的函数返回一个对象。</li><li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。</li></ul><h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>赋值运算符通常返回一个指向其左侧运算对象的引用</p><p>合成拷贝赋值运算符可以用来禁止该类型对象的赋值</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数释放对象使用的资源，并销毁对象的非static数据成员，析构函数不接受参数，没有返回值</p><p>在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。析构函数体本身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的</p><p><strong>当指向一个对象的引用或指针离开作用域时，析构函数不会执行</strong></p><p>合成析构函数可以用来阻止该类型的对象被销毁</p><h3 id="三-x2F-五法则"><a href="#三-x2F-五法则" class="headerlink" title="三&#x2F;五法则"></a>三&#x2F;五法则</h3><ul><li>需要析构函数的类也需要拷贝和赋值操作</li><li>需要拷贝操作的类也需要赋值操作，反之亦然</li></ul><h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用<code>=default</code></h3><p>类内使用<code>=default</code>修饰成员的声明时，隐式声明了该成员为内联的</p><p>如果不希望合成的成员是内联函数，则应该对其类外定义使用<code>=default</code></p><h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><ul><li>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。</li><li>定义删除的函数：<code>=delete</code> ，虽然声明了它们，但是不能以任何方式使用它们。</li><li>析构函数不能是删除的成员。</li><li>如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的</li><li>对于具有引用或无法默认构造的<code>const</code>成员的类，编译器不会为其合成默认构造函数。如果具有引用成员的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍指向与赋值前一样的对象，因此对于有引用成员的类，合成拷贝赋值运算符也被定义为删除的</li></ul><h3 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h3><p>通常，管理类外资源的类必须定义拷贝控制成员</p><ul><li><p>类的行为像值：对象有自己的状态，副本和原对象是完全独立的</p><p>如果将一个对象赋予它自身，赋值运算符必须能正确工作；大多数赋值运算符组合了析构函数和拷贝构造函数的工作</p></li><li><p>行为像指针：共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据</p></li></ul><p>IO类型和<code>unique_ptr</code>不允许拷贝或赋值，因此它们的行为不像值也不像指针</p><h3 id="HasPtr程序"><a href="#HasPtr程序" class="headerlink" title="HasPtr程序"></a><strong><code>HasPtr</code>程序</strong></h3><p>定义行为像值的类</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">class</span> HasPtr&#123;<br><span class="hljs-keyword">public</span>:<br>HasPtr(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s = <span class="hljs-built_in">string</span>()): ps(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(s)), i(<span class="hljs-number">0</span>) &#123;&#125;<br><span class="hljs-comment">//拷贝构造</span><br>HasPtr(<span class="hljs-keyword">const</span> HasPtr&amp; p): ps(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*p.ps)), i(p.i) &#123;&#125;<br><span class="hljs-comment">//拷贝赋值运算符</span><br>HasPtr&amp; operator=(<span class="hljs-keyword">const</span> HasPtr&amp; hp)&#123;<br><span class="hljs-keyword">auto</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*hp.ps);<br><span class="hljs-keyword">delete</span> ps;<br>ps = tmp;<br>i = hp.i;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~HasPtr() &#123;<br><span class="hljs-keyword">if</span>(--*use==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">delete</span> ps;<br><span class="hljs-keyword">delete</span> use;<br>&#125;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">string</span>* ps;<br><span class="hljs-keyword">int</span> i;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>定义行为像指针的类</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>HasPtr(<span class="hljs-keyword">const</span> string&amp; s = string()): ps(<span class="hljs-keyword">new</span> string(s)), i(<span class="hljs-number">0</span>), <span class="hljs-keyword">use</span>(<span class="hljs-keyword">new</span> size_t(<span class="hljs-number">1</span>)) &#123;&#125;<br><span class="hljs-comment">//拷贝构造</span><br>HasPtr(<span class="hljs-keyword">const</span> HasPtr&amp; p): ps(p.ps), i(p.i), <span class="hljs-keyword">use</span>(p.use) &#123;++*<span class="hljs-keyword">use</span>;&#125;<br><span class="hljs-comment">//拷贝赋值运算符</span><br>HasPtr&amp; operator=(<span class="hljs-keyword">const</span> HasPtr&amp; hp)<br>&#123;<br>++*hp.use;<br><span class="hljs-keyword">if</span>(--*<span class="hljs-keyword">use</span>==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> ps;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">use</span>;<br>&#125;<br>ps = hp.ps;<br>i = hp.i;<br><span class="hljs-keyword">use</span> = hp.use;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~HasPtr() &#123;<span class="hljs-keyword">delete</span> ps;&#125;<br><span class="hljs-keyword">private</span>:<br>string* ps;<br>int i;<br><span class="hljs-comment">//引用计数，记录有多少对象共享相同的string</span><br>size_t *<span class="hljs-keyword">use</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h3><p>除了定义拷贝控制成员，管理资源的类通常还定义一个名为<code>swap</code>的函数。拷贝一个类值的<code>HasPtr</code>会分配一个新<code>string</code>并将其拷贝到<code>HasPtr</code>指向的位置，理论上这些内存分配是不必要的，因为可以只交换指针</p><p>类值版本下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtr</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(HasPtr&amp;, HasPtr&amp;)</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HasPtr</span>(<span class="hljs-type">const</span> string&amp; s = <span class="hljs-built_in">string</span>()): <span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(s)), <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><span class="hljs-comment">//拷贝构造</span><br><span class="hljs-built_in">HasPtr</span>(<span class="hljs-type">const</span> HasPtr&amp; p): <span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*p.ps)), <span class="hljs-built_in">i</span>(p.i) &#123;&#125;<br><span class="hljs-comment">//拷贝赋值运算符</span><br>HasPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HasPtr&amp; hp)&#123;<br>++*hp.use;<br><span class="hljs-keyword">if</span>(--*use==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> ps;<br><span class="hljs-keyword">delete</span> use;<br>&#125;<br>ps = hp.ps;<br>i = hp.i;<br>use = hp.use;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">HasPtr</span>() &#123;<br><span class="hljs-keyword">if</span>(--*use==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">delete</span> ps;<br><span class="hljs-keyword">delete</span> use;<br>&#125;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>string* ps;<br><span class="hljs-type">int</span> i;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(HasPtr&amp; lhs, HasPtr&amp; rhs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">swap</span>(lhs.ps,rhs.ps);<br><span class="hljs-built_in">swap</span>(lhs.i,rhs.i);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于三个<code>swap</code>参数类型不同， 不会导致递归循环，<code>swap</code>函数应该调用特定版本的<code>swap</code>而不是<code>std::swap</code></p><h3 id="在赋值运算符中使用swap"><a href="#在赋值运算符中使用swap" class="headerlink" title="在赋值运算符中使用swap"></a>在赋值运算符中使用<code>swap</code></h3><p><strong>定义swap的类通常用swap来定义它们的赋值运算符</strong>，使用<strong>拷贝并交换</strong>的技术</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span>=(HasPtr hp)<br>&#123;<br>swap(*<span class="hljs-keyword">this</span>, hp);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数不是引用，传入的是右侧运算对象的一个副本，交换副本与<code>*this</code>中的数据成员，<code>*this</code>将指向新分配的<code>string</code>——右侧运算对象中<code>string</code>的一个副本，当赋值运算符结束时，<code>hp</code>将被销毁，析构函数<code>delete</code>掉<code>hp</code>指向的内存，即原来左侧运算对象的内存。并且，它自动处理了自赋值情况，通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确</p><h3 id="拷贝控制示例"><a href="#拷贝控制示例" class="headerlink" title="拷贝控制示例"></a>拷贝控制示例</h3><p>两个类通过拷贝控制进行簿记操作，<code>Message</code>和<code>Folder</code>分别表示电子邮件消息和消息目录，每个<code>Message</code>对象可以出现在多个<code>Folder</code>中，每个<code>Folder</code>中记录其中的所有<code>Message</code>对象</p><p>在<code>Message</code>中保存一个它所在<code>Folder</code>的指针的<code>set</code>，每个<code>Folder</code>中保存它包含的<code>Message</code>的指针的<code>set</code>。<code>Message</code>类提供<code>save</code>和<code>remove</code>操作，用于创建或删除一个对象时与<code>Folder</code>相关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Folders</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span>&#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Folder</span>;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Message&amp;,Message&amp;)</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//不允许隐式转换</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s = <span class="hljs-string">&quot;&quot;</span>)</span>: contents(s) &#123;</span>&#125;<br><br><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-built_in">Message</span>(<span class="hljs-type">const</span> Message&amp; me): <span class="hljs-built_in">contents</span>(me.contents), <span class="hljs-built_in">folders</span>(me.folders)<br>&#123;<br><span class="hljs-comment">//但是在每个folder上并没有更新刚拷贝的Message对象</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> f:folders)<br>&#123;<br>f-&gt;<span class="hljs-built_in">addMsg</span>(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//调用Folder类中的函数添加Message指针</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//拷贝赋值运算符</span><br>Message&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Message&amp; me)<br>&#123;<br><span class="hljs-comment">//为了自赋值操作正常，先删除原有的指针，再进行添加</span><br><span class="hljs-comment">//如果非自赋值，this为空，则不删除；不为空，则需要删除原有的关联再拷贝赋值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> f:folders)<br>&#123;<br>f-&gt;<span class="hljs-built_in">remMsg</span>(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//调用Folder类中的函数删除Message指针</span><br>&#125;<br>contents = me.contents;<br>folders = me.folders;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> f:folders)<br>&#123;<br>f-&gt;<span class="hljs-built_in">addMsg</span>(me);<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Message</span>()<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> f:folders)<br>&#123;<br>f-&gt;<span class="hljs-built_in">remMsg</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Folder &amp;f)</span></span><br><span class="hljs-function"></span>&#123;<br>folders.<span class="hljs-built_in">insert</span>(&amp;f);<br>f-&gt;<span class="hljs-built_in">addMsg</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Folder &amp;f)</span></span><br><span class="hljs-function"></span>&#123;<br>folders.<span class="hljs-built_in">erase</span>(&amp;f);<br>f-&gt;<span class="hljs-built_in">remMsg</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addFldr</span><span class="hljs-params">(Folder *f)</span> </span>&#123; folders.<span class="hljs-built_in">insert</span>(f); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remFldr</span><span class="hljs-params">(Folder *f)</span> </span>&#123; folders.<span class="hljs-built_in">erase</span>(f); &#125;<br><span class="hljs-keyword">private</span>:<br>string contents;<span class="hljs-comment">//保存消息文本</span><br>set&lt;Folder*&gt; folders;<span class="hljs-comment">//保存包含该消息的Folder指针</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Message&amp; lme, Message&amp; rme)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> f:lme.folders)<br>&#123;<br>f-&gt;<span class="hljs-built_in">remMsg</span>(lme);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> f:rme.folders)<br>&#123;<br>f-&gt;<span class="hljs-built_in">remMsg</span>(rme);<br>&#125;<br><span class="hljs-built_in">swap</span>(lme.contents,rme.contents);<br><span class="hljs-built_in">swap</span>(lme.folders,rme.folders);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> f:lme.folders)<br>&#123;<br>f-&gt;<span class="hljs-built_in">addMsg</span>(lme);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> f:rme.folders)<br>&#123;<br>f-&gt;<span class="hljs-built_in">addMsg</span>(rme);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于拷贝构造函数和拷贝赋值运算符，都需要实现已关联的<code>folders</code>进行更新，因为是拷贝，所以要在每个与原<code>Message</code>对象有关联的<code>Folder</code>对象都增加与新拷贝得到的<code>Message</code>对象进行关联，同理删除也是。另外，拷贝赋值运算符需要额外删除关联，是为了自赋值情况能正常运行，非</p><p>[TOC]</p><p>自赋值情况下，也需要让原对象删除原有的关联，如果为空则不删除。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Folders</span>&#123;</span><br><span class="hljs-class">friend <span class="hljs-keyword">class</span> <span class="hljs-type">Message</span>;</span><br><span class="hljs-class">friend void swap(<span class="hljs-type">Folders</span>&amp;, <span class="hljs-type">Folders</span>&amp;);</span><br><span class="hljs-class">public:</span><br><span class="hljs-class"><span class="hljs-type">Folder</span>() = default;</span><br><span class="hljs-class"><span class="hljs-type">Folder</span>(<span class="hljs-title">const</span> <span class="hljs-type">Folder</span> &amp;);</span><br><span class="hljs-class"><span class="hljs-type">Folder</span>&amp; operator=(<span class="hljs-title">const</span> <span class="hljs-type">Folder</span> &amp;);</span><br><span class="hljs-class">~<span class="hljs-type">Folder</span>();</span><br><span class="hljs-class">private:</span><br><span class="hljs-class">set&lt;<span class="hljs-type">Message</span>*&gt; msgs;</span><br><span class="hljs-class"></span><br><span class="hljs-class">void add_to_Message(<span class="hljs-title">const</span> <span class="hljs-type">Folder</span>&amp;);</span><br><span class="hljs-class">void remove_from_Message();</span><br><span class="hljs-class"></span><br><span class="hljs-class">void addMsg(<span class="hljs-type">Message</span> *<span class="hljs-title">m</span>) &#123; msgs.insert(<span class="hljs-title">m</span>); &#125;</span><br><span class="hljs-class">void remMsg(<span class="hljs-type">Message</span> *<span class="hljs-title">m</span>) &#123; msgs.erase(<span class="hljs-title">m</span>); &#125;</span><br><span class="hljs-class">&#125;;</span><br><span class="hljs-class"></span><br><span class="hljs-class">void swap(<span class="hljs-type">Folders</span>&amp; <span class="hljs-title">lf</span>, <span class="hljs-type">Folders</span>&amp; <span class="hljs-title">rf</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class">lf.remove_from_Message();</span><br><span class="hljs-class">rf.remove_from_Message();</span><br><span class="hljs-class"></span><br><span class="hljs-class">swap(<span class="hljs-title">lf</span>.<span class="hljs-title">msgs</span>,<span class="hljs-title">rf</span>.<span class="hljs-title">msgs</span>);</span><br><span class="hljs-class"></span><br><span class="hljs-class">lf.add_to_Message();</span><br><span class="hljs-class">rf.add_to_Message();</span><br><span class="hljs-class">&#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">void <span class="hljs-type">Folders</span>::add_to_Message(<span class="hljs-title">const</span> <span class="hljs-type">Folder</span>&amp; <span class="hljs-title">f</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class">for(<span class="hljs-title">auto</span> <span class="hljs-title">m</span>: <span class="hljs-title">f</span>.<span class="hljs-title">msgs</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class">m-&gt;folders.insert(<span class="hljs-title">this</span>);</span><br><span class="hljs-class">&#125;</span><br><span class="hljs-class">&#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">void <span class="hljs-type">Folders</span>::remove_from_Message()</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class">for(<span class="hljs-title">auto</span> <span class="hljs-title">m</span>: <span class="hljs-title">msgs</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class">m-&gt;folders.erase(<span class="hljs-title">this</span>);</span><br><span class="hljs-class">&#125;</span><br><span class="hljs-class">&#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-type">Folder</span>::<span class="hljs-type">Folder</span>(<span class="hljs-title">const</span> <span class="hljs-type">Folder</span>&amp; <span class="hljs-title">f</span>): msgs(<span class="hljs-title">f</span>.<span class="hljs-title">msgs</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class">add_to_Message(<span class="hljs-title">f</span>);</span><br><span class="hljs-class">&#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-type">Folder</span>::~<span class="hljs-type">Folder</span>() </span><br><span class="hljs-class">&#123; </span><br><span class="hljs-class">    remove_from_Message(); </span><br><span class="hljs-class">&#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-type">Folder</span> &amp;<span class="hljs-type">Folder</span>::operator=(<span class="hljs-title">const</span> <span class="hljs-type">Folder</span> &amp;<span class="hljs-title">rhs</span>) </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class">    remove_from_Message();</span><br><span class="hljs-class">    msgs = rhs.msgs;</span><br><span class="hljs-class">    add_to_Message(<span class="hljs-title">rhs</span>);</span><br><span class="hljs-class">    return *this;</span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure><p><code>Folder</code>类封装了对<code>set</code>中每个<code>Message</code>对象添加和删除该<code>folder</code>对象的函数，减少代码冗余，其余与<code>Message</code>类一致</p><p>在以上两种类的拷贝赋值运算符中，都没有使用到拷贝并交换技术，是因为此技术适用在有动态内存分配情况下，如<code>HasPtr</code>的类值实现，否则会增加复杂度</p><h3 id="动态内存管理类程序"><a href="#动态内存管理类程序" class="headerlink" title="动态内存管理类程序"></a><strong>动态内存管理类程序</strong></h3><p>定义一个类似于<code>vector</code>的类，需要自己进行内存分配，就要定义拷贝控制成员来管理内存，这个类只用于<code>string</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">StrVec</span>&#123;<br><span class="hljs-keyword">public</span>:<br>StrVec(): elements(nullptr), first_free(nullptr), cap(nullptr) &#123;&#125;<br>StrVec(<span class="hljs-keyword">const</span> StrVec&amp;); <span class="hljs-comment">//拷贝构造函数</span><br>StrVec&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> StrVec&amp;);  <span class="hljs-comment">//拷贝赋值运算符</span><br>~StrVec();<span class="hljs-comment">//析构函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;</span>)</span>;<br><span class="hljs-function">size_t <span class="hljs-title">size</span>() <span class="hljs-keyword">const</span></span> &#123;<span class="hljs-keyword">return</span> first_free - elements;&#125;<br><span class="hljs-function">size_t <span class="hljs-title">capacity</span>() <span class="hljs-keyword">const</span></span> &#123;<span class="hljs-keyword">return</span> cap - first_free;&#125;<br><span class="hljs-built_in">string</span>* begin() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> elements;&#125;<br><span class="hljs-built_in">string</span>* end() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> first_free;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">static</span> allocator&lt;<span class="hljs-built_in">string</span>&gt; alloc;<br>pair&lt;<span class="hljs-built_in">string</span>*, <span class="hljs-built_in">string</span>*&gt; alloc_n_copy(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>*, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>*);<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">free</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">chk_n_alloc</span>()</span> &#123;<span class="hljs-keyword">if</span>(size==capacity()) reallocate();&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reallocate</span>()</span>;<br><br><span class="hljs-built_in">string</span>* elements;<span class="hljs-comment">//指向数组开头</span><br><span class="hljs-built_in">string</span>* first_free;<span class="hljs-comment">//指向数组最后一个元素的后一个位置</span><br><span class="hljs-built_in">string</span>* cap;<span class="hljs-comment">//指向分配的内存的后一个位置</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>alloc</code>是一个静态成员，类型是<code>allocator&lt;string&gt;</code>，能够分配<code>StrVec</code>的内存</li><li><code>alloc_n_copy</code>会分配内存，并拷贝一个给定范围中的元素</li><li><code>free</code>会销毁构造的元素并释放内存</li><li><code>chk_n_alloc_</code>保证<code>StrVec</code>至少有容纳一个新元素的空间，如果没有则调用<code>reallocate</code>分配更多内存</li><li><code>reallocate</code>在内存用完时为<code>StrVec</code>分配新内存</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void StrVec::push<span class="hljs-constructor">_back(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s</span>)</span><br>&#123;<br>chk<span class="hljs-constructor">_n_alloc()</span>;<br><span class="hljs-comment">//确保有足够空间容纳新元素</span><br>alloc.construct(first_free++, s);<br><span class="hljs-comment">//a.construct(p,args)  p是一个指针指向原始内存，在p指向的内存中用args构造一个对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>allocator</code>分配内存时，内存是<strong>未构造</strong>的，需要用<code>construct</code>函数在此内存中构造一个对象，同时<code>first_free</code>指针往后递增一位，指向下一个未构造的元素</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pair&lt;<span class="hljs-built_in">string</span>*, <span class="hljs-built_in">string</span>*&gt; StrVec::alloc<span class="hljs-constructor">_n_copy(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">ls</span>, <span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">rs</span>)</span><br>&#123;<br>auto data = alloc.allocate(rs - ls);<br>return &#123;data, unitialized<span class="hljs-constructor">_copy(<span class="hljs-params">ls</span>, <span class="hljs-params">rs</span>, <span class="hljs-params">data</span>)</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>rs - ls</code>尾后指针减去首元素指针得出元素空间大小，传给<code>allocate</code>函数返回所分配空间的首地址，<code>unitialzed_copy</code>由<code>ls</code>和<code>rs</code>之间的元素拷贝到<code>data</code>起始的内存中，返回最后一个构造元素之后的位置，即返回的<code>pair</code>由新构建的首元素指针和尾后指针组成</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">void StrVec::<span class="hljs-built_in">free</span>()<br>&#123;<br><span class="hljs-built_in">if</span>(elements)<br>&#123;<br><span class="hljs-built_in">for</span>(auto p = first_free;p!=elements;p--)<br>alloc<span class="hljs-selector-class">.destory</span>(elements);<br>alloc<span class="hljs-selector-class">.deallocate</span>(element, cap - elements);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//用for_each实现的free()</span><br><span class="hljs-built_in">for_each</span>(elements, first_free, [this](std::string &amp;rhs)&#123; alloc<span class="hljs-selector-class">.destroy</span>(&amp;rhs); &#125;);<br></code></pre></td></tr></table></figure><p><code>destroy</code>会执行<code>string</code>的析构函数，释放<code>string</code>自己分配的内存空间。当元素销毁后，要调用<code>deallocate</code>函数释放<code>StrVec</code>分配的内存空间，传递的必须是<strong>之前<code>allocate</code>调用所返回的指针</strong>，因此在调用前应<strong>先对指针判空</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">StrVec</span>::<span class="hljs-type">StrVec</span>(const <span class="hljs-type">StrVec</span>&amp; sv)<br>&#123;<br>auto <span class="hljs-class"><span class="hljs-keyword">data</span> = alloc.allocate(<span class="hljs-title">sv</span>.<span class="hljs-title">begin</span>(), sv.end());</span><br>elements = <span class="hljs-class"><span class="hljs-keyword">data</span>-&gt;first;</span><br>first_free = <span class="hljs-class"><span class="hljs-keyword">data</span>-&gt;second;</span><br>cap = <span class="hljs-class"><span class="hljs-keyword">data</span>-&gt;second;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在拷贝构造函数中直接调用<code>alloc_n_copy</code>，返回值是一个指针的<code>pair</code>，<code>first</code>指向的是第一个构造的元素，<code>second</code>指向的是最后一个元素之后的位置，由于<code>alloc_n_copy</code>分配的空间是刚好容纳给定的元素，所以<code>cap</code>也是在最后一个元素之后的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//析构函数直接调用free()</span><br>StrVec::~<span class="hljs-built_in">StrVec</span>()<br>&#123;<br><span class="hljs-built_in">free</span>();<br>&#125;<br><span class="hljs-comment">//拷贝赋值运算符</span><br>StrVec&amp; StrVec::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> StrVec&amp; sv)<br>&#123;<br><span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">alloc_n_copy</span>(sv.<span class="hljs-built_in">begin</span>(),sv.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">free</span>();<br>elements = data.first;<br>cap = first_free = data.second;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样地，拷贝赋值运算符也调用<code>alloc_n_copy</code>函数来初始化指针，为了排除赋值左边对象初始值的影响，要先调用<code>free()</code>函数对原对象进行析构，为了正确处理<strong>自赋值</strong>的情况，**<code>free</code>要在调用<code>alloc_n_copy</code>之后调用**</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StrVec::reallocate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> newcapacity = <span class="hljs-built_in">size</span>()? <span class="hljs-number">2</span> * <span class="hljs-built_in">size</span>() : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">auto</span> data = alloc.<span class="hljs-built_in">allocate</span>(newcapacity);<br>    <span class="hljs-keyword">auto</span> elem = data;<br>    <span class="hljs-keyword">auto</span> ori = elements;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>    alloc.<span class="hljs-built_in">construct</span>(elem++, std::<span class="hljs-built_in">move</span>(*ori++));<br>    &#125;<br>    <span class="hljs-built_in">free</span>();<br>    elements = data;<br>    first_free = elem;<br>    cap = elements + newcapacity;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先确定重新分配内存的大小，新分配的容量加倍，如果原对象为空，则分配容纳一个元素的空间。在for循环中，使用<code>construct</code>构建新的<code>string</code>对象，同时用<code>elem</code>表示初始内存的地址并将其不断递增，第二个参数调用<code>move</code>，返回值将会使得<code>construct</code>使用<code>string</code>的移动构造函数，那么这些<code>string</code>管理的内存<strong>将不会被拷贝</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">StrVec::<span class="hljs-constructor">StrVec(<span class="hljs-params">const</span> <span class="hljs-params">initializer_list</span>&lt;<span class="hljs-params">string</span>&gt;&amp; <span class="hljs-params">il</span>)</span><br>&#123;<br>auto data = alloc<span class="hljs-constructor">_n_copy(<span class="hljs-params">il</span>.<span class="hljs-params">begin</span>()</span>, il.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>elements = data.first;<br>cap = first_free = data.second;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>StrVec</code> 类添加一个构造函数，它接受一个 <code>initializer_list&lt;string&gt;</code> 参数，可以直接调用<code>alloc_n_copy</code>函数</p><h3 id="手撕string实现代码"><a href="#手撕string实现代码" class="headerlink" title="手撕string实现代码"></a><a href="https://github.com/chenshuo/recipes/blob/fcf9486f5155117fb8c36b6b0944c5486c71c421/string/StringTrivial.h">手撕string实现代码</a></h3><h3 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h3><p>[TOC]</p><p>很多拷贝操作后，原对象会被销毁，因此引入移动操作可以大幅度提升性能</p><p>标准库容器、<code>string</code>和<code>shared_ptr</code>类既可以支持移动也支持拷贝。<code>IO</code>类和<code>unique_ptr</code>类可以移动但不能拷贝。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>通过<code>&amp;&amp;</code>获得右值引用，只能绑定到一个将要销毁的对象，常规引用可以称之为左值引用。左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值</p><ul><li><strong>返回左值引用的函数</strong>，以及<strong>赋值、下标、解引用</strong>和<strong>前置递增递减运算符</strong>，可以将左值引用绑定这类返回左值表达式</li><li><strong>返回非引用的函数</strong>，以及<strong>算术、关系、位</strong>和<strong>后置递增递减运算符</strong>，不能用左值引用绑定，但可以用**<code>const</code>的左值引用或一个右值引用绑定**</li></ul><p>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象</p><p>不能将一个右值引用绑定到一个右值引用类型的变量上</p><p><code>int &amp;&amp; rr1 = 42;</code></p><p><code>int &amp;&amp; rr2 = rr1;//错误，rr1是左值</code></p><p><strong>move函数</strong>：</p><ul><li><code>int &amp;&amp;rr3 = std::move(rr1);</code></li><li><code>move</code>告诉编译器，我们有一个左值，但我希望像右值一样处理它。</li><li>调用<code>move</code>意味着：除了对<code>rr1</code>赋值或者销毁它外，我们将不再使用它。</li></ul><h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>类似于拷贝构造函数，移动构造函数的第一个参数是该类类型的<strong>右值引用</strong>，其余额外的参数都必须有默认实参</p><p>一旦资源完成移动，源对象必须不再指向被移动的对象</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">StrVec::<span class="hljs-constructor">StrVec(StrVec<span class="hljs-operator">&amp;&amp;</span> <span class="hljs-params">s</span>)</span> noexcept<br>: elements(s.elements), first<span class="hljs-constructor">_free(<span class="hljs-params">s</span>.<span class="hljs-params">first_free</span>)</span>, cap(s.cap)<br>&#123;<br>s.element = first_free = cap = nullptr;<br>&#125;<br></code></pre></td></tr></table></figure><p>移动构造函数<strong>接管给定的<code>StrVec</code>中的内存</strong>，将给定对象中的指针都置为<code>nullptr</code>，移后源对象会被销毁，将在其上运行析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">StrVec&amp; StrVec::<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;sv) <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-keyword">if</span>(*<span class="hljs-keyword">this</span>!=sv)<br>&#123;<br><span class="hljs-built_in">free</span>();<br>elements = sv.elements;<br>first_free = sv.elements;<br>cap = sv.cap;<br>sv.elements = sv.first_free = sv.cap = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于自赋值情况，<strong>移动赋值运算符通常会先检查this指针与sv的地址是否相同</strong>，如果相同，右侧和左侧对象指向相同的对象，则不做任何事直接返回该<code>StrVec</code>对象；否则，释放左侧运算对象的内存，并接管右侧对象的内存，最后再将右侧对象的指针置为<code>nullptr</code></p><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员（非static）都能移动时，编译器才会为它合成移动构造函数或移动赋值运算符</p><p>有类成员<strong>定义了自己的拷贝构造函数且未定义移动构造函数</strong>，或者类成员定义自己的拷贝构造函数且编译器不能为其合成移动构造函数，那么合成的移动操作定义为删除</p><p>定义了移动操作的类也必须定义自己的拷贝操作，否则，合成拷贝操作都被默认定义为删除的</p><p>对于既有移动构造函数，也有拷贝构造函数的类，将会<strong>移动右值，拷贝左值</strong>，但如果没有移动构造函数，<strong>右值也会被拷贝</strong></p><h3 id="拷贝并交换赋值运算符和移动操作"><a href="#拷贝并交换赋值运算符和移动操作" class="headerlink" title="拷贝并交换赋值运算符和移动操作"></a>拷贝并交换赋值运算符和移动操作</h3><p>[如前所示](# 在赋值运算符中使用<code>swap</code>)，非引用参数意味着参数要进行拷贝初始化，对于左值将被拷贝，而右值则会被移动，因此，<strong>单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符</strong></p><p><code>hp = hp2;</code></p><p><code>hp = std::move(hp2);</code></p><p>第一个赋值，右侧运算对象是一个左值，因此将使用拷贝构造函数来初始化；第二个赋值，调用<code>std::move</code>将一个右值引用绑定到<code>hp2</code>上，移动构造函数是精准匹配的，因此，将用移动构造函数拷贝指针，而不分配任何内存</p><p>但是，<code>haspt</code>会执行两次的拷贝，一次在调用<code>move</code>函数，另一次在移动赋值运算符拷贝给<code>this</code>指针；而对于普通的移动构造版本，则只会执行一次拷贝</p><h3 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h3><p>移动迭代器的解引用运算符生成一个右值引用</p><p><code>make_move_iterator</code>函数讲一个普通迭代器转换为一个移动迭代器</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs irpf90">void StrVec::reallocate()<br>&#123;<br>auto newcapacity = <span class="hljs-built_in">size</span>()? <span class="hljs-number">2</span> * <span class="hljs-built_in">size</span>() : <span class="hljs-number">1</span>;<br>    auto <span class="hljs-keyword">data</span> = alloc.<span class="hljs-built_in">allocate</span>(newcapacity);<br>    auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(<span class="hljs-keyword">end</span>()), <span class="hljs-keyword">data</span>);<br>    <span class="hljs-keyword">free</span>();<br>    elements = <span class="hljs-keyword">data</span>;<br>    first_free = last;<br>    cap = elements + newcapacity;<br>&#125;<br></code></pre></td></tr></table></figure><p>[原版本](# 动态内存管理类程序)中使用一个<code>for</code>循环来调用<code>construct</code>从旧内存将元素拷贝到新内存中。作为一种替换，将使用<code>uninitialized_copy</code>来构造新分配的内存，传入的是移动迭代器，解引用运算生成符生成的是一个右值引用，意味着<code>construct</code>将使用移动构造函数来构造元素</p><h3 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h3><p>区分移动和拷贝的重载函数通常有一个版本接受一个<code>cosnt T&amp;</code>，另一个版本接受<code>T &amp;&amp;</code></p><p>通过在参数列表后放置一个引用限定符，可以强制赋值运算符左侧运算对象是左值或者右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Foo &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp;) <span class="hljs-type">const</span> &amp;;<br>Foo &amp;<span class="hljs-keyword">operator</span>=(Foo &amp;&amp;) &amp;&amp;;<br></code></pre></td></tr></table></figure><p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Foo <span class="hljs-title">Foo::sorted</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp; </span>&#123;<br><span class="hljs-function">Foo <span class="hljs-title">ret</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br><span class="hljs-keyword">return</span> ret.<span class="hljs-built_in">sorted</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>会产生递归并且最终溢出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Foo <span class="hljs-title">Foo::sorted</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp; </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Foo</span>(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">sorted</span>(); &#125;<br></code></pre></td></tr></table></figure><p>与上一题不同，本题的写法可以正确利用右值引用版本来完成排序。原因在于，编译器认为Foo(*this)是一个[无主]的右值，对它调用sorted会匹配右值引用版本</p><h2 id="第十四章-重载运算与类型转换"><a href="#第十四章-重载运算与类型转换" class="headerlink" title="第十四章 重载运算与类型转换"></a>第十四章 重载运算与类型转换</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>如果一个运算符函数是<strong>成员函数</strong>，则它的第一个（左侧）运算对象绑定到<strong>隐式的this指针</strong>上，成员运算符函数的（显式）参数数量比运算符的运算对象少一个</p><p>对于一个运算符函数来说，它或者是<strong>类的成员</strong>，或者<strong>至少含有一个类类型的参数</strong></p><p><strong>赋值、下标、调用和成员访问运算符</strong>必须是成员函数</p><h3 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h3><p>必须是普通的非成员函数，需要读写非公有数据成员时，一般被声明为友元</p><p>输出运算符的第一个形参是一个非常量<code>ostream</code>对象的引用，因为向流写入内容会改变其状态，且无法拷贝一个<code>ostream</code>对象；第二个形参是一个常量的引用，是想要打印的类类型</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stan">ostream &amp;operator&lt;&lt;(ostream&amp; os, const Sales_data&amp; <span class="hljs-built_in">sd</span>)<br>&#123;<br>os &lt;&lt; <span class="hljs-built_in">sd</span>.isbn &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">sd</span>.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">sd</span>.revenue<br>&lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">sd</span>.avg_price();<br><span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出运算符尽量减少格式化操作，不应该打印换行符</p><p>输入运算符的第一个形参是一个非常量<code>istream</code>对象的引用，第二个形参是将要读入的对象的引用，非常量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp">istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; <span class="hljs-keyword">is</span>, Sales_data &amp;sd)<br>&#123;<br><span class="hljs-built_in">double</span> price;<br><span class="hljs-keyword">is</span> &gt;&gt; sd.bookNo &gt;&gt; sd.units_sold &gt;&gt; price;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">is</span>)<br>sd.revenue = sd.units_sold * price;<br><span class="hljs-keyword">else</span><br>sd = Sales_data();<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">is</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>if</code>语句检查读取操作是否成功，如果发生IO错误，则运算符将给定的对象重置为空<code>Sales_data</code></p><p>输入运算符必须处理输入可能失败的情况</p><h3 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h3><p>一般不需要改变运算对象的状态，所以形参都是常量的引用。计算两个运算对象并得到一个新值，通常位于一个局部变量之内，最终返回该局部变量的一个副本</p><p>如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符，可以避免使用临时对象</p><p>相等运算符和不等运算符的一个应该把工作委托给另一个</p><p>如果存在唯一一种逻辑可靠的<code>&lt;</code>定义，则应该考虑为这个类定义<code>&lt;</code>运算符。如果同时还包含<code>==</code>，则当且晋档<code>&lt;</code>的定义和<code>++</code>产生的结果一直时才定义<code>&lt;</code>运算符</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a><strong>赋值运算符</strong></h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">StrVec</span>&amp; <span class="hljs-type">StrVec</span>::operator=(initializer_list&lt;string&gt; il)<br>&#123;<br>auto <span class="hljs-class"><span class="hljs-keyword">data</span> = alloc_n_copy(<span class="hljs-title">il</span>.<span class="hljs-title">begin</span>(),il.end());</span><br>free();<br>elements = <span class="hljs-class"><span class="hljs-keyword">data</span>.first;</span><br>cap = first_free = <span class="hljs-class"><span class="hljs-keyword">data</span>.second;</span><br>return *this;<br>&#125;<br></code></pre></td></tr></table></figure><p>与<a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB%E7%A8%8B%E5%BA%8F">拷贝赋值运算符不同</a>，这个运算符无需检查对象向自身的赋值，因为形参<code>initializer_list</code>确保<code>il</code>与<code>this</code>指向的不是同一个对象</p><h3 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h3><p>以所访问元素的引用作为返回值，一般同时定义下标运算符的常量版本和非常量版本</p><h3 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h3><p>定义递增和递减运算符的类应该同时定义前置版本和后置版本</p><p>前置运算符应该返回递增或递减后对象的引用；后置运算符应该返回递增或递减前对象的值，后置版本接受一个额外的，不被使用的<code>int</code>类型的形参</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//前置版本</span><br><span class="hljs-keyword">inline</span> StrBlobPtr&amp; StrBlobPtr::<span class="hljs-keyword">operator</span>++()<br>&#123;<br>    check(curr, <span class="hljs-string">&quot;increment past end of StrBlobPtr&quot;</span>);<br>    ++curr;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-keyword">inline</span> StrBlobPtr&amp; StrBlobPtr::<span class="hljs-keyword">operator</span>--()<br>&#123;<br>--curr;<br>    check(curr, <span class="hljs-string">&quot;decrement past begin of StrBlobPtr&quot;</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//后置版本</span><br><span class="hljs-keyword">inline</span> StrBlobPtr StrBlobPtr::<span class="hljs-keyword">operator</span>++(int)<br>&#123;<br>    StrBlobPtr ret = *<span class="hljs-keyword">this</span>;<br>    ++*<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">inline</span> StrBlobPtr StrBlobPtr::<span class="hljs-keyword">operator</span>--(int)<br>&#123;<br>    StrBlobPtr ret = *<span class="hljs-keyword">this</span>;<br>    --*<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意前置递增运算符先将当前值传递给<code>check</code>函数，而递减运算符是先递减<code>curr</code>，再调用<code>check</code>函数</p><p>后置版本无需检查有效性，因为返回的是递增或递减前的状态的副本</p><h3 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">string&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span><br>&#123;<br>auto p = check(curr,<span class="hljs-string">&quot;dereference past end&quot;</span>);<br><span class="hljs-keyword">return</span> (*p)[curr];<br>&#125;<br><br>string&amp; <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span><br>&#123;<br><span class="hljs-keyword">return</span>&amp; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">operator</span>*();<br>&#125;<br></code></pre></td></tr></table></figure><p>解引用运算符检查<code>curr</code>是否在作用范围内，如果在则返回<code>curr</code>指针所指元素的引用；箭头运算符调用解引用运算符并返回解引用结果元素的地址</p><h3 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h3><p>如果累定义了调用运算符，则该类的对象称作<strong>函数对象</strong></p><p>一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别</p><p><code>lambda</code>捕获变量：<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，由<code>lambda</code>产生的类当中的函数调用运算符是一个<code>const</code> 成员函数</p><p><strong>标准库函数对象</strong>:</p><table><thead><tr><th>算术</th><th>关系</th><th>逻辑</th></tr></thead><tbody><tr><td><code>plus&lt;Type&gt;</code></td><td><code>equal_to&lt;Type&gt;</code></td><td><code>logical_and&lt;Type&gt;</code></td></tr><tr><td><code>minus&lt;Type&gt;</code></td><td><code>not_equal_to&lt;Type&gt;</code></td><td><code>logical_or&lt;Type&gt;</code></td></tr><tr><td><code>multiplies&lt;Type&gt;</code></td><td><code>greater&lt;Type&gt;</code></td><td><code>logical_not&lt;Type&gt;</code></td></tr><tr><td><code>divides&lt;Type&gt;</code></td><td><code>greater_equal&lt;Type&gt;</code></td><td></td></tr><tr><td><code>modulus&lt;Type&gt;</code></td><td><code>less&lt;Type&gt;</code></td><td></td></tr><tr><td><code>negate&lt;Type&gt;</code></td><td><code>less_equal&lt;Type&gt;</code></td><td></td></tr></tbody></table><p>比较两个指针将产生未定义的行为，但可以通过<strong>标准库函数对象</strong>比较指针内存地址</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml">vector&lt;<span class="hljs-built_in">string</span>*&gt; vec;<br>sort(vec.<span class="hljs-keyword">begin</span>(),vec.<span class="hljs-keyword">end</span>(),[](<span class="hljs-built_in">string</span>* a, <span class="hljs-built_in">string</span>* b) &#123;<span class="hljs-keyword">return</span> a &lt; b;&#125;);<span class="hljs-comment">//错误，不能直接比较两个指针</span><br>sort(vec.<span class="hljs-keyword">begin</span>(),vec.<span class="hljs-keyword">end</span>(),greater&lt;<span class="hljs-built_in">string</span>*&gt; ());<span class="hljs-comment">//正确，按降序排列指针的地址</span><br></code></pre></td></tr></table></figure><p>统计大于1024的值有多少个</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">cout_if(<span class="hljs-name">vec</span>.begin(),vec.end(),bind(<span class="hljs-name">greater&lt;int&gt;</span>(), _1, <span class="hljs-number">1024</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>找到第一个不等于pooh的字符串</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">find_if(<span class="hljs-name">str</span>.begin(),str.end(),bind(<span class="hljs-name">not_equal_to&lt;string&gt;</span>(), _1, <span class="hljs-string">&quot;pooh&quot;</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>将所有的值乘以2</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">transform(<span class="hljs-name">vec</span>.begin(),vec.end(),bind(<span class="hljs-name">multiplies&lt;int&gt;</span>(), _1 ,<span class="hljs-number">2</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>判断一个给定的<code>int</code>值是否能被 <code>int</code> 容器中的所有元素整除</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">int</span> input = <span class="hljs-number">30</span>;<br>modulus&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-keyword">mod</span>;<br><span class="hljs-type">auto</span> predicator = [&amp;](<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == <span class="hljs-keyword">mod</span>(input, i); &#125;;<br><span class="hljs-type">auto</span> is_divisible = std::any_of(data.begin(), data.<span class="hljs-keyword">end</span>(), predicator);//any_of返回<span class="hljs-literal">true</span>或<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p>可调用对象：函数、函数指针、<code>lambda</code>表达式、重载调用运算符的类和<code>bind</code>创建的对象</p><p>每一个<code>lambda</code>都有自己唯一的未命名的类类型，函数和函数指针的类型则由返回值和实参类型决定，但两个不同类型的可调用对象可以有相同的调用形式，调用形式包含调用的返回类型和实参类型，<code>int (int, int)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br><span class="hljs-keyword">return</span> i + j;<br>&#125;<br><span class="hljs-comment">//lambda</span><br><span class="hljs-keyword">auto</span> mod = [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)&#123;<span class="hljs-keyword">return</span> i%j;&#125;;<br><span class="hljs-comment">//函数对象类</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">divide</span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> i/j;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>定义一个函数表，用于存储指向这些可调用对象的指针<code>map&lt;string, int(*)(int, int)&gt; calc</code></p><p><code>calc.insert(&quot;+&quot;, add);</code>可添加<code>add</code>的指针至函数表中，但不能直接存入<code>mod</code>和<code>divide</code>，因为它们并不是函数指针类型，与<code>map</code>中所要求的类型不匹配，但可以通过<code>function</code>类型来解决</p><p><strong>标准库function类型</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>function&lt;T&gt; f;</code></td><td><code>f</code>是一个用来存储可调用对象的空<code>function</code>，这些可调用对象的调用形式应该与类型<code>T</code>相同。</td></tr><tr><td><code>function&lt;T&gt; f(nullptr);</code></td><td>显式地构造一个空<code>function</code></td></tr><tr><td><code>function&lt;T&gt; f(obj)</code></td><td>在<code>f</code>中存储可调用对象<code>obj</code>的副本</td></tr><tr><td><code>f</code></td><td>将<code>f</code>作为条件：当<code>f</code>含有一个可调用对象时为真；否则为假。</td></tr><tr><td>定义为<code>function&lt;T&gt;</code>的成员的类型</td><td></td></tr><tr><td><code>result_type</code></td><td>该<code>function</code>类型的可调用对象返回的类型</td></tr><tr><td><code>argument_type</code></td><td>当<code>T</code>有一个或两个实参时定义的类型。如果<code>T</code>只有一个实参，则<code>argument_type</code></td></tr><tr><td><code>first_argument_type</code></td><td>第一个实参的类型</td></tr><tr><td><code>second_argument_type</code></td><td>第二个实参的类型</td></tr></tbody></table><p>声明一个<code>function</code>类型，它可以表示接受两个<code>int</code>，返回一个<code>int</code>的可调用对象。<code>function&lt;int(int, int)&gt;</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">map&lt;string, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt;&gt; calc = &#123;<br>&#123;<span class="hljs-string">&quot;+&quot;</span>, add&#125;, <span class="hljs-comment">//函数指针</span><br>&#123;<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-built_in">minus</span>&lt;<span class="hljs-type">int</span>&gt;()&#125;,  <span class="hljs-comment">//标准库函数对象</span><br>&#123;<span class="hljs-string">&quot;*&quot;</span>, [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)&#123;<span class="hljs-keyword">return</span> i*j;&#125;&#125;,   <span class="hljs-comment">//lambda表达式</span><br>&#123;<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-built_in">divide</span>()&#125;, <span class="hljs-comment">//重载调用运算符的类，函数对象</span><br>&#123;<span class="hljs-string">&quot;%&quot;</span>, mod&#125;<span class="hljs-comment">//命名的lambda对象</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h3><p>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型</p><p><code>operator type() const;</code></p><p>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是<code>const</code></p><p><code>int i = 42;</code></p><p><code>cin &lt;&lt; i;</code></p><p>使用<code>istream</code>的<code>bool</code>类型转换运算符将<code>cin</code>转换成<code>bool</code>，而这个<code>bool</code>会被提升为<code>int</code>进而执行左移42位的操作</p><p>可以通过显式的类型转换运算符防止自动隐式转换，这样，在执行类型转换时，需通过显式的强制类型转换</p><p><code>static_cast&lt;int&gt; (si) + 3;</code></p><p>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> Integral &#123;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-keyword">const</span> <span class="hljs-title">int</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>() <span class="hljs-keyword">const</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一条语句指明类型转换得到的值为<code>const int</code>，不能对其进行修改</p><p>第二条语句指明不能对类对象进行修改</p><p>两个类提供相同的类型转换，例如A定义一个接受B的构造函数，同时B类定义了一个转换目标是A的类型转换运算符，则产生二义性</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> A&#123;<br>A(<span class="hljs-keyword">const</span> B&amp;);<br>&#125;;<br><span class="hljs-keyword">struct</span> B&#123;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">A</span>() <span class="hljs-keyword">const</span></span>;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> A&amp;</span>)</span>;<br>B b;<br>A a = f(b);<span class="hljs-comment">//二义性：f(B::operator A())与f(A::A(const B&amp;))</span><br><br><span class="hljs-comment">//显式调用类型转换运算符或者构造函数</span><br>A a1 = f(b.<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">A</span>())</span>;<br>A a2 = f(A(b));<br></code></pre></td></tr></table></figure><p>同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> LongDouble&#123;<br>LongDouble(<span class="hljs-built_in">double</span> = <span class="hljs-number">0.0</span>);<br>LongDouble <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> SmallInt&amp;);<br><span class="hljs-function">oprerator <span class="hljs-title">double</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">float</span>()</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">SmallInt</span>&#123;<br>SmallInt <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> SmallInt&amp;, <span class="hljs-keyword">const</span> SmallInt&amp;);<br>SmallInt (<span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>() <span class="hljs-keyword">const</span></span> &#123;<br><span class="hljs-keyword">return</span> val;<br>&#125;<br>&#125;;<br><br>SmallInt s1, s2;<br>SmallInt s3 = s1 + s2;<span class="hljs-comment">// 成员函数重载+</span><br><span class="hljs-built_in">int</span> i = s3 + <span class="hljs-number">0</span>;<span class="hljs-comment">// 二义性: s3转换成int再使用内置+ 或 0转换成SmallInt再使用重载+</span><br><br>LongDouble <span class="hljs-keyword">operator</span>+(LongDouble&amp;, <span class="hljs-built_in">double</span>);<br>SmallInt si;<br>LongDouble ld;<br>ld = si + ld;<span class="hljs-comment">//错误</span><br>ld = ld + si;<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p><code>ld = si + ld;</code> 中两个类都不能相互转换，因此不能使用重载+，2<code>si</code>转换成<code>int</code>，<code>ld</code>转换成<code>double</code>或<code>float</code>，将产生二义性</p><p><code>ld = ld + si;</code> 中可以使用<code>ld</code>的重载+，<code>ld</code>在左，接受<code>double</code>的右侧运算对象，精确匹配；还可以<code>ld</code>转换成<code>double</code>或<code>float</code>，<code>si</code>转换成<code>int</code>，再使用内置+，但优先级低于前者，故无二义性</p><h2 id="第十五章-面向对象程序设计"><a href="#第十五章-面向对象程序设计" class="headerlink" title="第十五章 面向对象程序设计"></a>第十五章 面向对象程序设计</h2><h3 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h3><p>层次关系的根部是一个<strong>基类</strong>，其他类可通过直接或间接继承基类，继承得到的类称为<strong>派生类</strong></p><p>派生类要通过派生类列表显式指出从哪个基类继承而来，如<code>class Bulk_quote : public Quote&#123;//类定义&#125;;</code>，且只在类定义时才指出派生类列表，声明中只包含类名但不包含派生类列表<code>class Bulk_quote;</code></p><p>对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成<strong>虚函数</strong>，<code>virtual</code></p><p>派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字</p><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义</p><p>派生类对象中包含了：派生类自己定义的成员的子对象（非静态）以及所继承的基类的子对象，即派生类对象中也含有基类对应的组成部分，可以把派生类对象当成基类对象来使用，通过将基类的指针或引用绑定到派生类对象中的基类部分上</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">Quote item;<br>Bulk_quote bulk;<br>Quote *p = &amp;item;     <span class="hljs-regexp">//</span>p指向Quote对象item<br>p = bulk; <span class="hljs-regexp">//</span>p指向Bulk_quote对象bulk中的Quote部分<br>Quote &amp;r = bulk;  <span class="hljs-regexp">//</span>r绑定到bulk中的Quote部分<br></code></pre></td></tr></table></figure><p>这种转换称为<strong>派生类到基类的转换</strong></p><p>派生类必须使用基类的构造函数去初始化它的基类部分</p><p>如果将某个类作为基类，则该类必须已定义而非只有声明</p><p>防止继承发生可以在类名或函数名后加上关键字<code>final</code></p><h3 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h3><p>静态类型在编译时已知，是根据变量声明或表达式生成的类型；动态类型则是变量或表达式表示的在内存中的类型，在运行时才可知</p><p>如上例子中<code>p</code>或者<code>r</code>在绑定<code>bulk</code>后动态类型与静态类型不一样了，静态类型为<code>Quote</code>而动态类型为<code>Bulk_quote</code></p><p>因为一个基类对象可能是派生类对象一部分也可能不是，所以不存在从基类向派生类的隐式类型转换</p><p>用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分则会被忽略掉</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>使用虚函数可以执行动态绑定，动态绑定只有通过指针或者引用调用虚函数时才会发生</p><p>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同</p><p>当派生类覆盖了某个虚函数时，该函数在某类中的形参必须与派生类中的形参严格匹配</p><p>如果我们想覆盖某个虚函数，但不小心把形参列表弄错了，这个时候就不会覆盖基类中的虚函数。加上<code>override</code>可以明确程序员的意图，让编译器帮忙确认参数列表是否出错</p><p>如果通过基类引用或指针调用函数，则使用基类中定义的默认实参，因此派生类中定义的默认实参最好与基类一致</p><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>纯虚函数用于清晰地告诉用户当前的函数是没有实际意义的。只用在函数体的位置前书写<code>=0</code>就可以将一个虚函数说明为纯虚函数</p><p>含有纯虚函数的类是抽象基类，抽象基类不能被直接创建成对象</p><h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><ul><li><code>protected</code> ： 基类和和其派生类还有友元可以访问。</li><li><code>private</code> ： 只有基类本身和友元可以访问。</li></ul><p>派生类的成员或友元只能通过派生类对象来访问<strong>基类的受保护成员</strong>。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p><p>只有当<strong>公有继承</strong>自基类时，用户代码才能将<strong>派生类转换成基类</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Base *p = <span class="hljs-meta">&amp;d1;<span class="hljs-comment">//正确，d1是公有继承</span></span><br>p = <span class="hljs-meta">&amp;d2;<span class="hljs-comment">//报错，d2是私有继承</span></span><br></code></pre></td></tr></table></figure><p>派生访问说明符的目的是：控制派生类用户对于基类成员的访问权限。比如<code>struct Priv_Drev: private Base&#123;&#125;</code>意味着在派生类<code>Priv_Drev</code>中，从<code>Base</code>继承而来的部分都是<code>private</code>的</p><p><strong>供派生类访问 应声明为受保护的，则派生类及其友元不能访问私有成员</strong>；<strong>由基类及其基类的友元访问 应声明为私有的</strong></p><p>不能继承友元关系</p><p>使用<code>using</code>改变个别成员的可访问性，<code>using</code>声明语句中名字的访问权限由该<code>using</code>声明语句之前的访问说明符决定</p><h3 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h3><p>派生类的作用域嵌套在其基类的作用域之内</p><p>派生类的成员将隐藏同名的基类成员</p><h3 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h3><p>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针将产生未定义的行为。因此<strong>基类通常定义一个虚析构函数<code>virtual ~Quote() = default;</code></strong></p><p><strong>如果一个类定义了析构函数，即使是通过<code>=default</code>的形式使用合成的版本，编译器也不会合成移动操作</strong></p><p><strong>派生类构造函数在初始化阶段不仅要初始化派生类自己的成员，还负责初始化基类部分</strong>。拷贝、赋值和移动同理，而析构函数只负责销毁派生类自己分配的资源</p><p>当为派生类定义对应的拷贝或移动构造函数时，通常使用对应的基类构造函数来初始化派生类对象的基类部分</p><h3 id="容器与继承——Basket类程序"><a href="#容器与继承——Basket类程序" class="headerlink" title="容器与继承——Basket类程序"></a><strong>容器与继承——Basket类程序</strong></h3><p>如果希望使用容器存放具有继承关系的对象时，由于派生类赋值给基类对象时，其中的派生类对象会被忽略掉，因此实际上存放的应该是基类的（智能）指针</p><p>为了实现<code>basket</code>存放<code>shared_ptr</code>，定义一个表示购物篮的类，并提供添加和打印输出的接口，私有成员定义一个<code>multiset</code>存放指向不同<code>Quote</code>的<code>shared_ptr</code>即<code>multiset&lt;shared_ptr&lt;Quote&gt;&gt; </code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Basket</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_item</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;Quote&gt;&amp; q)</span> </span>&#123;items.<span class="hljs-built_in">insert</span>(q);&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">total_receipt</span><span class="hljs-params">(ostream&amp;)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;Quote&gt; &amp;l, <span class="hljs-type">const</span> shared_ptr&lt;Quote&gt; &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> l-&gt;<span class="hljs-built_in">isbn</span>() &lt; r-&gt;<span class="hljs-built_in">isbn</span>();<br>&#125;<br>multiset&lt;shared_ptr&lt;Quote&gt;, <span class="hljs-keyword">decltype</span>(compare)*&gt; <span class="hljs-built_in">items</span>(compare);<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>multiset</code>中存放的是<code>shared_ptr</code>，因此需要自定义小于运算符，初始化<code>items</code>并令其使用<code>compare</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">double total_receipt(ostream&amp; os) const<br>&#123;<br>double <span class="hljs-built_in">sum</span> = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>(auto <span class="hljs-built_in">iter</span> = items.begin();<br><span class="hljs-built_in">iter</span> != item.end();<br><span class="hljs-built_in">iter</span> = upper_bound(*<span class="hljs-built_in">iter</span>))<br>&#123;<br><span class="hljs-built_in">sum</span> += print_total(os, **<span class="hljs-built_in">iter</span>, items.count(*<span class="hljs-built_in">iter</span>));<br>&#125;<br>os &lt;&lt; <span class="hljs-string">&quot;total sale:&quot;</span> &lt;&lt; <span class="hljs-built_in">sum</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for</code>循环中，<code>*iter</code>解引用得到指向<code>Quote</code>的智能指针，调用<code>upper_bound</code>函数可以返回<code>multiset</code>中第一个非<code>*iter</code>智能指针指向的元素，替代了递增操作，意味着不需要打印重复的书本，在相同的书中只取一本作为代表打印。<code>**iter</code>解引用则返回<code>Quote</code>元素</p><p>接下来要实现<code>add_item</code>函数，因为存放的是<code>Quote</code>类型的智能指针，而并不确定指针所指向的具体类型，即该指针的静态类型有可能与动态类型不一样，在<code>make_shared(*类型*)</code>或者<code>shared_ptr pt = new *类型*</code>时无法确定使用基类还是派生类，如果使用基类，则派生类中的非基类部分会被忽略。因此，<strong>给<code>Quote</code>类添加一个虚函数，返回一个新申请的当前对象的拷贝</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Quote</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> Quote* <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp; </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Quote</span> (*<span class="hljs-keyword">this</span>);&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> Quote* <span class="hljs-title">clone</span><span class="hljs-params">()</span> &amp;&amp; </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Quote</span> (<span class="hljs-built_in">move</span>(*<span class="hljs-keyword">this</span>));&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_quote</span> : <span class="hljs-keyword">public</span> Quote &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">Bulk_quote* <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp; </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bulk_quote</span> (*<span class="hljs-keyword">this</span>);&#125;<br><span class="hljs-function">Bulk_quote* <span class="hljs-title">clone</span><span class="hljs-params">()</span> &amp;&amp; </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bulk_quote</span> (<span class="hljs-built_in">move</span>(*<span class="hljs-keyword">this</span>));&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>实现<code>add_item</code>函数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//原版本<br>//<span class="hljs-type">void</span> add_item(const shared_ptr&lt;<span class="hljs-keyword">Quote</span>&gt;&amp; q) &#123;items.<span class="hljs-keyword">insert</span>(q);&#125;<br><span class="hljs-type">void</span> Basket::add_item(const <span class="hljs-keyword">Quote</span>&amp; sale)<br>&#123;<br>items.<span class="hljs-keyword">insert</span>(shared_ptr&lt;<span class="hljs-keyword">Quote</span>&gt;(sale.clone()));<br>&#125;<br><span class="hljs-type">void</span> Basket::add_item(const <span class="hljs-keyword">Quote</span>&amp;&amp; sale)<br>&#123;<br>items.<span class="hljs-keyword">insert</span>(shared_ptr&lt;<span class="hljs-keyword">Quote</span>&gt;(<span class="hljs-keyword">move</span>(sale).clone()));<br>&#125;<br></code></pre></td></tr></table></figure><p>新版本<code>add_item</code>可以直接传入<code>quote</code>对象，程序自动生成相应类型的智能指针。<code>clone</code>无论是拷贝或者是移动数据，都会返回<code>shared_ptr</code>，然后调用<code>insert</code>直接加入到<code>items</code>中</p><h2 id="第十六章——模板与泛型编程"><a href="#第十六章——模板与泛型编程" class="headerlink" title="第十六章——模板与泛型编程"></a>第十六章——模板与泛型编程</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p><code>template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2)&#123;&#125;</code></p><p>以关键字 <code>template</code>开始，后接<strong>模板形参表</strong>，模板形参表是用<strong>尖括号</strong><code>&lt;&gt;</code>括住的一个或多个<strong>模板形参</strong>的列表，用逗号分隔，<strong>不能为空</strong></p><p>类型模板参数——在关键字<code>typrename</code>或者<code>class</code>之后，可以用来指定返回类型或函数的参数类型</p><p>非类型模板参数——用来表示一个值而非一个类型，通过<strong>特定的类型名指定非类型参数</strong>，<strong>当一个模板实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替</strong></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">template</span>&lt;unsighned N, unsigned M&gt;<br><span class="hljs-type">int</span> compare(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> (&amp;p1)[n], <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> (&amp;p2)[M])<br>&#123;<br><span class="hljs-keyword">return</span> strcmp(p1, p2);<br>&#125;<br><br>compare(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;mom&quot;</span>);<br>//当调用compare时，编译器使用字面常量的大小来代替M和N，即调用 <span class="hljs-type">int</span> compare(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> (&amp;p1)[<span class="hljs-number">3</span>],<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> (&amp;p2)[<span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><p>一个非类型参数可以是一个整数，或者是一个指向对象或函数类型的指针或引用；绑定到非类型整型参数的实参必须是一个常量表达式，必须具有静态的生存期。</p><p><code>inline</code>或<code>constexpr</code>说明符放在模板参数列表之后，返回类型之前</p><p><code>template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);</code></p><h3 id="编写类型无关的代码"><a href="#编写类型无关的代码" class="headerlink" title="编写类型无关的代码"></a>编写类型无关的代码</h3><ul><li>模板中的函数参数是<code>const</code>的引用</li><li>函数体中的条件判断仅使用<code>&lt;</code>比较运算</li></ul><h3 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h3><p>只有当实例化出模板的一个特定版本时，编译器才会生成代码</p><ul><li>普通函数的声明和类定义放在头文件，普通函数的定义和类成员函数的定义放在源文件中</li><li>函数模板或类模板成员函数的声明和定义都要在头文件中</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode回溯算法章节</title>
    <link href="/2022/11/05/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/"/>
    <url>/2022/11/05/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode回溯算法章节"><a href="#LeetCode回溯算法章节" class="headerlink" title="LeetCode回溯算法章节"></a>LeetCode回溯算法章节</h1><h2 id="回溯模板"><a href="#回溯模板" class="headerlink" title="回溯模板"></a>回溯模板</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">backtrace</span>(参数)&#123;<br><span class="hljs-built_in">if</span>(终止条件)<br>return;<br><span class="hljs-built_in">for</span>(每层中的元素)<br>&#123;<br>存入结果<br><span class="hljs-built_in">backtrace</span>();调用回溯<br>删除存入的结果，回溯<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E6%A8%A1%E6%9D%BF.png"></p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>[组合](<a href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a>)</p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>从[1,N]中找到凑成K个数的所有组合，将[i,N]（i&#x3D;1,2,3…N）看做一棵树的不同结点，每取出一个数就把剩下的数看做该结点的子结点，叶子结点则为符合要求的结果。因此，for循环中的是不断取出一个数进入递归，结束递归后删除，再递增取下一个数，直到遇到结束条件退出递归。即for循环会遍历[1,N]中所有的元素，每添加一个元素进入数组就进入一层递归，但进入递归后若符合终止条件则会跳出，避免了N次方的时间复杂度。也相当于枚举法，但会及时止损</p><p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E7%BB%84%E5%90%88.png"></p><ol><li><p>确定回溯终止条件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(vec.size()<span class="hljs-operator">=</span><span class="hljs-operator">=</span>k)<br>&#123;<br>res.push_back(vec)<span class="hljs-comment">;</span><br>return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当数组大小符合要求时，也就是遇到了叶子结点，这一次递归就终止，并更新结果集</p></li><li><p>确定回溯返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res,vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> start)</span></span><br><span class="hljs-function"></span>&#123;<br>不需要返回值<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定单层逻辑</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i = start;i&lt;=n;i++)<br>&#123;<br>vec<span class="hljs-selector-class">.push</span>(i);<br><span class="hljs-built_in">search</span>(n,k,res,vec,start+<span class="hljs-number">1</span>);<br>vec<span class="hljs-selector-class">.pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> start)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == k)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= n; ++i)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">search</span>(n, k, res, vec, i + <span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">search</span>(n, k, res, vec, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="回溯优化"><a href="#回溯优化" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>在回溯算法当中，由于是回溯的本质就是枚举，对枚举的优化只在于剪枝，通过给定限定条件减少无必要的递归，本题也同样如此，以上版本中将start赋予到了i，却并没有考虑到start的位置要求，在某些分支中，start过于太大，导致剩下的元素不能满足k的数量要求，因此，可以对回溯进行剪枝优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> start)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == k)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= n - (k - vec.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; ++i)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">search</span>(n, k, res, vec, i + <span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">search</span>(n, k, res, vec, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>剪枝的原因在于i不必从过于大的start中取值，因此将对for循环中i的循环结束语句修改，从进入递归之前剪枝</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回溯算法难点在于将题意转换成树形结构，对于树形结构可以更好的理解回溯，以及剪枝的操作</p><h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><h3 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h3><p>题目思路类似于上一题，只不过将取值范围固定在<code>1~9</code>之间，其余都一样</p><p>整体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == k)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>) == n)<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt;= <span class="hljs-number">9</span>; i++)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">traceback</span>(k, n, res, vec, i + <span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">traceback</span>(k, n, res, vec, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="回溯优化-1"><a href="#回溯优化-1" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>在以上版本代码中，容易看出需要优化的地方在于取值的范围是递增的，一旦有满足总和的vec数组，后续的遍历中的数组总和只会更大，因此可以忽略掉后续的遍历。类似地，同样在递归进入条件判断语句中增加限制，考虑到是用数组总和来做判断是否需要剪枝，则增加一个形参<code>sum</code>表示当前<code>vec</code>数组的总和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span>&amp; sum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == k)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (sum == n)<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt;= <span class="hljs-number">9</span> &amp;&amp; (n - sum) &gt;= i; i++)<br>        &#123;<br>            sum += i;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">traceback</span>(k, n, res, vec, i + <span class="hljs-number">1</span>, sum);<br>            sum -= i;<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">traceback</span>(k, n, res, vec, <span class="hljs-number">1</span>, sum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在回溯法中，如果想要不重复地访问元素，则需要<code>traceback(k,n,res,vec,i+1)</code>而不是<code>traceback(k,n,res,vec,index+1)</code>，后者会在<code>i</code>遍历时，与<code>index+1</code>有重复值，且重复值只从2开始</p><p>本题是与上题相同的回溯思路，但不同的剪枝思路。</p><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>[电话号码的字母组合](<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合 - 力扣（LeetCode）</a>)</p><h3 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h3><p>与前些题目不同的是，没有直接能获取到要进入递归的范围，即递归树的结点，需要借助容器来获取数值范围，这里使用数组保存<code>0~9</code>所分别对应的字母。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt;&gt; hashmap&#123;<br>    &#123;&#125;,<br>    &#123;&#125;,<br>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>&#125; &#125;;<br></code></pre></td></tr></table></figure><p>这里保存0,1两个空数组是为了方便索引访问直接对应</p><ol><li><p>确定递归结束条件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(digits.size()<span class="hljs-operator">=</span><span class="hljs-operator">=</span>str.size())<br>&#123;<br>res.push_back(str)<span class="hljs-comment">;</span><br>return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定递归返回值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traceback</span>(<span class="hljs-params">vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; res, <span class="hljs-built_in">string</span>&amp; str,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;digits,<span class="hljs-built_in">int</span> index</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定单层逻辑</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;hashmap[digit].size();i++)<br>        &#123;<br>            <span class="hljs-built_in">str</span> += hashmap[digit][i];<br>            traceback(res,<span class="hljs-built_in">str</span>,digits,<span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">str</span>.pop_back();<br>        &#125;<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; hashmap&#123;<br>        &#123;&#125;,<br>        &#123;&#125;,<br>    &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">void</span> traceback(vector&lt;string&gt;&amp; res,string&amp; <span class="hljs-built_in">str</span>,<span class="hljs-keyword">const</span> string &amp;digits,<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">str</span>.size()==digits.size())<br>        &#123;<br>            res.push_back(<span class="hljs-built_in">str</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> digit = digits[<span class="hljs-keyword">index</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;hashmap[digit].size();i++)<br>        &#123;<br>            <span class="hljs-built_in">str</span> += hashmap[digit][i];<br>            traceback(res,<span class="hljs-built_in">str</span>,digits,<span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">str</span>.pop_back();<br>        &#125;<br>    &#125;<br>    vector&lt;string&gt; letterCombinations(string digits) &#123;<br>        vector&lt;string&gt; res;<br>        string <span class="hljs-built_in">str</span>;<br><br>        <span class="hljs-keyword">if</span>(digits.empty())  <span class="hljs-keyword">return</span> res;<br>        traceback(res,<span class="hljs-built_in">str</span>,digits,<span class="hljs-number">0</span>);        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>由回溯过程可知，这个版本的回溯代码不需要剪枝优化。</p><p>在本题中，传入递归函数的<code>index</code>形参用来获取<code>digits</code>中的下一位数字，保证每次for循环的都是不同进位上的数字，也是这道题的最大变化点。并且不需要传入其余参数用于表示开始遍历的结点索引，因为需要遍历的是对应数字上的所有字母</p><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>[组合总和](<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a>)</p><h3 id="回溯-3"><a href="#回溯-3" class="headerlink" title="回溯"></a>回溯</h3><p>这道题给定一个数组和目标值，要求从数组中找到不限数量的数组元素，令其和等于目标值，并且能够重复用数组中的元素。最大的不同点在于能够重复使用数组元素，首先能想到的就是不需要index形参，不能让递归每次都从下一个元素开始遍历。</p><ol><li><p>确定递归结束条件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(target <span class="hljs-operator">=</span><span class="hljs-operator">=</span> sum)<br>&#123;<br>res.push_back(vec)<span class="hljs-comment">;</span><br>return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>容易想到只要让当前数组的和等于目标值即可结束该层递归，即到达叶子结点。但是这样就会导致了死循环，因为如果一旦数组和大于目标值，则递归永远不会退出。因此需要加上对sum值的限制（在进入递归前判断）</p></li><li><p>确定递归返回值</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res,<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;vec,<span class="hljs-type">int</span> <span class="hljs-built_in">target</span>,<span class="hljs-type">int</span> &amp;<span class="hljs-built_in">sum</span>,<span class="hljs-type">int</span> startindex)<br></code></pre></td></tr></table></figure></li><li><p>确定单层逻辑</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">for (<span class="hljs-built_in">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-keyword">target</span> &gt; <span class="hljs-built_in">sum</span>; i++)<br>        &#123;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-keyword">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            vec.pop_back();<br>        &#125;<br></code></pre></td></tr></table></figure><p>在这，startindex作为每次遍历时开始的索引下标，与[III](# 组合总和III)不同，传入到下一次递归的是<code>i</code>而不是<code>i+1</code>，这是因为<strong>允许重复元素的存在</strong></p></li></ol><p>整体代码如下</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span>&amp; <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> startindex)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)<br>        &#123;<br>            res.push_back(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">target</span> 》 <span class="hljs-built_in">sum</span>; i++)<br>        &#123;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            vec.pop_back();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="回溯优化-2"><a href="#回溯优化-2" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>可以想到，如同[III](# 组合总和III)，剪枝优化的思路在于当<strong>数组递增</strong>时，一旦有满足目标值的数组元素，往后的元素再进入递归，vec数组的和都会大于目标值，因此可以剪掉，所以<strong>先给数组进行排序</strong>，然后在<strong>递归进入前加以条件的限制</strong></p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span>&amp; <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> startindex)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)<br>        &#123;<br>            res.push_back(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; (<span class="hljs-built_in">target</span> - <span class="hljs-built_in">sum</span>) &gt;= candidates[i]; i++)<br>        &#123;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            vec.pop_back();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec;<br>        sort(candidates.begin(), candidates.end());<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>当允许重复元素出现时，在进入下一层递归时就可以传入<code>i</code>而不是<code>i+1</code>。</p><p>因为给出的数组非递增，需要先对数组进行排序，优化效果不明显</p><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>[组合总和II](<a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II - 力扣（LeetCode）</a>)</p><h3 id="回溯-4"><a href="#回溯-4" class="headerlink" title="回溯"></a>回溯</h3><p>该题与[II](# 组合总和II)的区别就在于输入的<code>candidates</code>数组允许有重复元素的出现，但<strong>每个元素只能使用一次</strong>，因此传递到下一层递归中的索引就必须是<code>index+1</code>。</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span>&amp; <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> startindex)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)<br>        &#123;<br>            res.push_back(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">target</span> &gt; <span class="hljs-built_in">sum</span>; i++)<br>        &#123;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            vec.pop_back();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此外，如果<code>candidates</code>中有重复元素，会导致同层的结点中可能会选取一样的值进入到下一层递归中，就会导致最终结果出现有<strong>相同元素的分组</strong>，如以上版本的代码，仅修改了上一题的<code>index</code>传递值。原因在于，可能会出现保存到<code>res</code>中的元素在回溯删除之后，因为相同值的元素存在，在遍历剩余元素时又被重新添加进去。</p><p>可以针对这种情况设立一个<code>tmp</code>变量，先对<code>candidates</code>进行排序，<code>tmp</code>记录刚被删除的元素的值，再下一个元素被添加时判断是否等于<code>tmp</code>，只有不相等时才会被添加进去。</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br><span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span>&amp; <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> startindex)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)<br>        &#123;<br>            res.push_back(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; (<span class="hljs-built_in">target</span>-<span class="hljs-built_in">sum</span>) &gt;= candidates[i]; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmp == candidates[i])<br>                <span class="hljs-keyword">continue</span>;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            tmp = candidates[i];<br>            vec.pop_back();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum2(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        sort(candidates.begin(),candidates.end());<br>        traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另一种方法</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fortran">for (<span class="hljs-built_in">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; (<span class="hljs-keyword">target</span>-<span class="hljs-built_in">sum</span>) &gt;= candidates[i]; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; startindex &amp;&amp; candidates[i] == candidates[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-keyword">target</span>, <span class="hljs-built_in">sum</span>, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            vec.pop_back();<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="回溯优化-3"><a href="#回溯优化-3" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>剪枝优化过程同<a href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%96%602">上题</a>，以上版本代码已剪枝</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>candidates</code>没有重复元素，但结果输出可以有重复元素，则修改<code>index</code></p><p><code>candidates</code>有重复元素，但结果输出不能有重复元素，即相同元素的分组，则通过添加限制条件防止重复元素进入递归</p><h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>[分割回文串](<a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a>)</p><h3 id="回溯-5"><a href="#回溯-5" class="headerlink" title="回溯"></a>回溯</h3><p>相比较于之前的题目，该题变化点主要集中在于递归结束判断条件，在满足回文的条件的同时，还需要<strong>将整个字符串完全分割</strong></p><p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg"></p><ol><li><p>确定递归结束条件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (index &gt;<span class="hljs-operator">=</span> s.size())<br>&#123;<br>    if (judge())<br>       res.push_back(vec)<span class="hljs-comment">;</span><br>    return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于不能添加重复元素进入递归，所以需要index形参，需要在对整个字符串完成分割的时候才停止递归，并且要满足回文的条件才能保存结果</p></li><li><p>确定递归返回值</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> traceback(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> index)<br></code></pre></td></tr></table></figure></li><li><p>确定单层逻辑</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = index; i &lt; s.size<span class="hljs-literal">()</span>; ++i)<br>&#123;<br>    vec.push<span class="hljs-constructor">_back(<span class="hljs-params">s</span>.<span class="hljs-params">substr</span>(<span class="hljs-params">index</span>,<span class="hljs-params">i</span>+1-<span class="hljs-params">index</span>)</span>);<br>    traceback(s, i + <span class="hljs-number">1</span>);<br>    vec.pop<span class="hljs-constructor">_back()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    vector&lt;string&gt; vec;<br>    string str;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> sustr:vec)<br>        &#123;<br>            <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = sustr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;=j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(sustr[i]!=sustr[j])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                ++i,--j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (index&gt;=s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>())<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(index,i+<span class="hljs-number">1</span>-index));<br>            <span class="hljs-built_in">traceback</span>(s, i + <span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> vector&lt;vector&lt;string&gt;&gt;&#123;&#123;s&#125;&#125;;<br>        <span class="hljs-built_in">traceback</span>(s, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此外，还可以在进入递归前完成对回文串的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    vector&lt;string&gt; vec;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> en,string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(st&lt;=en)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[st]!=s[en])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ++st,--en;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (index&gt;=s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judge</span>(index,i,s))<br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(index,i+<span class="hljs-number">1</span>-index));<br>            <span class="hljs-built_in">traceback</span>(s, i + <span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> vector&lt;vector&lt;string&gt;&gt;&#123;&#123;s&#125;&#125;;<br>        <span class="hljs-built_in">traceback</span>(s, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>难点在于</p><ul><li><p><strong>切割问题</strong>转换成<strong>组合问题</strong></p><p>关键在于模拟出树形结构</p></li><li><p>字符串分割如何用代码实现</p><p>利用index，以及substr函数，把递归开始时的初值模拟为切割线</p></li><li><p>判断回文串</p><p>双指针法；动态规划</p></li><li><p>递归结束条件的判断</p></li></ul><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>本题也属于切割问题，但切割完成的判断更为复杂，切割的IP地址分为4段，需要直接在原字符串中加上<code>&#39;.&#39;</code>表示分段，分段中的IP地址不能有前导0，不能大于255，否则都将是无效的IP。</p><p>转换成树形结构</p><p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/IP.png"></p><p>首先，确定判断IP段是否有效</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> ok(<span class="hljs-keyword">const</span> string&amp; s, <span class="hljs-built_in">int</span> st, <span class="hljs-built_in">int</span> en)<br>&#123;<br><span class="hljs-keyword">if</span>(st &gt; en)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">if</span>(s[st] == <span class="hljs-number">0</span> &amp;&amp; st!=en)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = st; i &lt;= en; i++)<br>&#123;<br><span class="hljs-built_in">num</span> = <span class="hljs-built_in">num</span>*<span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span> &gt; <span class="hljs-number">255</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果仅仅是首元素为0还不一定无效，IP地址段可以只有一个0，但不能是前导0</p><p>计算IP地址段可以用<code>for</code>循环，逐位相加，一旦某一位已经超过255则直接返回<code>false</code></p><h3 id="回溯1"><a href="#回溯1" class="headerlink" title="回溯1"></a>回溯1</h3><ol><li><p>递归结束条件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">if</span>(comma == <span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-built_in">if</span>(ok(s,index,s.size()-<span class="hljs-number">1</span>))<br>res<span class="hljs-selector-class">.push_back</span>(s);<br>return;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为是直接在源字符串中做分割，在加了3个<code>&#39;.&#39;</code>的情况下，还需要对最后一段IP进行判断是否有效才能加入到结果集中</p></li><li><p>递归返回值</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">void traceback(vector<span class="hljs-symbol">&lt;string&gt;</span>&amp; <span class="hljs-keyword">res</span>, <span class="hljs-keyword">int</span> comma, <span class="hljs-keyword">int</span> <span class="hljs-built_in">index</span>, <span class="hljs-built_in">string</span>&amp; s)<br></code></pre></td></tr></table></figure><p>因为直接在源字符串上操作，并且需要找到所有有效的IP地址，因此不需要返回值。传入参数为引用，不用拷贝并且允许直接修改、删除等操作</p></li><li><p>单层逻辑</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">index</span>; i &lt; s.size(); i++)<br>&#123;<br>s.<span class="hljs-keyword">insert</span>(s.<span class="hljs-keyword">begin</span>() + i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>++comma;<br>traceback(res, comma, i + <span class="hljs-number">2</span>, s);<br><span class="hljs-comment">--comma;</span><br>s.erase(s.<span class="hljs-keyword">begin</span>() + i + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>insert</code>函数将<code>&#39;.&#39;</code>插在输入的迭代器之前，即取代输入的迭代器位置，<code>erase</code>则是删除输入迭代器当前位置上的元素。进入递归由于插入多了一位，则下一层递归中需要从<code>index = i+2</code>开始</p></li></ol><p>整体代码如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">ok</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-built_in">int</span> st, <span class="hljs-built_in">int</span> en</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (st &gt; en)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (s[st] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; st != en)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = st; i &lt;= en; i++) <br>        &#123;<br><br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>            <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traceback</span>(<span class="hljs-params">vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; res, <span class="hljs-built_in">int</span> index, <span class="hljs-built_in">int</span> comma, <span class="hljs-built_in">string</span>&amp; s</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (comma == <span class="hljs-number">3</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ok(s, index, s.size() - <span class="hljs-number">1</span>))<br>            &#123;<br>                res.push_back(s);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = index; i &lt; s.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ok(s, index, i))<br>            &#123;<br>                s.insert(s.begin() + i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                ++comma;<br>                traceback(res, i + <span class="hljs-number">2</span>, comma, s);<br>                --comma;<br>                s.erase(s.begin() + i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">restoreIpAddresses</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> &#123;<br>        vector&lt;<span class="hljs-built_in">string</span>&gt; res;<br>        traceback(res, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, s);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="回溯2"><a href="#回溯2" class="headerlink" title="回溯2"></a>回溯2</h3><p>另外一种解法是， 不在源字符串上修改，而是将4段IP地址一段一段的加入一个空字符串中</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt;ans;<br>    <span class="hljs-keyword">void</span> backtrace(string&amp; s,<span class="hljs-built_in">int</span> cnt,<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>,string&amp; <span class="hljs-built_in">str</span>)&#123;<br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span> || <span class="hljs-keyword">index</span>==s.size() )&#123;<br>            <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span> &amp;&amp; <span class="hljs-keyword">index</span>==s.size())<br>                ans.push_back(<span class="hljs-built_in">str</span>.substr(<span class="hljs-number">0</span>,<span class="hljs-built_in">str</span>.size()<span class="hljs-number">-1</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span>+i&gt;s.size()) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(s[<span class="hljs-keyword">index</span>]==<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; i!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span> &amp;&amp; s.substr(<span class="hljs-keyword">index</span>,i)&gt;<span class="hljs-string">&quot;255&quot;</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-built_in">str</span>+=s.substr(<span class="hljs-keyword">index</span>,i);<br>            <span class="hljs-built_in">str</span>.push_back(<span class="hljs-string">&#x27;.&#x27;</span>);<br>            backtrace(s,cnt+<span class="hljs-number">1</span>,<span class="hljs-keyword">index</span>+i,<span class="hljs-built_in">str</span>);<br>            <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span>.substr(<span class="hljs-number">0</span>,<span class="hljs-built_in">str</span>.size()-i<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    vector&lt;string&gt; restoreIpAddresses(string s) &#123;<br>        string <span class="hljs-built_in">str</span> =<span class="hljs-string">&quot;&quot;</span>;<br>        backtrace(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">str</span>);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>回溯1是从一整段IP地址直接做分割，回溯2则是将各段分割好的小段最终才拼凑成完整的IP地址，这样做的好处是对于各段统一判断是否有效，而不用像回溯1中在添加了最后一个<code>&#39;.&#39;</code>之后，添加到结果集之前还要做一次有效判断。并且在回溯2中，判断有效更加简洁，可以利用加入的子段最多只有3位直接与”255”进行判断，而回溯1中可能会出现不止3位的IP地址，因此不能直接与”255”判断，但可以修改成<code>if(en - st == 2 &amp;&amp; s.substr(s.begin() + st, 3) &gt; &quot;255&quot;) return false;</code>以及<code>if(en - st &gt; 2)return false;</code></p><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><h3 id="回溯-6"><a href="#回溯-6" class="headerlink" title="回溯"></a>回溯</h3><p>子集问题中，依旧还是回溯的总体思路，不同在于之前结束条件的判断，仅仅只是遍历到数组结尾就退出</p><p>整体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums,vector&lt;<span class="hljs-type">int</span>&gt;&amp;vec,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;res,<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&gt;=nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-built_in">traceback</span>(nums,vec,res,i+<span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(vec);<br>        <span class="hljs-built_in">traceback</span>(nums,vec,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>子集问题不需要有判断条件，就直接存入结果集中，相当于将树型结构上的<strong>每个结点</strong>；而组合和切割问题则是<strong>保留叶子结点</strong></p><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><h3 id="回溯-7"><a href="#回溯-7" class="headerlink" title="回溯"></a>回溯</h3><p>给定输入数组中含有重复元素，但要求输出结果中不能有重复子数组，与[组合总和II](# 组合总和II)思路一致，且其余同<a href="#%E5%AD%90%E9%9B%86">子集</a>的处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums,vector&lt;<span class="hljs-type">int</span>&gt;&amp;vec,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;res,<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&gt;=nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-built_in">traceback</span>(nums,vec,res,i+<span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(vec);<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">traceback</span>(nums,vec,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>[递增子序列](<a href="https://leetcode.cn/problems/increasing-subsequences/">491. 递增子序列 - 力扣（LeetCode）</a>)</p><h3 id="回溯-8"><a href="#回溯-8" class="headerlink" title="回溯"></a>回溯</h3><p>这道题需要理解的几个关键点：</p><ul><li>要求是子序列，则不能对其排序，有点类似于分割问题但可以只取两边不取中间，即<code>[1,2,3]</code>选<code>[1,3]</code></li><li>要求是非严格递增，则在进入递归前应先进行判断，</li><li>输入数组中可能会有重复元素，但输出不能包含重复子数组</li></ul><p>可知，需要在<strong>不能排序</strong>的情况下，还要在递归过程中排除重复项，回溯的时候应该借助容器来帮助<strong>辨别重复项</strong>，容易想到用<code>unordered_set</code>容器储存结果用于去除重复项，然后遍历容器将没有重复的元素依次存放到<code>vector</code>中，但是，不能直接定义<code>unordered_set&lt;vector&lt;int&gt;&gt;</code>，还要有自定义的哈希函数。因此可以<strong>转换思路，在每一层的结点循环中设置一个<code>unordered_set</code>，即单单不允许这一层有重复被选数</strong>，这就避免重复项进入递归，因为前一个所选就囊括了后面所有相同数的子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br>        <span class="hljs-keyword">if</span>(index&gt;=nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(!vec.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i]&lt;vec.<span class="hljs-built_in">back</span>())<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(uset.<span class="hljs-built_in">find</span>(nums[i])!=uset.<span class="hljs-built_in">end</span>())<br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            uset.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-built_in">traceback</span>(nums,res,vec,i+<span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();            <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">traceback</span>(nums,res,vec,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="回溯优化1"><a href="#回溯优化1" class="headerlink" title="回溯优化1"></a>回溯优化1</h3><p>以上版本的代码，用到了<code>unordered_set</code>，又因为总数据量较小，可以用<code>vector</code>替代<code>unordered_set</code>以减少开销</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(<span class="hljs-number">201</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span>(index&gt;=nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(!vec.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i]&lt;vec.<span class="hljs-built_in">back</span>())<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[nums[i]+<span class="hljs-number">100</span>]==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[nums[i]+<span class="hljs-number">100</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-built_in">traceback</span>(nums,res,vec,i+<span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();            <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">traceback</span>(nums,res,vec,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="回溯优化2"><a href="#回溯优化2" class="headerlink" title="回溯优化2"></a>回溯优化2</h3><p>另一种回溯模板的解法，不需要用到额外的容器来记录，但较难理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums,<span class="hljs-type">int</span> cur,<span class="hljs-type">int</span> last)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur&gt;=nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[cur]&gt;=last)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>            <span class="hljs-built_in">traceback</span>(nums,cur+<span class="hljs-number">1</span>,nums[cur]);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[cur]!=last)<br>            <span class="hljs-built_in">traceback</span>(nums,cur+<span class="hljs-number">1</span>,last);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">traceback</span>(nums,<span class="hljs-number">0</span>,<span class="hljs-number">-101</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>选择合法项：只有<code>cur</code>值大于等于<code>last</code>，才会选择该元素（添加到vec中）</p><p><strong>不借助容器就能排除重复项：只有<code>last</code>和<code>cur</code>指向的值不相同时，才会不选择该结点（不添加到<code>vec</code>中），也就是说当有多个重复元素时，只选最后一个以避免重复</strong></p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>另一种回溯模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>vector&lt;<span class="hljs-type">int</span>&gt; temp;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == nums.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>() &amp;&amp; <span class="hljs-built_in">notVisited</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果选择当前元素</span><br>    temp.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>    <span class="hljs-built_in">dfs</span>(cur + <span class="hljs-number">1</span>, nums);<br>    temp.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-comment">// 如果不选择当前元素</span><br>    <span class="hljs-built_in">dfs</span>(cur + <span class="hljs-number">1</span>, nums);<br>&#125;<br></code></pre></td></tr></table></figure><p>[子集](# 子集)新解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur&gt;=nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br><br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        vec.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>        <span class="hljs-built_in">traceback</span>(cur+<span class="hljs-number">1</span>,nums);<br>        vec.<span class="hljs-built_in">pop_back</span>();<br>        <br>        <span class="hljs-built_in">traceback</span>(cur+<span class="hljs-number">1</span>,nums);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">traceback</span>(<span class="hljs-number">0</span>,nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>[子集II](# 子集II)新解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur&gt;=nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        vec.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>        <span class="hljs-built_in">traceback</span>(cur+<span class="hljs-number">1</span>,nums);<br>        vec.<span class="hljs-built_in">pop_back</span>();<br><br>        <span class="hljs-keyword">while</span>(cur &lt; nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> &amp;&amp; nums[cur]==nums[cur+<span class="hljs-number">1</span>])<br>            ++cur;<br>        <span class="hljs-built_in">traceback</span>(cur+<span class="hljs-number">1</span>,nums);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">traceback</span>(<span class="hljs-number">0</span>,nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>该题最关键是在不排序的前提下，排除重复项进入递归，需要借助容器，<strong>并且是在每层递归中重新定义一个容器，从而避免同层相同元素进入递归</strong></p><p>另一种回溯模板，<strong>不对应树形结构</strong>，因而更难理解；优先处理更多元素的情况，但因其一层两次递归，时间复杂度更高，但指针使用更加灵活，减少对容器的使用，降低空间复杂度</p><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><h3 id="回溯-9"><a href="#回溯-9" class="headerlink" title="回溯"></a>回溯</h3><p>排列问题，容易得知，每次递归时需要从0开始遍历数组，这就意味着不能像组合总和一样代入index对递归进行限制。并且，需要借助容器来记录遍历的当前值是否有被使用过。将全排列转化成树形结构，则同一个树枝上不能够有重复值，那么就可以借助全局的<code>vector</code>进行记录，与<code>vec</code>同步增删元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index,vector&lt;<span class="hljs-type">int</span>&gt; &amp;used)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (used[nums[i] + <span class="hljs-number">10</span>] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[nums[i] + <span class="hljs-number">10</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">traceback</span>(nums, index + <span class="hljs-number">1</span>,used);<br>            used[nums[i] + <span class="hljs-number">10</span>] = <span class="hljs-number">0</span>;<br>            vec.<span class="hljs-built_in">pop_back</span>();<br><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(<span class="hljs-number">21</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-built_in">traceback</span>(nums, <span class="hljs-number">0</span>,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>与[递增子序列](# 递增子序列)一样，可以通过<code>unordered_set</code>以及<code>vector</code>来记录，<code>vector</code>在数组样本小的情况下性能更加优越</p><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul><li>组合之和：只能往后选取（排列顺序不影响结果），故需要用index记录每次递归开始选取的位置；去重则通过排序后再对当前值进行是否与前值重复判断</li><li>分割：与组合之和差别在于终止条件，分割必须要字符串全部分割</li><li>子集：与组合之和差别在于子集的每个结点都是结果集</li><li>全排列：不需要index记录每次递归开始选取的位置，因为有排列顺序要求；去重因为没有index，需要借助容器来记录是否被选取过，通常选<code>vector</code></li></ul><h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><h3 id="回溯1-1"><a href="#回溯1-1" class="headerlink" title="回溯1"></a>回溯1</h3><p>在[全排列](# 全排列)基础上，输入数组可能会有重复值，即不仅在树枝上不能够有重复值，在树层上也不允许有重复值的存在，但是不能直接加上<strong>排序后再判断当前值与前一值是否相等的</strong>去重操作。因为重复值的存在，当在同一条路径上，即树枝上允许有重复值的存在（来源于不同的等值元素），针对树枝上的重复值，可以借助<code>vector</code>先遍历<code>nums</code>记录每个数值的个数，用来判断这个树枝上是否还能使用该数值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index,vector&lt;<span class="hljs-type">int</span>&gt; &amp;used)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (used[nums[i] + <span class="hljs-number">10</span>] == <span class="hljs-number">0</span>)<span class="hljs-comment">//树枝去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<span class="hljs-comment">//树层去重，同时防止树枝上取已取过的值</span><br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            --used[nums[i] + <span class="hljs-number">10</span>];<br>            <span class="hljs-built_in">traceback</span>(nums, index + <span class="hljs-number">1</span>,used);<br>            ++used[nums[i] + <span class="hljs-number">10</span>];<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(<span class="hljs-number">21</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:nums)<br>        &#123;<br>            ++used[i+<span class="hljs-number">10</span>];<br>        &#125;<br>        <span class="hljs-built_in">traceback</span>(nums, <span class="hljs-number">0</span>,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>关键语句在于<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])continue;</code>，既做到了对同一层上的结点去重，也做到在一棵树枝上对取过的值的去重（全排列的要求，相当于全排列中的used数组）</strong></p><h3 id="回溯2-1"><a href="#回溯2-1" class="headerlink" title="回溯2"></a>回溯2</h3><p>另一种做法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;used[i<span class="hljs-number">-1</span>]==<span class="hljs-literal">false</span>)<span class="hljs-comment">//树层去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[i]==<span class="hljs-literal">false</span>)<span class="hljs-comment">//树枝去重</span><br>            &#123;<br>                used[i]=<span class="hljs-literal">true</span>;<br>                vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">traceback</span>(nums,used);<br>                used[i]=<span class="hljs-literal">false</span>;<br>                vec.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">traceback</span>(nums,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>直观的用<code>used</code>数组表示原始数组中的每一个值是否使用过，是对全排列的进一步改进。不只是加上直接加上<strong>排序后再判断当前值与前一值是否相等的</strong>去重操作，为了防止树枝上的多余去重，额外增加了<code>&amp;&amp;used[i-1]==false</code>，限定了只在树层上去重，而不影响树枝上对等值元素的取用</p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>在全排列的基础上，只增加<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])continue;</code>语句会导致竖向上首元素会被重复加入（因为i从0开始），而语句本意是跳过横向重复结点和跳过已加入的竖向重复结点，因此，要么选择再增加对跳过竖向结点的限制，如[回溯2](# 回溯2)用额外<code>used</code>数组记录每个元素是否被访问过，如果前一个元素未被访问<code>nums[i-1]==false</code>，且满足当前元素与前一个元素相同<code>i&gt;0 &amp;&amp; nums[i]==nums[i-1]</code>，证明这是在横向上的重复结点（树层），应当跳过，而竖向上如果再次访问访问过的结点<code>used[i]==true</code>，则会执行跳过，不重复加入结果中（另一个角度，如果在满足当前元素与前一个元素相同<code>i&gt;0 &amp;&amp; nums[i]==nums[i-1]</code>时，前一个元素被访问过<code>nums[i-1]==true</code>，此时当前元素也可以被跳过，保留的是横向上的结点，而竖向重复结点被跳过）；要么在<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])continue;</code>语句不能跳过已加入的竖向重复结点和横向重复结点的情况下，限制加入的重复结点数量如[回溯1](# 回溯1)用<code>used</code>数组记录每一个结点的数量，那么当i从开始时，只会最多加入原数组数量的元素，一旦超过就会被跳过。以上两种算法过程都如下图，</p><p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%85%A8%E6%8E%92%E5%88%97.png"></p><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a><strong>重新安排行程</strong></h2><h3 id="回溯-10"><a href="#回溯-10" class="headerlink" title="回溯"></a>回溯</h3><p>本题中，关键点在于</p><ul><li>记录出发机场和目标机场的容器，同时还要记录是否访问过，防止死循环</li><li>回溯的终止条件，因为一定存在合理路径，所以机票数+1 &#x3D; 机场数</li><li>容器按字典序排列目标机场，若访问字典序较高的目标机场时，该机场是死胡同，则应返回或者回溯</li><li>回溯的返回值应该是bool类型，用返回值来判断是否应该回溯（删除死胡同元素）</li></ul><ol><li><p>递归终止条件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">if</span>(tickets.<span class="hljs-keyword">size</span>()==res.<span class="hljs-keyword">size</span>()-<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>递归返回值</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lsl">bool traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">string</span>&gt;&amp;res,<span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">string</span>&gt;&gt;&amp; tickets)<br></code></pre></td></tr></table></figure><p>当返回值为true时，意味着已添加到结果集的元素符合要求，应该直接返回，而不应回溯（删除）；但当返回值为false时，代表着根据字典序优先访问到的这个机场无法再访问其他机场，是个死胡同，应该回溯（pop_back)</p></li><li><p>递归单层逻辑</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">for</span>(auto const &amp; ticket:tickets[res[res.size()<span class="hljs-number">-1</span>]])<br>&#123;<br><span class="hljs-keyword">if</span>(ticket.<span class="hljs-keyword">second</span>&gt;<span class="hljs-number">0</span>)<br>&#123;<br>res.push_back(ticket.<span class="hljs-keyword">first</span>);<br>ticket.<span class="hljs-keyword">second</span><span class="hljs-comment">--;</span><br><span class="hljs-keyword">if</span>(traceback(res,tickets))<span class="hljs-literal">return</span> <span class="hljs-literal">true</span>;<br>ticket.<span class="hljs-keyword">second</span>++;<br>res.pop_back();<br>&#125;<br>&#125;<br><span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>上述代码在取目的机场的map时，使用范围for循环，<code>auto &amp;ticket:tickets[res[res.size()-1]]</code>等价于<code>pair&lt;const string,int&gt; &amp;ticket:tickets[res[res.size()-1]]</code>，其中因为map的key值不能改变，所以一定要用const引用，或者只是用副本<code>pair&lt;string,int&gt;ticket:tickets[res[res.size()-1]]</code>。而当不使用范围for循环时，类型符就要更改为<code>map&lt;const string, int&gt;&amp; ticket = tickets[res[res.size()-1]]</code>，因为赋值需要同样的类型或者可转变的类型，而pair不能转变为map</p></li></ol><p>整体代码如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;string, map&lt;string, <span class="hljs-type">int</span>&gt;&gt; targets;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;string&gt;&amp; res, vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() == tickets.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; target:targets[res[res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(target.second&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                target.second--;<br>                res.<span class="hljs-built_in">push_back</span>(target.first);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traceback</span>(res,tickets))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                res.<span class="hljs-built_in">pop_back</span>();<br>                target.second++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ticket : tickets)<br>        &#123;<br>            targets[ticket[<span class="hljs-number">0</span>]][ticket[<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        <span class="hljs-built_in">traceback</span>(res, tickets);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="special解法"><a href="#special解法" class="headerlink" title="special解法"></a>special解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, std::greater&lt;string&gt;&gt;&gt; vec;<br><br>    vector&lt;string&gt; stk;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; curr)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (vec.<span class="hljs-built_in">count</span>(curr) &amp;&amp; vec[curr].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>            string tmp = vec[curr].<span class="hljs-built_in">top</span>();<br>            vec[curr].<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-built_in">move</span>(tmp));<br>        &#125;<br>        stk.<span class="hljs-built_in">emplace_back</span>(curr);<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : tickets) &#123;<br>            vec[it[<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace</span>(it[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br><br>        <span class="hljs-built_in">reverse</span>(stk.<span class="hljs-built_in">begin</span>(), stk.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> stk;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>按字典序从<code>priority_queue</code>中访问目标机场，对新访问的机场进行深度有限搜索，并删除访问过的机场，直到该机场是最后一个机场，则添加到数组当中，再不断返回，将之前访问过的机场也添加到数组中，最后将数组逆序即为结果集</p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>该题巧妙选择容器，记录复杂的信息，用<code>unordered_map</code>记录出发机场和目标机场，是因为不需要对出发机场进行排序，为了减少开销，用<code>map&lt;string,int&gt;</code>按字典序记录目标机场及机票数，不使用<code>multiset</code>单纯记录目标机场，就是为了防止同一张机票的重复访问，防止死循环</p><p>在第二种解法中，使用不用的容器来记录，通过优先队列来按字典序记录目标机场，每次访问只需要<code>p.top()</code>，访问时间复杂度是O(1)，删除的时间复杂度是O(logm)</p><h2 id="破解保险箱"><a href="#破解保险箱" class="headerlink" title="破解保险箱"></a>破解保险箱</h2><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a><strong>N皇后</strong></h2><p>[N皇后](<a href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a>)</p><p>要求在<code>n*n</code>的棋盘上放置n个皇后，并且皇后互相不能攻击，即同行同列包括斜角线上不能有两个皇后</p><p>逐行遍历棋盘，因为只需要在一行中摆放一个皇后，则不需要两层循环遍历，同时还要有判断是否冲突的函数</p><p>首先，根据规则判断在该位置上放置皇后是否会被攻击</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">bool</span> noattack(vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">row</span>)<br>&#123;<br>//列<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(chessboard[i][<span class="hljs-keyword">index</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br>//左上角斜线<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">row</span> - <span class="hljs-number">1</span>, j = <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--, j--)</span><br>&#123;<br><span class="hljs-keyword">if</span>(chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br>//右上角斜线<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">row</span> - <span class="hljs-number">1</span>, j = <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i<span class="hljs-comment">--, j++)</span><br>&#123;<br><span class="hljs-keyword">if</span>(chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为是每一行遍历，因此不需要判断同行是否还有其他皇后；也因为是逐行往下遍历，不需要判断下方是否还有其他皇后，仅判断左上和右上方即可</p><h3 id="回溯-11"><a href="#回溯-11" class="headerlink" title="回溯"></a>回溯</h3><ol><li><p>确定递归结束条件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(chessboard.size()<span class="hljs-operator">=</span><span class="hljs-operator">=</span>n)<br>&#123;<br>res.push_back(chessboard)<span class="hljs-comment">;</span><br>return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不断添加单行到棋盘中，当棋盘中数量达到n时，就是一个符合要求的棋盘摆法</p></li><li><p>确定递归返回值</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">void</span></span> traceback(...)<br><br></code></pre></td></tr></table></figure><p>因为可能有多种不同符合规则的摆法，因此返回值为void，遍历所有可能值再返回</p></li><li><p>确定单层逻辑</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++)<br>&#123;<br>    <span class="hljs-built_in">if</span> (noattack(chessboard, <span class="hljs-built_in">n</span>,<span class="hljs-built_in">index</span>,i))<br>    &#123;<br>        chessboard[<span class="hljs-built_in">index</span>][i] = &#x27;Q&#x27;;<br>        traceback(res, <span class="hljs-built_in">n</span>, chessboard, <span class="hljs-built_in">index</span> + <span class="hljs-number">1</span>);<br>        chessboard[<span class="hljs-built_in">index</span>][i] = &#x27;.&#x27;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对单行棋盘中皇后的摆放位置进行枚举，再递归进入下一行，如果发生相互攻击（遍历完所有值都不符合要求）则进行回溯，不发生攻击则继续递归下一行，直到满足要求</p></li></ol><p>整体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">noattack</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= row; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][column] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = column - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp;j &gt;= <span class="hljs-number">0</span>; --i, --j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = column + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; --i, ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; res, <span class="hljs-type">int</span> n, vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= n)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(chessboard);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">noattack</span>(chessboard, n,index,i))<br>            &#123;<br>                chessboard[index][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                <span class="hljs-built_in">traceback</span>(res, n, chessboard, index + <span class="hljs-number">1</span>);<br>                chessboard[index][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">chessboard</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-built_in">traceback</span>(res, n, chessboard, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>该题的关键点在于</p><ul><li>不需要两层循环，虽然是二维棋盘，但N皇后中不需要在二维棋盘的每一个点上都要放置皇后，仅是<strong>判断当前的点是否能放，因此使用单层循环</strong></li><li>回溯不需要返回值，是因为要寻找<strong>所有可行的棋盘摆放</strong>，应当<strong>用全局变量或者引用返回</strong>，同时要遍历所有情况；若只需要找到<strong>一种可行的棋盘</strong>，则返回值应为**<code>bool</code><strong>，一旦找到则</strong>返回<code>true</code>退出递归**</li><li>不需要对同行皇后进行判断，是因为对<strong>同行位置进行遍历时，肯定不会发生同一行同时有两个皇后出现</strong>，一旦某一个位置能够摆放皇后，就会马上<strong>进入到下一层递归</strong>，即到下一行的遍历，而后面回溯回本行时，又会将原位置的皇后删除，再从下一位进行遍历</li></ul><h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a><strong>解数独</strong></h2><p>[解数独](<a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a>)</p><p>与上题<a href="#N%E7%9A%87%E5%90%8E">N皇后</a>相比，解数独也是在一个二维棋盘上，但不仅要判断该点是否会有冲突，还要在遍历时在每个点上都要填充数字，也就是说，不能像上题一样，如果是单层循环，填完该位置上的数字就进入递归，遍历下一行。因此需要两层循环，填完数字后进入递归，还是从刚填过的位置开始继续填。</p><p>同样，首先需要根据规则判断是否有冲突</p><ul><li>同行不能有重复数字</li><li>同列不能有重复数字</li><li>同一个3x3格子不能有重复数字</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp; chessboard,<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> tmp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//判断列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(chessboard[i][col]==tmp+<span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//判断行</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(chessboard[row][j]==tmp+<span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//判断9宫格</span><br><span class="hljs-type">int</span> subrow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<span class="hljs-comment">//0,1,2行等于0, 3,4,5行等于3，6,7,8行等于6</span><br><span class="hljs-type">int</span> subcol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = subrow; i &lt; subrow + <span class="hljs-number">3</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = subcol; j &lt; subcol + <span class="hljs-number">3</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span>(board[i][j]==tmp+<span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可知，需要多次的循环来完成一次的判断。则可以用哈希表的方法，先储存已有的数字，然后在一次循环完成冲突的判断</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs prolog">//全局变量<br>int row[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] &#123;<span class="hljs-number">0</span>&#125;;<br>int col[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] &#123;<span class="hljs-number">0</span>&#125;;<br>int subbox[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] &#123;<span class="hljs-number">0</span>&#125;;<br><br>//先完成对棋盘上已有数字的存储<br>for(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br>for(int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++)<br>&#123;<br>if(chessboard[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>)<br>&#123;<br>int tmp = chessboard[i][j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>row[i][tmp] = <span class="hljs-number">1</span>;<br>col[j][tmp] = <span class="hljs-number">1</span>;<br>subbox[j/<span class="hljs-number">3</span> + (i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>bool ok(int i, int j, int tmp)<br>&#123;<br>if(row[i][tmp]==<span class="hljs-number">1</span>)<br>return false;<br>if(col[j][tmp]==<span class="hljs-number">1</span>)<br>return false;<br>if(subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp]==<span class="hljs-number">1</span>)<br>return false;<br>row[i][tmp] = <span class="hljs-number">1</span>;<br>col[j][tmp] = <span class="hljs-number">1</span>;<br>subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">1</span>;<br>return true;<br>&#125;<br></code></pre></td></tr></table></figure><p>将三种规则分别替换为三个用二维数组记录的哈希表，行表（row）用第一维表示对应的行数，用第二维表示该行上出现过的数字<code>0-9</code>，如果出现过则置为1，列表（col）同理；由于9宫格中刚好有九个数字，也可以用同样的方法来记录，将棋盘上行列号映射为9个不同的9宫格序号，再记录出现过的数字</p><h3 id="回溯-12"><a href="#回溯-12" class="headerlink" title="回溯"></a>回溯</h3><ol><li><p>确定递归结束条件</p><p>因为结束时，总是需要遍历棋盘上所有位置，当遍历结束也就是递归的结束，因此不需要递归的结束条件</p></li><li><p>确定递归返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; chessboard, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span><br></code></pre></td></tr></table></figure><p>因为只需要寻找到一种符合的答案，一旦遇到有，则应立即退出递归并返回</p></li><li><p>递归单层逻辑</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs prolog">for(int i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>for(int j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>&#123;<br>if(chessboard[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>&#123;<br>for(int tmp = <span class="hljs-number">1</span>;tmp&lt;<span class="hljs-number">10</span>;tmp++)<br>&#123;<br>if(ok(i,j,tmp))<br>&#123;<br>chessboard[i][j]=tmp+<span class="hljs-string">&#x27;0&#x27;</span>;<br>if(traceback(chessboard)) return true;<br>chessboard[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>row[i][tmp] = <span class="hljs-number">0</span>;<br>col[j][tmp] = <span class="hljs-number">0</span>;<br>subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>return false;<br>&#125;<br>&#125;<br>&#125;<br>return true;<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs prolog">class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>int row[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;,column[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;, subbox[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    bool ok(int i, int j, int tmp)<br>    &#123;<br>        if(row[i][tmp]==<span class="hljs-number">1</span>)<br>            return false;<br>        if(column[j][tmp]==<span class="hljs-number">1</span>)<br>            return false;<br>        if(subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp]==<span class="hljs-number">1</span>)<br>            return false;<br>        row[i][tmp] = <span class="hljs-number">1</span>;<br>        column[j][tmp] = <span class="hljs-number">1</span>;<br>        subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">1</span>;<br>        return true;<br>    &#125;<br>    bool traceback(vector&lt;vector&lt;char&gt;&gt;&amp; board)<br>    &#123;<br>        for(int i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>        &#123;<br>            for(int j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>            &#123;<br>                if(board[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                &#123;<br>                    for(int tmp = <span class="hljs-number">1</span>;tmp&lt;<span class="hljs-number">10</span>;tmp++)<br>                    &#123;<br>                        if(ok(i,j,tmp))<br>                        &#123;<br>                            board[i][j] = tmp+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                            if(traceback(board)) return true;<br>                            board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                            row[i][tmp] = <span class="hljs-number">0</span>;<br>                            column[j][tmp] = <span class="hljs-number">0</span>;<br>                            subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">0</span>;<br>                        &#125;<br>                    &#125;<br>                    return false;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return true;<br>    &#125;<br>    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;<br>        for(int i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>        &#123;<br>            for(int j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>            &#123;<br>                if(board[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>)<br>                &#123;<br>                    int tmp = board[i][j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                    row[i][tmp] = <span class="hljs-number">1</span>;<br>                    column[j][tmp] = <span class="hljs-number">1</span>;<br>                    subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        traceback(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>该题的关键点在于</p><ul><li>递归中需要用双层循环，<strong>如果单层循环，则在该行填入一个数字之后进入递归，不管传入怎样的参数都不能使继续填充该行并且完成换行继续填充</strong></li><li>递归不需要结束条件，因为题目需要对棋盘上所有点都进行一次遍历，递归结束时就是得到结果时，即遍历结束即为递归结束</li><li>递归需要返回值，题目保证能找到一个有效的解决方案，且最多只有一个解，因此返回bool值，当找到时，即遍历完棋盘，就返回true；当在棋盘上某一个点遍历完9个数字都没有合适结果时，应当返回false，令上一层递归进行回溯。也就是说，有返回值如bool类型，可以通过判断返回值（如果为真）可以避免进一步递归，同时还能让进入多余分支的递归及时退出，防止了死循环（如本题，在没有递归结束条件的情况下，如果不用返回值限制则会导致死循环）；而无返回值的通常是要遍历所有分支，从中找到所有解</li><li>一次循环即可完成对数独是否有效的判断，借助哈希表，将一维的数据通过二维的哈希表进行重复性判断</li></ul><h2 id="最接近目标价格的甜点成本"><a href="#最接近目标价格的甜点成本" class="headerlink" title="最接近目标价格的甜点成本"></a><a href="https://leetcode.cn/problems/closest-dessert-cost/">最接近目标价格的甜点成本</a></h2><p>该题要求从必选数组<code>base</code>中选择一份基料，以及从可选数组<code>topping</code>中选择0份、1份或者2份配料，组成的冰淇淋总价格最接近<code>target</code>且成本最低</p><h3 id="回溯-13"><a href="#回溯-13" class="headerlink" title="回溯"></a>回溯</h3><p>容易想到，给定数据量较少，可以用回溯算法对数组进行遍历，用<code>set</code>保存可行的方案，并最终选择最合适的一个价格返回</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    set&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; toppingCosts, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> res)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (index == toppingCosts.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; toppingCosts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            res += toppingCosts[i];<br>            vec.insert(res);<br>            traceback(toppingCosts, <span class="hljs-built_in">target</span>, i + <span class="hljs-number">1</span>, res);<br>            res += toppingCosts[i];<br>            vec.insert(res);<br>            traceback(toppingCosts, <span class="hljs-built_in">target</span>, i + <span class="hljs-number">1</span>, res);<br>            res -= toppingCosts[i] * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> closestCost(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; baseCosts, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; toppingCosts, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//int m = toppingCosts.size();</span><br>        <span class="hljs-comment">//for (int i = 0; i &lt; m; i++)</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    toppingCosts.push_back(toppingCosts[i]);</span><br>        <span class="hljs-comment">//&#125;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; baseCosts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            res = baseCosts[i];<br>            vec.insert(res);<br>            traceback(toppingCosts, <span class="hljs-built_in">target</span>, <span class="hljs-number">0</span>, res);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br>        <span class="hljs-keyword">for</span> (auto it: vec)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">target</span> - it) &lt; <span class="hljs-built_in">abs</span>(ans - <span class="hljs-built_in">target</span>))<br>                ans = it;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">target</span> - it == <span class="hljs-built_in">abs</span>(ans-<span class="hljs-built_in">target</span>)))<br>                ans = it &lt; ans? it:ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><del>因为最多可以添加两份配料，则将原数组<code>topping</code>中的元素都复制一遍，再进行回溯</del>，但会超时</p><p>则可以对数组<code>topping</code>中的同一个元素进行两次回溯递归，分别将一份和两份配料的价格传递到递归当中</p><p>无论价格是多少，都会被存入到<code>set</code>当中，因为难以在存入结果之前对结果的合法性进行判断，所以只能被动地存入所有结果，最后在遍历所有结果的时候，选取最合适的结果</p><h3 id="回溯优化-4"><a href="#回溯优化-4" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>优化在只需要用O(1)的空间存储结果，存储的不再是所有结果，而是最合适的结果，并对其进行维护</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> ans = INT_MAX;<br>    void traceback(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; toppingCosts, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span>, <span class="hljs-built_in">int</span> res)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-keyword">target</span>-ans) &gt; <span class="hljs-built_in">abs</span>(res-<span class="hljs-keyword">target</span>))<br>            ans = res;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-keyword">target</span>-ans) == <span class="hljs-built_in">abs</span>(res-<span class="hljs-keyword">target</span>) &amp;&amp; res &lt; ans )<br>            ans = res;<br>        <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-keyword">target</span>)<br>            <span class="hljs-keyword">return</span>;<br>        for (<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">index</span>; i &lt; toppingCosts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            traceback(toppingCosts, <span class="hljs-keyword">target</span>, i + <span class="hljs-number">1</span>, res + toppingCosts[i]);<br>            traceback(toppingCosts, <span class="hljs-keyword">target</span>, i + <span class="hljs-number">1</span>, res+ <span class="hljs-number">2</span> * toppingCosts[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">int</span> closestCost(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; baseCosts, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; toppingCosts, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; baseCosts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            res = baseCosts[i];<br>            traceback(toppingCosts, <span class="hljs-keyword">target</span>, <span class="hljs-number">0</span>, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><strong>回溯算法的题目要注意回溯参数<code>i</code>与 <code>index</code>，如果是<code>i</code>，则是允许元素重复加入结果集，在本题中，使用<code>i</code>作为参数传递而不是<code>i+1</code>，则意味着可以使用任意数量的配料<code>topping</code>，不符合题意；添加元素到结果集时，向递归函数传递的参数永远都是<code>i</code>而不是<code>index</code></strong></p><p><strong>因为有必选数组和可选数组的存在，对必选数组进行<code>for</code>循环遍历，再进行回溯，保证结果集中有必选数组的元素；而必选数组中又可以对不同数量的元素重复使用（同一个元素最多两次），则可以通过两次回溯调用来实现</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C3P阅读笔记</title>
    <link href="/2022/10/18/C3P%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/18/C3P%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="第二章——变量和基本类型"><a href="#第二章——变量和基本类型" class="headerlink" title="第二章——变量和基本类型"></a>第二章——变量和基本类型</h2><h3 id="char类型及其扩展"><a href="#char类型及其扩展" class="headerlink" title="char类型及其扩展"></a>char类型及其扩展</h3><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td><code>char</code></td><td>字符</td><td>8bit</td></tr><tr><td><code>wchar_t</code></td><td>宽字符</td><td>16bit</td></tr><tr><td><code>char16_t</code></td><td>Unicode字符</td><td>16bit</td></tr><tr><td><code>char32_t</code></td><td>Unicode字符</td><td>32bit</td></tr></tbody></table><p><code>wchar_t</code>确保可以存放机器最大扩展字符集中的任一个字符，char16_t和char32_t为Unicode字符集服务</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>如果赋予一个取值区间之外的值，如<code>unsigned char</code>（8bit）表示0-255，赋予-2，则-2对256取模后的余数，实际结果为254(数据类型所占位数而定)</p><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>默认的，整形字面值数据类型是带符号数，即<code>int</code>；浮点型默认数据类型为<code>double</code>，因为float精度不够且双精度浮点数计算代价与单精度差不多；字符串字面值结尾处会多一个空字符<code>\0</code>，字符串字面值的实际长度要比它的内容多1；若两个字符串字面值位置紧邻且仅由<em><strong>空格、缩进和换行符</strong></em>分割时，实际上是一个整体</p><h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\n</span> 换行符<span class="hljs-string">\t</span> 横向制表符<span class="hljs-string">\v</span> 纵向制表符<span class="hljs-string">\b</span> 退格符<span class="hljs-string">\r</span> 回车符(清空当前行并回到行首)<br></code></pre></td></tr></table></figure><p>如果反斜线后的八进制数字超过三个，只有前三个与反斜线构成转义序列；如果跟着十六进制数字，则所有十六进制数字都参与构成转义序列</p><h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><table><thead><tr><th>前缀&#x2F;后缀</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>u</td><td>Unicode16字符</td><td><code>char16_t</code></td></tr><tr><td>U</td><td>Unicode32字符</td><td><code>char32_t</code></td></tr><tr><td>L</td><td>宽字符</td><td><code>wchar_t</code></td></tr><tr><td>u8</td><td>UTF-8</td><td><code>char</code></td></tr><tr><td>整型后缀</td><td></td><td></td></tr><tr><td>u&#x2F;U</td><td>无符号型</td><td><code>unsigned</code></td></tr><tr><td>l&#x2F;L</td><td></td><td><code>long</code></td></tr><tr><td>ll&#x2F;LL</td><td></td><td><code>long long</code></td></tr><tr><td>浮点型后缀</td><td></td><td></td></tr><tr><td>f&#x2F;F</td><td></td><td><code>float</code></td></tr><tr><td>l&#x2F;L</td><td></td><td><code>long double</code></td></tr></tbody></table><p>整型字面值不能添加浮点型后缀F</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>如果使用列表初始化且初始值存在信息丢失的风险，则会报错，如<code>int a = &#123;3.14&#125;</code></p><ol><li>在任何函数体之外的变量会被初始化为0</li><li>在函数体内部的内置型变量不会被初始化，其未定义，不可被访问</li><li>类不初始化则由类自己定义</li></ol><p>变量声明规定了变量的类型和名字，定义则为其开辟空间</p><p>变量声明：在变量名前添加关键字 <code>extern</code>，如<code>extern int i;</code>。但如果包含了初始值，就变成了定义：<code>extern double pi = 3.14;</code></p><p>变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。</p><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>同时存在全局和局部变量时，已定义局部变量的作用域中可用<code>::reused</code>显式访问全局变量reused。</p><h3 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h3><p>引用类型的初始值必须是一个<em><strong>对象</strong></em>（不能是字面值），必须在定义时给引用赋初值</p><p>指针本身就是一个对象，可以不赋初值</p><p>引用自加——引用的对象加一</p><p>指针自加——指针指向下一个类型，即向后偏移一个类型的大小</p><h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a><code>void*</code>指针</h3><p>可以存放任意对象的地址，但不能访问对象</p><ol><li>与其它指针比较</li><li>当做函数的输入或输出</li><li>赋值给另一个<code>void*</code>指针</li></ol><h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3><p><code>int i = 0; </code></p><p><code>int* b = &amp;i; </code></p><p><code>int * &amp; a = b;</code></p><p><code>i</code>是整型变量，<code>b</code>是指向整型变量<code>i</code>的整型指针，<code>a</code>是指向整型指针<code>b</code>的整型引用</p><p><code>*a = 1;</code>通过引用对整型变量进行访问和修改</p><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a><code>const</code>限定符</h3><p><code>const</code>对象一旦创建就不能被修改，因此在定义时必须赋初值</p><p><code>const int ci = 0; int i = ci; </code><code>const</code>的常量特征只在被修改时显示，因此可以用常量值赋初值</p><h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a><code>const</code>的引用</h3><p>即为对常量的引用，且无法对引用对象进行修改(常量引用)</p><p><code>const int ci = 30; const int &amp; cr = ci</code></p><p>则<code>cr</code>为对<code>ci</code>的常量引用</p><p>常量引用初始化时能够用字面值赋值，而引用不能，且能够用任意表达式进行初始化</p><p><code>const</code>引用的也可以不是常量，因为引用对象本身不是常量，即时不能通过引用修改对象，但能通过其他途径来修改。</p><h3 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a><em><strong>常量指针和指针常量</strong></em></h3><p><code>const int ci = 30; int const* cptr =&amp;ci;</code> 则<code>cptr</code>为指向常量的<code>int</code>指针，且因为其是指针，可以不用初始化</p><p>常量指针指向的也可以不是常量，只是不能通过指针改变对象的值，但仍可以通过其他途径修改。底层<code>const</code></p><p><code>const int ci = 30; const int *const ptrc = &amp;ci;</code>则<code>ptrc</code>为指针常量，是一个指向整型常量的<code>const int</code>指针常量</p><p><code>int i = 30; int *const ptri = &amp;i;</code>则<code>prti</code>为指针常量，是一个指向整型字面量的<code>int</code>指针常量。顶层<code>const</code></p><p>相同地，指针常量指向的也可以不是常量，只是不能更改指针常量本身的指向，但仍可以通过其他途径修改对象的值</p><h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>声明为<code>constexpr</code>的变量一定是一个常量（顶层<code>const</code>），且必须用常量表达式初始化。一个<code>constexpr</code>指针的初始值必须为0或者<code>nullptr</code>或者是存在某个固定地址的对象；定义于所有函数体之外的对象其地址固定不变，此时能用于初始化<code>constexpr</code>指针。</p><p><code>constexpr int *q = nullptr</code>则q为指向整数的指针常量</p><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a><em><strong>处理类型</strong></em></h3><p><code>using SI = Sales_item;</code> 类型别名</p><p><code>typedef char *pstring; </code><code>pstring</code>为<code>char*</code>类型，指向<code>char</code>类型的指针</p><p> <code>const pstring cstr = 0; </code><code>cstr</code>为指向<code>char</code>的指针常量，注意与下一个式子的区别</p><p> <code>const char *cstr = 0; </code><code>cstr</code>为指向<code>char</code>的常量指针</p><p><code>decltype</code>返回表达式结果或变量对应的类型；如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型；如果表达式或者变量加多一层括号，则也将得到引用类型</p><p><code>const int ci = 0;decltype(ci) x = 0</code>则x的类型为<code>const int</code></p><p><code>int i = 30; decltype(*p) c = i</code>则p的类型为引用类型</p><p><code>decltype ((i)) d = i</code>则d的类型也为引用类型</p><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><ul><li><code>#indef</code>已定义时为真</li><li><code>#inndef</code>未定义时为真</li><li>头文件保护符的名称需要唯一，且保持全部大写。养成良好习惯，不论是否该头文件被包含，要加保护符。</li></ul><h2 id="第三章——字符串、向量和数组"><a href="#第三章——字符串、向量和数组" class="headerlink" title="第三章——字符串、向量和数组"></a>第三章——字符串、向量和数组</h2><h3 id="string对象"><a href="#string对象" class="headerlink" title="string对象"></a>string对象</h3><p>如果提供一个字符串字面值给string对象初始化，则该字面值中除了最后的空字符其他所有字符都被拷贝到string对象</p><ul><li><p>string io：</p><ul><li><code>string word; cin&gt;&gt;word</code>忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止</li><li><code>string word; while(cin&gt;&gt;word)</code>读取到文件结束符或非法输入时停止 Ctrl+Z</li><li><code>getline</code>：读取一整行，<strong>包括空白符</strong>，直到换行符，但不会将换行符存到string对象中</li><li>string line; while(getline(cin,line))</li></ul></li><li><p><code>s.size()</code>返回的时<code>string::size_type</code>类型，记住是一个<strong>无符号</strong>类型的值，不要和<code>int</code>混用</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">void<span class="hljs-built_in"> check </span>(size_type i,<span class="hljs-built_in"> const </span>string &amp;msg)<span class="hljs-built_in"> const</span><br><span class="hljs-built_in"></span>&#123;<br>if(i&gt;=data-&gt;size())<br><span class="hljs-built_in">throw </span>out_of_range(msg);<br>&#125;<br>当i小于0，会自动转换成正整数，即i = i + UINT_MAX;<br></code></pre></td></tr></table></figure></li><li><p><code>s1+s2</code>使用时，保证至少一侧是string类型。<code>string s1 = &quot;hello&quot; + &quot;world&quot; // 错误，两侧均为字符串字面值</code></p></li></ul><p><code>cctype</code>头文件中的标准函数</p><table><thead><tr><th>函数</th><th>解释</th></tr></thead><tbody><tr><td><code>isalnum(c)</code></td><td>当<code>c</code>是字母或数字时为真</td></tr><tr><td><code>isalpha(c)</code></td><td>当<code>c</code>是字母时为真</td></tr><tr><td><code>iscntrl(c)</code></td><td>当<code>c</code>是控制字符时为真</td></tr><tr><td><code>isdigit(c)</code></td><td>当<code>c</code>是数字时为真</td></tr><tr><td><code>isgraph(c)</code></td><td>当<code>c</code>不是空格但可以打印时为真</td></tr><tr><td><code>islower(c)</code></td><td>当<code>c</code>是小写字母时为真</td></tr><tr><td><code>isprint(c)</code></td><td>当<code>c</code>是可打印字符时为真</td></tr><tr><td><code>ispunct(c)</code></td><td>当<code>c</code>是标点符号时为真</td></tr><tr><td><code>isspace(c)</code></td><td>当<code>c</code>是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</td></tr><tr><td><code>isupper(c)</code></td><td>当<code>c</code>是大写字母时为真</td></tr><tr><td><code>isxdigit(c)</code></td><td>当<code>c</code>是十六进制数字时为真</td></tr><tr><td><code>tolower(c)</code></td><td>当<code>c</code>是大写字母，输出对应的小写字母；否则原样输出<code>c</code></td></tr><tr><td><code>toupper(c)</code></td><td>当<code>c</code>是小写字母，输出对应的大写字母；否则原样输出<code>c</code></td></tr></tbody></table><h3 id="vector对象"><a href="#vector对象" class="headerlink" title="vector对象"></a>vector对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//v1中有10个元素，默认值为0</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v2&#123;<span class="hljs-number">10</span>&#125;;<span class="hljs-comment">//v2中有1个元素，值为10</span><br></code></pre></td></tr></table></figure><p>如果初始化用的是圆括号，则提供的值是用来构造vector对象；</p><p>如果初始化用的是花括号，则表示列表初始化vector对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; v3&#123;<span class="hljs-number">10</span>&#125;;<span class="hljs-comment">//v3中有10个元素，默认值为空</span><br></code></pre></td></tr></table></figure><p>当初始化用了花括号的形式，但提供的值又无法列表初始化，则编译器会尝试用默认值初始化vector对象</p><p>因为范围for循环语句内不应改变其所遍历序列的大小，因此不能用范围for循环向vector添加元素</p><p>size返回值的类型是由vector定义的size_type类型即<code>vector&lt;int&gt;::size_type</code></p><p>用下标访问vector，下标类型应是size_type类型，可以通过<code>auto</code>或者<code>decltype</code>获取</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran">for(decltype(ivec.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">index</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">index</span>&lt;=<span class="hljs-number">10</span>;<span class="hljs-built_in">index</span>++)<br>ivec.push_back(ix);<br></code></pre></td></tr></table></figure><pre><code class="hljs">### vector迭代器</code></pre><p><code>*iter.mem</code>等同于<code>iter-&gt;mem</code></p><p><code>vector&lt;int&gt;::iterator it1; </code>&#x2F;&#x2F;<code>it1</code>能够读写元素</p><p><code>vector&lt;int&gt;::const_iterator it2;</code>&#x2F;&#x2F;it2只能读元素，不能写</p><p>两个迭代器之间的运算只有减法运算，返回值类型为<code>difference_type</code></p><p><code>difference_type</code>返回带符号整数，所得结果是右侧迭代器向前移动能追上左侧迭代器的距离</p><p>迭代器与整数值之间有加法运算</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的大小确定不变，不能随意向数组中增加元素</p><p>数组声明时，其中维度必须是<em><strong>常量表达式</strong></em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> cnt = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> sz = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">30</span>];<span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span> arr[cnt];<span class="hljs-comment">//报错，cnt不是常量表达式</span><br><span class="hljs-type">int</span> ve[sz];<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p><em><strong>字符数组在用字符串字面值初始化时，会自动添加表示字符串结束的空字符</strong></em></p><p><em><strong>不允许数组拷贝初始化，也不允许用数组给其他数组赋值</strong></em></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-built_in">int</span> a2[] = a;<span class="hljs-comment">//报错，不允许数组拷贝初始化</span><br>a2 = a;<span class="hljs-comment">//报错，不允许用数组赋值</span><br></code></pre></td></tr></table></figure><p>数组下标类型为<code>size_t</code>（头文件cstddef），而vector和string的下标类型为<code>size_type</code></p><h3 id="复杂数组"><a href="#复杂数组" class="headerlink" title="复杂数组"></a>复杂数组</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> *ptrs[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">int</span> (*parray)[<span class="hljs-number">10</span>]=&amp;arr;<br><span class="hljs-built_in">int</span> (&amp;<span class="hljs-built_in">array</span>)[<span class="hljs-number">10</span>]=arr;<br></code></pre></td></tr></table></figure><p><code>ptrs</code>是一个数组，包含了10个整型指针——指针数组</p><p> <code>parray</code>是一个指针，指向一个有10个整型元素的数组——数组指针</p><p><code>array</code>是一个引用，引用对象是一个有10个整型元素的数组</p><p><code>int *(&amp;array)[10]=ptrs</code>则是一个引用，引用对象是一个有10个整型指针的数组</p><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>数组名就是数组首元素的指针</p><p><code>string *p2=nums;//等价于p2 = &amp;nums[0];</code></p><p>auto可以推断数组名得到指针类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>;<span class="hljs-comment">//ia2是一个指针，指向数组ia首元素</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia3</span><span class="hljs-params">(&amp;ia[<span class="hljs-number">0</span>])</span></span>;<span class="hljs-comment">//同上</span><br></code></pre></td></tr></table></figure><p>但当用decltype时则不一样</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">decltype</span>(ia) ia4;<span class="hljs-comment">//获取到的是ia的数组类型，即ia4是一个整型数组</span><br></code></pre></td></tr></table></figure><h3 id="数组的库函数"><a href="#数组的库函数" class="headerlink" title="数组的库函数"></a>数组的库函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia);<span class="hljs-comment">//beg指向首元素</span><br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia);<span class="hljs-comment">//last指向尾元素</span><br></code></pre></td></tr></table></figure><p>当两个数组指针相减时，返回的类型为<code>ptrdiff_t</code>；vector和string返回的类型为<code>difference_type</code>，都是一种带符号类型</p><p>数组下标可以是负数，而vector的下标只能是正整数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> *p = &amp;ia[<span class="hljs-number">2</span>];<span class="hljs-comment">//p指向数组第三个元素</span><br><span class="hljs-built_in">int</span> j = p[<span class="hljs-number">-2</span>];<span class="hljs-comment">//指向数组ia的首元素</span><br></code></pre></td></tr></table></figure><h3 id="C风格的字符串-不推荐使用"><a href="#C风格的字符串-不推荐使用" class="headerlink" title="C风格的字符串(不推荐使用)"></a>C风格的字符串(不推荐使用)</h3><p>会在字符串最后一个字符后面跟着一个空字符(<code>\0</code>)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">char</span> ca[] = &#123;<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> ca1[] = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><p>C标准库String函数，定义在<code>&lt;cstring&gt;</code> 中：</p><table><thead><tr><th>函数</th><th>介绍</th></tr></thead><tbody><tr><td><code>strlen(p)</code></td><td>返回<code>p</code>的长度，空字符不计算在内</td></tr><tr><td><code>strcmp(p1, p2)</code></td><td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td></tr><tr><td><code>strcat(p1, p2)</code></td><td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td></tr><tr><td><code>strcpy(p1, p2)</code></td><td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code></td></tr></tbody></table><p>C风格字符串不支持运算符操作，如<code>+,-,==</code>，因为操作的是指针而非字符串本身，并无意义</p><h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><p>允许使用string对象给C风格字符串初始化</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello!&quot;</span><span class="hljs-comment">;</span><br>const char *str <span class="hljs-operator">=</span> s.c_str()<span class="hljs-comment">;//c_str()返回一个C风格的字符串，即一个指针，并在数组最后加上空字符结束</span><br></code></pre></td></tr></table></figure><p>使用数组给vector初始化</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(begin(ia),end(ia))</span></span>;<br></code></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>数组的数组，由内而外的顺序理解</p><p>使用范围for循环访问多维数组时，外层循环需要使用引用类型，这是为了在内层循环数组被自动转成指针</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(const auto &amp;<span class="hljs-built_in">row</span>: ia)<br>&#123;<br><span class="hljs-keyword">for</span>(auto <span class="hljs-built_in">col</span>:<span class="hljs-built_in">row</span>)<br>cout &lt;&lt; <span class="hljs-built_in">col</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 如果不加引用</span><br><span class="hljs-keyword">for</span>(auto <span class="hljs-built_in">row</span>: ia)<br><span class="hljs-keyword">for</span>(auto <span class="hljs-built_in">col</span>:<span class="hljs-built_in">row</span>)<br><span class="hljs-comment">//此时row转成指针，类型为int* 因此在内层循环时就会报错</span><br></code></pre></td></tr></table></figure><p>利用别名代替，使多维数组降维访问</p><p><code>using int_array int[4];</code></p><p><code>typedef int int_array[4];</code></p><p>编写3个不同版本的程序，令其均能输出<code>ia</code>的元素。<br>版本1使用范围<code>for</code>语句管理迭代过程；版本2和版本3都使用普通<code>for</code>语句，其中版本2要求使用下标运算符，版本3要求使用指针。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout; <span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <br>    &#123; <br>        &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;,<br>        &#123; <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;,<br>        &#123; <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span> &#125;<br>    &#125;;<br>    <br><span class="hljs-comment">//范围for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p:arr)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q:p)<br>    cout &lt;&lt; q &lt;&lt; endl;<br>    <span class="hljs-comment">//范围for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-built_in">int</span> (&amp;p)[<span class="hljs-number">4</span>]:arr)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> q:p)<br>    cout &lt;&lt; q &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">//下标for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j&lt;arr[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)<br>    cout &lt;&lt; arr[i][j] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">//指针for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> *p = <span class="hljs-built_in">begin</span>(arr); p! = <span class="hljs-built_in">end</span>(arr); p++)<br>    &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> *q = <span class="hljs-built_in">begin</span>(*p);q!= end（*p);q++)<br>    cout &lt;&lt; *q &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//指针for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span>(*p)[<span class="hljs-number">4</span>]=arr;p &lt; arr.<span class="hljs-built_in">size</span>();p++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> *q = *p;q &lt; arr[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();q++)<br>    cout &lt;&lt; *q &lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="第四章——表达式"><a href="#第四章——表达式" class="headerlink" title="第四章——表达式"></a>第四章——表达式</h2><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>当一个对象被用作左值时，使用的是对象的身份（在内存中的位置）；</p><p>当一个对象被用作右值时，使用的是对象的值</p><p>解引用符返回的结果是左值</p><p>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">decltype</span>(*p);<span class="hljs-comment">//返回引用类型int&amp;</span><br><span class="hljs-built_in">decltype</span>(&amp;p);<span class="hljs-comment">//返回指针类型int**，即指向整型指针的指针</span><br></code></pre></td></tr></table></figure><p>表达式的结果是左值，decltype得到引用类型；表达式的结果是右值，decltype得到指针类型</p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>运算对象和运算结果都是右值</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bool b <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br>bool b2 <span class="hljs-operator">=</span> -b<span class="hljs-comment">;//b2依然为true</span><br></code></pre></td></tr></table></figure><p>参与取余运算的运算对象都为整数类型</p><p><code>(-m)/n,m/(-n)</code>结果都为<code>-(m/n)</code></p><p><code>m%(-n)</code>结果为<code>m%n</code>，<code>(-m)%n</code>结果为<code>-(m%n)</code></p><p>逻辑和关系运算符运算对象和运算结果都是右值</p><h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p>前置递增运算符将对象本身作为左值返回，后置递增则将对象原始值的副本作为右值返回。后置需要将原始值存储下来以便返回这个未修改的内容，如果不需要修改前的值，应直接使用前置递增</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">auto <span class="hljs-built_in">iter</span> = vi.begin();<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">iter</span>!=vi.end()&amp;&amp;*<span class="hljs-built_in">iter</span>&gt;=<span class="hljs-number">0</span>)<br>cout&lt;&lt;*<span class="hljs-built_in">iter</span>++&lt;&lt;endl;// 输出当前值，指针向前移<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>后置递增运算符高于解引用运算符</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">vec</span>[ival++]&lt;=<span class="hljs-built_in">vec</span>[ival];<span class="hljs-comment">//表达式未定义,应改为</span><br><span class="hljs-built_in">vec</span>[ival]&lt;=<span class="hljs-built_in">vec</span>[ival+<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>不应在运算符左右两边都用到一个变量，并且右侧还改变其值</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">while</span><span class="hljs-comment">(beg!=s.end()</span> &amp;&amp; !isspace<span class="hljs-comment">(*beg)</span>)<br>*beg = toupper<span class="hljs-comment">(*beg++)</span>;<span class="hljs-comment">//未定义</span><br></code></pre></td></tr></table></figure><p>假设<code>iter</code>的类型是<code>vector::iterator</code>, 说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a) *iter++;<br>(b) (*iter)++;<br>(c) *iter.<span class="hljs-built_in">empty</span>();<br>(d) iter-&gt;<span class="hljs-built_in">empty</span>();<br>(e) ++*iter;<br>(f) iter++-&gt;<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure><p>解：</p><ul><li>(a)合法。返回迭代器所指向的元素，然后迭代器递增。</li><li>(b)不合法。因为<code>vector</code>元素类型是<code>string</code>，没有<code>++</code>操作。</li><li>(c)不合法。这里应该加括号。</li><li>(d)合法。判断迭代器当前的元素是否为空。</li><li>(e)不合法。<code>string</code>类型没有<code>++</code>操作。</li><li>(f)合法。判断迭代器当前元素是否为空，然后迭代器递增。</li></ul><h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><ul><li>对引用类型执行sizeof运算得到引用对象的类型大小</li><li>对解引用指针类型执行sizeof运算得到指针指向对象的类型大小，指针可以不有效</li><li>对数组执行sizeof运算得到整个数组所占空间的大小，而不会把数组转换成指针</li><li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，与对象中元素个数或所占空间大小无关</li></ul><p>通过查看STL源码可以看到vector有四个成员变量<br>   _A  allocator; </p><p>   iterator  _First,  _Last,  _End; </p><p>所以<code>sizeof(vec)</code>会返回4个字节即16bit</p><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><p>隐式转换</p><ul><li><p>常见的char、bool、short能存在int就会转换成int，否则提升为<code>unsigned int</code></p></li><li><p><code>wchar_t,char16_t,char32_t</code>提升为整型中<code>int,long,long long ……</code>最小的，且能容纳原类型所有可能值的类型</p></li><li><p>当数组被用作<code>decltype</code>关键字的参数，或者作为取地址符(&amp;)、<code>sizeof</code>及<code>typeid</code>等运算符的运算对象时，转换不发生</p></li></ul><p>显示转换</p><ul><li><p><strong>static_cast</strong>：任何明确定义的类型转换，只要不包含底层const，都可以使用。 <code>double slope = static_cast&lt;double&gt;(j);</code></p></li><li><p><strong>dynamic_cast</strong>：支持运行时类型识别</p></li><li><p><strong>const_cast</strong>：只能改变运算对象的底层const，一般可用于去除const性质。 <code>const char *pc; char *p = const_cast&lt;char*&gt;(pc)</code>只有其可以改变常量属性，通常用在<em><strong>函数重载</strong></em></p></li><li><p><strong>reinterpret_cast</strong>：通常为运算对象的位模式提供低层次上的重新解释，实际上仍为原类型</p></li></ul><h2 id="第五章——语句"><a href="#第五章——语句" class="headerlink" title="第五章——语句"></a>第五章——语句</h2><h3 id="悬垂else"><a href="#悬垂else" class="headerlink" title="悬垂else"></a>悬垂else</h3><p>有多个if时，else只与离它最近的尚未匹配的if匹配或者在想要匹配的if语句下加上花括号，以控制执行路径</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>case关键字和它对应的值一起被称为case标签，其必须是整型常量表达式</p><p>如果某个case标签匹配成功，将从改标签开始往后顺序执行所有case分支，因此需要添加break语句</p><p>若以一个空的default标签作为结束，则必须跟上一个空语句或者空块</p><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(init-statement<span class="hljs-comment">;condition;expression)</span><br>statement<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在init-statement中可以定义多个对象，但只能有一条声明语句，即所有变量的基础类型都必须相同</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">for(<span class="hljs-name">decltype</span>(<span class="hljs-name">v</span>.size() ) i=0,sz = v.size()<span class="hljs-comment">; i != sz; ++i)</span><br>v.push_back(<span class="hljs-name">v</span>[i])<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>for语句也可以省略掉任意一部分，但要以一条空语句代替，即要保留分号</p><p><code>if(cin.eof())</code>可以读取<code>eof</code>文件结束符，可以用<code>Ctrl+z</code>代替</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常处理包括：</p><ul><li><strong>throw表达式</strong>：异常检测部分使用 <code>throw</code>表达式来表示它遇到了无法处理的问题。我们说 <code>throw</code>引发 <code>raise</code>了异常。</li><li><strong>try语句块</strong>：以 <code>try</code>关键词开始，以一个或多个 <code>catch</code>字句结束。 <code>try</code>语句块中的代码抛出的异常通常会被某个 <code>catch</code>捕获并处理。 <code>catch</code>子句也被称为<strong>异常处理代码</strong>。</li><li><strong>异常类</strong>：用于在 <code>throw</code>表达式和相关的 <code>catch</code>子句之间传递异常的具体信息</li></ul><p>try语句块内声明的变量在块外部无法访问，在catch子句内也无法访问</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-keyword">while</span>(cin &gt;&gt; item1 &gt;&gt; item2)&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">if</span>(item1.isbn()!=item2.isbn())<br><span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">&quot;Data must refer to same ISBN&quot;</span>);<br><span class="hljs-comment">//如果没有抛出异常，则表示两个isbn是相同的</span><br>cout &lt;&lt; item1 + item2 &lt;&lt; <span class="hljs-literal">endl</span>;<br>&#125;<span class="hljs-keyword">catch</span>(runtime_error err)&#123;<br><span class="hljs-comment">//异常处理代码，提醒用户异常，询问是否继续</span><br>cout &lt;&lt; err.what() &lt;&lt; <span class="hljs-literal">endl</span><br>&lt;&lt; <span class="hljs-string">&quot;Try again? Enter y or n&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>char c;<br>cin &gt;&gt; c;<br><span class="hljs-keyword">if</span>(!cin || c == <span class="hljs-string">&#x27;n&#x27;</span>)<br><span class="hljs-built_in">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理程序中，<code>err.what()</code>的返回值是C风格字符串，返回初始化<code>runtime_error</code>对象时的string对象的副本</p><p>如果异常抛出，但最终没有找到任何匹配的catch语句，程序转到名为<code>terminate</code>的标准库函数，一般将导致程序非正常退出</p><p><stdexcept>头文件定义的异常类</p><table><thead><tr><th><code>exception</code></th><th>最常见的问题</th></tr></thead><tbody><tr><td><code>runtime_error</code></td><td>只有在运行时才能检测出来的问题</td></tr><tr><td><code>range_error</code></td><td>结果超出有意义的值域范围</td></tr><tr><td><code>overflow_error</code></td><td>计算上溢</td></tr><tr><td><code>underflow_error</code></td><td>计算下溢</td></tr><tr><td><code>logic_error</code></td><td>逻辑错误</td></tr><tr><td><code>domain_error</code></td><td>参数对应的结果值不存在</td></tr><tr><td><code>invalid_argument</code></td><td>无效参数</td></tr><tr><td><code>length_error</code></td><td>试图创建一个超出该类型最大长度的对象</td></tr><tr><td><code>out_of_range</code></td><td>使用一个超出有效范围的值</td></tr></tbody></table><p>对于<code>exception</code>，<code>bad_alloc</code>，<code>bad_cast</code>只能默认初始化而不允许提供初始值</p><h2 id="第六章——函数"><a href="#第六章——函数" class="headerlink" title="第六章——函数"></a>第六章——函数</h2><h3 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h3><p>当执行指针拷贝操作时，拷贝的是指针的值，可以通过指针改变所指的对象的值，但不改变指针本身</p><p>编写一个函数，使用指针形参交换两个整数的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* p,<span class="hljs-type">int</span>* q)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> tmp = *p;<br>*p = *q;<br>*q = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">swap</span>(&amp;a,&amp;b);<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><ul><li><p>使用引用可以避免额外空间开销</p></li><li><p>还可以利用引用形参返回额外信息</p></li></ul><p><em><strong>右值实参不能用作引用形参</strong></em></p><h3 id="常量形参"><a href="#常量形参" class="headerlink" title="常量形参"></a><em><strong>常量形参</strong></em></h3><p>尽量使用常量引用，因为如果是普通引用如字符串，将无法接收<em><strong>字符字面值常量</strong></em>以及<em><strong>常量字符串</strong></em></p><p>不能把const对象、结果为该类型的表达式、字面值或者需要类型转换的对象传递给普通的引用形参</p><h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组——不允许拷贝，不允许赋值给其他数组，使用数组时通常会将其转换成指针</p><p>数组形参只能以<code>const int *</code>类型传参，但可以有不同形式</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* pa)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> pa[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> pa[<span class="hljs-number">10</span>])</span></span>;<span class="hljs-comment">//维度以实参为主</span><br></code></pre></td></tr></table></figure><p>三种形式等价</p><h3 id="管理数组指针形参"><a href="#管理数组指针形参" class="headerlink" title="管理数组指针形参"></a>管理数组指针形参</h3><ol><li><p>使用标记指定数组长度</p><p>如C风格字符串，自带有空字符，遇到空字符时即停止，但数组没有明显标记</p><p><code>void print(const char *cp)</code></p></li><li><p>使用标准库规范</p><p>传递指向数组首元素和尾元素的指针，<code>begin</code>和<code>end</code>函数</p><p><code>void print(const int *beg,const int *end)</code></p></li><li><p>显示传递表示数组大小的形参</p><p><code>void print(const int ia[],size_t size)</code></p></li></ol><h3 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h3><p>形参可以是数组的引用，且<em><strong>维度</strong></em>是类型的一部分，但绑定了维度就意味着函数只能作用于固定维度的数组</p><p><code>void print(int (&amp;arr)[10])</code></p><h3 id="多维数组形参"><a href="#多维数组形参" class="headerlink" title="多维数组形参"></a>多维数组形参</h3><p>数组第二维以及后面所有维度的大小都是数组类型的一部分，不能省略</p><p><code>void print(int (*arr)[10])</code>指针指向10个整数数组，等价于<code>void print(int arr[][10])</code></p><p><code>void print(int *arr [10])</code>则代表10个整型指针的数组</p><h3 id="处理命令行选项"><a href="#处理命令行选项" class="headerlink" title="处理命令行选项"></a>处理命令行选项</h3><p><code>int main(int argc,char* argv[])</code>等价于<code>int main(int argc,char**argv)</code></p><p>其中第一个形参表示数组中字符串的数量，第二个形参表示数组，元素是指向C风格字符串的指针</p><p>argv中的实参0保存程序的名字，往后是用户输入的实参，最后一个指针之后的元素值保证是0</p><h3 id="可变形参的函数"><a href="#可变形参的函数" class="headerlink" title="可变形参的函数"></a>可变形参的函数</h3><ul><li><p>如果所有的实参类型相同，可以传递一个名为<code>initializer_list</code>的标准库类型，表示某种特定类型的值的数组</p><p><code>initializer_list</code>对象中的元素永远是常量值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-type">const</span>&amp; il)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : il) sum += i;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> il = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;; <span class="hljs-comment">//可变长度</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">sum</span>(il) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果类型不相同，可以用可变参数模板</p></li><li><p>省略符，一般只用于与C函数机交互的接口程序</p></li></ul><h3 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h3><p>调用一个返回引用的函数得到左值，其他返回类型得到右值</p><p>函数返回类型不能是数组或者函数，但可以是指向数组或者函数的指针</p><h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a><em><strong>返回数组指针</strong></em></h3><ul><li><code>Type (*function (parameter_list))[dimension]</code>如<code>int (*func(int i)[10])</code>表明需要实参类型是int，函数调用结果返回的是指针类型，指针指向的是个大小为10的整型数组，</li><li>使用类型别名： <code>typedef int arrT[10];</code> 或者 <code>using arrT = int[10;]</code>，然后 <code>arrT* func() &#123;...&#125;</code></li><li>使用 <code>decltype</code>： <code>int odd[] = &#123;1,2,3,4,5&#125;; decltype(odd) *arrPtr(int i) &#123;...&#125;</code></li><li><strong>尾置返回类型</strong>： 在形参列表后面以一个<code>-&gt;</code>开始：<code>auto func(int i) -&gt; int(*)[10]</code></li></ul><p>编写一个函数声明，使其返回数组的引用并且该数组包含10个string对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">string (&amp;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>)[<span class="hljs-number">10</span>];<span class="hljs-comment">//初始版本</span><br><br>typedef string str_arr[<span class="hljs-number">10</span>];<span class="hljs-comment">//类型别名</span><br>str_arr&amp; <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br><br>auto <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>-&gt;string(&amp;)[<span class="hljs-number">10</span>];<span class="hljs-comment">//尾置返回类型</span><br><br>string s[<span class="hljs-number">10</span>];<span class="hljs-comment">//decltype关键字</span><br>decltype(s)&amp; <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>不允许两个函数除了返回类型外其他都一样，这不是重载的函数</p><p><em><strong>顶层const不影响传入函数的对象，因此不能用顶层const来进行函数重载，而底层const则可以</strong></em></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>*)</span></span>;<span class="hljs-comment">//形参为常量指针，是底层const，可以对函数重载</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span></span>;<span class="hljs-comment">//函数重载为普通指针的形参</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>* <span class="hljs-type">const</span>)</span></span>;<span class="hljs-comment">//形参为指针常量，是顶层const</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span></span>;<span class="hljs-comment">//等价于上式，重复声明函数</span><br></code></pre></td></tr></table></figure><p>const形参重载可借助<code>const_cast</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const <span class="hljs-built_in">string</span> &amp;shorter<span class="hljs-constructor">String(<span class="hljs-params">const</span> <span class="hljs-params">string</span> &amp;<span class="hljs-params">s1</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s2</span>)</span><br>&#123;<br>return s1.size<span class="hljs-literal">()</span> &lt;= s2.size<span class="hljs-literal">()</span> ? s1 : s2;<br>&#125;<br><br><span class="hljs-built_in">string</span> &amp;shorter<span class="hljs-constructor">String(<span class="hljs-params">string</span> &amp;<span class="hljs-params">s1</span>, <span class="hljs-params">string</span> &amp;<span class="hljs-params">s2</span>)</span><br>&#123;<br>auto &amp;r = shorter<span class="hljs-constructor">String(<span class="hljs-params">const_cast</span>&lt;<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp;&gt;(<span class="hljs-params">s1</span>)</span>,const_cast&lt;const <span class="hljs-built_in">string</span>&amp;&gt;(s2));<br>return const_cast&lt;<span class="hljs-built_in">string</span> &amp;&gt;(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>当普通引用传入时，调用第二个版本函数，将普通引用强制转换成const引用，再调用第一个版本函数，返回得到const引用绑定为一个引用上，再将其转换回普通引用返回</p><p>若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名</p><h3 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h3><ul><li><p>默认实参</p><p><code>string screen(sz ht = 24, sz wid = 80, char backgrnd = &#39; &#39;);</code></p><p>一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值</p><p>局部变量不能作为默认实参</p></li><li><p>内联函数</p><p>可避免函数调用的开销</p><p><code>inline const string &amp;shorterString(const string &amp;s1,const string&amp; s2)</code></p></li><li><p>constexpr函数</p><p>函数的返回类型及所有形参的类型都得是字面值类型，不一定返回常量表达式</p></li><li><p>调试帮助</p><ul><li><p>assert预处理宏</p><p><code>assert(expr)</code>如果expr为真则忽略，为假则输出信息并终止程序</p><p>通常用于检查不能发生的条件</p></li><li><p>NDEBUG预处理变量</p><p><code>CC -D NDEBUG main.c</code>可以定义这个变量<code>NDEBUG</code>，等价于在main.c一开始写# define NDEBUG</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDEBUG</span><br>        cerr &lt;&lt; <span class="hljs-string">&quot;Error:&quot;</span> &lt;&lt; __FILE__<br>             &lt;&lt; <span class="hljs-string">&quot;: in funciton &quot;</span> &lt;&lt; __func__<br>             &lt;&lt; <span class="hljs-string">&quot;at line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot; Compiled on &quot;</span> &lt;&lt; __DATE__<br>             &lt;&lt; <span class="hljs-string">&quot;at &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>分别输出报错的文件名的字符串字面值、当前调试的函数名的字符串字面值、行号的整型字面值、编译日期和编译时间的字符串字面值</p></li></ul></li></ul><h3 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h3><ul><li>重载函数匹配的<strong>三个步骤</strong>：1.候选函数；2.可行函数；3.寻找最佳匹配。</li><li><strong>候选函数</strong>：选定本次调用对应的重载函数集，集合中的函数称为候选函数</li><li><strong>可行函数</strong>：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数</li><li><strong>寻找最佳匹配</strong>：实参转换等级：精确匹配-const转换的匹配-类型提升-算术类型转换-类类型转换</li></ul><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a><em><strong>函数指针</strong></em></h3><p>函数名作为一个值使用，该函数自动转换成指针</p><p>声明一个指向函数的指针，需包括返回类型和形参类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">lengthCompare</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;</span>)</span>;<span class="hljs-comment">//函数声明</span><br><span class="hljs-built_in">bool</span> (*pf)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;);<span class="hljs-comment">//函数指针，用指针替换函数名</span><br></code></pre></td></tr></table></figure><p>使用函数指针时，解引用与不解引用指针等价。<code>bool flag = pf(&quot;hh&quot;,&quot;kk&quot;);</code>等价于<code>bool flag = (*pf)(&quot;hh&quot;,&quot;kk&quot;);</code></p><p>把函数指针用作形参时，使用函数定义和使用函数指针定义等价</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void use<span class="hljs-constructor">Bigger(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s1</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp;<span class="hljs-params">s2</span>, <span class="hljs-params">bool</span> <span class="hljs-params">pf</span>(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp;,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp;)</span>);<br><span class="hljs-comment">//形参为函数类型，将自动转换成函数指针类型</span><br>void use<span class="hljs-constructor">Bigger(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s1</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp;<span class="hljs-params">s2</span>, <span class="hljs-params">bool</span> (<span class="hljs-operator">*</span><span class="hljs-params">pf</span>)</span>(const <span class="hljs-built_in">string</span>&amp;,const <span class="hljs-built_in">string</span>&amp;));<br><span class="hljs-comment">//形参为显式定义函数指针</span><br></code></pre></td></tr></table></figure><p>另外，可以用类型别名或者decltype简化需要用到函数指针的函数声明</p><h3 id="函数指针当返回值"><a href="#函数指针当返回值" class="headerlink" title="函数指针当返回值"></a><em><strong>函数指针当返回值</strong></em></h3><ol><li><p>普通版本</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> (*f(<span class="hljs-built_in">int</span>))(<span class="hljs-built_in">int</span>*,<span class="hljs-built_in">int</span>);<br></code></pre></td></tr></table></figure><p>首先，这是一个函数指针，且函数形参为int类型，指针本身也有形参列表，所以该指针指向函数，函数返回类型为int</p></li><li><p>类型别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> F = <span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>* ,<span class="hljs-type">int</span>);<span class="hljs-comment">//F是函数类型</span><br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>* ,<span class="hljs-type">int</span>);<span class="hljs-comment">//PF是函数指针类型</span><br><br><span class="hljs-function">PF <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">F* <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">//两种均等价于普通版本</span><br></code></pre></td></tr></table></figure></li><li><p>尾置返回类型</p><p>与返回数组指针类型类似</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">auto <span class="hljs-built_in">f</span>(int) -&gt;<span class="hljs-built_in">int</span>(*)(int*,int);<br></code></pre></td></tr></table></figure></li><li><p>auto和decltype</p><p>如果明确知道返回函数，可以使用decltype简化</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">decltype</span>(f1)* <span class="hljs-built_in">f</span>(int* ,int);<span class="hljs-comment">//f1即为需要返回的函数类型</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="第七章——类"><a href="#第七章——类" class="headerlink" title="第七章——类"></a>第七章——类</h2><p>类的基本思想是<em><strong>数据抽象</strong></em> 和<em><strong>封装</strong></em></p><p>数据抽象依赖于<em><strong>接口</strong></em> 和<em><strong>实现</strong></em> 技术</p><p>定义在类内部的函数都是隐式的inline函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span>&#123;<br><span class="hljs-comment">//成员函数</span><br><span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br><span class="hljs-comment">//返回书本的ISBN编号</span><br><span class="hljs-function">Sales_data &amp;<span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-comment">//两个类对象属性相加，返回原对象</span><br><span class="hljs-function">doule <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">//返回平均价格</span><br><br>std::string bookNo;<br><span class="hljs-comment">//ISBN编号</span><br><span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//数量</span><br><span class="hljs-type">double</span> revenue = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//总收入</span><br>&#125;;<br><span class="hljs-comment">//声明非成员函数，即接口</span><br><span class="hljs-function">Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data&amp;,<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function">std::ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream&amp; os,<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function">std::istream&amp; <span class="hljs-title">add</span><span class="hljs-params">(std::istream&amp; is,Sales_data&amp;)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数通过this隐式参数来访问调用的对象，当调用成员函数时，隐式地先将类对象的地址初始化this</p><p><code>struct *const this</code>，this是一个指针常量，指针指向不变，即一直保存对象的地址</p><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>目的并非通用，属于类的实现部分</p><p>成员函数的声明需在类内，函数声明在其他成员之后，因此不用考虑函数体和其他成员的次序</p><p>默认情况下，this是指向非常量的指针常量，意味着不能将this绑定到常量对象上，则无法正常使用到该成员函数，因此应该在函数声明时，在函数形参列表后函数体前加上const，<code>std::string isbn() const&#123;return bookNo;&#125;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sales_data::avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(units_sold)<br><span class="hljs-keyword">return</span> revenue/units_sold;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="返回this对象的函数"><a href="#返回this对象的函数" class="headerlink" title="返回this对象的函数"></a>返回this对象的函数</h3><p><code>return *this</code>语句返回调用该函数的对象，令函数能够被连续调用</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Sales_data &amp;Sales_data::<span class="hljs-built_in">combine</span>(const Sales_data &amp;<span class="hljs-built_in">rhs</span>)<br>&#123;<br>units_sold += <span class="hljs-built_in">rhs</span>.units_sold;<br>revenue += <span class="hljs-built_in">rhs</span>.revenue;<br><span class="hljs-built_in">return</span> *this;<br>&#125;<br><br>//调用代码<br>Sales_data sd1,sd2,sd3;<br>sd1.<span class="hljs-built_in">combine</span>(sd2).<span class="hljs-built_in">combine</span>(sd3);<br></code></pre></td></tr></table></figure><h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><p>属于类的接口的组成部分，非成员函数声明与类声明在同一个文件，但不在类内</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery">//输入书本ISBN编号，数量以及单价<br>std::istream&amp; read(std::istream&amp; <span class="hljs-literal">is</span>,Sales_data&amp; <span class="hljs-type">item</span>)<br>&#123;<br>double price = <span class="hljs-number">0</span>;<br><span class="hljs-literal">is</span> &gt;&gt; <span class="hljs-type">item</span>.bookNo &gt;&gt; <span class="hljs-type">item</span>.units_sold &gt;&gt; price;<br><span class="hljs-type">item</span>.revenue = price * <span class="hljs-type">item</span>.units_sold;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">is</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//打印输出书本ISBN编号、数量、总销售额及均价</span><br>std::<span class="hljs-variable constant_">ostream</span>&amp; <span class="hljs-keyword">print</span>(std::<span class="hljs-variable constant_">ostream</span>&amp; os, <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Sale_data</span>&amp; item)<br>&#123;<br>os &lt;&lt; item.bookNo &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>    &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.<span class="hljs-title function_ invoke__">avg_price</span>();<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><span class="hljs-comment">//执行输出任务的函数尽量减少对格式控制，让用户代码决定是否换行</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//add函数，输入两个类类型，返回一个新类的副本</span><br><span class="hljs-title class_">Sales</span>_data <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> Sales_data&amp;item1,<span class="hljs-keyword">const</span> Sales_data&amp;item2</span>)<br>&#123;<br><span class="hljs-title class_">Sales</span>_data tmp = item1;<br>item1.<span class="hljs-title function_">combine</span>(item2);<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>构造函数是特殊的成员函数</li><li>无返回值</li><li>构造函数放在类的<code>public</code>部分</li><li>直到构造函数完成，对象才会有常量属性，因此构造函数可以向const对象写值</li><li><code>=default</code>要求编译器合成默认的构造函数</li><li>初始化列表：冒号和花括号之间的代码： <code>Sales_item(): units_sold(0), revenue(0.0) &#123; &#125;</code></li></ul><p>class和struct默认访问权限不同，struct则在第一个访问说明符之前的成员是public的，class则是private</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>允许特定的<strong>非成员函数</strong>访问一个类的<strong>私有成员</strong>，通常将友元声明成组地放在<strong>类定义的开始或者结尾</strong></p><p>必须在友元声明之外再对函数进行一次声明</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span></span>&#123;<br>friend Sales_data <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-keyword">const</span> Sales_data&amp;,<span class="hljs-keyword">const</span> Sales_data&amp;);<br>friend std::<span class="hljs-variable constant_">istream</span>&amp; <span class="hljs-title function_ invoke__">read</span>(std::<span class="hljs-variable constant_">istream</span>&amp; is, Sales_data&amp;);<br>friend std::<span class="hljs-variable constant_">ostream</span>&amp; <span class="hljs-keyword">print</span>(std::<span class="hljs-variable constant_">ostream</span>&amp; os,<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Sales_data</span>&amp;);<br><span class="hljs-keyword">public</span>:<br><span class="hljs-title function_ invoke__">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-title function_ invoke__">Sales_data</span>(<span class="hljs-keyword">const</span> std::<span class="hljs-variable constant_">string</span> &amp;s,unsigned n,douple p):<br><span class="hljs-title function_ invoke__">boodNo</span>(s),<span class="hljs-title function_ invoke__">revenue</span>(p),<span class="hljs-title function_ invoke__">units_sold</span>(n) &#123;&#125;<br><span class="hljs-title function_ invoke__">Sales_data</span>(<span class="hljs-keyword">const</span> std::<span class="hljs-variable constant_">string</span> &amp;s):<span class="hljs-title function_ invoke__">bookNo</span>(s) &#123;&#125;<br><span class="hljs-title function_ invoke__">Sales_data</span>(std::<span class="hljs-variable constant_">istream</span>&amp;);<span class="hljs-comment">//类外实现构造函数</span><br><span class="hljs-comment">//类内实现构造函数 Sales_data(std::istream&amp; is) &#123;return read(is,*this);&#125;</span><br><br>std::<span class="hljs-variable constant_">string</span>&amp; <span class="hljs-title function_ invoke__">isbn</span>() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> bookNo&#125;;<br>Sales_data&amp; <span class="hljs-title function_ invoke__">combine</span>(<span class="hljs-keyword">const</span> Sales_data&amp;);<br><span class="hljs-keyword">double</span>&amp; <span class="hljs-title function_ invoke__">avg_price</span>(<span class="hljs-keyword">const</span> Sales_data&amp;) <span class="hljs-keyword">const</span>;<br><span class="hljs-keyword">private</span>:<br>std::<span class="hljs-variable constant_">string</span> bookNo;<br><span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>unsigned units_sold = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//类外接口函数声明</span><br>Sales_data <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-keyword">const</span> Sales_data&amp;,<span class="hljs-keyword">const</span> Sales_data&amp;);<br>std::<span class="hljs-variable constant_">istream</span>&amp; <span class="hljs-title function_ invoke__">read</span>(std::<span class="hljs-variable constant_">istream</span>&amp; is, Sales_data&amp;);<br>std::<span class="hljs-variable constant_">ostream</span>&amp; <span class="hljs-keyword">print</span>(std::<span class="hljs-variable constant_">ostream</span>&amp; os,<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Sales_data</span>&amp;);<br></code></pre></td></tr></table></figure><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员</p><p>也可以只对声明另一个类中的某个成员函数为友元，并说明该成员函数的作用域</p><p>若想要把一组重载函数声明为友元，则需要对每一个分别声明</p><h3 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h3><p><em><strong>用来定义类型的成员必须先定义后使用</strong></em></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> std::string::size_type pos;<br><span class="hljs-keyword">private</span>:<br>pos cursor = <span class="hljs-number">0</span>;<br>pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>std::string contents;<br>&#125;;<br></code></pre></td></tr></table></figure><p>定义在类内部的成员函数都是自动inline的，可以在类内部显式inline声明，也能在类外部定义的时候说明inline</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> std::string::size_type pos;<br><span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br><span class="hljs-built_in">Screen</span>(pos ht,pos wd,<span class="hljs-type">char</span> c):<span class="hljs-built_in">height</span>(ht),<span class="hljs-built_in">width</span>(wd),<span class="hljs-built_in">contents</span>(ht*wd,c) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> contents[cursor];&#125;<br><span class="hljs-comment">//获取光标当前的内容,隐式内联</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//显式内联，在类外定义</span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r,pos c)</span></span>;<br><span class="hljs-keyword">private</span>:<br>pos cursor = <span class="hljs-number">0</span>;<br>pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>std::string contents;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span> <span class="hljs-comment">//因为已经在类内声明过inline，此处可以省略</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> contents[ht*width+wd];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span><br><span class="hljs-function"></span>&#123;<br>cursor = r * width + c;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若希望能修改类的const成员函数中的某个成员变量，可以通过变量声明前加入mutable实现</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> std::string::size_type pos;<br><span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br><span class="hljs-built_in">Screen</span>(pos ht,pos wd,<span class="hljs-type">char</span> c):<span class="hljs-built_in">height</span>(ht),<span class="hljs-built_in">width</span>(wd),<span class="hljs-built_in">contents</span>(ht*wd,c) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> contents[cursor];&#125;<br><span class="hljs-comment">//获取光标当前的内容,隐式内联</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//显式内联，在类外定义</span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r,pos c)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//修改mutable变量函数</span><br><span class="hljs-keyword">private</span>:<br>pos cursor = <span class="hljs-number">0</span>;<br>pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>std::string contents;<br><br><span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;<span class="hljs-comment">//被修改mutable变量</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span> <span class="hljs-comment">//因为已经在类内声明过inline，此处可以省略</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> contents[ht*width+wd];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span><br><span class="hljs-function"></span>&#123;<br>cursor = r * width + c;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>++access_ctr;<span class="hljs-comment">//记录被调用次数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>返回*this的成员函数，返回对象本身，则可以连续调用</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> std::string::size_type pos;<br><span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br><span class="hljs-built_in">Screen</span>(pos ht,pos wd,<span class="hljs-type">char</span> c):<span class="hljs-built_in">height</span>(ht),<span class="hljs-built_in">width</span>(wd),<span class="hljs-built_in">contents</span>(ht*wd,c) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> contents[cursor];&#125;<br><span class="hljs-comment">//获取光标当前的内容,隐式内联</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//显式内联，在类外定义</span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r,pos c)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//修改mutable变量函数</span><br><br><span class="hljs-function">Screen&amp; <span class="hljs-title">set</span><span class="hljs-params">(pos,pos,<span class="hljs-type">char</span>)</span></span>;<br><span class="hljs-function">Screan&amp; <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>pos cursor = <span class="hljs-number">0</span>;<br>pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>std::string contents;<br><br><span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;<span class="hljs-comment">//被修改mutable变量</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span> <span class="hljs-comment">//因为已经在类内声明过inline，此处可以省略</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> contents[ht*width+wd];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span><br><span class="hljs-function"></span>&#123;<br>cursor = r * width + c;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>++access_ctr;<span class="hljs-comment">//记录被调用次数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">Screen::set</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>contents[cursor] = c;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">screen::set</span><span class="hljs-params">(pos r,pos col, <span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>contents[r * width + col] = c;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//调用set  myScreen.move(4,0).set(&#x27;#&#x27;);</span><br></code></pre></td></tr></table></figure><h3 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a><em><strong>基于const的重载</strong></em></h3><p>若有常量成员函数，即使返回对象本身，也不能与非常量成员函数一起连续调用，则应该对该常量成员函数进行非常量版本的重载</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> std::string::size_type pos;<br><span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br><span class="hljs-built_in">Screen</span>(pos ht,pos wd,<span class="hljs-type">char</span> c):<span class="hljs-built_in">height</span>(ht),<span class="hljs-built_in">width</span>(wd),<span class="hljs-built_in">contents</span>(ht*wd,c) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> contents[cursor];&#125;<br><span class="hljs-comment">//获取光标当前的内容,隐式内联</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//显式内联，在类外定义</span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r,pos c)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//修改mutable变量函数</span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">set</span><span class="hljs-params">(pos,pos,<span class="hljs-type">char</span>)</span></span>;<br><span class="hljs-function">Screen&amp; <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br><br><span class="hljs-comment">//display函数重载</span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> </span>&#123;<span class="hljs-built_in">do_display</span>(os);<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> Screen&amp; <span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-built_in">do_display</span>(os);<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<br><br><span class="hljs-keyword">private</span>:<br>pos cursor = <span class="hljs-number">0</span>;<br>pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>std::string contents;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;<span class="hljs-comment">//被修改mutable变量</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream&amp; os)</span> <span class="hljs-type">const</span> </span>&#123;os &gt;&gt; contents;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span> <span class="hljs-comment">//因为已经在类内声明过inline，此处可以省略</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> contents[ht*width+wd];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span><br><span class="hljs-function"></span>&#123;<br>cursor = r * width + c;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>++access_ctr;<span class="hljs-comment">//记录被调用次数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">Screen::set</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>contents[cursor] = c;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">screen::set</span><span class="hljs-params">(pos r,pos col, <span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>contents[r * width + col] = c;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//此时可以调用 myScreen.display(cout).set(&#x27;*&#x27;);</span><br></code></pre></td></tr></table></figure><p>以上，display函数有常量和非常量版本，对于常量版本，调用do_display函数，常量对象再被调用成常量对象，即直接对常量对象操作，常量对象传递到函数内部并打印并返回常量对象；对于非常量版本，调用do_display函数，非常量对象被传递，此时传递的是对该非常量对象的常量调用，传递到函数内部并打印，返回该调用的常量对象，即原来的非常量对象。也就是说，将非常量对象通过多一次的函数调用统一成常量对象的调用，而对常量对象不影响。</p><p>每个类都是唯一的类型，类在声明后定义前，是一个不完全类型，可以定义指向给类的指针或引用，也可以声明以该类类型作为参数或返回类型的函数。</p><h3 id="Person类程序"><a href="#Person类程序" class="headerlink" title="Person类程序"></a>Person类程序</h3><p>编写一个Person类，表示人员的姓名和住址，string来存放，能够返回姓名和住址，能够读取和打印Person对象，构造函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>friend std::<span class="hljs-variable constant_">istream</span>&amp; <span class="hljs-title function_ invoke__">read</span>(std::<span class="hljs-variable constant_">istream</span>&amp;, Person&amp;);<br>friend std::<span class="hljs-variable constant_">ostream</span>&amp; <span class="hljs-title function_ invoke__">pritn</span>(std::<span class="hljs-variable constant_">ostream</span>&amp;,<span class="hljs-keyword">const</span> Person&amp;);<br><span class="hljs-keyword">public</span>:<br>auto <span class="hljs-title function_ invoke__">get_name</span>() <span class="hljs-keyword">const</span> -&gt; std::<span class="hljs-variable constant_">string</span> <span class="hljs-keyword">const</span>&amp; &#123;<span class="hljs-keyword">return</span> name;&#125;<br>auto <span class="hljs-title function_ invoke__">get_address</span>() <span class="hljs-keyword">const</span> -&gt; std::<span class="hljs-variable constant_">string</span> <span class="hljs-keyword">const</span>&amp; &#123;<span class="hljs-keyword">return</span> address;&#125;<br><span class="hljs-comment">//const位置不影响,也可以在std::string之前</span><br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">std</span>::<span class="hljs-variable constant_">string</span>&amp; <span class="hljs-title function_ invoke__">get_neme</span>() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> name;&#125;<br>std::<span class="hljs-variable constant_">string</span> <span class="hljs-keyword">const</span>&amp; <span class="hljs-title function_ invoke__">get_address</span>() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> address;&#125;<br><br><span class="hljs-title function_ invoke__">Person</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-title function_ invoke__">Person</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; s1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; s2): <span class="hljs-title function_ invoke__">name</span>(s1),<span class="hljs-title function_ invoke__">name</span>(s2) &#123;&#125;<br><span class="hljs-title function_ invoke__">Person</span>(std::<span class="hljs-variable constant_">istream</span>&amp;)&#123;&#125;;<span class="hljs-comment">//类外定义</span><br><span class="hljs-comment">//类内定义 Person(std::istream&amp; is) &#123;read(is,*this);&#125;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">string</span> name,address;<br>&#125;;<br><br>std::<span class="hljs-variable constant_">istream</span>&amp; <span class="hljs-title function_ invoke__">read</span>(std::<span class="hljs-variable constant_">istream</span>&amp; is, Person&amp; p)<br>&#123;<br>is &lt;&lt; p.name &lt;&lt; p.address;<br><span class="hljs-keyword">return</span> is;<br>&#125;<br>std::<span class="hljs-variable constant_">ostream</span>&amp; <span class="hljs-keyword">print</span>(std::<span class="hljs-variable constant_">ostream</span>&amp; os, <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Person</span>&amp; p)<br>&#123;<br>os &gt;&gt; p.name &gt;&gt; p.address;<br><span class="hljs-keyword">return</span> os;<br>&#125;<br><span class="hljs-title class_">Person</span>::<span class="hljs-title function_ invoke__">person</span>(std::<span class="hljs-variable constant_">istream</span>&amp; is)<br>&#123;<br><span class="hljs-title function_ invoke__">read</span>(is,*this);<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的<strong>返回类型</strong>通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外</p><p>如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，则必须通过构造函数初始值列表为这些成员提供初值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> NoDefault&#123;<br><span class="hljs-constructor">NoDefault(<span class="hljs-params">int</span>)</span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//NoDefault类没有提供默认构造函数，此时必须给C加上构造函数</span><br><span class="hljs-keyword">class</span> C&#123;<br><span class="hljs-constructor">C(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>: <span class="hljs-constructor">NoDefault(<span class="hljs-params">x</span>)</span> &#123;&#125;<br>NoDefault nf;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>委托构造函数使用所属类中其他的构造函数来执行自己的初始化过程，受委托的构造函数的初始值列表和函数体被依次执行，最后再执行委托者的函数体</p><h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则实际上定义了转换为此类类型的<strong>隐式转换机制</strong>，编译器只会自动地执行<strong>仅一步</strong>类型转换</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string null_book <span class="hljs-operator">=</span> <span class="hljs-string">&quot;9999-99&quot;</span><span class="hljs-comment">;</span><br>item.combine(null_book)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>string实参传入combine成员函数时，string会自动创建一个Sales_data对象</p><p>编译器只会执行一步类型转换</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">item.combine(<span class="hljs-string">&quot;9999-99&quot;</span>);<span class="hljs-regexp">//</span>此时会报错<br>item.combine(string(<span class="hljs-string">&quot;9999-99&quot;</span>));<br>item.combine(Sales_data(<span class="hljs-string">&quot;9999-99&quot;</span>));<span class="hljs-regexp">//</span>加上一步显式类型转换则不报错<br></code></pre></td></tr></table></figure><p>通过对成员函数声明explicit可以阻止隐式类型转换，explicit只能出现在类内函数的声明中。但可以使用构造函数进行显式的类型转换</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-type">item</span>.combine(Sales_data(null_book));<br><span class="hljs-type">item</span>.combine(static_cast<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Sales_data</span>&gt;</span>(cin));</span><br></code></pre></td></tr></table></figure><p><code>explicit</code>构造函数只能用于直接初始化，不能用于拷贝形式的初始化</p><h3 id="聚合类-（aggregate-class）"><a href="#聚合类-（aggregate-class）" class="headerlink" title="聚合类 （aggregate class）"></a>聚合类 （aggregate class）</h3><ul><li>满足以下所有条件：<ul><li>所有成员都是<code>public</code>的。</li><li>没有定义任何构造函数。</li><li>没有类内初始值。</li><li>没有基类，也没有<code>virtual</code>函数。</li></ul></li><li>可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。</li></ul><h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><ul><li><code>constexpr</code>函数的参数和返回值必须是字面值。</li><li><strong>字面值类型</strong>：除了算术类型、引用和指针外，某些类也是字面值类型。</li><li>数据成员都是字面值类型的聚合类是字面值常量类。</li><li>如果不是聚合类，则必须满足下面所有条件：<ul><li>数据成员都必须是字面值类型。</li><li>类必须至少含有一个<code>constexpr</code>构造函数。</li><li>如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li><li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。</li></ul></li></ul><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ul><li>非<code>static</code>数据成员存在于类类型的每个对象中。</li><li>成员函数可以直接使用静态成员</li><li>每个<code>static</code>数据成员是与类关联的对象，并不与该类的对象相关联。</li><li>声明：<ul><li>声明之前加上关键词<code>static</code>。</li></ul></li><li>使用：<ul><li>成员算符**<code>::</code>直接访问静态成员:<code>r = Account::rate();</code></li><li>也可以使用对象访问：<code>r = ac.rate();</code></li></ul></li><li>定义：在类外部定义时不用加<code>static</code>。</li><li>初始化：<ul><li>通常不在类的内部初始化，而是在定义时进行初始化，如 <code>double Account::interestRate = initRate();</code></li><li>如果一定要在类内部定义，则要求必须是字面值常量类型的<code>constexpr</code>。</li></ul></li></ul><h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="第八章——IO库"><a href="#第八章——IO库" class="headerlink" title="第八章——IO库"></a>第八章——IO库</h2><h3 id="标准库定义的IO类型"><a href="#标准库定义的IO类型" class="headerlink" title="标准库定义的IO类型"></a>标准库定义的IO类型</h3><ul><li><code>iostream</code>头文件：从标准流中读写数据，<code>istream</code>、<code>ostream</code>等。</li><li><code>fstream</code>头文件：从文件中读写数据，<code>ifstream</code>、<code>ofstream</code>等。</li><li><code>sstream</code>头文件：从字符串中读写数据，<code>istringstream</code>、<code>ostringstream</code></li></ul><h3 id="IO对象不可复制或赋值"><a href="#IO对象不可复制或赋值" class="headerlink" title="IO对象不可复制或赋值"></a>IO对象不可复制或赋值</h3><ul><li>1.IO对象不能存在容器里.</li><li>2.形参和返回类型也不能是流类型</li><li>3.形参和返回类型一般是流的<strong>引用</strong></li><li>4.读写一个IO对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的</li></ul><h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><p><code>strm</code>是一种IO类型，（如<code>istream</code>）， <code>s</code>是一个流对象</p><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td><code>strm:iostate</code></td><td>是一种机器无关的<strong>类型</strong>，提供了表达条件状态的完整功能</td></tr><tr><td><code>strm:badbit</code></td><td>用来指出流已经崩溃</td></tr><tr><td><code>strm:failbit</code></td><td>用来指出一个IO操作失败了</td></tr><tr><td><code>strm:eofbit</code></td><td>用来指出流到达了文件结束</td></tr><tr><td><code>strm:goodbit</code></td><td>用来指出流未处于错误状态，此值保证为零</td></tr><tr><td><code>s.eof()</code></td><td>若流<code>s</code>的<code>eofbit</code>置位，则返回<code>true</code></td></tr><tr><td><code>s.fail()</code></td><td>若流<code>s</code>的<code>failbit</code>置位，则返回<code>true</code></td></tr><tr><td><code>s.bad()</code></td><td>若流<code>s</code>的<code>badbit</code>置位，则返回<code>true</code></td></tr><tr><td><code>s.good()</code></td><td>若流<code>s</code>处于有效状态，则返回<code>true</code></td></tr><tr><td><code>s.clear()</code></td><td>将流<code>s</code>中所有条件状态位复位，将流的状态设置成有效，返回<code>void</code></td></tr><tr><td><code>s.clear(flags)</code></td><td>将流<code>s</code>中指定的条件状态位复位，返回<code>void</code></td></tr><tr><td><code>s.setstate(flags)</code></td><td>根据给定的标志位，将流<code>s</code>中对应的条件状态位置位，返回<code>void</code></td></tr><tr><td><code>s.rdstate()</code></td><td>返回流<code>s</code>的当前条件状态，返回值类型为<code>strm::iostate</code></td></tr></tbody></table><p>从给定流中读取数据，直至遇到文件结束符时停止，然后对流进行按所需位复位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string buf;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; buf)<br>std::cout &lt;&lt; buf &lt;&lt; std::endl;<br>cin.<span class="hljs-built_in">clear</span>(cin.<span class="hljs-built_in">rdstate</span>() &amp; ~cin.eobit);<br><span class="hljs-comment">//cin.clear();直接将failbit,badbit,eofbit复位</span><br></code></pre></td></tr></table></figure><h3 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h3><p>缓冲刷新的原因</p><ul><li><p>程序正常结束</p></li><li><p>缓冲区满</p></li><li><p>endl显式刷新缓冲区</p></li><li><p>操纵符unitbuf设置流的内部状态来清空缓冲区，对cerr默认设置unitbuf，即cerr是立即刷新的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cout &lt;&lt; unitbuf; <span class="hljs-regexp">//</span>所有输出操作都会立即刷新缓冲区<br>cout &lt;&lt; nounitbuf; <span class="hljs-regexp">//</span>恢复正常缓冲方式<br></code></pre></td></tr></table></figure></li><li><p>当读写被关联的流时，关联到的流的缓冲区会被刷新。如cin和cerr关联到cout，读cin或写cerr都导致cout刷新缓冲区</p></li><li><p>flush刷新缓冲区，不附加任何额外字符</p></li><li><p>ends插入一个空字符，再刷新缓冲区</p></li></ul><p>交互式系统通常应该关联输入流和输出流，则所有输出包括用户提示，都会在读操作之前被打印出来</p><h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p><code>fstream</code>是头文件<code>fstream</code>中定义的一个类型，<code>fstrm</code>是一个文件流对象</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>fstream fstrm;</code></td><td>创建一个未绑定的文件流。</td></tr><tr><td><code>fstream fstrm(s);</code></td><td>创建一个文件流，并打开名为<code>s</code>的文件，<code>s</code>可以是<code>string</code>也可以是<code>char</code>指针</td></tr><tr><td><code>fstream fstrm(s, mode);</code></td><td>与前一个构造函数类似，但按指定<code>mode</code>打开文件</td></tr><tr><td><code>fstrm.open(s)</code></td><td>打开名为<code>s</code>的文件，并和<code>fstrm</code>绑定</td></tr><tr><td><code>fstrm.close()</code></td><td>关闭和<code>fstrm</code>绑定的文件</td></tr><tr><td><code>fstrm.is_open()</code></td><td>返回一个<code>bool</code>值，指出与<code>fstrm</code>关联的文件是否成功打开且尚未关闭</td></tr></tbody></table><p>在要求用到基类对象的地方，可以用继承类型对象来替代。则接受iostream引用参数的函数可以用一个fstream类型调用</p><p>当一个fstream对象被销毁时，close自动会被调用</p><table><thead><tr><th>文件模式</th><th>解释</th></tr></thead><tbody><tr><td><code>in</code></td><td>以读的方式打开</td></tr><tr><td><code>out</code></td><td>以写的方式打开</td></tr><tr><td><code>app</code></td><td>每次写操作前均定位到文件末尾</td></tr><tr><td><code>ate</code></td><td>打开文件后立即定位到文件末尾</td></tr><tr><td><code>trunc</code></td><td>截断文件</td></tr><tr><td><code>binary</code></td><td>以二进制方式进行IO操作。</td></tr></tbody></table><p>默认情况下，out模式打开会是trunc模式，out模式打开同时指定app模式或者in模式才不会被截断</p><h3 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h3><p><code>sstream</code>是头文件<code>sstream</code>中任意一个类型。<code>s</code>是一个<code>string</code></p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>sstream strm</code></td><td>定义一个未绑定的<code>stringstream</code>对象</td></tr><tr><td><code>sstream strm(s)</code></td><td>用<code>s</code>初始化对象</td></tr><tr><td><code>strm.str()</code></td><td>返回<code>strm</code>所保存的<code>string</code>的拷贝</td></tr><tr><td><code>strm.str(s)</code></td><td>将<code>s</code>拷贝到<code>strm</code>中，返回<code>void</code></td></tr></tbody></table><h3 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a>istringstream</h3><p>对整行文本进行读取，对其中行内的单词进行处理，则可以使用<code>istringstream</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PersonInfo</span>&#123;<br>string name;<br>vector&lt;string&gt; phones;<br>&#125;;<br>string line, <span class="hljs-type">word</span>;<br>vector&lt;PersonInfo&gt; people;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(cin,line))<br>&#123;<br>PersonInfo info;<br><span class="hljs-function">istringstream <span class="hljs-title">record</span><span class="hljs-params">(line)</span></span>;<br>record &gt;&gt; info.name;<br><span class="hljs-keyword">while</span>(record &gt;&gt; <span class="hljs-type">word</span>)<br>info.phones.<span class="hljs-built_in">push_back</span>(<span class="hljs-type">word</span>);<br>people.<span class="hljs-built_in">push_back</span>(info);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第九章——顺序容器"><a href="#第九章——顺序容器" class="headerlink" title="第九章——顺序容器"></a>第九章——顺序容器</h2><p><code>value_type</code>  元素类型  </p><p><code>reference</code>  元素的左值类型，和<code>value_type &amp;</code>含义相同  </p><p><code>const_reference</code>  元素的<code>const</code>左值类型，即<code>const value_type &amp;</code></p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><code>forward list</code>迭代器不支持递减运算符</p><p>将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同；而当使用迭代器来拷贝一个范围时，就不要求容器类型相同</p><h3 id="array容器"><a href="#array容器" class="headerlink" title="array容器"></a>array容器</h3><p>定义array时，不仅要指定元素类型，还要指定容器大小，<code>array&lt;int,42&gt; arr</code>，默认构造的array是非空的，包含了与其大小一样多的元素</p><p>不能对<strong>内置数组</strong>进行拷贝或对象赋值操作，但array可以</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">array</span>&lt;int, <span class="hljs-number">10</span>&gt; digits = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-attribute">array</span>&lt;int, <span class="hljs-number">10</span>&gt; copy = digits;<br></code></pre></td></tr></table></figure><h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和<code>swap</code></h3><p><code>c.assign(b, e)</code>  将<code>c</code>中的元素替换成迭代器<code>b</code>和<code>e</code>表示范围中的元素，<code>b</code>和<code>e</code>不能指向<code>c</code>中的元素  </p><p><code>c.assign(il)</code>  将<code>c</code>中的元素替换成初始化列表<code>il</code>中的元素  </p><p><code>c.assign(n, r)</code>  将<code>c</code>中的元素替换为<code>n</code>个值是<code>t</code>的元素</p><p>array容器不能使用assign；由于值列表对象的大小与原对象大小不一样，也不允许用花括号包围的值列表进行赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;string&gt; names;<br>vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; oldstyle;<br>names = oldstyle;<span class="hljs-comment">// 报错，容器类型不匹配</span><br>name.<span class="hljs-built_in">assign</span>(oldstyle.<span class="hljs-built_in">begin</span>(),oldstyle.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><p>赋值运算会导致指向左边容器的迭代器、引用和指针都失效，swap则不会（array和string除外）这是因为swap不对元素进行交换，只交换两个容器内部的数据结构，时间复杂度为O(1)。而swap对string会导致失效；对array进行swap会真正交换它们的元素</p><h3 id="容器操作——insert"><a href="#容器操作——insert" class="headerlink" title="容器操作——insert"></a>容器操作——<code>insert</code></h3><p><code>c.insert(p, t)</code>  在迭代器<code>p</code>指向的元素之前创建一个值是<code>t</code>的元素，返回指向新元素的迭代器</p><p><code>c.insert(p, n, t)</code>  在迭代器<code>p</code>指向的元素之前插入<code>n</code>个值为<code>t</code>的元素，返回指向第一个新元素的迭代器；如果<code>n</code>是0，则返回<code>p</code>  </p><p><code>c.insert(p, b, e)</code>  将迭代器<code>b</code>和<code>e</code>范围内的元素，插入到<code>p</code>指向的元素之前；如果范围为空，则返回<code>p</code>  </p><p><code>c.insert(p, il)</code>  <code>il</code>是一个花括号包围中的元素值列表，将其插入到<code>p</code>指向的元素之前；如果<code>il</code>是空，则返回<code>p</code></p><p><code>insert</code>函数将元素插入到迭代器指定位置<strong>之前</strong>，时间复杂度为O(n)，对于list时间复杂度则为O(1)</p><p>向<code>vector</code>,<code>string</code>,<code>deque</code>容器中插入元素都会使所有迭代器、指针和引用失效，向deque首尾位置添加元素，迭代器失效，但指针和引用不失效</p><p>利用insert的返回值，可以在容器中一个特定位置反复插入元素</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">list&lt;string&gt; lst;<br><span class="hljs-keyword">auto</span> iter = lst.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span>(cin &gt;&gt; <span class="hljs-type">word</span>)<br>iter = lst.<span class="hljs-built_in">insert</span>(iter,<span class="hljs-type">word</span>);<span class="hljs-comment">//不断在链表头插入元素</span><br></code></pre></td></tr></table></figure><h3 id="容器操作——emplace"><a href="#容器操作——emplace" class="headerlink" title="容器操作——emplace"></a>容器操作——<code>emplace</code></h3><p><code>emplace_back(args)</code>在尾部创建一个由args创建的元素</p><p><code>emplace_front(args)</code>在头部创建一个由args创建的元素</p><p><code>emplace(p,args)</code>在迭代器p指向的元素之前创建一个由args创建的元素，返回指向新添加元素的迭代器</p><p><code>emplace</code>开头的函数是新标准引入的，这些操作是构造而不是拷贝元素,传递给<code>emplace</code>的参数必须和元素类型的<strong>构造函数</strong>相匹配</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>c是一个Sales_data对象<br>c.emplace_back(<span class="hljs-string">&quot;989-32000&quot;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">15.99</span>);<br><span class="hljs-regexp">//</span>在c的末尾构造一个Sales_data对象<br>c.push_back(Sales_data(<span class="hljs-string">&quot;989-32000&quot;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">15.99</span>));<br><span class="hljs-regexp">//</span>相当于创建一个临时的Sales_data对象传递给push_back<br></code></pre></td></tr></table></figure><p>上述语句都会创建新的Sales_data对象，在调用emplace_back时，会在容器管理的内存空间中直接创建对象，而调用push_back则会创建一个局部临时对象，并将其压入容器中。</p><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.back()</code></td><td>返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义</td></tr><tr><td><code>c.front()</code></td><td>返回<code>c</code>中头元素的引用。若<code>c</code>为空，函数行为未定义</td></tr><tr><td><code>c[n]</code></td><td>返回<code>c</code>中下标是<code>n</code>的元素的引用，<code>n</code>时候一个无符号证书。若<code>n&gt;=c.size()</code>，则函数行为未定义</td></tr><tr><td><code>c.at(n)</code></td><td>返回下标为<code>n</code>的元素引用。如果下标越界，则抛出<code>out_of_range</code>异常</td></tr></tbody></table><p>访问成员函数返回的是引用</p><p>如果希望确保下标是合法的，可以使用at成员函数</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><code>c.erase(p)</code>  删除迭代器<code>p</code>指向的元素，返回一个指向被删除元素之后的元素的迭代器，若<code>p</code>本身是尾后迭代器，则函数行为未定义  </p><p><code>c.erase(b, e)</code>  删除迭代器<code>b</code>和<code>e</code>范围内的元素，返回指向最后一个被删元素<strong>之后</strong>元素的迭代器，若<code>e</code>本身就是尾后迭代器，则返回尾后迭代器</p><p>删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效，删除deque的尾元素会导致尾后迭代器失效。指向vector、string被删除元素位置之后的迭代器、引用和指针都会失效</p><h3 id="forward-list容器"><a href="#forward-list容器" class="headerlink" title="forward_list容器"></a><code>forward_list</code>容器</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>lst.before_begin()</code></td><td>返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。</td></tr><tr><td><code>lst.cbefore_begin()</code></td><td>同上，但是返回的是常量迭代器。</td></tr><tr><td><code>lst.insert_after(p, t)</code></td><td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象。返回<strong>最后一个</strong>插入元素的迭代器</td></tr><tr><td><code>lst.insert_after(p, n, t)</code></td><td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象，<code>n</code>是数量。若<code>n</code>是0则函数行为未定义</td></tr><tr><td><code>lst.insert_after(p, b, e)</code></td><td>在迭代器<code>p</code>之后插入元素。由迭代器<code>b</code>和<code>e</code>指定范围，不能指向lst内</td></tr><tr><td><code>lst.insert_after(p, il)</code></td><td>在迭代器<code>p</code>之后插入元素。由<code>il</code>指定初始化列表。</td></tr><tr><td><code>emplace_after(p, args)</code></td><td>使用<code>args</code>在<code>p</code>之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若<code>p</code>为尾后迭代器，则函数行为未定义。</td></tr><tr><td><code>lst.erase_after(p)</code></td><td>删除<code>p</code>指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若<code>p</code>指向<code>lst</code>的尾元素或者是一个尾后迭代器，则函数行为未定义。</td></tr><tr><td><code>lst.erase_after(b, e)</code></td><td>类似上面，删除对象换成从<code>b</code>到<code>e</code>指定的范围。</td></tr></tbody></table><p>当在<code>forward_list</code>中添加或删除元素时，需要关注两个迭代器，指向当前元素和指向其前驱</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//删除所有奇数元素</span><br>forward_list&lt;<span class="hljs-built_in">int</span>&gt; flst = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>auto prev = flst.<span class="hljs-keyword">begin</span><span class="hljs-constructor">_before()</span>;<br>auto curr = flst.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>;<br><span class="hljs-keyword">while</span>(curr!=flst.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(*curr&amp;<span class="hljs-number">0x1</span>)<br>curr = flst.erase<span class="hljs-constructor">_after(<span class="hljs-params">prev</span>)</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>prev = curr;<br>++curr;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除奇数元素程序"><a href="#删除奇数元素程序" class="headerlink" title="删除奇数元素程序"></a>删除奇数元素程序</h3><p>编写程序，查找并删除<code>forward_list&lt;int&gt;</code>中的奇数元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;forward_list&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::forward_list;<br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">remove_odds</span><span class="hljs-params">(forward_list&lt;<span class="hljs-type">int</span>&gt;&amp; flist)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> is_odd = [] (<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> i &amp; <span class="hljs-number">0x1</span>; &#125;;<br>    flist.<span class="hljs-built_in">remove_if</span>(is_odd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    forward_list&lt;<span class="hljs-type">int</span>&gt; data = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;;<br>    <span class="hljs-built_in">remove_odds</span>(data);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : data) <br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>remove_if</code>是list容器的特定算法，让谓词为真时删除该元素</p><h3 id="容器大小管理操作"><a href="#容器大小管理操作" class="headerlink" title="容器大小管理操作"></a>容器大小管理操作</h3><p>调用<code>reserve</code>不会减少容器所占用的内存空间，即<code>capacity</code>，将会大于或等于当前的容量大小传递给<code>reserve</code>的参数；<code>resize</code>只会改变容器中元素的数量，即<code>size</code>而不改变容器的容量；<code>shrink_to_fit</code>则会请求退回多余的内存空间，但不保证一定退回</p><h3 id="string的额外操作"><a href="#string的额外操作" class="headerlink" title="string的额外操作"></a>string的额外操作</h3><p>构造string</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>string s(cp, n)</code></td><td><code>s</code>是<code>cp</code>指向的数组中前<code>n</code>个字符的拷贝，此数组</td></tr><tr><td><code>string s(s2, pos2)</code></td><td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符的拷贝。若<code>pos2 &gt; s2.size()</code>，则构造函数的行为未定义。</td></tr><tr><td><code>string s(s2, pos2, len2)</code></td><td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的<code>len2</code>个字符的拷贝。</td></tr></tbody></table><p>从一个<code>const char*</code>创建string时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符串时停止；如果构造函数中还有计数值作为形参，数组则不必以空字符结尾</p><p>substr操作</p><p><code>s.substr(pos, n)</code>  返回一个<code>string</code>，包含<code>s</code>中<strong>从<code>pos</code>开始</strong>的<code>n</code>个字符的拷贝。<code>pos</code>的默认值是0，<code>n</code>的默认值是<code>s.size() - pos</code>，即拷贝从<code>pos</code>开始的所有字符</p><p>改变string的其他方法</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>s.insert(pos, args)</code></td><td>在<code>pos</code>之前插入<code>args</code>指定的字符。<code>pos</code>可以使是下标或者迭代器。接受下标的版本返回指向<code>s</code>的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td></tr><tr><td><code>s.erase(pos, len)</code></td><td>删除从<code>pos</code>开始的<code>len</code>个字符，如果<code>len</code>被省略，则删除后面所有字符，返回指向<code>s</code>的引用。</td></tr><tr><td><code>s.assign(args)</code></td><td>将<code>s</code>中的字符替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td></tr><tr><td><code>s.append(args)</code></td><td>将<code>args</code>指定的字符追加到<code>s</code>，返回一个指向<code>s</code>的引用。</td></tr><tr><td><code>s.replace(range, args)</code></td><td>删除<code>s</code>中范围<code>range</code>中的字符，替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td></tr></tbody></table><p>编写一个函数，接受三个<code>string</code>参数是<code>s</code>、<code>oldVal</code> 和<code>newVal</code>。使用迭代器及<code>insert</code>和<code>erase</code>函数将<code>s</code>中所有<code>oldVal</code>替换为<code>newVal</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout; <br><span class="hljs-keyword">using</span> std::endl; <br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">replace_with</span><span class="hljs-params">(string &amp;s, string <span class="hljs-type">const</span>&amp; oldVal, string <span class="hljs-type">const</span>&amp; newVal)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur = s.<span class="hljs-built_in">begin</span>(); cur &lt;= s.<span class="hljs-built_in">end</span>() - oldVal.<span class="hljs-built_in">size</span>(); )<br>        <span class="hljs-keyword">if</span> (oldVal == string&#123; cur, cur + oldVal.<span class="hljs-built_in">size</span>() &#125;)<br>            cur = s.<span class="hljs-built_in">erase</span>(cur, cur + oldVal.<span class="hljs-built_in">size</span>()),<br>            cur = s.<span class="hljs-built_in">insert</span>(cur, newVal.<span class="hljs-built_in">begin</span>(), newVal.<span class="hljs-built_in">end</span>()),<br>            cur += newVal.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">else</span>  <br>            ++cur;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s&#123; <span class="hljs-string">&quot;To drive straight thru is a foolish, tho courageous act.&quot;</span> &#125;;<br>    <span class="hljs-built_in">replace_with</span>(s, <span class="hljs-string">&quot;tho&quot;</span>, <span class="hljs-string">&quot;though&quot;</span>);<br>    <span class="hljs-built_in">replace_with</span>(s, <span class="hljs-string">&quot;thru&quot;</span>, <span class="hljs-string">&quot;through&quot;</span>);<br>    cout &lt;&lt; s &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重写上一题的函数，这次使用一个下标和<code>replace</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout; <br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">replace_with</span><span class="hljs-params">(string &amp;s, string <span class="hljs-type">const</span>&amp; oldVal, string <span class="hljs-type">const</span>&amp; newVal)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>; pos &lt;= s.<span class="hljs-built_in">size</span>() - oldVal.<span class="hljs-built_in">size</span>();)<br>        <span class="hljs-keyword">if</span> (s[pos] == oldVal[<span class="hljs-number">0</span>] &amp;&amp; s.<span class="hljs-built_in">substr</span>(pos, oldVal.<span class="hljs-built_in">size</span>()) == oldVal)<br>            s.<span class="hljs-built_in">replace</span>(pos, oldVal.<span class="hljs-built_in">size</span>(), newVal),<br>            pos += newVal.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">else</span><br>            ++pos;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str&#123; <span class="hljs-string">&quot;To drive straight thru is a foolish, tho courageous act.&quot;</span> &#125;;<br>    <span class="hljs-built_in">replace_with</span>(str, <span class="hljs-string">&quot;tho&quot;</span>, <span class="hljs-string">&quot;though&quot;</span>);<br>    <span class="hljs-built_in">replace_with</span>(str, <span class="hljs-string">&quot;thru&quot;</span>, <span class="hljs-string">&quot;through&quot;</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="string的搜索操作"><a href="#string的搜索操作" class="headerlink" title="string的搜索操作"></a>string的搜索操作</h3><p>每个操作都接受一个可选的第二参数，表示从什么位置开始搜索</p><table><thead><tr><th>搜索操作</th><th>解释</th></tr></thead><tbody><tr><td><code>s.find(args)</code></td><td>查找<code>s</code>中<code>args</code>第一次出现的位置</td></tr><tr><td><code>s.rfind(args)</code></td><td>查找<code>s</code>中<code>args</code>最后一次出现的位置</td></tr><tr><td><code>s.find_first_of(args)</code></td><td>在<code>s</code>中查找<code>args</code>中任何一个字符第一次出现的位置</td></tr><tr><td><code>s.find_last_of(args)</code></td><td>在<code>s</code>中查找<code>args</code>中任何一个字符最后一次出现的位置</td></tr><tr><td><code>s.find_first_not_of(args)</code></td><td>在<code>s</code>中查找第一个不在<code>args</code>中的字符</td></tr><tr><td><code>s.find_first_not_of(args)</code></td><td>在<code>s</code>中查找最后一个不在<code>args</code>中的字符</td></tr></tbody></table><p>每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。如果搜索失败则返回一个名为<code>string::npos</code>的<code>static</code>成员（类型是<code>string::size_type</code>，初始化值是-1，npos是一个无符号类型，也就是<code>string</code>最大的可能大小）</p><h3 id="string的比较操作"><a href="#string的比较操作" class="headerlink" title="string的比较操作"></a>string的比较操作</h3><table><thead><tr><th>参数形式</th><th>解释</th></tr></thead><tbody><tr><td><code>s2</code></td><td>比较<code>s</code>和<code>s2</code></td></tr><tr><td><code>pos1, n1, s2</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td></tr><tr><td><code>pos1, n1, s2, pos2, n2</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td></tr><tr><td><code>cp</code></td><td>比较<code>s</code>和<code>cp</code>指向的以空字符结尾的字符数组</td></tr><tr><td><code>pos1, n1, cp</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的以空字符结尾的字符数组</td></tr><tr><td><code>pos1, n1, cp, n2</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的地址开始<code>n2</code>个字符</td></tr></tbody></table><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><code>to_string(val)</code>  一组重载函数，返回数值<code>val</code>的<code>string</code>表示。<code>val</code>可以使任何算术类型。对每个浮点类型和<code>int</code>或更大的整型，都有相应版本的<code>to_string()</code>。和往常一样，小整型会被提升。</p><p><code>stoi(s, p, b)</code>  返回<code>s</code>起始子串（表示整数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0，即函数不保存下标。<code>b</code>是转换所用的基数，默认是10。返回<code>int</code></p><p>要转换为数值的string中第一个非空表字符必须是数值中可能出现的字符</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string s2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pi = 3.14&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">d</span> <span class="hljs-operator">=</span> stod(s2.substr(s2.find_first_of(<span class="hljs-string">&quot;+-.0123456789&quot;</span>)))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>适配器是使一事物的行为类似于另一事物的行为的一种机制。函数、容器和迭代器都有适配器</p><p>三个顺序容器适配器：stack、queue和priority_queue</p><p>默认下，stack和queue是基于deque实现的，priority_queue是基于vector实现的，可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，实现对默认容器类型的重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>,&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; stk;<br></code></pre></td></tr></table></figure><p>stack需要实现后进先出，即<code>push_back</code>和<code>pop_back</code>的操作，则可以使用<code>vector</code>和<code>deque</code>实现，而不可以用<code>forward_list</code>构建</p><p>queue需要实现先进先出，即<code>push_back</code>和<code>pop_front</code>的操作，那么就不可以使用<code>vector</code>而可以使用<code>deque</code>和<code>list</code>构建</p><p>priority_queue需要有随机访问的能力，因此可使用<code>vector</code>和<code>deque</code>构建</p><p>对于每个容器适配器，只可以使用适配器操作，而不能使用底层容器类型的操作</p><h2 id="第十章——泛型算法"><a href="#第十章——泛型算法" class="headerlink" title="第十章——泛型算法"></a>第十章——泛型算法</h2><p>泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现</p><p>算法<strong>永远不会改变底层容器的大小</strong>。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素</p><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p> <code>accumulate</code>（在<code>numeric</code>中定义），接受三个参数，前两个指出需要求和的元素的范围，第三个是求和的初值。由于在string中定义了“+”运算符，则可以通过accumulate将string元素连接起来；如果传入一个字符串字面值给第三个参数，类型将是<code>const char *</code>，并没有“+”运算符，则会报错</p><p><code>find_first_of</code>，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的<code>end</code>迭代器。</p><p>对于只读取而不改变元素的算法，通常最好使用<code>cbegin</code>和<code>cend</code></p><p><code>equal</code>：确定两个序列是否保存相同的值，前两个表示第一个序列中的范围，第三个表示第二个序列的首元素。若在传入C风格字符串，则比较的是两个指针指向的地址</p><p>只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长</p><h3 id="写容器的算法"><a href="#写容器的算法" class="headerlink" title="写容器的算法"></a>写容器的算法</h3><p><code>fill</code>： <code>fill(vec.begin(), vec.end(), 0);</code> 将每个元素重置为0</p><p><code>fill_n</code>： <code>fill_n(vec.begin(), 10, 0);</code>将给定值赋予迭代器指向的元素开始的指定个元素，但要确保容器能容纳要写入的元素</p><p>插入迭代器<code>back_inserter</code>：</p><p>用来确保算法有足够的空间存储数据。<code>#include &lt;iterator&gt;</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vector&lt;<span class="hljs-built_in">int</span>&gt; vec;<span class="hljs-comment">//空vector</span><br>auto it = back<span class="hljs-constructor">_inserter(<span class="hljs-params">vec</span>)</span>; <span class="hljs-comment">//创建插入迭代器</span><br>*it = <span class="hljs-number">42</span>;<span class="hljs-comment">//添加一个元素</span><br>fill<span class="hljs-constructor">_n(<span class="hljs-params">back_inserter</span>(<span class="hljs-params">vec</span>)</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);  <span class="hljs-comment">//添加10个元素</span><br></code></pre></td></tr></table></figure><p>拷贝算法<code>copy</code>，前两个参数指定输入范围，第三个指向目标序列。传递给copy的目的序列至少要包含与输入序列一样多的元素，返回目的位置迭代器递增后的位置。可以用copy实现对内置数组的拷贝</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">int</span> <span class="hljs-built_in">a1</span>[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<span class="hljs-comment">;</span><br><span class="hljs-symbol">int</span> <span class="hljs-built_in">a2</span>[sizeof(<span class="hljs-built_in">a1</span>)/sizeof(*<span class="hljs-built_in">a1</span>)]<span class="hljs-comment">;</span><br><span class="hljs-symbol">auto</span> ret = copy(begin(<span class="hljs-built_in">a1</span>),<span class="hljs-meta">end</span>(<span class="hljs-built_in">a1</span>),<span class="hljs-built_in">a2</span>)<span class="hljs-comment">;</span><br><span class="hljs-comment">//ret指向拷贝到a2的尾元素之后的位置</span><br></code></pre></td></tr></table></figure><p>replace算法将输入序列中所有等于给定值的元素都改为另一个值</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">replace(<span class="hljs-name">ilst</span>.begin(),ilst.edn(),<span class="hljs-number">0</span>,<span class="hljs-number">42</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>上述语句将该序列中所有0替换成42，若希望原序列不变，则用replace_copy</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">replace<span class="hljs-constructor">_copy(<span class="hljs-params">ilst</span>.<span class="hljs-params">cbegin</span>()</span>,ilst.cend<span class="hljs-literal">()</span>,back<span class="hljs-constructor">_inserter(<span class="hljs-params">ivec</span>)</span>,<span class="hljs-number">0</span>,<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>ivec包含ilst的一份拷贝，且将所有0换成42</p><h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">sort</span>(<span class="hljs-keyword">words</span>.begin(),<span class="hljs-keyword">words</span>.<span class="hljs-keyword">end</span>())<span class="hljs-comment">;//只根据首字母排字典序</span><br>auto end_unique = unique(<span class="hljs-keyword">words</span>.begin(),<span class="hljs-keyword">words</span>.<span class="hljs-keyword">end</span>())<span class="hljs-comment">;//返回的是指向不重复区域之后第一个位置的迭代器</span><br><span class="hljs-keyword">words</span>.erase(end_unique,<span class="hljs-keyword">words</span>.<span class="hljs-keyword">end</span>())<span class="hljs-comment">;//要删除重复元素必须要用到容器操作</span><br></code></pre></td></tr></table></figure><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>谓词是一个<strong>可调用的表达式</strong>，返回结果是一个能用作条件的值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> is<span class="hljs-constructor">Shorter(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s1</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s2</span>)</span><br>&#123;<br>return s1.size<span class="hljs-literal">()</span> &lt; s2.size<span class="hljs-literal">()</span>;<br>&#125;<br>sort(words.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>,words.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,isShorter);<span class="hljs-comment">//按照单词长短排序</span><br>stable<span class="hljs-constructor">_sort(<span class="hljs-params">words</span>.<span class="hljs-params">begin</span>()</span>,words.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,isShorter);<span class="hljs-comment">//单词长度相同的则会保持字典序</span><br></code></pre></td></tr></table></figure><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>可以向一个算法传递任何类别的可调用对象，包括<strong>函数、函数指针、重载函数调用运算符的类和lambda表达式</strong></p><p><code>lambda</code>表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数</p><p><code>[capture list](parameter list) -&gt; return type &#123;function body&#125;</code></p><ul><li><p><code>capture list</code>捕获列表</p><p>不可忽略。为空时表明不使用它所在函数中的任何局部变量。捕获列表只用于局部非static变量，lambda可直接使用局部static变量和它所在函数之外声明的名字</p></li><li><p><code>return type</code>是返回类型。可忽略</p><p>如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void；当需要为一个lambda定义返回类型时，必须使用尾置返回类型</p></li><li><p><code>parameter</code>是参数列表。可忽略</p></li><li><p><code>function body</code>是函数体。不可忽略</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">stable<span class="hljs-constructor">_sort(<span class="hljs-params">words</span>.<span class="hljs-params">begin</span>()</span>,words.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,<span class="hljs-literal">[]</span>(const <span class="hljs-built_in">string</span>&amp;a, const <span class="hljs-built_in">string</span>&amp; b)&#123;return a.size<span class="hljs-literal">()</span>&lt;b.size<span class="hljs-literal">()</span>;&#125;);<br>auto wc = find<span class="hljs-constructor">_if(<span class="hljs-params">words</span>.<span class="hljs-params">begin</span>()</span>, words.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, <span class="hljs-literal">[<span class="hljs-identifier">sz</span>]</span>(const <span class="hljs-built_in">string</span> &amp;a)&#123;return a.size<span class="hljs-literal">()</span> &gt;= sz;&#125;);<br><span class="hljs-comment">//获取一个迭代器，指向第一个满足size&gt;=sz的元素</span><br><span class="hljs-keyword">for</span><span class="hljs-constructor">_each(<span class="hljs-params">wc</span>, <span class="hljs-params">words</span>.<span class="hljs-params">end</span>()</span>, <span class="hljs-literal">[]</span>(const <span class="hljs-built_in">string</span> &amp;s)&#123;cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;)<br></code></pre></td></tr></table></figure><p>使用partition算法</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lisp">auto pivot = partition(<span class="hljs-name">vs</span>.begin(), vs.end(), [sz](<span class="hljs-name">const</span> std:<span class="hljs-symbol">:string</span> <span class="hljs-symbol">&amp;s</span>)&#123;<br>        return s.size() &gt;= sz<span class="hljs-comment">;&#125;);//相当于排序好，符合谓词的元素排在前，返回最后一个符合谓词元素的后一个位置迭代器</span><br><br>for(<span class="hljs-name">auto</span> it = vs.cbegin()<span class="hljs-comment">; it != pivot; ++it)</span><br>    std:<span class="hljs-symbol">:cout</span> &lt;&lt; *it &lt;&lt; &quot; &quot;;<br></code></pre></td></tr></table></figure><h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>定义<code>lambda</code>时会生成一个新的类类型和该类型的一个对象</p><p>当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的</p><p>隐式捕获：&amp;告诉编译器采用捕获引用方式，&#x3D;则表示值捕获方式</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">wc = find_if(<span class="hljs-built_in">words</span>.begin(), <span class="hljs-built_in">words</span>.<span class="hljs-keyword">end</span>(), [=](const <span class="hljs-built_in">string</span> &amp;a)&#123;<span class="hljs-literal">return</span> a.size() &gt;= sz;&#125;);<br></code></pre></td></tr></table></figure><p>混合使用隐式捕获和显式捕获时，捕获列表第一个元素必须是一个&amp;或&#x3D;，显式捕获的变量必须使用与隐式捕获不同的方式，即如果隐式捕获采用引用方式（&amp;），则显式捕获命名变量必须采用值方式。</p><h3 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变lambda</h3><p>如果希望能改变一个<strong>被捕获的变量</strong>的值（不改变原来的值），就必须在<strong>参数列表首</strong>加上<code>mutable</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">size_t <span class="hljs-built_in">v1</span> = <span class="hljs-number">42</span>;<br>auto f = [<span class="hljs-built_in">v1</span>] () mutable &#123;return ++<span class="hljs-built_in">v1</span><span class="hljs-comment">;&#125;;</span><br><span class="hljs-built_in">v1</span> = <span class="hljs-number">0</span>;<br>auto <span class="hljs-keyword">j </span>= f()<span class="hljs-comment">; //j为43</span><br></code></pre></td></tr></table></figure><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>标准库bind函数，定义在头文件<code>functional</code>中，可以看做为一个通用的函数适配器。接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表</p><p><code>auto newCallable = bind(callable, arg_list);</code></p><p><code>arg_list</code>中的参数可能包含形如<code>_n</code>的名字，其中n是一个整数，这些是占位符。<code>_n</code>代表第n个位置的参数。定义在<code>placeholders</code>的命名空间中。<code>using std::placeholder::_1;</code>或<code>using namespace std::placeholders;</code>使得由<code>placeholders</code>定义的所有名字都可用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> check<span class="hljs-constructor">_size(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s</span>, <span class="hljs-params">string</span>::<span class="hljs-params">size_type</span> <span class="hljs-params">sz</span>)</span><br>&#123;<br>return s.size<span class="hljs-literal">()</span> &gt;= sz;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要将这个函数作为<code>find_if</code>（接受一个一元谓词）的参数，则可以绑定<code>check_size</code>的sz参数</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">auto</span> check6 = bind(check_size,_1,<span class="hljs-number">6</span>);<br><br><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">bool</span> b1 = check6(s);<span class="hljs-comment">//相当于调用check_size(s,6);</span><br></code></pre></td></tr></table></figure><p><code>auto g = bind(f, a, b, _2, c, _1);</code>，调用<code>g(_1, _2)</code>实际上调用<code>f(a, b, _2, c, _1)</code></p><p>非占位符的参数要使用引用传参，必须使用标准库<code>ref</code>函数或者<code>cref</code>函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">ostream &amp;<span class="hljs-built_in">print</span>(ostream &amp;<span class="hljs-built_in">os</span>,const <span class="hljs-built_in">string</span> &amp;s,<span class="hljs-built_in">char</span> c)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">os</span> &lt;&lt; s &lt;&lt; c; <br>&#125;<br>for_each(words.begin(),words.<span class="hljs-keyword">end</span>(),bind(<span class="hljs-built_in">print</span>,ref(<span class="hljs-built_in">os</span>),_1,<span class="hljs-string">&#x27; &#x27;</span>));<br></code></pre></td></tr></table></figure><h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素</p><ul><li><code>back_inserter</code>：创建一个使用<code>push_back</code>的迭代器。</li><li><code>front_inserter</code>创建一个使用<code>push_front</code>的迭代器。元素总是插入到容器的第一个元素之前</li><li><code>inserter</code>创建一个使用<code>insert</code>的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被查到迭代器所指向的元素<strong>之前</strong></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">list</span>&lt;int&gt; lst = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-attribute">list</span>&lt;int&gt; lst2,lst3;<br><span class="hljs-attribute">copy</span>(lst.begin(),lst.end(),front_inserter(lst2));//生成&#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">copy</span>(lst.begin(),lst.end(),inserter(lst3,lst.begin()));//生成&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><p><code>front_inserter</code>生成的迭代器会将插入的元素序列的顺序颠倒过来，而<code>inserter</code>和<code>back_inserter</code>则不会</p><h3 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h3><p>迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl">istream_iterator &lt;<span class="hljs-keyword">int</span>&gt; in_iter(cin);<span class="hljs-regexp">//</span>从cin读入<span class="hljs-keyword">int</span><br>istream_iteraator &lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">eof</span>;<span class="hljs-regexp">//</span>尾后迭代器<br><span class="hljs-keyword">while</span>(in_iter!=<span class="hljs-keyword">eof</span>)<br>&#123;<br>vec.push_back(*in_iter++);<br>&#125;<br>//另一种方式<br>vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">vec</span>(in_iter,<span class="hljs-keyword">eof</span>);<br></code></pre></td></tr></table></figure><p>ostream_iterator提供可选第二参数，是一个C风格字符串，每各元素输出后都打印此字符串</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">ostream_iterator&lt;int&gt; out_iter(cout,<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-keyword">for</span>(auto <span class="hljs-keyword">e</span>:<span class="hljs-keyword">vec</span>)<br><span class="hljs-comment">*out_iter+= = e;</span><br>cout &lt;&lt; endl;<br><span class="hljs-comment">//另一种方式</span><br><span class="hljs-keyword">copy</span>(<span class="hljs-keyword">vec</span>.begin(),<span class="hljs-keyword">vec</span>.end(),out_iter);<br></code></pre></td></tr></table></figure><p>其中解引用和递增运算可以忽略，不产生作用。</p><h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>递增一个反向迭代器会移动到前一个元素</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">string line = <span class="hljs-string">&quot;first,second,third&quot;</span>;<br><span class="hljs-keyword">auto</span> comma = <span class="hljs-built_in">find</span>(line.<span class="hljs-built_in">cbegin</span>(),line.<span class="hljs-built_in">cend</span>(),<span class="hljs-string">&#x27;,&#x27;</span>);<span class="hljs-comment">//comma指向第一个逗号</span><br><span class="hljs-keyword">auto</span> rcomma = <span class="hljs-built_in">find</span>(line.<span class="hljs-built_in">crbegin</span>(),line.<span class="hljs-built_in">crend</span>(),<span class="hljs-string">&#x27;,&#x27;</span>);<span class="hljs-comment">//rcomma指向的是最后一个逗号</span><br></code></pre></td></tr></table></figure><p>当需要打印出第一个和最后一个单词时</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">cout &lt;&lt; <span class="hljs-built_in">string</span>(line.cbegin(),comma);<br>cout &lt;&lt; <span class="hljs-built_in">string</span>(line.rcbegin(),rcomma);<span class="hljs-comment">//这里打印出来的单词逆序打印</span><br>cout &lt;&lt; <span class="hljs-built_in">string</span>(rcomma.base(),line<span class="hljs-selector-class">.rcend</span>());<span class="hljs-comment">//正序打印最后一个单词</span><br></code></pre></td></tr></table></figure><h3 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h3><p>对于<code>list</code>和<code>forward_list</code>，优先使用成员函数版本的算法而不是通用算法</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>lst.merge(lst2)</code></td><td>将来自<code>lst2</code>的元素合并入<code>lst</code>，二者都必须是有序的，元素将从<code>lst2</code>中删除。</td></tr><tr><td><code>lst.merge(lst2, comp)</code></td><td>同上，给定比较操作。</td></tr><tr><td><code>lst.remove(val)</code></td><td>调用<code>erase</code>删除掉与给定值相等(&#x3D;&#x3D;)的每个元素</td></tr><tr><td><code>lst.remove_if(pred)</code></td><td>调用<code>erase</code>删除掉令一元谓词为真的每个元素</td></tr><tr><td><code>lst.reverse()</code></td><td>反转<code>lst</code>中元素的顺序</td></tr><tr><td><code>lst.sort()</code></td><td>使用<code>&lt;</code>排序元素</td></tr><tr><td><code>lst.sort(comp)</code></td><td>使用给定比较操作排序元素</td></tr><tr><td><code>lst.unique()</code></td><td>调用<code>erase</code>删除同一个值的连续拷贝。使用<code>==</code>。</td></tr><tr><td><code>lst.unique(pred)</code></td><td>调用<code>erase</code>删除同一个值的连续拷贝。使用给定的二元谓词。</td></tr></tbody></table><p><strong>list和forward_list的splice成员函数版本的参数</strong>：</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td><code>(p, lst2)</code></td><td><code>p</code>是一个指向<code>lst</code>中元素的迭代器，或者一个指向<code>flst</code>首前位置的迭代器。函数将<code>lst2</code>中的所有元素移动到<code>lst</code>中<code>p</code>之前的位置或是<code>flst</code>中<code>p</code>之后的位置。将元素从<code>lst2</code>中删除。<code>lst2</code>的类型必须和<code>lst</code>相同，而且不能是同一个链表。</td></tr><tr><td><code>(p, lst2, p2)</code></td><td>同上，<code>p2</code>是一个指向<code>lst2</code>中位置的有效的迭代器，将<code>p2</code>指向的元素移动到<code>lst</code>中，或将<code>p2</code>之后的元素移动到<code>flst</code>中。<code>lst2</code>可以是于<code>lst</code>或<code>flst</code>相同的链表。</td></tr><tr><td><code>(p, lst2, b, e)</code></td><td><code>b</code>和<code>e</code>表示<code>lst2</code>中的合法范围。将给定范围中的元素从<code>lst2</code>移动到<code>lst</code>或<code>first</code>中。<code>lst2</code>与<code>lst</code>可以使相同的链表，但<code>p</code>不能指向给定范围中的元素。</td></tr></tbody></table><ul><li>使用<code>lst.splice(args)</code>或<code>flst.splice_after(args)</code></li></ul><p>链表特有版本与通用版本的区别在于链表版本会改变底层的容器</p><h2 id="第十一章——关联容器"><a href="#第十一章——关联容器" class="headerlink" title="第十一章——关联容器"></a>第十一章——关联容器</h2><p>关联容器中的元素时按照<strong>关键字</strong>来保存和访问的，支持通过关键字来高效地查找和读取元素</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器，关键字类型必须定义元素比较的方法。默认是<code>&lt;</code></p><p>对于自定义类型，如果想传递一个比较的函数，所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>（小于等于），可以这样定义，提供关键字类型（Sales_data）以及比较操作类型（函数指针类型）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareIsbn</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;lhs, <span class="hljs-type">const</span> Sales_data &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() &lt; rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br><span class="hljs-comment">//1.</span><br><span class="hljs-function">multiset&lt;Sales_data, <span class="hljs-title">decltype</span><span class="hljs-params">(compareIsbn)</span>*&gt; <span class="hljs-title">bookstore</span><span class="hljs-params">(compareIsbn)</span></span>;<br><span class="hljs-comment">//2.</span><br><span class="hljs-built_in">bool</span> (*pf) (<span class="hljs-type">const</span> Sales_data &amp;,<span class="hljs-type">const</span> Sales_data &amp;) = &amp;compareIsbn;<span class="hljs-comment">//&amp;可忽略</span><br><span class="hljs-function">multiset&lt;Sales_data, pf&gt; <span class="hljs-title">bookstore</span><span class="hljs-params">(pf)</span></span>;<br><span class="hljs-comment">//3.</span><br><span class="hljs-keyword">using</span> pf = <span class="hljs-built_in">bool</span> (*) (<span class="hljs-type">const</span> Sales_data &amp;,<span class="hljs-type">const</span> Sales_data &amp;);<br><span class="hljs-function">multiset&lt;Sales_data, pf&gt; <span class="hljs-title">bookstore</span><span class="hljs-params">(pf)</span></span>;<br></code></pre></td></tr></table></figure><p>用<code>compareIsbn</code>来初始化<code>bookstore</code>对象，表明在向对象添加元素时，将调用<code>compareIsbn</code>函数来进行排序。且可以代替<code>&amp;compareIsbn</code>，当使用一个函数名字时，会自动转换成指针类型</p><h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>在<code>utility</code>头文件中定义</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>pair&lt;T1, T2&gt; p;</code></td><td><code>p</code>是一个<code>pair</code>，两个类型分别是<code>T1</code>和<code>T2</code>的成员都进行了值初始化。</td></tr><tr><td><code>pair&lt;T1, T2&gt; p(v1, v2);</code></td><td><code>first</code>和<code>second</code>分别用<code>v1</code>和<code>v2</code>进行初始化。</td></tr><tr><td><code>pair&lt;T1, T2&gt;p = &#123;v1, v2&#125;;</code></td><td>等价于&#96;p(v1, v2)</td></tr><tr><td><code>make_pair(v1, v2);</code></td><td><code>pair</code>的类型从<code>v1</code>和<code>v2</code>的类型推断出来。</td></tr></tbody></table><p>当函数需要返回一个pair时，可以直接对返回值进行列表初始化</p><p><code>return &#123;v.back(),v.back().size()&#125;;</code></p><h3 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h3><table><thead><tr><th>类型别名</th><th>解释</th></tr></thead><tbody><tr><td><code>key_type</code></td><td>此容器类型的关键字类型</td></tr><tr><td><code>mapped_type</code></td><td>每个关键字关联的类型，只适用于<code>map</code></td></tr><tr><td><code>value_type</code></td><td>对于<code>map</code>，是<code>pair&lt;const key_type, mapped_type&gt;</code>; 对于<code>set</code>，和<code>key_type</code>相同。</td></tr></tbody></table><h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>解引用一个关联容器迭代器时，<strong>会得到一个类型为容器的<code>value_type</code>的值的引用</strong></p><p>虽然set定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种类型都只允许只读访问</p><p>遍历<code>map</code>、<code>multimap</code>、<code>set</code>、<code>multiset</code>时，迭代器按<strong>关键字升序</strong>遍历元素</p><p>使用关联容器定义的专用算法会比泛型算法快很多</p><table><thead><tr><th><code>insert</code>操作</th><th>关联容器</th></tr></thead><tbody><tr><td><code>c.insert(v)</code>  <code>c.emplace(args)</code></td><td><code>v</code>是<code>value_type</code>类型的对象；<code>args</code>用来构造一个元素。 对于<code>map</code>和<code>set</code>，只有元素的关键字不存在<code>c</code>中才插入或构造元素。函数返回一个<code>pair</code>，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的<code>bool</code>值。对于<code>multimap</code>和<code>multiset</code>则会插入范围中的每个元素。</td></tr><tr><td><code>c.insert(b, e)</code> <code>c.insert(il)</code></td><td><code>b</code>和<code>e</code>是迭代器，表示一个<code>c::value_type</code>类型值的范围；<code>il</code>是这种值的花括号列表。函数返回<code>void</code>。对于 <code>map</code>和<code>set</code>，只插入关键字不在<code>c</code>中的元素。</td></tr><tr><td><code>c.insert(p, v)</code>  <code>c.emplace(p, args)</code></td><td>类似<code>insert(v)</code>，但将迭代器<code>p</code>作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。</td></tr></tbody></table><p>向<code>map</code>添加元素：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">word_count.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-type">word</span>, <span class="hljs-number">1</span>&#125;);<br>word_count.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-type">word</span>, <span class="hljs-number">1</span>));<br>word_count.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">size_t</span>&gt;(<span class="hljs-type">word</span>, <span class="hljs-number">1</span>));<br>`word_count.<span class="hljs-built_in">insert</span>(map&lt;string, <span class="hljs-type">size_t</span>&gt;::<span class="hljs-built_in">value_type</span> (<span class="hljs-type">word</span>, <span class="hljs-number">1</span>));`<br></code></pre></td></tr></table></figure><p>以上四种添加方式等价</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">while</span> (cin &gt;&gt; word)<br>++word_count.<span class="hljs-built_in">insert</span>(&#123;word, <span class="hljs-number">0</span>&#125;).<span class="hljs-built_in">first</span>-&gt;<span class="hljs-built_in">second</span>;<br></code></pre></td></tr></table></figure><p>这条语句等价于</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">while</span> (cin &gt;&gt; word)<br>&#123;<br>auto result = word_count.<span class="hljs-built_in">insert</span>(&#123;word, <span class="hljs-number">0</span>&#125;);<br>++(result.<span class="hljs-built_in">first</span>-&gt;<span class="hljs-built_in">second</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>insert</code>成功时，返回指向该元素位置的迭代器，并对其值加一操作，即<code>insert</code>一个<code>&#123;word，1&#125;;</code></p><p><code>insert</code>失败时，返回的是指向map容器中已有的该元素位置的迭代器，并对其值加一操作</p><h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.erase(k)</code></td><td>从<code>c</code>中删除每个关键字为<code>k</code>的元素。返回一个<code>size_type</code>值，指出删除的元素的数量。</td></tr><tr><td><code>c.erase(p)</code></td><td>从<code>c</code>中删除迭代器<code>p</code>指定的元素。<code>p</code>必须指向<code>c</code>中一个真实元素，不能等于<code>c.end()</code>。返回一个指向<code>p</code>之后元素的迭代器，若<code>p</code>指向<code>c</code>中的尾元素，则返回<code>c.end()</code></td></tr><tr><td><code>c.erase(b, e)</code></td><td>删除迭代器对<code>b</code>和<code>e</code>所表示范围中的元素。返回<code>e</code>。</td></tr></tbody></table><h3 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h3><p>只有**<code>map</code>和<code>unordered_map（非const）</code>有下标运算符和对应的at函数**，set类型不支持下标，<code>multimap</code>或<code>unordered_multimap</code>可能有多个值与关键字相关联，也不支持下标操作</p><p>如果使用下标操作时，关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化</p><h3 id="访问查找元素"><a href="#访问查找元素" class="headerlink" title="访问查找元素"></a>访问查找元素</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.find(k)</code></td><td>返回一个迭代器，指向第一个关键字为<code>k</code>的元素，若<code>k</code>不在容器中，则返回尾后迭代器</td></tr><tr><td><code>c.count(k)</code></td><td>返回关键字等于<code>k</code>的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1。</td></tr><tr><td><code>c.lower_bound(k)</code></td><td>返回一个迭代器，指向第一个关键字<strong>不小于</strong><code>k</code>的元素。</td></tr><tr><td><code>c.upper_bound(k)</code></td><td>返回一个迭代器，指向第一个关键字<strong>大于</strong><code>k</code>的元素。</td></tr><tr><td><code>c.equal_range(k)</code></td><td>返回一个迭代器<code>pair</code>，表示关键字等于<code>k</code>的元素的范围。若<code>k</code>不存在，<code>pair</code>的两个成员均等于<code>c.end()</code>。</td></tr></tbody></table><p><code>lower_bound</code>和<code>upper_bound</code>不适用于无序容器</p><h3 id="打印作者的所有著作"><a href="#打印作者的所有著作" class="headerlink" title="打印作者的所有著作"></a>打印作者的所有著作</h3><p>使用find和count函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">string search_item(<span class="hljs-string">&quot;Kevin&quot;</span>);<span class="hljs-comment">//要查找的作者</span><br>auto entries = authors.<span class="hljs-built_in">count</span>(search_item);<br>auto iter = authors.<span class="hljs-built_in">find</span>(search_item);<br><span class="hljs-keyword">while</span>(entries)<br>&#123;<br>cout &lt;&lt; iter-&gt;<span class="hljs-built_in">second</span> &lt;&lt; endl;<br>    ++iter;<br>    --entries;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>lower_bound</code>和<code>upper_bound</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">for</span>(auto beg = authors.lower<span class="hljs-constructor">_bound(<span class="hljs-params">search_item</span>)</span>;beg!=authors.upper<span class="hljs-constructor">_bound(<span class="hljs-params">search_item</span>)</span>;beg++)<br>cout &lt;&lt; beg-&gt;second &lt;&lt; endl;<br><span class="hljs-comment">//lower_bound 返回的是第一个等于查找值的迭代器，upper_bound 返回的是最后一个等于查找值的后一个元素的迭代器</span><br></code></pre></td></tr></table></figure><p>使用<code>equal_range</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span>(auto pos = authors.equal_range(search_item);pos.<span class="hljs-built_in">first</span>!=pos.<span class="hljs-built_in">second</span>;++pos.<span class="hljs-built_in">first</span>)<br>cout &lt;&lt; pos.<span class="hljs-built_in">first</span>-&gt;<span class="hljs-built_in">second</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="单词转换程序？？？"><a href="#单词转换程序？？？" class="headerlink" title="单词转换程序？？？"></a>单词转换程序？？？</h3><p>here is the link to [istringistream](# istringstream)</p><p>通过读取map_file文件获得单词转换规则，在读入input文件过程中将根据映射返回转换后的内容，即打印出来</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript">map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; <span class="hljs-title function_">buildMap</span>(<span class="hljs-params">ifstream &amp;map_file</span>)<br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; <span class="hljs-title function_">transform</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">const</span> map&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; &amp;m</span>)<br>&#123;<br><br>&#125;<br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">word_transform</span>(<span class="hljs-params">ifstream &amp;map_file,ifstream &amp;input</span>)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h3><p>有序容器使用比较运算符来组织元素；无序容器使用哈希函数和关键字类型的<code>==</code>运算符</p><p>无序容器在存储上组织为一组桶(bucket)，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><strong>桶接口</strong></td><td></td></tr><tr><td><code>c.bucket_count()</code></td><td>正在使用的桶的数目</td></tr><tr><td><code>c.max_bucket_count()</code></td><td>容器能容纳的最多的桶的数目</td></tr><tr><td><code>c.bucket_size(n)</code></td><td>第<code>n</code>个桶中有多少个元素</td></tr><tr><td><code>c.bucket(k)</code></td><td>关键字为<code>k</code>的元素在哪个桶中</td></tr><tr><td><strong>桶迭代</strong></td><td></td></tr><tr><td><code>local_iterator</code></td><td>可以用来访问桶中元素的迭代器类型</td></tr><tr><td><code>const_local_iterator</code></td><td>桶迭代器的<code>const</code>版本</td></tr><tr><td><code>c.begin(n)</code>，<code>c.end(n)</code></td><td>桶<code>n</code>的首元素迭代器</td></tr><tr><td><code>c.cbegin(n)</code>，<code>c.cend(n)</code></td><td>与前两个函数类似，但返回<code>const_local_iterator</code>。</td></tr><tr><td><strong>哈希策略</strong></td><td></td></tr><tr><td><code>c.load_factor()</code></td><td>每个桶的平均元素数量，返回<code>float</code>值。</td></tr><tr><td><code>c.max_load_factor()</code></td><td><code>c</code>试图维护的平均比桶大小，返回<code>float</code>值。<code>c</code>会在需要时添加新的桶，以使得<code>load_factor&lt;=max_load_factor</code></td></tr><tr><td><code>c.rehash(n)</code></td><td>重组存储，使得<code>bucket_count&gt;=n</code>，且<code>bucket_count&gt;size/max_load_factor</code></td></tr><tr><td><code>c.reverse(n)</code></td><td>重组存储，使得<code>c</code>可以保存<code>n</code>个元素且不必<code>rehash</code>。</td></tr></tbody></table><p>无序容器的性能依赖于哈希函数的质量和桶的数量和大小</p><h3 id="无序类型对关键字类型的要求"><a href="#无序类型对关键字类型的要求" class="headerlink" title="无序类型对关键字类型的要求"></a>无序类型对关键字类型的要求</h3><p>不能直接定义关键字类型为自定义类类型的无序容器，需要提供自定义的哈希值函数以及提供函数替代<code>==</code>运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">hasher</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;sd)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;string&gt;() (sd.<span class="hljs-built_in">isbn</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eqOp</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;lhs,<span class="hljs-type">const</span> Sales_data &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br><span class="hljs-comment">//使用重载的哈希值计算函数和比较函数来定义无序容器</span><br><span class="hljs-keyword">using</span> SD_multiset = unordered_multiset&lt;Sales_data,<span class="hljs-keyword">decltype</span>(hasher)*,<span class="hljs-keyword">decltype</span>(eqOp)*&gt;;<br><span class="hljs-function">SD_multiset <span class="hljs-title">bookstore</span><span class="hljs-params">(<span class="hljs-number">42</span>,hasher,eqOp)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="第十二章——动态内存"><a href="#第十二章——动态内存" class="headerlink" title="第十二章——动态内存"></a>第十二章——动态内存</h2><ul><li><strong>静态内存</strong>用来保存局部<code>static</code>对象、类<code>static</code>对象、定义在任何函数之外的变量（全局）。</li><li><strong>栈内存</strong>用来保存定义在函数内的非<code>static</code>对象（局部）。</li><li><strong>堆内存</strong>，又称自由空间，用来存储<strong>动态分配</strong>的对象，即在程序运行时分配的对象，需要显式地销毁</li></ul><p>动态内存管理通过<code>new</code>为对象分配空间并返回一个指向该对象的指针，通过<code>delete</code>接收一个动态对象的指针，销毁对象并释放内存。</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><strong>shared_ptr和unique_ptr都支持的操作</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>shared_ptr&lt;T&gt; sp</code>  <code>unique_ptr&lt;T&gt; up</code></td><td>空智能指针，可以指向类型是<code>T</code>的对象</td></tr><tr><td><code>p</code></td><td>将<code>p</code>用作一个条件判断，若<code>p</code>指向一个对象，则为<code>true</code></td></tr><tr><td><code>*p</code></td><td>解引用<code>p</code>，获得它指向的对象。</td></tr><tr><td><code>p-&gt;mem</code></td><td>等价于<code>(*p).mem</code></td></tr><tr><td><code>p.get()</code></td><td>返回<code>p</code>中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。</td></tr><tr><td><code>swap(p, q)</code> <code>p.swap(q)</code></td><td>交换<code>p</code>和<code>q</code>中的指针</td></tr></tbody></table><p><strong>shared_ptr独有的操作</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>make_shared&lt;T&gt;(args)</code></td><td>返回一个<code>shared_ptr</code>，指向一个动态分配的类型为<code>T</code>的对象。使用<code>args</code>初始化此对象。</td></tr><tr><td><code>shared_ptr&lt;T&gt;p(q)</code></td><td><code>p</code>是<code>shared_ptr q</code>的拷贝；此操作会<strong>递增</strong><code>q</code>中的计数器。<code>q</code>中的指针必须能转换为<code>T*</code></td></tr><tr><td><code>p = q</code></td><td><code>p</code>和<code>q</code>都是<code>shared_ptr</code>，所保存的指针必须能互相转换。此操作会<strong>递减</strong><code>p</code>的引用计数，<strong>递增</strong><code>q</code>的引用计数；若<code>p</code>的引用计数变为0，则将其管理的原内存释放。</td></tr><tr><td><code>p.unique()</code></td><td>若<code>p.use_count()</code>是1，返回<code>true</code>；否则返回<code>false</code></td></tr><tr><td><code>p.use_count()</code></td><td>返回与<code>p</code>共享对象的智能指针数量；可能很慢，主要用于调试。</td></tr></tbody></table><p><code>make_shared</code>用其参数来构造给定类型的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;5&#x27;</span>); <br></code></pre></td></tr></table></figure><p>每个<code>shared_ptr</code>都有一个关联的计数器，称为引用计数，记录有多少个<code>shared_ptr</code>指向相同的对象。当指向一个对象的最后一个<code>shared_ptr</code>被销毁时，会自动销毁此对象，即释放相关联的内存。</p><h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>用new动态分配和初始化对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> *ps1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>;<span class="hljs-comment">//默认初始化为空</span><br><span class="hljs-built_in">string</span> *ps2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>();<span class="hljs-comment">//值初始化为空</span><br><span class="hljs-built_in">int</span> *pi1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>;<span class="hljs-comment">//默认初始化，未定义</span><br><span class="hljs-built_in">int</span> *pi2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>();<span class="hljs-comment">//值初始化为0，*pi2 为0</span><br></code></pre></td></tr></table></figure><p>对于内置类型来说，值初始化有定义的值，默认初始化的对象的值则是未定义；对于定义了构造函数的类类型，都会通过默认构造函数来初始化</p><p>由于要用初始化器的类型来推断要分配的类型，只有当括号中有单一初始化器才可以使用auto</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">auto</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">auto</span>(obj);<br></code></pre></td></tr></table></figure><p>默认下，new不能分配所要求的内存空间，会抛出<code>bad_alloc</code>的异常，可以将<code>nothrow</code>传递给new阻止其抛出异常</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">int</span> *p1 = <span class="hljs-keyword">new</span> (<span class="hljs-keyword">nothrow</span>) <span class="hljs-keyword">int</span>;<br></code></pre></td></tr></table></figure><p><code>delete</code>要求必须指向<strong>动态分配的内存</strong>或者是一个<strong>空指针</strong></p><h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>接受指针参数的智能指针构造函数是<code>explicit</code>的，不能将一个内置指针隐式转换成智能指针，只能直接初始化，即用new返回的指针来初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;<span class="hljs-type">int</span>&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1024</span>);<br><span class="hljs-comment">//错误，不能隐式转换,类似于函数传参</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">1024</span>))</span></span>;<br><span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p><strong>定义和改变shared_ptr的其他方法</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>shared_ptr&lt;T&gt; p(q)</code></td><td><code>p</code>管理内置指针<code>q</code>所指向的对象；<code>q</code>必须指向<code>new</code>分配的内存，且能够转换为<code>T*</code>类型</td></tr><tr><td><code>shared_ptr&lt;T&gt; p(u)</code></td><td><code>p</code>从<code>unique_ptr u</code>那里接管了对象的所有权；将<code>u</code>置为空</td></tr><tr><td><code>shared_ptr&lt;T&gt; p(q, d)</code></td><td><code>p</code>接管了内置指针<code>q</code>所指向的对象的所有权。<code>q</code>必须能转换为<code>T*</code>类型。<code>p</code>将使用可调用对象<code>d</code>来代替<code>delete</code>。</td></tr><tr><td><code>shared_ptr&lt;T&gt; p(p2, d)</code></td><td><code>p</code>是<code>shared_ptr p2</code>的拷贝，唯一的区别是<code>p</code>将可调用对象<code>d</code>来代替<code>delete</code>。</td></tr><tr><td><code>p.reset()</code></td><td>若<code>p</code>是唯一指向其对象的<code>shared_ptr</code>，<code>reset</code>会释放此对象。若传递了可选的参数内置指针<code>q</code>，会令<code>p</code>指向<code>q</code>，否则会将<code>p</code>置空。若还传递了参数<code>d</code>，则会调用<code>d</code>而不是<code>delete</code>来释放<code>q</code>。</td></tr><tr><td><code>p.reset(q)</code></td><td>同上</td></tr><tr><td><code>p.reset(q, d)</code></td><td>同上</td></tr></tbody></table><p>get函数返回一个<strong>内置指针</strong>，指向智能指针管理的对象。只有在确定代码不会delete指针的情况下才使用。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span>(!p.<span class="hljs-built_in">unique</span>())<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span>(new <span class="hljs-built_in">int</span>(*p));<br><span class="hljs-comment">//如果不是唯一用户，则将一份拷贝到新内存上并使其成为唯一用户</span><br></code></pre></td></tr></table></figure><p>不使用get()初始化或reset另一个智能指针</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">process(<span class="hljs-name">shared_ptr&lt;int&gt;</span>(<span class="hljs-name">p</span>.get()))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>p.get()</code>返回内置指针，然后创建了新的临时<code>shared_ptr</code>智能指针，也是指向p指向的对象，但这是新的<code>shared_ptr</code>，此时计数值为1，当执行完该语句后，临时智能指针被销毁，所指向的内存也被释放，则原有的p指针成为空悬指针，再对p进行操作会出现错误</p><p><strong>只有<code>shared_ptr&lt;int&gt; p2(p)</code>，此时p2与p共同指向同一个对象，计数值为2</strong></p><h3 id="使用自己的释放操作"><a href="#使用自己的释放操作" class="headerlink" title="使用自己的释放操作"></a>使用自己的释放操作</h3><p>如果你使用智能指针管理的资源不是<code>new</code>分配的内存，记住传递给它一个删除器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">connection</span><br>&#123;<br>std::string ip;<br><span class="hljs-type">int</span> port;<br><span class="hljs-built_in">connection</span>(std::string i, <span class="hljs-type">int</span> p) : <span class="hljs-built_in">ip</span>(i), <span class="hljs-built_in">port</span>(p) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">destination</span><br>&#123;<br>std::string ip;<br><span class="hljs-type">int</span> port;<br><span class="hljs-built_in">destination</span>(std::string i, <span class="hljs-type">int</span> p) : <span class="hljs-built_in">ip</span>(i), <span class="hljs-built_in">port</span>(p) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function">connection <span class="hljs-title">connect</span><span class="hljs-params">(destination* pDest)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">std::shared_ptr&lt;connection&gt; <span class="hljs-title">pConn</span><span class="hljs-params">(<span class="hljs-keyword">new</span> connection(pDest-&gt;ip, pDest-&gt;port))</span></span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;creating connection(&quot;</span> &lt;&lt; pConn.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> *pConn;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(connection pConn)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;connection close(&quot;</span> &lt;&lt; pConn.ip &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; pConn.port &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">end_connection</span><span class="hljs-params">(connection* pConn)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">disconnect</span>(*pConn);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(destination &amp;d)</span></span><br><span class="hljs-function"></span>&#123;<br>connection conn = <span class="hljs-built_in">connect</span>(&amp;d);<br><span class="hljs-function">std::shared_ptr&lt;connection&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;conn, end_connection)</span></span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;connecting now(&quot;</span> &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">destination <span class="hljs-title">dest</span><span class="hljs-params">(<span class="hljs-string">&quot;220.181.111.111&quot;</span>, <span class="hljs-number">10086</span>)</span></span>;<br><span class="hljs-built_in">f</span>(dest);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当p被销毁时，会调用删除器函数<code>end_connection</code>，即使发生异常，p同样会被销毁从而关闭连接</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>某一个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象，不支持拷贝或者赋值操作</p><p><strong>unique_ptr操作</strong>:</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>unique_ptr&lt;T&gt; u1</code></td><td>空<code>unique_ptr</code>，可以指向类型是<code>T</code>的对象。<code>u1</code>会使用<code>delete</code>来是释放它的指针。</td></tr><tr><td><code>unique_ptr&lt;T, D&gt; u2</code></td><td><code>u2</code>会使用一个类型为<code>D</code>的可调用对象来释放它的指针。</td></tr><tr><td><code>unique_ptr&lt;T, D&gt; u(d)</code></td><td>空<code>unique_ptr</code>，指向类型为<code>T</code>的对象，用类型为<code>D</code>的对象<code>d</code>代替<code>delete</code></td></tr><tr><td><code>u = nullptr</code></td><td>释放<code>u</code>指向的对象，将<code>u</code>置为空。</td></tr><tr><td><code>u.release()</code></td><td><code>u</code>放弃对指针的控制权，返回指针，并将<code>u</code>置空。</td></tr><tr><td><code>u.reset()</code></td><td>释放<code>u</code>指向的对象</td></tr><tr><td><code>u.reset(q)</code></td><td>令<code>u</code>指向<code>q</code>指向的对象</td></tr><tr><td><code>u.reset(nullptr)</code></td><td>将<code>u</code>置空</td></tr></tbody></table><p>可以通过调用<code>release</code>或<code>reset</code>将指针的所有权转移给另一个<code>unique_ptr</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> (<span class="hljs-number">42</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1.release())</span></span>;<span class="hljs-comment">//release返回悬空指针</span><br>p2.<span class="hljs-built_in">reset</span>(p1.<span class="hljs-built_in">release</span>());<span class="hljs-comment">//reset释放掉原来的对象，并指向给定的指针，即p1指针release之后的指针，指向p1原来的对象</span><br></code></pre></td></tr></table></figure><p>可以拷贝或赋值一个将要被销毁的<code>unique_ptr</code>，即通过函数的返回值返回</p><p>与<code>shared_ptr</code>不同，<code>unique_ptr</code>管理删除器的方式必须在指向类型之后提供删除器类型（可调用对象）</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">unique_ptr</span>&lt;connection,decl<span class="hljs-keyword">type</span>(end_connection)*&gt; p(&amp;c,end_connection);<br></code></pre></td></tr></table></figure><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>weak_ptr&lt;T&gt; w</code></td><td>空<code>weak_ptr</code>可以指向类型为<code>T</code>的对象</td></tr><tr><td><code>weak_ptr&lt;T&gt; w(sp)</code></td><td>与<code>shared_ptr</code>指向相同对象的<code>weak_ptr</code>。<code>T</code>必须能转换为<code>sp</code>指向的类型。</td></tr><tr><td><code>w = p</code></td><td><code>p</code>可以是<code>shared_ptr</code>或一个<code>weak_ptr</code>。赋值后<code>w</code>和<code>p</code>共享对象。</td></tr><tr><td><code>w.reset()</code></td><td>将<code>w</code>置为空。</td></tr><tr><td><code>w.use_count()</code></td><td>与<code>w</code>共享对象的<code>shared_ptr</code>的数量。</td></tr><tr><td><code>w.expired()</code></td><td>若<code>w.use_count()</code>为0，返回<code>true</code>，否则返回<code>false</code></td></tr><tr><td><code>w.lock()</code></td><td>如果<code>expired</code>为<code>true</code>，则返回一个空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code>。</td></tr></tbody></table><p>创建一个<code>weak_ptr</code>时，需要用<code>shared_ptr</code>来初始化它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-function">weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wk</span><span class="hljs-params">(p)</span></span>;<br></code></pre></td></tr></table></figure><p>wk和p指向相同的对象，但wk不影响p的引用计数。wk指向的对象可能会被释放掉</p><h3 id="StrBlob和StrBlobPtr程序"><a href="#StrBlob和StrBlobPtr程序" class="headerlink" title="StrBlob和StrBlobPtr程序"></a><strong>StrBlob和StrBlobPtr程序</strong></h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs scss">class StrBlobPtr;<br>class StrBlob&#123;<br>friend class StrBlobPtr;<br>public:<br>string&amp; <span class="hljs-built_in">begin</span>();<br>string&amp; <span class="hljs-built_in">end</span>();<br><br><span class="hljs-built_in">StrBlob</span>() : <span class="hljs-built_in">data</span>(make_shared&lt;vector&lt;string&gt;())&#123;&#125;<br><span class="hljs-built_in">StrBlob</span>(initializer_list&lt;string&gt; il) : <span class="hljs-built_in">data</span>(make_shared&lt;vector&lt;string&gt;(il)) &#123;&#125;<br><br>vector&lt;string&gt;::size_type <span class="hljs-built_in">size</span>() const &#123;return data-&gt;size;&#125;<br>bool <span class="hljs-built_in">empty</span>() const &#123;return data-&gt;<span class="hljs-built_in">empty</span>(&#125;<br><br>string&amp; front() &#123;<span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>,&quot;no front&quot;);return data-&gt;<span class="hljs-built_in">front</span>();&#125;<br>string&amp; <span class="hljs-built_in">back</span>() &#123;<span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>,&quot;no back&quot;);return data-&gt;<span class="hljs-built_in">back</span>();&#125;<br>const string&amp; <span class="hljs-built_in">front</span>() const &#123;<span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>,&quot;no front&quot;);return data-&gt;<span class="hljs-built_in">front</span>();&#125;<br>const string&amp; <span class="hljs-built_in">back</span>() const &#123;<span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>,&quot;no back&quot;);return data-&gt;<span class="hljs-built_in">back</span>();&#125;<br><br>void <span class="hljs-built_in">push_back</span>(const string&amp; s) &#123;data-&gt;<span class="hljs-built_in">push_back</span>(s);&#125;<br>void <span class="hljs-built_in">pop_back</span>() &#123;<span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>,&quot;no back to pop&quot;); data-&gt;<span class="hljs-built_in">pop_back</span>();&#125;<br>private:<br>void <span class="hljs-built_in">check</span>(vector&lt;string&gt;::size_type t, const string&amp; msg) const<br>&#123;<br><span class="hljs-built_in">if</span>(t &gt;= data-&gt;size())<br>throw <span class="hljs-built_in">out_of_range</span>(msg);<br>&#125;<br>shared_ptr&lt;vector&lt;string&gt;&gt; data;<br>&#125;;<br><br>StrBlobPtr StrBlob::<span class="hljs-built_in">begin</span>()<br>&#123;<br>return <span class="hljs-built_in">StrBlobPtr</span>(*this);<br>&#125;<br><br>StrBlobPtr StrBlob::<span class="hljs-built_in">end</span>()<br>&#123;<br>return <span class="hljs-built_in">StrBlobPtr</span>(*this, data-&gt;size());<br>&#125;<br></code></pre></td></tr></table></figure><p>定义<code>StrBlob</code>类，用<code>shared_ptr</code>存储数组，提供访问元素和始末迭代器接口，声明<code>friend</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrBlobPtr</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">StrBlobPtr</span>(): <span class="hljs-built_in">cur</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><span class="hljs-built_in">StrBlobPtr</span>(StrBlob&amp; sb, size_type t = <span class="hljs-number">0</span>): <span class="hljs-built_in">wkptr</span>(sb.data),<span class="hljs-built_in">cur</span>(t) &#123;&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> StrBlobPtr&amp; p) &#123; <span class="hljs-keyword">return</span> p.curr != curr; &#125;<br><span class="hljs-function">string&amp; <span class="hljs-title">deref</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//检查指针是否存在以及是否超出范围</span><br><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">check</span>(cur, <span class="hljs-string">&quot;dereference past end&quot;</span>);<br><span class="hljs-keyword">return</span> (*p)[cur];<br>&#125;<br><br><span class="hljs-function">StrBlobPtr&amp; <span class="hljs-title">incr</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//检查是否超出范围，如果已经指向尾后迭代器则不能递增</span><br><span class="hljs-built_in">check</span>(cur, <span class="hljs-string">&quot;increase past end&quot;</span>);<br>cur++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>shared_ptr&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">check</span>(size_type t, <span class="hljs-type">const</span> string&amp; msg) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">auto</span> p = wkptr.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span>(!p)<span class="hljs-comment">//如果p为空指针</span><br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">runningtime_error</span>(<span class="hljs-string">&quot;unbound&quot;</span>);<br><span class="hljs-keyword">if</span>(i &gt;= p-&gt;<span class="hljs-built_in">size</span>())<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(msg);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br>weak_ptr&lt;vector&lt;string&gt;&gt; wkptr;<br>vector&lt;string&gt;::size_type cur;<br>&#125;;<br></code></pre></td></tr></table></figure><p>核查指针类，定义一个<code>weak_ptr</code>与<code>StrBlob</code>共享存储数组，要么指向为空，要么指向<code>vector</code>，但不增加引用数</p><p><code>bool operator!=(const StrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</code>重载运算符<code>!=</code>判断两个指针类是否相等</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">int main()<br>&#123;<br>ifstream ifs(<span class="hljs-string">&quot;books.txt&quot;</span>);<br>StrBlob <span class="hljs-keyword">sb;</span><br><span class="hljs-keyword"></span>string s;<br>while (getline(ifs, s))<br>&#123;<br><span class="hljs-keyword">sb.push_back(s);</span><br><span class="hljs-keyword"></span>&#125;<br>for (StrBlobPtr <span class="hljs-keyword">sbp </span>= <span class="hljs-keyword">sb.begin(); </span><span class="hljs-keyword">sbp </span>!= <span class="hljs-keyword">sb.end(); </span><span class="hljs-keyword">sbp.incr())</span><br><span class="hljs-keyword"></span>&#123;<br>cout &lt;&lt; <span class="hljs-keyword">sbp.deref() </span>&lt;&lt; endl;<br>&#125;<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对两个类的使用，类似于指针与指针指向对象的操作</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p><code>new</code>一个动态数组：类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量），返回<strong>指向第一个元素类型的指针</strong>，而不是数组类型</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//未初始化</span><br><span class="hljs-type">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]();<span class="hljs-comment">//值初始化为0</span><br></code></pre></td></tr></table></figure><p>因为在值初始化的括号中未能提供初始化器，因此不能用auto</p><p>当用new分配一个大小为0的数组时，返回一个合法的非空指针，但不能解引用，类似于尾后迭代器</p><p><code>delete</code>一个动态数组：</p><p><code>delete [] p;</code></p><h3 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">unique_ptr&lt;<span class="hljs-keyword">int</span> []&gt; up(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]);<span class="hljs-comment">//up指向一个包含10个元素的未初始化数组</span><br></code></pre></td></tr></table></figure><p>指向数组的<code>unique_ptr</code>不支持成员访问运算符（点和箭头），可以用下标访问数组中的元素</p><p><code>shared_ptr</code>不直接支持管理动态数组，需要提供自定义的删除器，且<code>shared_ptr</code>未定义下标运算符，则需要通过get函数获取一个内置指针来访问数组元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>],[](<span class="hljs-type">int</span>*p)&#123;<span class="hljs-keyword">delete</span>[] p;&#125;)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)<br>&#123;<br>*(sp.<span class="hljs-built_in">get</span>() + i) = i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>定义在头文件<code>memory</code>中，将内存分配和对象构造分离开</p><p><strong>标准库allocator类及其算法</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>allocator&lt;T&gt; a</code></td><td>定义了一个名为<code>a</code>的<code>allocator</code>对象，它可以为类型为<code>T</code>的对象分配内存</td></tr><tr><td><code>a.allocate(n)</code></td><td>分配一段原始的、未构造的内存，保存<code>n</code>个类型为<code>T</code>的对象。</td></tr><tr><td><code>a.deallocate(p, n)</code></td><td>释放从<code>T*</code>指针<code>p</code>中地址开始的内存，这块内存保存了<code>n</code>个类型为<code>T</code>的对象；<code>p</code>必须是一个先前由<code>allocate</code>返回的指针。且<code>n</code>必须是<code>p</code>创建时所要求的大小。在调用<code>deallocate</code>之前，用户必须对每个在这块内存中创建的对象调用<code>destroy</code>。</td></tr><tr><td><code>a.construct(p, args)</code></td><td><code>p</code>必须是一个类型是<code>T*</code>的指针，指向一块原始内存；<code>args</code>被传递给类型为<code>T</code>的构造函数，用来在<code>p</code>指向的内存中构造一个对象。</td></tr><tr><td><code>a.destroy(p)</code></td><td><code>p</code>为<code>T*</code>类型的指针，此算法对<code>p</code>指向的对象执行析构函数。</td></tr></tbody></table><p><strong>allocator伴随算法</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>uninitialized_copy(b, e, b2)</code></td><td>从迭代器<code>b</code>和<code>e</code>给定的输入范围中拷贝元素到迭代器<code>b2</code>指定的未构造的原始内存中。<code>b2</code>指向的内存必须足够大，能够容纳输入序列中元素的拷贝。返回目的位置迭代器，指向最后一个构造的元素之后的位置</td></tr><tr><td><code>uninitialized_copy_n(b, n, b2)</code></td><td>从迭代器<code>b</code>指向的元素开始，拷贝<code>n</code>个元素到<code>b2</code>开始的内存中。</td></tr><tr><td><code>uninitialized_fill(b, e, t)</code></td><td>在迭代器<code>b</code>和<code>e</code>执行的原始内存范围中创建对象，对象的值均为<code>t</code>的拷贝。</td></tr><tr><td><code>uninitialized_fill_n(b, n, t)</code></td><td>从迭代器<code>b</code>指向的内存地址开始创建<code>n</code>个对象。<code>b</code>必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br>allocator&lt;string&gt; alloc;<br><span class="hljs-keyword">auto</span> p = alloc.<span class="hljs-built_in">allocate</span>(n);<br>string s;<br><span class="hljs-keyword">auto</span> q = p;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; s &amp;&amp; q != p + n)<br>&#123;<br>alloc.<span class="hljs-built_in">construct</span>(q++, s);<br>&#125;<br><span class="hljs-keyword">while</span> (q != p)<br>&#123;<br>std::cout &lt;&lt; *--q &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>alloc.<span class="hljs-built_in">destroy</span>(q);<br>&#125;<br>alloc.<span class="hljs-built_in">deallocate</span>(p, n);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="文本查询程序"><a href="#文本查询程序" class="headerlink" title="文本查询程序"></a>文本查询程序</h1><ul><li>当程序读取输入文件时，需记住单词出现的每一行</li><li>输出需提取每个单词所关联的行号，行号升序出现且只出现一次，还要打印给定行号的文本</li></ul><p>对应地，</p><ul><li>将使用<code>istringstream</code>读取文件中的每一行，并拆分成逐个单词，再用<code>vector&lt;string&gt;</code>进行保存</li><li>用<code>map</code>保存与行号的映射，<code>set</code>保存一个单词对应的所有行号</li></ul><p>将上述定义为一个抽象的解决方案，定义一个保存输入文件的类<code>TextQuery</code>，包含<code>vector</code>和<code>map</code>，还有读取给定输入文件的构造函数和查询函数，查询函数返回单词出现次数，行号以及每行的文本；又将返回的结果定义成另一个类<code>QueryResult</code>，用来保存输出结果，包含一个<code>print</code>函数，完成结果的打印</p><p>显然，需要在两个类之间共享数据，如果只是将数据拷贝传输，则会浪费；如果是返回迭代器或指针，则可能会导致空悬指针；因此将用到<code>shared_ptr</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">void run(ifstream &amp;infile)<br>&#123;<br>TextQuery t<span class="hljs-string">q(infile)</span>;<br><span class="hljs-keyword">while</span>(true)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;enter word to look for, or q to quit:&quot;</span>;<br>string s;<br><span class="hljs-keyword">if</span>(!(cin &gt;&gt; s) || s == <span class="hljs-string">&#x27;q&#x27;</span>)<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">print</span>(cout, tq.query(s)) &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>infile</code>初始化<code>TextQuery</code>对象，构造函数读取输入文件，保存在成员变量<code>vector</code>中，并建立单词行号映射的<code>map</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueryResult</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextQuery</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> line_no = vector&lt;string&gt;::size_type;<br><span class="hljs-built_in">TextQuery</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-built_in">TextQuery</span>(ifstream&amp; infile);<br><span class="hljs-function">QueryResult <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>shared_ptr&lt;vector&lt;string&gt;&gt; file;<br>map&lt;string,shared_ptr&lt;set&lt;line_no&gt;&gt;&gt; wm;<br>&#125;;<br></code></pre></td></tr></table></figure><p>考虑与<code>QueryResult</code>类对象共享数据的需求，<code>QueryResult</code>需要共享保存输入文件的<code>vector</code>，用于输入同行的文本；<code>QueryResult</code>还需要共享保存单词关联的行号的<code>set</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino">TextQuery::<span class="hljs-built_in">TextQuery</span>(ifstream&amp; infile): <span class="hljs-built_in">file</span>(<span class="hljs-keyword">new</span> vector&lt;string&gt;)<span class="hljs-comment">//file(make_shared&lt;vector&lt;string&gt;&gt;())</span><br>&#123;<br>string text;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(infile,text))<br>&#123;<br>file-&gt;<span class="hljs-built_in">push_back</span>(text);<br><span class="hljs-type">int</span> n = file-&gt;<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-function">istringstream <span class="hljs-title">line</span><span class="hljs-params">(text)</span></span>;<br>string <span class="hljs-type">word</span>;<br><span class="hljs-keyword">while</span>(line &gt;&gt; <span class="hljs-type">word</span>)<br>&#123;<br><span class="hljs-keyword">auto</span>&amp; lines = wm[<span class="hljs-type">word</span>];<span class="hljs-comment">//返回的是shared_ptr指针</span><br><span class="hljs-keyword">if</span>(!lines)   <span class="hljs-comment">//指针为空即第一次出现该单词，则新建一个</span><br>lines.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> set&lt;line_no&gt;);<br>lines-&gt;<span class="hljs-built_in">insert</span>(n);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数分配一个<code>vector</code>保存输入文件的文本。<code>getline</code>逐行读取文件并存入<code>vector</code>中，再用一个<code>istringstream</code>处理刚读入的一行中的每个单词，内层<code>while</code>用<code>istringstream</code>的输入运算符从当前行读取每个单词存入<code>word</code>中。当<code>map</code>中不存在<code>word</code>，即第一次出现该单词，下标运算符创建了一个<code>word</code>，返回一个空的智能指针，则再将指针<code>reset</code>，分配新的<code>set</code>，令其指向该<code>set</code>，再向<code>set</code>中插入行号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueryResult</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-title">print</span> <span class="hljs-params">(ostream&amp; os, <span class="hljs-type">const</span> QueryResult&amp; qr)</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">QueryResult</span>(string s, shared_prt&lt;set&lt;TextQuery::line_no&gt;&gt; l, shared_ptr&lt;vector&lt;string&gt;&gt; p): <span class="hljs-built_in">sought</span>(s), <span class="hljs-built_in">file</span>(p), <span class="hljs-built_in">lines</span>(l) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>string sought;<span class="hljs-comment">//搜索的单词</span><br>shared_ptr&lt;vector&lt;string&gt;&gt; file; <span class="hljs-comment">//输入文件</span><br>shared_ptr&lt;set&lt;TextQuery::line_no&gt;&gt; lines;  <span class="hljs-comment">//记录的行号</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>声明友元函数<code>print</code>，定义构造函数，将参数保存在数据成员中</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">QueryResult TextQuery::query(const <span class="hljs-built_in">string</span>&amp; s) const<br>&#123;<br><span class="hljs-comment">// static shared_ptr&lt;set&lt;line_no&gt;&gt; nodata(new set&lt;line_no&gt;);</span><br>auto pos = wm.find(s);<br><span class="hljs-keyword">if</span>(pos<span class="hljs-operator"> == </span>wm.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>)  <span class="hljs-comment">//找不到单词</span><br>return <span class="hljs-constructor">QueryResult(<span class="hljs-params">s</span>,<span class="hljs-params">make_shared</span>&lt;<span class="hljs-params">set</span>&lt;<span class="hljs-params">line_no</span>&gt;&gt;()</span>,file);<br><span class="hljs-comment">//return QuertResult(s,nodata,file);</span><br><span class="hljs-keyword">else</span><span class="hljs-comment">//找到单词</span><br>return <span class="hljs-constructor">QueryResult(<span class="hljs-params">s</span>, <span class="hljs-params">pos</span>-&gt;<span class="hljs-params">second</span>, <span class="hljs-params">file</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>query</code>函数接受一个单词，在<code>map</code>中定位其对应的行号，并构造一个<code>QueryResult</code>对象返回，包括<code>string, file, set</code>的<code>TextQuery</code>成员，并且共享着相同的数据</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">string</span> make<span class="hljs-constructor">_plural(<span class="hljs-params">size_t</span> <span class="hljs-params">ctr</span>, <span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">word</span>, <span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">ending</span>)</span><br>&#123;<br>return (ctr &gt; <span class="hljs-number">1</span>) ? word + ending : word;<br>&#125;<br><br>ostream&amp; print(ostream&amp; os, const QueryResult&amp; qr)<br>&#123;<br>os &lt;&lt; qr.sought &lt;&lt; <span class="hljs-string">&quot;occurs &quot;</span> &lt;&lt; qr.lines-&gt;size<span class="hljs-literal">()</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>&lt;&lt; make<span class="hljs-constructor">_plural(<span class="hljs-params">qr</span>.<span class="hljs-params">lines</span>-&gt;<span class="hljs-params">size</span>()</span>, <span class="hljs-string">&quot;times&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>) &lt;&lt; endl;<br><span class="hljs-keyword">for</span>(auto num : *qr.lines)<br>&#123;<br>os &lt;&lt; <span class="hljs-string">&quot;\t(line&quot;</span> &lt;&lt; num + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;)&quot;</span><br>&lt;&lt; *(qr.file-&gt;<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span> + num) &lt;&lt; endl;<br>&#125;<br>return os;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>qr.lines</code>是指向记录的行号的智能指针，需要先解引用或者用<code>-&gt;</code>运算符，范围for循环中解引用得到的<code>num</code>是取出<code>set</code>的每一个行号，对应类型为<code>set&lt;TextQuery::line_no&gt;&gt;::size_type</code>，而<code>qr.file</code>指向记录文本的数组，用<code>qr.file-&gt;begin()+num</code>则指向对应<code>num</code>行号的文本，同样，解引用即可获得整行文本。另外，程序能正确处理未找到单词的情况，只打印第一条输出语句，次数为0不进入范围for循环</p>]]></content>
    
    
    
    <tags>
      
      <tag>notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode贪心算法章节</title>
    <link href="/2022/10/15/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AB%A0%E8%8A%82/"/>
    <url>/2022/10/15/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AB%A0%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode二叉树章节"><a href="#LeetCode二叉树章节" class="headerlink" title="LeetCode二叉树章节"></a>LeetCode二叉树章节</h1><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><p>形式固定，相对简单，不同遍历仅仅改变代码顺序</p><ul><li>先序递归遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//中左右</span><br><span class="hljs-comment">//            1</span><br><span class="hljs-comment">//         /     \</span><br><span class="hljs-comment">//        2       3</span><br><span class="hljs-comment">//       /  \    /  \</span><br><span class="hljs-comment">//      4    5  6    7     遍历顺序 1 - 2 - 4 - 5 - 3 - 6 - 7</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br><span class="hljs-type">int</span> val;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-built_in">TreeNode</span>():<span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br><span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(nullprt),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br><span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x,TreeNode* leftnode, TreeNode* rightnode):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(leftnode),<span class="hljs-built_in">right</span>(rightnode)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root)</span><span class="hljs-comment">//用数组返回储存遍历的结点的值</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//中</span><br>        <span class="hljs-built_in">preorder</span>(root-&gt;left); <span class="hljs-comment">//左</span><br>        <span class="hljs-built_in">preorder</span>(root-&gt;right); <span class="hljs-comment">//右</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>中序递归遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//左中右</span><br><span class="hljs-comment">//            1</span><br><span class="hljs-comment">//         /     \</span><br><span class="hljs-comment">//        2       3</span><br><span class="hljs-comment">//       /  \    /  \</span><br><span class="hljs-comment">//      4    5  6    7     遍历顺序 4 - 2 - 5 - 1 - 6 - 3 - 7</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    <br>    <span class="hljs-built_in">TreeNode</span>():<span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x,TreeNode* left,TreeNode* right):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(left),<span class="hljs-built_in">right</span>(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left);          <span class="hljs-comment">//左</span><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);  <span class="hljs-comment">//中</span><br>        <span class="hljs-built_in">inorder</span>(root-&gt;right); <span class="hljs-comment">//右</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>后序递归遍历<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//左右中</span><br><span class="hljs-comment">//            1</span><br><span class="hljs-comment">//         /     \</span><br><span class="hljs-comment">//        2       3</span><br><span class="hljs-comment">//       /  \    /  \</span><br><span class="hljs-comment">//      4    5  6    7     遍历顺序 4 - 5 - 2 - 6 - 7 - 3 - 1</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    <br>    <span class="hljs-built_in">TreeNode</span>():<span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x,TreeNode* left,TreeNode* right):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(left),<span class="hljs-built_in">right</span>(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">postorder</span>(root-&gt;left);<span class="hljs-comment">//左</span><br>        <span class="hljs-built_in">postorder</span>(root-&gt;right);<span class="hljs-comment">//右</span><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//中</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><p>先、中、后序遍历均属于DFS（深度优先搜索算法），借助栈实现</p><p>而层序遍历为BFS（广度优先搜索算法），借助队列实现</p><ul><li>先序迭代遍历</li></ul><p>对于先序迭代遍历（中左右）和后序迭代遍历（左右中），<strong>访问顺序</strong>和<strong>处理顺序</strong>相同，仅需要改变入栈顺序，再翻转数组</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//中左右</span><br><span class="hljs-comment">//            1</span><br><span class="hljs-comment">//         /     \</span><br><span class="hljs-comment">//        2       3</span><br><span class="hljs-comment">//       /  \    /  \</span><br><span class="hljs-comment">//      4    5  6    7     遍历顺序 1 - 2 - 4 - 5 - 3 - 6 - 7</span><br><br><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>:<span class="hljs-keyword">val</span>(x),left(nullprt),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">x</span>,TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">leftnode</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">rightnode</span>)</span>:<span class="hljs-keyword">val</span>(x),left(leftnode),right(rightnode)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution&#123;<br>public:<br>vector&lt;<span class="hljs-built_in">int</span>&gt; res;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; preorder(TreeNode* root)<span class="hljs-comment">//用数组返回储存遍历的结点的值</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!root) return res;<br>        stack&lt;TreeNode*&gt; stk;<br>        stk.push(root);<br>        <span class="hljs-keyword">while</span>(!stk.empty<span class="hljs-literal">()</span>)<br>        &#123;<br>        TreeNode* node = stk.top<span class="hljs-literal">()</span>;<br>        stk.pop<span class="hljs-literal">()</span>;<br>        res.push<span class="hljs-constructor">_back(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">val</span>)</span>;<span class="hljs-comment">//中</span><br>        <span class="hljs-keyword">if</span>(node-&gt;right) stk.push(node-&gt;right); <span class="hljs-comment">//右，保证空结点不入栈</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left) stk.push(node-&gt;left); <span class="hljs-comment">//左，保证空结点不入栈</span><br>        <span class="hljs-comment">//由于栈的先进后出，后进先出的特性，先将右节点入栈，再将左节点入栈</span><br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>后序迭代遍历<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//左右中</span><br><span class="hljs-comment">//            1</span><br><span class="hljs-comment">//         /     \</span><br><span class="hljs-comment">//        2       3</span><br><span class="hljs-comment">//       /  \    /  \</span><br><span class="hljs-comment">//      4    5  6    7     遍历顺序 4 - 5 - 2 - 6 - 7 - 3 - 1</span><br><br><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>:<span class="hljs-keyword">val</span>(x),left(nullprt),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">x</span>,TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">leftnode</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">rightnode</span>)</span>:<span class="hljs-keyword">val</span>(x),left(leftnode),right(rightnode)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution&#123;<br>public:<br>vector&lt;<span class="hljs-built_in">int</span>&gt; res;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; preorder(TreeNode* root)<span class="hljs-comment">//用数组返回储存遍历的结点的值</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!root) return res;<br>        stack&lt;TreeNode*&gt; stk;<br>        stk.push(root);<br>        <span class="hljs-keyword">while</span>(!stk.empty<span class="hljs-literal">()</span>)<br>        &#123;<br>        TreeNode* node = stk.top<span class="hljs-literal">()</span>;<br>        stk.pop<span class="hljs-literal">()</span>;<br>        res.push<span class="hljs-constructor">_back(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">val</span>)</span>;<span class="hljs-comment">//中</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left) stk.push(node-&gt;left); <span class="hljs-comment">//左，保证空结点不入栈</span><br>        <span class="hljs-keyword">if</span>(node-&gt;right) stk.push(node-&gt;right); <span class="hljs-comment">//右，保证空结点不入栈</span><br>        <span class="hljs-comment">//由于栈的先进后出，后进先出的特性，先将左节点入栈，再将右节点入栈，翻转后符合左右中</span><br>        &#125;<br>        return reverse(res.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>,res.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>中序迭代遍历</li></ul><p>而中序迭代遍历（左中右）先访问中间结点，但先处理左结点（存入数组），故需要额外用<em><strong>cur指针</strong></em>不断指向最左结点并将沿路左结点入栈，先处理左结点随后不断回退读取中间结点和右结点完成遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//左中右</span><br><span class="hljs-comment">//            1</span><br><span class="hljs-comment">//         /     \</span><br><span class="hljs-comment">//        2       3</span><br><span class="hljs-comment">//       /  \    /  \</span><br><span class="hljs-comment">//      4    5  6    7     遍历顺序 4 - 2 - 5 - 1 - 6 - 3 - 7</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    <br>    <span class="hljs-built_in">TreeNode</span>():<span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x,TreeNode* left,TreeNode* right):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(left),<span class="hljs-built_in">right</span>(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        stack&lt;TreeNode*&gt; stk;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()||!cur)<br>        &#123;<br>        <span class="hljs-keyword">if</span>(!cur) <span class="hljs-comment">//cur已指向最左结点的左结点(nullptr)</span><br>        &#123;<br>        TreeNode* node = stk.<span class="hljs-built_in">top</span>();<br>                 stk.<span class="hljs-built_in">pop</span>();<br>                 res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<span class="hljs-comment">//中</span><br>                 <br>                 <br>                 <br>                 <span class="hljs-keyword">if</span>(node-&gt;right) stk.<span class="hljs-built_in">push</span>(node-&gt;right); <span class="hljs-comment">//右      有漏洞</span><br>                 <br>                 <br>                 <br>        &#125;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//cur不指向空结点时</span><br>        &#123;<br>        stk.<span class="hljs-built_in">push</span>(cur);   <span class="hljs-comment">//左，且保证空结点不入栈</span><br>                 cur = cur-&gt;left;<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码段有漏洞，原因在于<code> if(node-&gt;right) stk.push(node-&gt;right)</code> ，没有考虑到当前右结点还有左结点的可能性，从而导致没有完全遍历。因此，并不需要创建新节点<code> TreeNode* node</code> ，而是继续赋值给<code>cur</code>指针</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span>(!cur)<br>&#123;<br>    cur = stk.<span class="hljs-built_in">top</span>();<br>    stk.pop();<br>    cur = cur-&gt;<span class="hljs-built_in">right</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续让<code>cur</code> 指针指向子树中的最左结点，完成遍历。</p><ul><li>层序迭代遍历<br>因为需要边访问（入）边处理结点（出），栈无法满足使用需求，因此使用队列完成层序迭代遍历<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//            1</span><br><span class="hljs-comment">//         /     \</span><br><span class="hljs-comment">//        2       3</span><br><span class="hljs-comment">//       /  \    /  \</span><br><span class="hljs-comment">//      4    5  6    7     遍历顺序 1 - 2 - 3 - 4 - 5 - 6 - 7</span><br><br><span class="hljs-keyword">struct</span> TreeNode&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>    TreeNode* left;<br>    TreeNode* right;<br>    <br>    <span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br>    <span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>:<span class="hljs-keyword">val</span>(x),left(nullptr),right(nullptr)&#123;&#125;<br>    <span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">x</span>,TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">left</span>,TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">right</span>)</span>:<span class="hljs-keyword">val</span>(x),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution&#123;<br>public:<br>vector&lt;<span class="hljs-built_in">int</span>&gt; res;<br>vector&lt;<span class="hljs-built_in">int</span>&gt; levelorder(TreeNode* root)<br>&#123;<br><span class="hljs-keyword">if</span>(!root) return res;<br>queue&lt;TreeNode*&gt; que;<br>que.push(root);<br><span class="hljs-keyword">while</span>(!que.empty<span class="hljs-literal">()</span>)<br>&#123;<br><span class="hljs-built_in">int</span> qsize = que.size<span class="hljs-literal">()</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt;qsize;i++)<br>&#123;<br>                TreeNode* node = que.front<span class="hljs-literal">()</span>;<br>                que.pop<span class="hljs-literal">()</span>;<br>                res.push<span class="hljs-constructor">_back(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">val</span>)</span>;<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.push(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.push(node-&gt;right);<br>&#125;<br>&#125;<br>return res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>[LeetCode226](<a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（LeetCode）</a>)</p><p>给你一颗二叉树的根节点<code>root</code>，翻转这棵二叉树，并返回其根节点。</p><p>示例1：</p><p><img src="http://rjwc2zvww.hn-bkt.clouddn.com/invert2-tree.jpg?e=1666095210&token=nvUz3pCbpAvvS7EDBSYy4y-3Z_w8Q5E-JegZiINf:Asr154wbRoPorJIjGWPjLHwOz3k=" alt="示例1"></p><p><img src="/invert1-tree.jpg" alt="aa"></p><div align="center"> <img src="/invert2-tree.jpg"/> </div>示例2：<p><img src="http://rjwc2zvww.hn-bkt.clouddn.com/invert1-tree.jpg?e=1666095256&token=nvUz3pCbpAvvS7EDBSYy4y-3Z_w8Q5E-JegZiINf:oS9ISvGEMgbb3DZszw7vezLUNjA=" alt="示例2"></p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>首先，可以考虑<em><strong>递归</strong></em>，并使用<code>swap(TreeNode* left,TreeNode* right)</code>函数完成左右子结点的交换，即翻转。考虑到处理顺序，可以使用先序递归遍历。</p><ol><li>确定递归的终止条件<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br></code></pre></td></tr></table></figure>①不判断<code>root-&gt;left</code>或<code>root-&gt;right</code>是否为空，会导致也将叶子结点也进行翻转，造成一定的浪费；②或递归前判断是否空结点，空结点不进入到下一层递归；③或考虑<code>root-&gt;left</code>或<code>root-&gt;right</code>是否为空，减少对叶子结点翻转的时间开销。</li><li>确定递归的返回值<br>由题目要求返回翻转后的根节点可知返回root结点<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">TreeNode* invertTree(TreeNode*<span class="hljs-built_in"> root</span>)<br><span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br></code></pre></td></tr></table></figure></li><li>单层递归中的逻辑处理<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">swap</span>(root-&gt;<span class="hljs-built_in">left</span>,root-&gt;<span class="hljs-built_in">right</span>);<br><span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">let</span>) invertTree(root-&gt;<span class="hljs-built_in">left</span>);<br><span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-built_in">right</span>) invertTree(root-&gt;<span class="hljs-built_in">right</span>);<br></code></pre></td></tr></table></figure>整体代码如下：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs scss">struct TreeNode&#123;<br>    int val;<br>    TreeNode* <span class="hljs-attribute">left</span>;<br>    TreeNode* <span class="hljs-attribute">right</span>;<br>    <br>    <span class="hljs-built_in">TreeNode</span>():<span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">left</span>(nullptr),<span class="hljs-built_in">right</span>(nullptr)&#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(int x):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(nullptr),<span class="hljs-built_in">right</span>(nullptr)&#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(int x,TreeNode* left,TreeNode* right):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(left),<span class="hljs-built_in">right</span>(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//全部非空结点都对其子结点进行翻转，多耗费O(2^(h-1))的时间，h为二叉树层高</span><br><span class="hljs-comment">//①</span><br>class Solution &#123;<br>public:<br>    TreeNode* <span class="hljs-built_in">invertTree</span>(TreeNode* root) &#123;<br>        <span class="hljs-built_in">if</span>(!root) return root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left,root-&gt;right);<br>    <span class="hljs-built_in">if</span>(root-&gt;left) <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>    <span class="hljs-built_in">if</span>(root-&gt;right) <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        return root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//对子结点进行判断，非子结点才进行递归，子结点不进入递归</span><br><span class="hljs-comment">//②</span><br>class Solution &#123;<br>public:<br>    TreeNode* <span class="hljs-built_in">invertTree</span>(TreeNode* root) &#123;<br>        <span class="hljs-built_in">if</span>(!root) return root;<br>        <span class="hljs-built_in">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right) return root;  <span class="hljs-comment">//子结点则退出递归</span><br>        <span class="hljs-built_in">if</span>(root-&gt;left&amp;&amp;(root-&gt;left-&gt;left||root-&gt;left-&gt;right)) <span class="hljs-built_in">invertTree</span>(root-&gt;left);<span class="hljs-comment">//判断是否子结点</span><br>        <span class="hljs-built_in">if</span>(root-&gt;right&amp;&amp;(root-&gt;right-&gt;left||root-&gt;right-&gt;right)) <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        <span class="hljs-built_in">swap</span>(root-&gt;left,root-&gt;right);<br>        return root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//如果是子结点则退出递归，非子结点和子结点都进入递归</span><br><span class="hljs-comment">//③</span><br>class Solution &#123;<br>public:<br>    TreeNode* <span class="hljs-built_in">invertTree</span>(TreeNode* root) &#123;<br>        <span class="hljs-built_in">if</span>(!root) return root;<br>        <span class="hljs-built_in">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right) return root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left,root-&gt;right);<br>    <span class="hljs-built_in">if</span>(root-&gt;left) <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>    <span class="hljs-built_in">if</span>(root-&gt;right) <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>在对结点的子结点的子结点进行判断时，要注意结点的子结点的空指针判断！</p><p><code>if(root-&gt;left-&gt;left||root-&gt;left-&gt;right)</code>则忽略掉了<code>root-&gt;left</code>是空结点的可能性，</p><p>应改为<code>if(root-&gt;left&amp;&amp;(root-&gt;left-&gt;left||root-&gt;left-&gt;right))</code></p><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>下面是迭代的解法</p><p>很容易想到层序迭代遍历，对每个结点进行遍历然后对其子结点进行翻转；亦或者用先序迭代遍历和后序迭代遍历，都能达到翻转整棵二叉树的效果。唯独不能使用中序迭代遍历，因为左中右的处理顺序，在处理<em><strong>中间结点</strong></em>时，会将原来的左右子树也翻转，这就导致按照左中右来翻转二叉树，实际上是左中左的翻转操作顺序。</p><p><em><strong>迭代解法不再考虑子结点是否为空，统一只判断当前结点是否为空，即也对叶子结点进行翻转</strong></em></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs coq">struct TreeNode&#123;<br>    int val;<br>    TreeNode* <span class="hljs-built_in">left</span>;<br>    TreeNode* <span class="hljs-built_in">right</span>;<br>    <br>    TreeNode():val(<span class="hljs-number">0</span>),<span class="hljs-built_in">left</span>(nullptr),<span class="hljs-built_in">right</span>(nullptr)&#123;&#125;<br>    TreeNode(int x):val(x),<span class="hljs-built_in">left</span>(nullptr),<span class="hljs-built_in">right</span>(nullptr)&#123;&#125;<br>    TreeNode(int x,TreeNode* <span class="hljs-built_in">left</span>,TreeNode* <span class="hljs-built_in">right</span>):val(x),<span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>),<span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>)&#123;&#125;<br>&#125;;<br><br>//层序迭代遍历<br>class Solution &#123;<br>public:<br>    TreeNode* invertTree(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br>        queue&lt;TreeNode*&gt; que;<br>        que.push(root);<br>        while(!que.empty())<br>        &#123;<br>        int qsize = que.size();<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i&lt;qsize;i++)<br>        &#123;<br>        TreeNode* node = que.front();<br>        que.pop();<br>        <span class="hljs-built_in">swap</span>(node-&gt;<span class="hljs-built_in">left</span>,node-&gt;<span class="hljs-built_in">right</span>);<br>        <span class="hljs-keyword">if</span>(node-&gt;<span class="hljs-built_in">left</span>) que.push(node-&gt;<span class="hljs-built_in">left</span>);<br>        <span class="hljs-keyword">if</span>(node-&gt;<span class="hljs-built_in">right</span>) que.push(node-&gt;<span class="hljs-built_in">right</span>);<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br>//先序迭代遍历<br>class Solution &#123;<br>public:<br>    TreeNode* invertTree(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br>        stack&lt;TreeNode*&gt; stk;<br>        stk.push(root);<br>        while(!stk.empty())<br>        &#123;<br>        TreeNode* node = stk.<span class="hljs-built_in">top</span>();<br>        stk.pop();<br>        <span class="hljs-built_in">swap</span>(node-&gt;<span class="hljs-built_in">left</span>,node-&gt;<span class="hljs-built_in">right</span>);//中<br>        <span class="hljs-keyword">if</span>(node-&gt;<span class="hljs-built_in">right</span>) stk.push(node-&gt;<span class="hljs-built_in">right</span>);//右<br>        <span class="hljs-keyword">if</span>(node-&gt;<span class="hljs-built_in">left</span>) stk.push(node-&gt;<span class="hljs-built_in">left</span>);//左<br>        //<span class="hljs-built_in">swap</span>(node-&gt;<span class="hljs-built_in">left</span>,node-&gt;<span class="hljs-built_in">right</span>);//中，后序遍历<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>翻转二叉树题目中，主要需要注意到对结束条件的判断以及后续要处理结点的条件约束，如是否需要处理叶子结点。如果设定要非叶子结点才能进入判断即<code>!root-&gt;left-&gt;left||!root-&gt;left-&gt;right</code>，需要先加入判断<code>root-&gt;left!=nullptr</code>保证孙子结点能够被合法访问</p><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>[对称二叉树](<a href="https://leetcode.cn/problems/symmetric-tree/">Loading Question… - 力扣（LeetCode）</a>)</p><p>检查以<code>root</code>为根节点的树是否对称</p><h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>首先，可以想到递归法，递归函数传入两个结点，判断其值是否相等，并把下一个要判断的结点放入递归栈中</p><ol><li>判断递归结束条件<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span>(left==nullptr&amp;&amp;right==nullptr) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(left-&gt;<span class="hljs-keyword">val</span>!=right-&gt;<span class="hljs-keyword">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li>递归返回值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(TreeNode* left,TreeNode* right)</span></span><br><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span>;<br></code></pre></td></tr></table></figure></li><li>单层递归函数<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span>-&gt;val==<span class="hljs-built_in">right</span>-&gt;val)<br>&#123;<br>    judge(<span class="hljs-built_in">left</span>-&gt;<span class="hljs-built_in">left</span>,<span class="hljs-built_in">right</span>-&gt;<span class="hljs-built_in">right</span>);<br>    judge(<span class="hljs-built_in">right</span>-&gt;<span class="hljs-built_in">left</span>,<span class="hljs-built_in">left</span>-&gt;<span class="hljs-built_in">right</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">struct TreeNode&#123;<br>    <span class="hljs-built_in">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right; <br>    TreeNode():val(<span class="hljs-number">0</span>),left(<span class="hljs-literal">null</span>ptr),right(<span class="hljs-literal">null</span>ptr)&#123;&#125;<br>    TreeNode(<span class="hljs-built_in">int</span> x):val(x),left(<span class="hljs-literal">null</span>ptr),right(<span class="hljs-literal">null</span>ptr)&#123;&#125;<br>    TreeNode(<span class="hljs-built_in">int</span> x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//递归判断平衡二叉树</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">bool</span> judge(TreeNode* left,TreeNode* right)<br>&#123;<br><span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>ptr&amp;&amp;right==<span class="hljs-literal">null</span>ptr)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>ptr&amp;&amp;right!=<span class="hljs-literal">null</span>ptr)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">null</span>ptr&amp;&amp;right==<span class="hljs-literal">null</span>ptr)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">bool</span> flagleft,flagright;<br><span class="hljs-keyword">if</span>(left-&gt;val!=right-&gt;val)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>flagleft = judge(left-&gt;left,right-&gt;right);<br>flagright = judge(left-&gt;right,right-&gt;left);<br>&#125;<br>        <span class="hljs-keyword">return</span> flagleft&amp;&amp;flagright;<br>&#125;<br>    <span class="hljs-built_in">bool</span> isSymmetric(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">bool</span> flag = judge(root-&gt;left,root-&gt;right);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a><strong>迭代法</strong></h3><p>选择层序迭代遍历最为恰当</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">struct TreeNode&#123;<br><span class="hljs-built_in">int</span> val;<br>TreeNode* left;<br>TreeNode* right;<br><br>TreeNode():val(<span class="hljs-number">0</span>),left(<span class="hljs-literal">null</span>ptr),right(<span class="hljs-literal">null</span>ptr)&#123;&#125;<br>TreeNode(<span class="hljs-built_in">int</span> val):val(val),left(<span class="hljs-literal">null</span>prt),right(<span class="hljs-literal">null</span>prt)&#123;&#125;<br>TreeNode(<span class="hljs-built_in">int</span> val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//层序迭代遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">bool</span> isSymmetric(TreeNode* root)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.push(root-&gt;left);<br>        que.push(root-&gt;right);<br>        <span class="hljs-keyword">while</span>(!que.empty())<br>        &#123;<br>            TreeNode* left = que.front();<br>            que.pop();<br>            TreeNode* right = que.front();<br>            que.pop();<br>            <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>ptr&amp;&amp;right==<span class="hljs-literal">null</span>ptr)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>ptr&amp;&amp;right!=<span class="hljs-literal">null</span>ptr)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">null</span>ptr&amp;&amp;right==<span class="hljs-literal">null</span>ptr)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left-&gt;val!=right-&gt;val)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            que.push(left-&gt;left);<br>            que.push(right-&gt;right);<br>            que.push(left-&gt;right);<br>            que.push(right-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这道题主要要对不同情况进行分类判断，并且要注意后续进行<strong>两两判断</strong>的结点，递归法更为清晰；迭代法则需要注意当<code>left==nullptr&amp;&amp;right==nullptr</code>时并不能直接返回<code>true</code>与递归法不同，因为递归法返回的是上一层递归，仍需要继续对其他结点进行判断，因此在使用迭代法时需要对返回值特别注重，另外，在迭代法中不能强行按照模板<code>for(int i = 0;i&lt;que.size();i++</code>，在本题中，由于每次处理所读取的队头元素并不只有一个，因为不能用队列数量来给定处理结点的次数。 </p><h2 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h2><p>[二叉树最大深度](<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">Loading Question… - 力扣（LeetCode）</a>)</p><p>对于求最大深度，可以首先想到层序迭代遍历，用<code>level</code>来记录深度，每执行一轮就<code>level++</code>，最后返回<code>level</code>输出答案。层序迭代遍历时间复杂度为O(n)，n为结点数，空间复杂度最大为O(n)</p><h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(nullprt),right(nullprt)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">left</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">right</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution&#123;<br>public:<br><span class="hljs-built_in">int</span> max<span class="hljs-constructor">Depth(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span>(!root) return <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> level = <span class="hljs-number">0</span>;<br>queue&lt;TreeNode*&gt; que;<br>que.push(root);<br><span class="hljs-keyword">while</span>(!que.empty<span class="hljs-literal">()</span>)<br>&#123;<br><span class="hljs-built_in">int</span> qsize = que.size<span class="hljs-literal">()</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span>;i&lt;qsize;i++)<br>&#123;<br>TreeNode* node = que.front<span class="hljs-literal">()</span>;<br>que.pop<span class="hljs-literal">()</span>;<br><span class="hljs-keyword">if</span>(node-&gt;left) que.push(node-&gt;left);<br><span class="hljs-keyword">if</span>(node-&gt;right)que.push(node-&gt;right);<br>&#125;<br>level++;<br>&#125;<br>return level;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h3><p>先序递归遍历</p><ol><li>确定递归终止判断条件<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span>(!root-&gt;<span class="hljs-built_in">left</span>&amp;&amp;!root-&gt;<span class="hljs-built_in">right</span>)<span class="hljs-keyword">return</span> level;<br></code></pre></td></tr></table></figure></li><li>确定返回值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>: <span class="hljs-type">int</span> level = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"><span class="hljs-keyword">return</span> level</span>;<br></code></pre></td></tr></table></figure></li><li>确定单层递归函数<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">dfs</span>(TreeNode* node,int level)<br>level++;<span class="hljs-comment">//中</span><br><span class="hljs-built_in">dfs</span>(root-&gt;left,level); <span class="hljs-comment">//左</span><br><span class="hljs-built_in">dfs</span>(root-&gt;right,level); <span class="hljs-comment">//右</span><br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(nullprt),right(nullprt)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">left</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">right</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution&#123;<br>public:<br><span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>void dfs(TreeNode* node, <span class="hljs-built_in">int</span> level)<br>&#123;<br><span class="hljs-keyword">if</span>(!node) return;<br>res = max(level,res);<span class="hljs-comment">//中</span><br>dfs(node-&gt;left,level+<span class="hljs-number">1</span>);<span class="hljs-comment">//左</span><br>dfs(node-&gt;right,level+<span class="hljs-number">1</span>);<span class="hljs-comment">//右</span><br>&#125;<br><span class="hljs-built_in">int</span> max<span class="hljs-constructor">Depth(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span>(!root) return <span class="hljs-number">0</span>;<br>dfs(root,<span class="hljs-number">1</span>);<br>return res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>后序递归遍历</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(nullprt),right(nullprt)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">left</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">right</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution&#123;<br>public:<br><span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> dfs(TreeNode* node)<br>&#123;<br><span class="hljs-keyword">if</span>(!node) return <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> llevel = dfs(node-&gt;left);<br><span class="hljs-built_in">int</span> rlevel = dfs(node-&gt;right);<br>return max(llevel,rlevel)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">int</span> max<span class="hljs-constructor">Depth(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span>(!root) return <span class="hljs-number">0</span>;<br>res = dfs(root);<br>return res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>递归法时间复杂度O(n)，空间复杂度为O(h)，h为树高</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>层序遍历迭代法更容易理解，但付出空间复杂度可能更高的代价；递归法有先序递归遍历和后序递归遍历，先序递归遍历是<em><strong>由顶至底</strong></em>的遍历顺序，求的是从根节点开始的二叉树<em><strong>深度</strong></em>，而后序递归遍历则是<strong>由底至顶</strong>的遍历顺序，求的是从叶子结点开始的二叉树<em><strong>高度</strong></em>。也正因如此，先序递归遍历首先处理中间结点，<code>level++</code>，不需要返回值；而后序递归遍历最后处理中间结点，在此之前已得出子结点的高度，则需要返回值并加一，表示返回当前的高度。</p><h2 id="N叉树最大深度"><a href="#N叉树最大深度" class="headerlink" title="N叉树最大深度"></a>N叉树最大深度</h2><h3 id="递归法-3"><a href="#递归法-3" class="headerlink" title="递归法"></a>递归法</h3><p>后序递归遍历</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">public</span>:<br>    int val;<br>    vector<span class="hljs-tag">&lt;Node*&gt;</span> children;<br><br>    <span class="hljs-keyword">Node</span><span class="hljs-title">() &#123;&#125;</span><br><span class="hljs-title"></span><br><span class="hljs-title">    Node</span>(int _val) &#123;<br>        val = _val;<br>    &#125;<br><br>    <span class="hljs-keyword">Node</span><span class="hljs-title">(int</span> _val, vector<span class="hljs-tag">&lt;Node*&gt;</span> _children) &#123;<br>        val = _val;<br>        children = _children;<br>    &#125;<br>&#125;;<br><br>class Solution&#123;<br>public:<br>int dfs(<span class="hljs-keyword">Node</span><span class="hljs-title">* node</span>)<br>&#123;<br>int res = <span class="hljs-number">0</span>;<br>if(!<span class="hljs-keyword">node</span><span class="hljs-title">) return</span> <span class="hljs-number">0</span>;<br>for(<span class="hljs-keyword">Node</span><span class="hljs-title">* child</span> : <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;children</span>)<br>&#123;<br>int clevel = dfs(child);<br>res = max(res,clevel);<br>&#125;<br>return res+<span class="hljs-number">1</span>;<br>&#125;<br>int maxDepth(<span class="hljs-keyword">Node</span><span class="hljs-title">* root</span>)<br>&#123;<br>if(!root) return <span class="hljs-number">0</span>;<br>int res = dfs(root);<br>return res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先序递归遍历</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">public</span>:<br>    int val;<br>    vector<span class="hljs-tag">&lt;Node*&gt;</span> children;<br><br>    <span class="hljs-keyword">Node</span><span class="hljs-title">() &#123;&#125;</span><br><span class="hljs-title"></span><br><span class="hljs-title">    Node</span>(int _val) &#123;<br>        val = _val;<br>    &#125;<br><br>    <span class="hljs-keyword">Node</span><span class="hljs-title">(int</span> _val, vector<span class="hljs-tag">&lt;Node*&gt;</span> _children) &#123;<br>        val = _val;<br>        children = _children;<br>    &#125;<br>&#125;;<br><br>class Solution&#123;<br>public:<br>int res = <span class="hljs-number">0</span>;<br>void dfs(<span class="hljs-keyword">Node</span><span class="hljs-title">* node</span>,int level)<br>&#123;<br>if(!<span class="hljs-keyword">node</span><span class="hljs-title">) return</span>;<br>res = max(res,level);<br>for(<span class="hljs-keyword">Node</span><span class="hljs-title">* child</span> : <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;children</span>)<br>dfs(child,level+<span class="hljs-number">1</span>);<br>&#125;<br>int maxDepth(<span class="hljs-keyword">Node</span><span class="hljs-title">* root</span>)<br>&#123;<br>if(!root) return <span class="hljs-number">0</span>;<br>dfs(root,<span class="hljs-number">1</span>);<br>return res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Node &#123;<br>public:<br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>    vector&lt;Node*&gt; children;<br><br>    <span class="hljs-constructor">Node()</span> &#123;&#125;<br><br>    <span class="hljs-constructor">Node(<span class="hljs-params">int</span> <span class="hljs-params">_val</span>)</span> &#123;<br>        <span class="hljs-keyword">val</span> = _val;<br>    &#125;<br><br>    <span class="hljs-constructor">Node(<span class="hljs-params">int</span> <span class="hljs-params">_val</span>, <span class="hljs-params">vector</span>&lt;Node<span class="hljs-operator">*</span>&gt; <span class="hljs-params">_children</span>)</span> &#123;<br>        <span class="hljs-keyword">val</span> = _val;<br>        children = _children;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution&#123;<br>public:<br><span class="hljs-built_in">int</span> max<span class="hljs-constructor">Depth(Node<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span>(!root) return <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> level = <span class="hljs-number">0</span>;<br>queue&lt;Node*&gt; que;<br>que.push(root);<br><span class="hljs-keyword">while</span>(!que.empty<span class="hljs-literal">()</span>)<br>&#123;<br><span class="hljs-built_in">int</span> qsize = que.size<span class="hljs-literal">()</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span>;i&lt;qsize;i++)<br>&#123;<br>Node* node = que.front<span class="hljs-literal">()</span>;<br>que.pop<span class="hljs-literal">()</span>;<br><span class="hljs-keyword">for</span>(Node* child:node-&gt;children)<br>que.push(child);<br>&#125;<br>level++;<br>&#125;<br>return level;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>与二叉树最大深度如出一辙。注意如何获取<code>children</code>结点，</p><p><code>vector&lt;Node *&gt; children = root-&gt;children;</code></p><p><code>for(auto child:children)</code></p><h2 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h2><p>[二叉树最小深度](<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（LeetCode）</a>)</p><h3 id="递归法-4"><a href="#递归法-4" class="headerlink" title="递归法"></a><em><strong>递归法</strong></em></h3><p>先序递归遍历</p><ol><li><p>确定递归结束条件</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span>(!root-&gt;<span class="hljs-built_in">left</span>&amp;&amp;root-&gt;<span class="hljs-built_in">right</span>)<br>&#123;<br>res = min(res,level);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定返回值</p></li></ol>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function"><span class="hljs-keyword">return</span></span>;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>确定单层递归逻辑</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">dfs(root-&gt;<span class="hljs-built_in">left</span>,level+<span class="hljs-number">1</span>);<br>dfs(root-&gt;<span class="hljs-built_in">right</span>,level+<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><p>整体代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(nullprt),right(nullprt)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">left</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">right</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution&#123;<br>public:<br><span class="hljs-built_in">int</span> res = INT_MAX;<br>void dfs(TreeNode* node, <span class="hljs-built_in">int</span> level)<br>&#123;<br><span class="hljs-keyword">if</span>(!node-&gt;left&amp;&amp;!node-&gt;right)<br>        &#123;<br>        res = min(res,level);<span class="hljs-comment">//中</span><br>        return;<br>        &#125;<br><span class="hljs-keyword">if</span>(node-&gt;left)dfs(node-&gt;left,level+<span class="hljs-number">1</span>);<span class="hljs-comment">//左</span><br><span class="hljs-keyword">if</span>(node-&gt;right)dfs(node-&gt;right,level+<span class="hljs-number">1</span>);<span class="hljs-comment">//右</span><br>&#125;<br><span class="hljs-built_in">int</span> min<span class="hljs-constructor">Depth(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span>(!root) return <span class="hljs-number">0</span>;<br>dfs(root,<span class="hljs-number">1</span>);<br>return res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同理，后序遍历做法模仿二叉树最大深度，整体代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(nullprt),right(nullprt)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">left</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">right</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution&#123;<br>public:<br><span class="hljs-built_in">int</span> dfs(TreeNode* node)<br>&#123;<br><span class="hljs-keyword">if</span>(!node-&gt;left&amp;&amp;!node-&gt;right)<br>        return <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> llevel = INT_MAX,rlevel = INT_MAX;<br>        <span class="hljs-keyword">if</span>(node-&gt;left)<br>    llevel = dfs(node-&gt;left);<span class="hljs-comment">//左</span><br><span class="hljs-keyword">if</span>(node-&gt;right)<br>            rlevel = dfs(node-&gt;right); <span class="hljs-comment">//右</span><br>return min(llevel,rlevel) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">int</span> min<span class="hljs-constructor">Depth(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span>(!root) return <span class="hljs-number">0</span>;<br>return dfs(root) + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另一种后序递归遍历</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(nullprt),right(nullprt)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">left</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">right</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Depth(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">node</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node<span class="hljs-operator"> == </span>NULL) return <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当一个左子树为空，右不为空，这时并不是最低点</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left<span class="hljs-operator"> == </span>NULL<span class="hljs-operator"> &amp;&amp; </span>node-&gt;right != NULL) &#123; <br>            return <span class="hljs-number">1</span> + get<span class="hljs-constructor">Depth(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">right</span>)</span>;<br>        &#125;   <br>        <span class="hljs-comment">// 当一个右子树为空，左不为空，这时并不是最低点</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left != NULL<span class="hljs-operator"> &amp;&amp; </span>node-&gt;right<span class="hljs-operator"> == </span>NULL) &#123; <br>            return <span class="hljs-number">1</span> + get<span class="hljs-constructor">Depth(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">left</span>)</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">1</span> + min(leftDepth, rightDepth);<br>        return result;<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> min<span class="hljs-constructor">Depth(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(!root)return <span class="hljs-number">0</span>;<br>        return get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>)</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代法-4"><a href="#迭代法-4" class="headerlink" title="迭代法"></a>迭代法</h3><p>层序迭代遍历</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(nullprt),right(nullprt)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">left</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">right</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution&#123;<br>public:<br><span class="hljs-built_in">int</span> min<span class="hljs-constructor">Depth(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span>(!root) return <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> res =INT_MAX;<br><span class="hljs-built_in">int</span> level = <span class="hljs-number">1</span>;<br>queue&lt;TreeNode*&gt; que;<br>que.push(root);<br><span class="hljs-keyword">while</span>(!que.empty<span class="hljs-literal">()</span>)<br>&#123;<br><span class="hljs-built_in">int</span> qsize = que.size<span class="hljs-literal">()</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; qsize; i++)<br>&#123;<br>TreeNode* node = que.front<span class="hljs-literal">()</span>;<br>que.pop<span class="hljs-literal">()</span>;<br><span class="hljs-keyword">if</span>(!node-&gt;left&amp;&amp;!node-&gt;right)<span class="hljs-comment">//只有到达叶子结点才更新res</span><br>&#123;<br>res = min(res,level);<br>&#125;<br><span class="hljs-keyword">if</span>(node-&gt;left)que.push(node-&gt;left);<br><span class="hljs-keyword">if</span>(node-&gt;right)que.push(node-&gt;right);<br>&#125;<br>level++;<br>&#125;<br>return res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>这题的突破点主要在于理解只有在到达叶子结点时才是二叉树的深度，即[2,null,3,null,4,null,5,null,6]的最小深度不是1，而是5。另外，在递归遍历中，可以根据不同的递归判断（判断是否让该结点进入下一层递归），来确定不同的返回值，如<code>if(!node)return 0;</code>或<code>if(!node-&gt;left&amp;&amp;!node-&gt;right)</code>，并且如果是后者，需要先判断<code>node</code>结点本身是否为空，否则会报错；如果是前者，则必须保证能够让单亲结点进入递归（否则直接返回错误的最小深度）</p><h2 id="完全二叉树的结点个数"><a href="#完全二叉树的结点个数" class="headerlink" title="完全二叉树的结点个数"></a><strong>完全二叉树的结点个数</strong></h2><p>[完全二叉树的结点个数](<a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a>)</p><p>最直观的做法就是遍历每个结点，非空则计数+1，直至遇到空结点，可采用先序、中序和后序的递归遍历、迭代遍历法，也可以用层序迭代遍历法</p><h3 id="递归法-5"><a href="#递归法-5" class="headerlink" title="递归法"></a>递归法</h3><p>先序递归遍历</p><ol><li>确定递归结束条件<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">if(!<span class="hljs-keyword">node</span><span class="hljs-title">) return</span>;<br></code></pre></td></tr></table></figure></li><li>确定返回值<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span><br><span class="hljs-function"><span class="hljs-keyword">return</span></span>;<br></code></pre></td></tr></table></figure></li><li>确定单层逻辑<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sum++;<br>dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);<br>dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs scss">struct TreeNode&#123;<br>int val;<br>TreeNode* <span class="hljs-attribute">left</span>;<br>TreeNode* <span class="hljs-attribute">right</span>;<br><br><span class="hljs-built_in">TreeNode</span>():<span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">left</span>(nullptr),<span class="hljs-built_in">right</span>(nullptr)&#123;&#125;<br><span class="hljs-built_in">TreeNode</span>(int val):<span class="hljs-built_in">val</span>(val),<span class="hljs-built_in">left</span>(nullprt),<span class="hljs-built_in">right</span>(nullprt)&#123;&#125;<br><span class="hljs-built_in">TreeNode</span>(int val,TreeNode*left,TreeNode*right):<span class="hljs-built_in">val</span>(val),<span class="hljs-built_in">left</span>(left),<span class="hljs-built_in">right</span>(right)&#123;&#125;<br>&#125;;<br><br>class Solution &#123;<br>public:<br>    int sums = <span class="hljs-number">0</span>;<br>    void <span class="hljs-built_in">dfs</span>(TreeNode* node)<br>    &#123;<br>    <span class="hljs-built_in">if</span>(!node)return;<br>    sums++;<br>    <span class="hljs-built_in">dfs</span>(node-&gt;left);<br>    <span class="hljs-built_in">dfs</span>(node-&gt;right);<br>    &#125;<br>    int <span class="hljs-built_in">countNodes</span>(TreeNode* root) &#123;<br>    <span class="hljs-built_in">if</span>(!root)return <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dfs</span>(root);<br>        return sums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h3 id="迭代法-5"><a href="#迭代法-5" class="headerlink" title="迭代法"></a>迭代法</h3><p>中序迭代遍历法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>TreeNode* left;<br>TreeNode* right;<br><br><span class="hljs-constructor">TreeNode()</span>:<span class="hljs-keyword">val</span>(<span class="hljs-number">0</span>),left(nullptr),right(nullptr)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(nullprt),right(nullprt)&#123;&#125;<br><span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">left</span>,TreeNode<span class="hljs-operator">*</span><span class="hljs-params">right</span>)</span>:<span class="hljs-keyword">val</span>(<span class="hljs-keyword">val</span>),left(left),right(right)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> count<span class="hljs-constructor">Nodes(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(!root)return <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//中序迭代遍历</span><br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>    stack&lt;TreeNode*&gt; stk;<br>        TreeNode* cur = root;<br><br>        <span class="hljs-keyword">while</span>(cur!=nullptr<span class="hljs-pattern-match"><span class="hljs-operator">||</span>!stk.empty())</span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-keyword">if</span>(!cur)</span><br><span class="hljs-pattern-match">            &#123;</span><br><span class="hljs-pattern-match">                cur = stk.top();stk.pop();</span><br><span class="hljs-pattern-match">                res<span class="hljs-operator">++</span>;</span><br><span class="hljs-pattern-match">                cur = cur-&gt;right;</span><br><span class="hljs-pattern-match">            &#125;</span><br><span class="hljs-pattern-match">            <span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">            &#123;</span><br><span class="hljs-pattern-match">                stk.push(cur);</span><br><span class="hljs-pattern-match">                cur = cur-&gt;left;</span><br><span class="hljs-pattern-match">            &#125;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        return res;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;;</span><br></code></pre></td></tr></table></figure><h3 id="special解法"><a href="#special解法" class="headerlink" title="special解法"></a><em><strong>special解法</strong></em></h3><p>然而，以上方法都只是遍历所有结点才能确定结点个数，只是单纯当成一个普通的二叉树，时间复杂度都是O(n)。可以利用完全二叉树的性质来减小时间复杂度</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs excel">/*对于一颗完全二叉树，如果找到最底层是<span class="hljs-built_in">n</span>，可以用公式计算前<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>层的结点数`<span class="hljs-number">2</span>^(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)-<span class="hljs-number">1</span>`再加上第<span class="hljs-built_in">n</span>层的结点<br><br>对于第<span class="hljs-built_in">n</span>层上的结点，利用二分法不断缩小范围来找到最后一个结点<br><br>  <span class="hljs-number">1</span><br>   /      \<br>  <span class="hljs-number">2</span>        <span class="hljs-number">3</span><br> / \      / \<br><span class="hljs-number">4</span>   <span class="hljs-number">5</span>    <span class="hljs-number">6</span>   <span class="hljs-number">7</span><br><br>给定二分法的范围，通过序号的二进制数顺序即可判断结点是否存在，如在level = <span class="hljs-number">3</span>，序号为<span class="hljs-number">6</span>的结点，二进制数为<span class="hljs-number">110</span>，取除最高位剩下的即<span class="hljs-number">10</span>,从根节点出发，<span class="hljs-number">1</span>代表右子树，<span class="hljs-number">0</span>代表左子树，则根节点的右子树的左子树即为该节点;再如level = <span class="hljs-number">4</span>，序号为<span class="hljs-number">9</span>的结点，除最高位剩下的二进制数为<span class="hljs-number">001</span>，即代表从根节点出发，其左子树的左子树的右子树即为该结点<br>*/<br><br>class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>bool is_exist(TreeNode* root, <span class="hljs-built_in">int</span> level, <span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span>)<br>&#123;<br><span class="hljs-built_in">int</span> cmp = <span class="hljs-number">1</span>&lt;&lt;(level - <span class="hljs-number">2</span>);<br>//cmp 用作取序号<span class="hljs-built_in">index</span>对应位置上的数<br>        TreeNode* node = root;<br>while(node!=nullptr&amp;&amp;cmp)<br>&#123;<br><span class="hljs-built_in">if</span>(cmp&amp;<span class="hljs-built_in">index</span>)<br>node = node-&gt;<span class="hljs-built_in">right</span>;<br>else<br>node = node-&gt;<span class="hljs-built_in">left</span>;<br>cmp &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br>return node!=nullptr;<br>&#125;<br>    <span class="hljs-built_in">int</span> countNodes(TreeNode* root) &#123;<br>    <span class="hljs-built_in">if</span>(!root)return <span class="hljs-number">0</span>;<br>    //先循环左子树找出树高<br>    <span class="hljs-built_in">int</span> level = <span class="hljs-number">1</span>;<br>    TreeNode* node = root;<br>    while(node-&gt;<span class="hljs-built_in">left</span>)<br>    &#123;<br>    level++;<br>    node = node-&gt;<span class="hljs-built_in">left</span>;<br>    &#125;<br>    //这时node结点为二叉树最大深度的最左结点<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">1</span> &lt;&lt; (level - <span class="hljs-number">1</span>), <span class="hljs-built_in">right</span> = (<span class="hljs-number">1</span> &lt;&lt; level) - <span class="hljs-number">1</span>;<br>    //<span class="hljs-built_in">left</span> 指向最大深度的最左结点，<span class="hljs-built_in">right</span> 指向最大深度的最右结点<br>    while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)<br>    &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span> + (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;//+<span class="hljs-number">1</span>为了防止死循环<br>    <span class="hljs-built_in">if</span>(is_exist(root,level,<span class="hljs-built_in">mid</span>))<br>    <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>;<br>    else<br>    <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    //此时，<span class="hljs-built_in">mid</span>即为最大结点序号<br>     return <span class="hljs-built_in">left</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于上述程序的时间复杂度，循环查找二叉树最大深度<code>O(logn)</code>，二分法时间复杂度<code>O(logn)</code>，但嵌套了时间复杂度为O(log n)<code>的结点存在判断算法，因此总的时间复杂度为</code>O(log n+log n^2)&#96;</p><blockquote><p>时间复杂度：O(log^2 n)，其中 n 是完全二叉树的节点数。</p><p>首先需要 O(h)的时间得到完全二叉树的最大层数，其中 h 是完全二叉树的最大层数；使用二分查找确定节点个数时，需要查找的次数为 O(log2^h)&#x3D;O(h)，每次查找需要遍历从根节点开始的一条长度为 h 的路径，需要 O(h)的时间，因此二分查找的总时间复杂度是 O(h^2)。因此总时间复杂度是 O(h^2)，由于完全二叉树满足 2^h &lt;&#x3D; n &lt;&#x3D;2^(h+1)，因此有 O(h)&#x3D;O(log n)，O(h^2)&#x3D;O(\log^2 n)</p></blockquote><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>在题目中的位运算解法中，需要弄清楚完全二叉树的特殊性质，即结点按顺序从左到右依次填满，以及可以通过序号反推从根节点开始到该结点的路径，并且清楚位运算中<code>1 &lt;&lt; n</code>等价于<code>1*2^n</code>，在运算时间上位运算也会更有优势，再结合二分法即可在小于O(n)的时间复杂度内完成</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h2><p>[平衡二叉树](<a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（LeetCode）</a>)</p><h3 id="由顶至底法"><a href="#由顶至底法" class="headerlink" title="由顶至底法"></a>由顶至底法</h3><p>最容易想到的一种方法就是分别求出左右子树的高度，再根据两者的差值进行判断。若是用先序遍历（求树深）的方法来做，需要有更多变量来保存临时树深和最大树深，因此更适合用后序遍历来做</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> dfs(TreeNode* node)<br>&#123;<br><span class="hljs-keyword">if</span>(!node)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> llevel = dfs(node-&gt;left);<br>        <span class="hljs-keyword">int</span> rlevel = dfs(node-&gt;right);<br><span class="hljs-keyword">return</span> max(llevel,rlevel)+<span class="hljs-number">1</span>;<br>&#125;<br>    <span class="hljs-keyword">bool</span> isBalanced(TreeNode* root) &#123;<br><span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(abs(dfs(root-&gt;right)-dfs(root-&gt;left))&gt;<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述方法还有个bug，没有考虑到子树本身是否平衡，因此需要再对子树进行平衡判断</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> dfs(TreeNode* node)<br>&#123;<br><span class="hljs-keyword">if</span>(!node)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">int</span> llevel = dfs(node-&gt;left);<br>         <span class="hljs-keyword">int</span> rlevel = dfs(node-&gt;right);<br><span class="hljs-keyword">return</span> max(llevel,rlevel)+<span class="hljs-number">1</span>;<br>&#125;<br>    <span class="hljs-keyword">bool</span> isBalanced(TreeNode* root) &#123;<br><span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>         <span class="hljs-keyword">if</span>(abs(dfs(root-&gt;right)-dfs(root-&gt;left))&gt;<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">return</span> isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于进行了大量的重复运算，最坏情况下时间复杂度为O(n^2)</p><h3 id="由底至顶法"><a href="#由底至顶法" class="headerlink" title="由底至顶法"></a><em><strong>由底至顶法</strong></em></h3><p>上述代码中，重复运算的原因在于子树高度时一旦遇到子树的子树不平衡时，没有及时向上返回，而是只返回最大深度，这就导致了还要对子树的子树进行额外的重复运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!node)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> llevel = <span class="hljs-built_in">dfs</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (llevel == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> rlevel = <span class="hljs-built_in">dfs</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span> (rlevel == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(llevel - rlevel) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-built_in">max</span>(llevel, rlevel) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root) != <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n)，最多每个结点运算一次</p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>进一步理解求树深用先序遍历，求树高用后序遍历。在做判断二叉树是否符合某种要求题目时，不仅要考虑根节点，还要考虑其子树是否同样符合。</p><p>由底至顶法提到，涉及到判断树是否符合某种条件时，一旦遇到不符合的，应立即向上返回，避免做其他开销，只需要加多判断语句，在本题中，形象上看起来就像是由底至顶地判断</p><h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a><strong>二叉树的所有路径</strong></h2><p>[二叉树的所有路径](<a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径 - 力扣（LeetCode）</a>)</p><h3 id="递归法-6"><a href="#递归法-6" class="headerlink" title="递归法"></a>递归法</h3><ol><li><p>递归结束条件</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">if(!<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>&amp;&amp;!<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)<br></code></pre></td></tr></table></figure></li><li><p>递归返回值</p><p>​递归结束时即遇到了叶子结点，则证明改路径结束，应该返回整条路径并输出到res中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">TreeNode* node</span>)<br>&#123;<br><span class="hljs-comment">//将path整条打印成&quot;node1-&gt;node2-&gt;...-&gt;noden&quot;格式</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>单层递归逻辑</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>) <br>&#123;<br>traversal(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);<br>path.pop_back();//回溯<br>&#125;<br><br>if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)<br>&#123;<br>traversal(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);<br>path.pop_back();<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    void traversal(TreeNode* <span class="hljs-keyword">node</span><span class="hljs-title">, vector</span><span class="hljs-tag">&lt;string&gt;</span> &amp;res, vector<span class="hljs-tag">&lt;TreeNode*&gt;</span> &amp;path)<br>    &#123;<br>        path.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">        if</span> (!<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>&amp;&amp;!<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)//叶子结点则路径结束<br>        &#123;<br>            <span class="hljs-keyword">string</span> str;<br>            for (int i = <span class="hljs-number">0</span>; i <span class="hljs-tag">&lt; path.size() - 1; i++)</span><br><span class="hljs-tag">            &#123;</span><br><span class="hljs-tag">                str += to_string(path[i]-&gt;</span>val);<br>                str += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            &#125;<br>            str += to_string(path.back()-&gt;val);<br>            res.push_back(str);<br>            path.pop_back();<br>            return;<br>        &#125;<br>        <br>        if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>)  traversal(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>, res, path);<br>        if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>) traversal(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>, res, path);<br>        path.pop_back();<br><br>    &#125;<br>    vector<span class="hljs-tag">&lt;string&gt;</span> binaryTreePaths(TreeNode* root) &#123;<br>        vector<span class="hljs-tag">&lt;string&gt;</span> res;<br>        vector<span class="hljs-tag">&lt;TreeNode*&gt;</span>path;<br>        traversal(root, res, path);<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>本题是第一次遇到回溯算法，在二叉树中的回溯算法结合递归可能较难以理解，需要多加模拟回溯过程，体验不同的回溯方式可以更好理解。因为要求按顺序打印路径，此题就需要用先序遍历（先打印的是根结点），但一般来说，回溯法使用后序遍历更简便</p><h2 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h2><p>[左叶子之和](<a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和 - 力扣（LeetCode）</a>)</p><p>首先要清楚如何判断是否是左叶子结点，哪种情况下才能算是左叶子，例如<code>[1,null,2]</code>中并不存在左叶子。因此可以得到关键判断语句<code>if(root-&gt;left&amp;&amp;!root-&gt;left-&gt;left&amp;&amp;!root-&gt;left-&gt;right)</code>，这是解题的关键</p><h3 id="递归法-7"><a href="#递归法-7" class="headerlink" title="递归法"></a>递归法</h3><p>后序递归遍历</p><ol><li><p>确定递归结束条件</p><p>遇到左叶子或者遇到叶子结点即返回</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-built_in">left</span>&amp;&amp;!root-&gt;<span class="hljs-built_in">left</span>-&gt;<span class="hljs-built_in">left</span>&amp;&amp;!root-&gt;<span class="hljs-built_in">left</span>-&gt;<span class="hljs-built_in">right</span>) <span class="hljs-keyword">return</span> lsum+rsum+root-&gt;<span class="hljs-built_in">left</span>-&gt;val;<br></code></pre></td></tr></table></figure></li><li><p>确定递归返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> lsum </span>= <span class="hljs-number">0</span>,rsum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> lsum + rsum;<br></code></pre></td></tr></table></figure></li><li><p>单层递归逻辑</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(node-&gt;left)</span></span><span class="hljs-built_in">dfs</span>(root-&gt;<span class="hljs-attribute">left</span>);<br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(node-&gt;right)</span></span><span class="hljs-built_in">dfs</span>(root-&gt;<span class="hljs-attribute">right</span>);<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs coq">class Solution &#123;<br>public:<br>    int dfs(TreeNode* node)<br>    &#123;<br>        int lsum = <span class="hljs-number">0</span>,rsum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-built_in">left</span>) <br>            lsum = sumOfLeftLeaves(node-&gt;<span class="hljs-built_in">left</span>);<br>        <span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-built_in">right</span>) <br>            rsum = sumOfLeftLeaves(node-&gt;<span class="hljs-built_in">right</span>);<br>        <span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-built_in">left</span> &amp;&amp; !node-&gt;<span class="hljs-built_in">left</span>-&gt;<span class="hljs-built_in">left</span> &amp;&amp; !node-&gt;<span class="hljs-built_in">left</span>-&gt;<span class="hljs-built_in">right</span>)//左叶子结点<br>            <span class="hljs-keyword">return</span> node-&gt;<span class="hljs-built_in">left</span>-&gt;val+lsum+rsum;<br>        <span class="hljs-keyword">return</span> lsum + rsum;<br>    &#125;<br>    int sumOfLeftLeaves(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span> (!root-&gt;<span class="hljs-built_in">left</span> &amp;&amp; !root-&gt;<span class="hljs-built_in">right</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因为在进入递归之前加上了结点是否为空的判断，因此在递归结束判断条件中并不是传统的<code>if(!node)</code>判断，只需要判断是否为左叶子即可</p><p>先序递归遍历</p><p>整体代码如下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>    int res = <span class="hljs-number">0</span>;<br>    void dfs(TreeNode* node)<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (node-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> &amp;&amp; !node-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> &amp;&amp; !node-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>right)<span class="hljs-comment">//左叶子结点</span><br>            <span class="hljs-function"><span class="hljs-title">res</span> += node-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>val;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (node-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>) sumOfLeftLeaves(node-&gt;</span>left);<br>        <span class="hljs-function"><span class="hljs-title">if</span> (node-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>) sumOfLeftLeaves(node-&gt;</span>right);<br>    &#125;<br>    int sumOfLeftLeaves(TreeNode* root) &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (!root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> &amp;&amp; !root-&gt;</span>right) return <span class="hljs-number">0</span>;<br>        dfs(root);<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先序递归遍历代码只是对左叶子的判断语句提前，符合先序遍历中左右的结点处理顺序</p><h3 id="迭代法-6"><a href="#迭代法-6" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法采用层序迭代遍历，代码思路较为简单直接</p><p>整体代码如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs coq">class Solution &#123;<br>public:<br>    int sumOfLeftLeaves(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(root==nullptr)   <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        int res = <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        TreeNode* node;<br>        que.push(root);<br>        while(!que.empty())<br>        &#123;<br>            int size = que.size();<br>            <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i&lt;size;i++)<br>                &#123;<br>                    node = que.front();<br>                    que.pop();<br>                    <span class="hljs-keyword">if</span>(node-&gt;<span class="hljs-built_in">left</span>)<br>                    &#123;<br>                        que.push(node-&gt;<span class="hljs-built_in">left</span>);<br>                        <span class="hljs-keyword">if</span>(node-&gt;<span class="hljs-built_in">left</span>-&gt;<span class="hljs-built_in">left</span> == nullptr&amp;&amp;node-&gt;<span class="hljs-built_in">left</span>-&gt;<span class="hljs-built_in">right</span> ==nullptr)<br>                            res+=node-&gt;<span class="hljs-built_in">left</span>-&gt;val;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(node-&gt;<span class="hljs-built_in">right</span>)<br>                        que.push(node-&gt;<span class="hljs-built_in">right</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>本题的关键点在于理解左叶子结点，如何对左叶子结点进行判断，需要通过父结点，判断其是否为左孩子，再判断是否为叶子结点，算是扩展了一种解题的新思路</p><h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value">找树左下角的值</a></p><p>本题中，需要找到左下角的结点，即需要最大深度和最左边的叶子结点，则可以利用先序（中、后序同样也可以）递归遍历的特点，先访问左结点再访问右结点，即<strong>只要记录下当前深度和最大深度</strong>，若是当前深度大于最大深度，则更新最大深度，并把当前的结点作为左下角的结点；若当前深度等于最大深度，则不更新，因为当前结点仅仅只是最大深度，一定不是左下角的点；若当前深度小于最大深度则同理。</p><h3 id="递归法-8"><a href="#递归法-8" class="headerlink" title="递归法"></a>递归法</h3><ol><li><p>确定递归结束条件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定返回值</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> height = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node, <span class="hljs-type">int</span> level)</span></span><br></code></pre></td></tr></table></figure></li><li><p>单层递归逻辑</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">if(level &gt; height)//当前深度为最大深度<br>&#123;<br>height = level;<br>res = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>;<br>&#125;<br>if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>)dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);<br>if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>int res = <span class="hljs-number">0</span>;<br>int height = -<span class="hljs-number">1</span>;<br>    void dfs(TreeNode* <span class="hljs-keyword">node</span><span class="hljs-title">,int</span> level)<br>    &#123;<br>        if(!<span class="hljs-keyword">node</span><span class="hljs-title">)   return</span>;<br>        if(height <span class="hljs-tag">&lt; level)//如遇到更大深度的，则直接修改res，且只遇到第一个更深的结点才修改</span><br><span class="hljs-tag">        &#123;</span><br><span class="hljs-tag">            res = node-&gt;</span>val;<br>            height = level;<br>        &#125;   <br>        if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>) dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>,level + <span class="hljs-number">1</span>);<br>        if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>) dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>,level + <span class="hljs-number">1</span>);<br>    &#125;<br>    int findBottomLeftValue(TreeNode* root) &#123;<br>        if(!root-&gt;left&amp;&amp;!root-&gt;right)   return root-&gt;val;<br>        dfs(root,<span class="hljs-number">1</span>);<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在本题递归解法中，实际上也有使用到回溯的过程，即在判断<code>node-&gt;left</code>进入递归时，应对当前深度加一，退出递归后又要将当前深度减一</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> maxDepth = INT_MIN;<br>    <span class="hljs-keyword">int</span> result;<br>    void traversal(TreeNode* root, <span class="hljs-keyword">int</span> depth) &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123;<br>            <span class="hljs-keyword">if</span> (depth &gt; maxDepth) &#123;<br>                maxDepth = depth;<br>                result = root-&gt;val;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            depth++;<br>            traversal(root-&gt;left, depth);<br>            depth--; <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            depth++;<br>            traversal(root-&gt;right, depth);<br>            depth--; <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> findBottomLeftValue(TreeNode* root) &#123;<br>        traversal(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代法-7"><a href="#迭代法-7" class="headerlink" title="迭代法"></a>迭代法</h3><p>层序迭代法更为直观理解，只要在每一层遍历时，存入第一个结点的值即为结果</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> findBottomLeftValue(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">NULL</span>) que.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = que.<span class="hljs-keyword">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">size</span>; i++) &#123;<br>                TreeNode* node = que.front();<br>                que.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) result = node-&gt;val; <span class="hljs-comment">// 记录最后一行第一个元素</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-keyword">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-keyword">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>两种方法的时间复杂度为O(n)，其中若是链式结构，递归法空间复杂度为O(n)，若是完全二叉树，迭代法空间复杂度O(n&#x2F;2)。递归法用到了回溯的思想，但可以将其隐藏起来，并不会对结果产生影响。</p><h2 id="路径之和"><a href="#路径之和" class="headerlink" title="路径之和"></a>路径之和</h2><p>[路径之和](<a href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（LeetCode）</a>)</p><h3 id="递归法-9"><a href="#递归法-9" class="headerlink" title="递归法"></a>递归法</h3><p>很明显这道题需要用到回溯的思想，与寻找二叉树所有路径题相似，通过深度优先遍历递归寻找到一条“路径”（指从根节点到叶子结点的完整路径），再比较路径上结点的值是否与target值相等。需要注意的是在回退上一层父结点时，需要将加入的子结点及时pop出去，即回溯（删除结点）发生在访问到叶子结点的时候。</p><p>根据题意，因为要先处理中间结点，更适合用先序遍历</p><ol><li><p>确定递归结束条件</p><p>因为在进入递归前先判断结点是否为空，则递归结束条件不是结点为空，而是当前结点到达路径终点，即结点是叶子结点</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span>(!root-&gt;<span class="hljs-built_in">left</span>&amp;&amp;!root-&gt;<span class="hljs-built_in">right</span>)<br></code></pre></td></tr></table></figure></li><li><p>确定递归返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> lflag = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> rflag = <span class="hljs-literal">false</span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node,vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> lflag||rflag;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归逻辑</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">vec.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">if</span>(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>) <br>&#123;<br>lflag = dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>,vec,target);<br>vec.pop_back();//回溯<br>&#125;<br>if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)<br>&#123;<br>rflag = dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>,vec,target);<br>vec.pop_back();//回溯<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    int lflag = <span class="hljs-literal">false</span>, rflag = <span class="hljs-literal">false</span>;<br>    bool dfs(TreeNode* <span class="hljs-keyword">node</span><span class="hljs-title">, vector</span><span class="hljs-tag">&lt;int&gt;</span>&amp; vec, int target)<br>    &#123;<br>        vec.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>        if (!<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span> &amp;&amp; !<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)//遇到叶子结点则路径结束<br>        &#123;<br>            if (accumulate(vec.begin(), vec.end(), <span class="hljs-number">0</span>) == target)<br>                return <span class="hljs-literal">true</span>;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        if (<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>)<br>        &#123;<br>            lflag = lflag||dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>, vec, target);<br>            vec.pop_back();<br>        &#125;<br>        if (<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)<br>        &#123;<br>            rflag = rflag||dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>, vec, target);<br>            vec.pop_back();<br>        &#125;<br>        return lflag || rflag;<br>    &#125;<br>    bool hasPathSum(TreeNode* root, int targetSum) &#123;<br>        if (!root)  return <span class="hljs-literal">false</span>;<br>        vector <span class="hljs-tag">&lt;int&gt;</span> vec;<br>        return dfs(root, vec, targetSum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该版本代码在任何情况下都需要遍历所有结点，因此时间复杂度是O(n)，最坏情况下的空间复杂度是O(n)。可以先判断flag的值是否有被修改成true，如果有，则证明存在一条路径符合要求，此时即可直接返回true，只需要添加以下语句</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span>(lflag||rflag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>修改过的版本有类似于平衡二叉树中由底至顶法的意思，一旦遇到有符合的路径就要及时返回，避免额外开销</p><h3 id="迭代法-8"><a href="#迭代法-8" class="headerlink" title="迭代法"></a>迭代法</h3><p>先序迭代遍历</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">bool</span> has<span class="hljs-constructor">PathSum(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">targetSum</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!root) return <span class="hljs-literal">false</span>;<br>        stack&lt;pair&lt;TreeNode*, <span class="hljs-built_in">int</span>&gt;&gt; stk;<br>        stk.push(make<span class="hljs-constructor">_pair(<span class="hljs-params">root</span>, <span class="hljs-params">root</span>-&gt;<span class="hljs-params">val</span>)</span>);<br>        <span class="hljs-keyword">while</span> (!stk.empty<span class="hljs-literal">()</span>)<br>        &#123;<br>            TreeNode* node = stk.top<span class="hljs-literal">()</span>.first;<br>            <span class="hljs-built_in">int</span> tmp = stk.top<span class="hljs-literal">()</span>.second;<br>            stk.pop<span class="hljs-literal">()</span>;<br>            <span class="hljs-keyword">if</span> (!node-&gt;left<span class="hljs-operator"> &amp;&amp; </span>!node-&gt;right<span class="hljs-operator"> &amp;&amp; </span>targetSum==tmp)<br>            &#123;<br>                return <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node-&gt;right)<br>            &#123;<br>                stk.push(make<span class="hljs-constructor">_pair(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">node</span>-&gt;<span class="hljs-params">right</span>-&gt;<span class="hljs-params">val</span> + <span class="hljs-params">tmp</span>)</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node-&gt;left)<br>            &#123;<br>                stk.push(make<span class="hljs-constructor">_pair(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">node</span>-&gt;<span class="hljs-params">left</span>-&gt;<span class="hljs-params">val</span> + <span class="hljs-params">tmp</span>)</span>);<br>            &#125;<br>        &#125;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>在递归法中，需要注意与二叉树的所有路径题目不同的是，应该在每次调用递归之后马上进行回溯，即删除结点，这也是个良好的习惯，二叉树的所有路径题中只是因为没有返回值，才导致可以有多个回溯方式，但理论上应统一回溯只发生在递归结束之后。并且根据题目应该遇到合适路径就要立即返回，不需要再做额外的递归开销</p><p>在迭代法中，依旧使用stack进行先序遍历，但不能只存储<code>TreeNode*</code>结点，还要存储上当前结点的路径总和值，当遇到叶子结点并且路径总和值与target值相等时，即可直接返回true。其他迭代遍历版本亦是如此</p><h2 id="路径之和II"><a href="#路径之和II" class="headerlink" title="路径之和II"></a>路径之和II</h2><p>[路径之和](<a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II - 力扣（LeetCode）</a>)</p><h3 id="递归法-10"><a href="#递归法-10" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node, vector&lt;<span class="hljs-type">int</span>&gt;&amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        path.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-keyword">if</span>(!node-&gt;left&amp;&amp;!node-&gt;right)<span class="hljs-comment">//遇到叶子结点则当前路径结束</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">accumulate</span>(path.<span class="hljs-built_in">begin</span>(),path.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>)==target)<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node-&gt;left)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(node-&gt;left,path,res,target);<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//回溯</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(node-&gt;right)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(node-&gt;right,path,res,target);<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//回溯</span><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(root,path,res,targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>与路径之和思路一致，只不过换了方式存储结果和路径结点的值，其他都如出一辙</p><h2 id="从中序和后序遍历序列构造二叉树"><a href="#从中序和后序遍历序列构造二叉树" class="headerlink" title="从中序和后序遍历序列构造二叉树"></a><strong>从中序和后序遍历序列构造二叉树</strong></h2><p>[从中序和后序遍历序列构造二叉树](<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a>)</p><h3 id="递归法-11"><a href="#递归法-11" class="headerlink" title="递归法"></a>递归法</h3><p>大致思路如下</p><ol><li><p>从中序遍历和后序遍历比对，先从后序遍历找到最后一个值，即为根节点的值，在中序遍历序列找到该值并分割</p></li><li><p>根据中序遍历分割得到的左右段区间，即为该结点的左右子树，根据左子树区间长度，获取后序遍历中前一部分相等长度的区间，即获得左子树的中序遍历和后序遍历序列，再进入递归运算，返回值作为根节点的左子树；右子树区间同理</p></li><li><p>确定递归结束条件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(postorder.size()<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>)return nullprt<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>当递归到获取到空的数组时则证明递归结束</p></li><li><p>确定递归返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">buildtree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span></span><br><span class="hljs-function"></span>&#123;<br>TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder.<span class="hljs-built_in">back</span>());<br><span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> root;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回当前的结点作为根节点</p></li><li><p>确定递归单层逻辑</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">root-&gt;left = buildtree<span class="hljs-comment">(**新的中序遍历序列数组**，**新的后序遍历序列数组**)</span>;<br>root-&gt;right = buildtree<span class="hljs-comment">(**新的中序遍历序列数组**，**新的后序遍历序列数组**)</span>;<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[postorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i; i &lt; inorder.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inorder[i]==postorder[postorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(inorder.begin(),inorder.begin()+i)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp1</span><span class="hljs-params">(postorder.begin(),postorder.begin()+i)</span></span>;<br>        TreeNode* lnode = <span class="hljs-built_in">buildTree</span>(tmp,tmp1);<br>        root-&gt;left = lnode;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp2</span><span class="hljs-params">(inorder.begin()+i+<span class="hljs-number">1</span>,inorder.end())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp3</span><span class="hljs-params">(postorder.begin()+i,postorder.end()<span class="hljs-number">-1</span>)</span></span>;<br>        TreeNode* rnode = <span class="hljs-built_in">buildTree</span>(tmp2,tmp3);<br>        root-&gt;right = rnode;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>代码较为直观，容易理解，但每次递归都会产生很多新的数组，而且不必要；在寻找<code>i</code>即分割序号时，每次递归都要遍历数组来查找，浪费较多时间。因此，在代码改进上可以只传递两个原有的数组，两组新数组的边界点来达到减少内存开销；通过使用<code>hashmap</code>存储元素和下标实现对时间开销的减少</p><p>改进后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashmap;<br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> lboarder, <span class="hljs-type">int</span> rboarder)</span><span class="hljs-comment">//lboarder代表的是左子树的左边界点，rboarder代表的是右子树的右边界点</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (rboarder &lt; lboarder) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> rinb = hashmap[postorder[index]] + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> linb = hashmap[postorder[index]] - <span class="hljs-number">1</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[index--]);<br>        <span class="hljs-keyword">if</span> (rboarder == lboarder) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//分割点：hashmap[postorder[index]],为根节点</span><br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, postorder, rinb, rboarder);<br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, postorder, lboarder, linb);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        index = postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : inorder)<br>        &#123;<br>            hashmap[num] = i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代法？？？"><a href="#迭代法？？？" class="headerlink" title="迭代法？？？"></a>迭代法？？？</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* build<span class="hljs-constructor">Tree(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">inorder</span>, <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">postorder</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (postorder.size<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>            return nullptr;<br>        &#125;<br>        auto root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">postorder</span>[<span class="hljs-params">postorder</span>.<span class="hljs-params">size</span>()</span> - <span class="hljs-number">1</span>]);<br>        auto s = stack&lt;TreeNode*&gt;<span class="hljs-literal">()</span>;<br>        s.push(root);<br>        <span class="hljs-built_in">int</span> inorderIndex = inorder.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">int</span>(postorder.size<span class="hljs-literal">()</span>) - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-built_in">int</span> postorderVal = postorder<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>            auto node = s.top<span class="hljs-literal">()</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-keyword">val</span> != inorder<span class="hljs-literal">[<span class="hljs-identifier">inorderIndex</span>]</span>) &#123;<br>                node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">postorderVal</span>)</span>;<br>                s.push(node-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!s.empty<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>s.top<span class="hljs-literal">()</span>-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span>inorder<span class="hljs-literal">[<span class="hljs-identifier">inorderIndex</span>]</span>) &#123;<br>                    node = s.top<span class="hljs-literal">()</span>;<br>                    s.pop<span class="hljs-literal">()</span>;<br>                    inorderIndex--;<br>                &#125;<br>                node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">postorderVal</span>)</span>;<br>                s.push(node-&gt;left);<br>            &#125;<br>        &#125;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>递归解法中，解法思路类似于手算构造二叉树过程，但在程序当中，若要低开销的算法，又有很多的小问题小细节需要注意。通常来说，递归解法最好要另外创建一个函数，方便传递不同数量或类型的参数。在本题中，若想要传入数组的大小<code>size</code>，与另一个边界值组成一个区间的形参，如<code>(inorder,postorder,size,lboarder,rboarded)</code>，就要<strong>仔细考虑<code>lboarder</code>和<code>rboarder</code>所需要代表是哪一个边界值</strong>，如果是左子树的左边界和右子树的右边界点，那么可以得以实现；而如果是左子树的右边界和右子树的左边界，那么无法实现，因为已经知道<code>index</code>代表分割点的位置，即+1或-1就可以知道这两个边界点，<strong>两个参数实际上只是一个参数</strong>，所以无法实现，必须再传入其他的参数。因此也可以直接传入四个边界点作为形参。</p><h2 id="从先序和中序遍历序列构造二叉树"><a href="#从先序和中序遍历序列构造二叉树" class="headerlink" title="从先序和中序遍历序列构造二叉树"></a>从先序和中序遍历序列构造二叉树</h2><p>[从先序和中序遍历序列构造二叉树](<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a>)</p><h3 id="递归法-12"><a href="#递归法-12" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashmap;<br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> lboarder, <span class="hljs-type">int</span> rboarder)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[index--]);<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//分割点：hashmap[postorder[rboarder]],为根节点</span><br>        <span class="hljs-type">int</span> lsize = hashmap[postorder[rboarder]];<br>        <span class="hljs-type">int</span> rsize = size - hashmap[postorder[rboarder]] - <span class="hljs-number">1</span>;<br>        lboarder = hashmap[postorder[rboarder]] - <span class="hljs-number">1</span>;<br>        rboarder = hashmap[postorder[rboarder]] + <span class="hljs-number">1</span>;<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, postorder, rsize, rboarder, rboarder + rsize - <span class="hljs-number">1</span>);<br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, postorder, lsize, lboarder - lsize + <span class="hljs-number">1</span>, lboarder);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        index = postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : inorder)<br>        &#123;<br>            hashmap[num] = i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder, postorder.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>与上一题思路一样。但能发现，要构造出唯一的二叉树，无论是先序还是后序遍历序列，都必须要有中序遍历序列，这是因为只有中序遍历序列才能得到左右子树的分界线，仅靠先序和后序遍历根本无法得知左右子树的分区间。</p><h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><p>[最大二叉树](<a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a>)</p><h3 id="递归法-13"><a href="#递归法-13" class="headerlink" title="递归法"></a>递归法</h3><p>本题中，与构造二叉树题有些许相似，都是需要用到数组的区间来构造二叉树，但这题需要额外找到当前区间的最大值来做根节点并递归</p><ol><li><p>确定递归结束条件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">if</span>(lboarder&gt;rboarder)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>ptr;<br></code></pre></td></tr></table></figure></li><li><p>确定递归返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums,<span class="hljs-type">int</span> lboarder,<span class="hljs-type">int</span> rboarder)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> 根节点;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定递归单层逻辑</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//find_maximum并创建根节点root</span><br>root-&gt;<span class="hljs-attribute">left</span> = <span class="hljs-built_in">traversal</span>(nums,lboarder,index-<span class="hljs-number">1</span>);<br>root-&gt;<span class="hljs-attribute">right</span> = <span class="hljs-built_in">traversal</span>(nums,index+<span class="hljs-number">1</span>,rboarder);<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> root_val;<br>    <span class="hljs-built_in">int</span> find<span class="hljs-constructor">_maximum(<span class="hljs-params">const</span> <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span><span class="hljs-comment">//返回最大元素的下标值</span><br>    &#123;<br>        root_val = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> root_index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = l; i &lt;= r; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &gt; root_val)<br>            &#123;<br>                root_index = i;<br>                root_val = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>            &#125;<br>        &#125;<br>        return root_index;<br>    &#125;<br>    TreeNode* traversal(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> lboarder, <span class="hljs-built_in">int</span> rboarder)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (lboarder &gt; rboarder) return nullptr;<br>        <span class="hljs-built_in">int</span> mid = find<span class="hljs-constructor">_maximum(<span class="hljs-params">nums</span>, <span class="hljs-params">lboarder</span>, <span class="hljs-params">rboarder</span>)</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">root_val</span>)</span>;<br>        <span class="hljs-keyword">if</span> (lboarder<span class="hljs-operator"> == </span>rboarder)  return root;<br><br>        root-&gt;left = traversal(nums, lboarder, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = traversal(nums, mid + <span class="hljs-number">1</span>, rboarder);<br>        return root;<br>    &#125;<br>    TreeNode* construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.size<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">1</span>)<br>        &#123;<br>            TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">nums</span>[0])</span>;<br>            return root;<br>        &#125;<br>        return traversal(nums, <span class="hljs-number">0</span>, nums.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="单调栈special解法"><a href="#单调栈special解法" class="headerlink" title="单调栈special解法"></a><strong>单调栈special解法</strong></h3><p>针对找到当前最大值元素作为根节点，联想到单调栈实现，并根据在栈中元素关系确定左右子树</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>)</span> &#123;<br>        stack&lt;TreeNode*&gt; stk;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(-1)</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.size<span class="hljs-literal">()</span>;i++)<br>        &#123;<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">nums</span>[<span class="hljs-params">i</span>])</span>;<br>            <span class="hljs-keyword">while</span>(!stk.empty<span class="hljs-literal">()</span>&amp;&amp;nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>&gt;stk.top<span class="hljs-literal">()</span>-&gt;<span class="hljs-keyword">val</span>)<span class="hljs-comment">//栈顶有元素且比当前元素小，则栈顶元素作当前元素的左子结点</span><br>            &#123;<br>                TreeNode* cur = stk.top<span class="hljs-literal">()</span>;<br>                stk.pop<span class="hljs-literal">()</span>;<br>                node-&gt;left = cur;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(!stk.empty<span class="hljs-literal">()</span>)<span class="hljs-comment">//栈还有元素，则比当前元素大，当前元素为栈顶元素的右子结点</span><br>            &#123;<br>                stk.top<span class="hljs-literal">()</span>-&gt;right = node;<br>            &#125;<br>            stk.push(node);<br>            <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span>&lt;node-&gt;<span class="hljs-keyword">val</span>)<br>                root = node;<br>        &#125;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>在递归法中，根据构造二叉树题中的经验，创建额外的递归函数，并以左右子树区间为形参，再将遍历找到最大元素进行函数封装，避免了每次递归创建新的数组的额外开销。时间复杂度为O(n^2)，最坏情况下数组每个元素都会被遍历一次的同时寻找最大元素也会遍历一遍数组，即此时为递增或递减数组；空间复杂度最坏情况下，<code>nums</code>为递减数组或递增数组，需要递归n层，此时空间复杂度为O(n)</p><p>针对不断找到最大元素这个点，提出单调栈来优化，在元素存入单调栈的过程中，不断剔除比当前元素小的栈顶元素，并将栈顶元素作为当前元素的左子结点；遇到比当前元素大的栈顶元素，则把当前元素作为栈顶元素的右子结点。时间复杂度为O(n)，数组每个元素最多只被遍历一次；空间复杂度为O(n)，最坏情况下递减或递增数组需要大小为n的栈空间</p><h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><h3 id="递归法-14"><a href="#递归法-14" class="headerlink" title="递归法"></a>递归法</h3><p>先序遍历递归</p><ol><li><p>确定递归结束条件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">if</span>(!root1&amp;&amp;!root2)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>ptr;<br></code></pre></td></tr></table></figure></li><li><p>确定递归返回值</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">TreeNode</span><span class="hljs-operator">*</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">TreeNode</span>* <span class="hljs-params">root1</span>,<span class="hljs-params">TreeNode</span>* <span class="hljs-params">root2</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable">root1</span>;<span class="hljs-comment">//直接在root1上操作，避免新建树产生的额外开销</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定递归单层逻辑</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">root1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> += root2-&gt;</span>val;<br><span class="hljs-function"><span class="hljs-title">root1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = mergeTrees(root1-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>, root2-&gt;</span>left);<br><span class="hljs-function"><span class="hljs-title">root1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = mergeTrees(root1-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>, root2-&gt;</span>right);<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;<br>        <span class="hljs-keyword">if</span> (!root1 &amp;&amp; !root2)  return nullptr;<br>        <span class="hljs-keyword">if</span> (root1 &amp;&amp; !root2) return root1;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root1 &amp;&amp; root2)  return root2;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-function"><span class="hljs-title">root1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> += root2-&gt;</span>val;<span class="hljs-comment">//中</span><br>        <span class="hljs-function"><span class="hljs-title">root1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = mergeTrees(root1-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>, root2-&gt;</span>left);  <span class="hljs-comment">//左</span><br>        <span class="hljs-function"><span class="hljs-title">root1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = mergeTrees(root1-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>, root2-&gt;</span>right);  <span class="hljs-comment">//右</span><br>        return root1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于中间结点的处理语句，只要更改相对于左右结点处理语句的顺序，就可以实现不同顺序递归遍历二叉树，而不对结果造成影响</p><h3 id="迭代法-9"><a href="#迭代法-9" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;<br>        <span class="hljs-keyword">if</span>(!root1)  return root2;<br>        <span class="hljs-keyword">if</span>(!root2)  return root1;<br>        queue&lt;TreeNode*&gt; que;<br>        que.push(root1);<br>        que.push(root2);<br>        <span class="hljs-keyword">while</span>(!que.empty())<br>        &#123;<br>            TreeNode* node1 = que.front();<br>            que.pop();<br>            TreeNode* node2 = que.front();<br>            que.pop();<br>            <span class="hljs-function"><span class="hljs-title">node1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> += node2-&gt;</span>val;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(node1-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>&amp;&amp;node2-&gt;</span>left)<br>            &#123;<br>                <span class="hljs-function"><span class="hljs-title">que</span>.push(node1-&gt;</span>left);<br>                <span class="hljs-function"><span class="hljs-title">que</span>.push(node2-&gt;</span>left);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(node1-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>&amp;&amp;node2-&gt;</span>right)<br>            &#123;<br>                <span class="hljs-function"><span class="hljs-title">que</span>.push(node1-&gt;</span>right);<br>                <span class="hljs-function"><span class="hljs-title">que</span>.push(node2-&gt;</span>right);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(!node1-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>&amp;&amp;node2-&gt;</span>left)<br>                <span class="hljs-function"><span class="hljs-title">node1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = node2-&gt;</span>left;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(!node1-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>&amp;&amp;node2-&gt;</span>right)<br>                <span class="hljs-function"><span class="hljs-title">node1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = node2-&gt;</span>right;<br>        &#125;<br>        return root1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="指针法？？？"><a href="#指针法？？？" class="headerlink" title="指针法？？？"></a>指针法？？？</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>public:<br>    <span class="hljs-literal">void</span> process(TreeNode** t1, TreeNode** t2) &#123;<br>        <span class="hljs-keyword">if</span> ((*t1) == NULL &amp;&amp; (*t2) == NULL) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> ((*t1) != NULL &amp;&amp; (*t2) != NULL) &#123;<br>            <span class="hljs-function"><span class="hljs-params">(*t1)</span>-&gt;</span>val += <span class="hljs-function"><span class="hljs-params">(*t2)</span>-&gt;</span>val;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((*t1) == NULL &amp;&amp; (*t2) != NULL) &#123;<br>            *t1 = *t2;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((*t1) != NULL &amp;&amp; (*t2) == NULL) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        process<span class="hljs-function"><span class="hljs-params">(&amp;((*t1)-&gt;left), &amp;((*t2)-&gt;left))</span>;</span><br><span class="hljs-function">        <span class="hljs-title">process</span><span class="hljs-params">(&amp;((*t1)-&gt;right), &amp;((*t2)-&gt;right))</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">    <span class="hljs-title">TreeNode</span>* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">process</span><span class="hljs-params">(&amp;t1, &amp;t2)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">t1</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;;</span><br></code></pre></td></tr></table></figure><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>这道题提醒了同时在处理两颗二叉树时的操作，类似于对称二叉树，考虑的需要更加复杂。</p><h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><p>[二叉搜索树中的搜索](<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a>)</p><p>根据二叉搜索树的特性，左子结点值小于根节点值小于右子结点值，通过判断当前结点的值与所要求的值的大小，快速找到所要求的值的方向，可以有递归法和迭代法实现</p><h3 id="递归法-15"><a href="#递归法-15" class="headerlink" title="递归法"></a>递归法</h3><ol><li><p>确定递归结束条件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>prt;<br></code></pre></td></tr></table></figure></li><li><p>确定递归返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">TreeNode* searchBST(TreeNode* root,int <span class="hljs-keyword">val</span>)<br><span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span>==<span class="hljs-keyword">val</span>)<span class="hljs-keyword">return</span> root;<br><span class="hljs-keyword">return</span> nullptr;<br></code></pre></td></tr></table></figure></li><li><p>确定递归单层逻辑</p></li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &gt; <span class="hljs-keyword">val</span>) search<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">val</span>)</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &lt; <span class="hljs-keyword">val</span>)search<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">val</span>)</span>;<br><span class="hljs-keyword">else</span>return root;<br></code></pre></td></tr></table></figure><p>整体代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* search<span class="hljs-constructor">BST(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!root)   return nullptr;<br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span>==<span class="hljs-keyword">val</span>)  return root;<br>        return root-&gt;<span class="hljs-keyword">val</span> &gt; <span class="hljs-keyword">val</span>? search<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>,<span class="hljs-params">val</span>)</span>: search<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>,<span class="hljs-params">val</span>)</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代法-10"><a href="#迭代法-10" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    TreeNode* searchBST(TreeNode* root, int val) &#123;<br>    TreeNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= root</span>;<br>    while(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">    &#123;</span><br><span class="hljs-title">if</span>(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>)return <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">if</span>(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span> &gt; <span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">node</span> = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>;<br>else if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span> <span class="hljs-tag">&lt; node)</span><br><span class="hljs-tag">node = node-&gt;</span>right;<br>&#125;<br>return nullptr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>根据二叉搜索树的特性，能够极大地简化了代码的复杂程度。在递归法中，由于二叉搜索树有方向性，从而不用考虑是否需要回溯，如平衡二叉树和路径之和题；在迭代法中，二叉搜索树则不需要借助栈或者队列完成对二叉树的遍历，也是因为其特有的方向性。</p><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>[验证二叉搜索树](<a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a>)</p><h3 id="递归法-16"><a href="#递归法-16" class="headerlink" title="递归法"></a>递归法</h3><p>对于本题，先想到验证二叉搜索树的方法是 左子结点的值小于根节点的值小于右子结点的值，再对整棵二叉树进行该过程的递归遍历。但这就掉入一个坑中，因为二叉搜索树不仅需要当前的左右子结点与根节点符合规律，还要整棵左右子树都要符合规律，即根节点的左子树上的所有结点都要比根节点要小，同理右子树也是，但这种方法显然无法满足。</p><p>因此，借助于中序遍历，若一棵二叉树时二叉搜索树，则中序遍历序列为递增的序列，只要通过一个变量记录最大值，并递归检查当前结点的值是否要比最大值要大，就可以判断是否为二叉搜索树。另外，这个变量为了符合数据大小的要求，结点最小值为INT_MIN，则可以将该变量设为LONG_MIN；或者可以设为前一个结点pre</p><ol><li><p>确定递归结束条件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>当前结点为空时，也为二叉搜索树，返回true</p></li><li><p>确定递归返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tmp = LONG_MIN;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> lflag = <span class="hljs-literal">true</span>,rflag = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">return</span> lflag&amp;&amp;rflag;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定递归单层逻辑</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">lflag</span> <span class="hljs-operator">=</span> isValidBST(root-&gt;left)<span class="hljs-comment">;</span><br>if(tmp &gt;<span class="hljs-operator">=</span> root-&gt;val)return false<span class="hljs-comment">;</span><br><span class="hljs-attribute">rflag</span> <span class="hljs-operator">=</span> isValidBST(root-&gt;right)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下（使用<code>long long</code>变量）</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxi = LONG_MIN;<br>    <span class="hljs-keyword">bool</span> isValidBST(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">bool</span> lflag = <span class="hljs-keyword">true</span>, rflag = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left)  lflag = isValidBST(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; maxi)    <br>            maxi = root-&gt;val;<br>        <span class="hljs-keyword">else</span>    <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;right) rflag = isValidBST(root-&gt;right);<br>        <span class="hljs-keyword">return</span> lflag&amp;&amp;rflag;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>（使用前一个结点变量）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>TreeNode* pre = nullptr;<br>    <span class="hljs-built_in">bool</span> is<span class="hljs-constructor">ValidBST(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!root)   return <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">bool</span> lflag = <span class="hljs-literal">true</span>, rflag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left)  lflag = is<span class="hljs-constructor">ValidBST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>)</span>;<br>        <span class="hljs-keyword">if</span>(!pre<span class="hljs-pattern-match"><span class="hljs-operator">||</span>pre-&gt;<span class="hljs-keyword">val</span> &lt; root-&gt;<span class="hljs-keyword">val</span>)</span><br><span class="hljs-pattern-match">            pre = root;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">            return <span class="hljs-literal">false</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span>(root-&gt;right) rflag = is<span class="hljs-constructor">ValidBST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>)</span>;</span><br><span class="hljs-pattern-match">        return lflag<span class="hljs-operator">&amp;&amp;</span>rflag;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;;</span><br></code></pre></td></tr></table></figure><h3 id="迭代法-11"><a href="#迭代法-11" class="headerlink" title="迭代法"></a>迭代法</h3><p>使用中序迭代遍历法，只需稍微修改即可,对应地，迭代法也可以用一个long long变量或者前一个结点来存储最大值，下面只给出long long变量。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    bool isValidBST(TreeNode* root) &#123;<br>        if(!root)   return <span class="hljs-literal">true</span>;<br>        stack<span class="hljs-tag">&lt;TreeNode*&gt;</span> stk;<br>        TreeNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= root</span>;<br>        long long tmp = LONG_MIN;<br>        while(!stk.empty()||<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        &#123;</span><br><span class="hljs-title">            if</span>(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">            &#123;</span><br><span class="hljs-title">                stk</span>.push(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">                node</span>=<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>;<br>            &#125;<br>            else<br>            &#123;<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= stk</span>.top();<br>                stk.pop();<br>                if(tmp &gt;= <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>)<br>                    return <span class="hljs-literal">false</span>;<br>                tmp = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>;<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= node-</span>&gt;right;<br>            &#125;<br>        &#125;<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>为了验证一棵二叉搜索树，要将其当成一棵普通二叉树来看待，就不能利用二叉搜索树的特性。在判断时，需要注意<strong>左子树小于根节点小于右子树</strong>，而不只是单单的左子结点小于根节点小于右子结点，再结合中序遍历，可以利用严格单调有序性来判断一棵树是否为二叉搜索树，这时就要用到一个变量来记录当前下的最大结点值，结合所给定数据范围，可以将这个变量设为LONG_MIN来完成所有INT数据的测试；但如果测试数据中<strong>出现了LONG型数据</strong>，那可以将这个变量设为一个<strong>树的结点类型</strong>，用于存储前一个结点，这就不用考虑数据的类型和大小范围。</p><p>对于迭代法，则是基于中序迭代遍历模板的改变版，同样也有两种不同类型变量。两种方法的时间复杂度和空间复杂度都是O(n)，最坏情况下是一条链。</p><h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><p>[二叉搜索树的最小绝对差](<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a>)</p><h3 id="递归法-17"><a href="#递归法-17" class="headerlink" title="递归法"></a>递归法</h3><p>根据题意，因为是<strong>任意两个结点的差</strong>，依旧可以使用中序遍历的方法对二叉树进行遍历，且因为中序遍历序列严格单调递增，则可以通过对相邻两个结点的值进行判断来获取最小绝对差。此外，该题中，既可以先用数组存储所有结点的值，再遍历一次数组进行判断；也可以通过一个结点变量，记录前一个结点的值，从而在遍历二叉树过程中就完成对绝对差的记录</p><p>中序递归遍历+转换成数组计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-type">int</span> ans = INT_MAX;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left)  <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i,j;i&lt;res.<span class="hljs-built_in">size</span>();i++,j++)<br>        &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">abs</span>(res[i]-res[j]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>记录前一个结点与当前结点进行判断</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>    int res = INT_MAX;<br>    int pre = -<span class="hljs-number">1</span>,cur = -<span class="hljs-number">1</span>;<br>    int getMinimumDifference(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span> (!root)   return <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (root-&gt;</span>left)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">cur</span> = root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>val;<br>            <span class="hljs-function"><span class="hljs-title">getMinimumDifference</span>(root-&gt;</span>left);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">cur</span> = root-&gt;</span>val;<br>        <span class="hljs-comment">//if(pre!=-1)即可</span><br>        <span class="hljs-keyword">if</span> (pre!=-<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">abs</span>(cur - pre))<br>            res = min(<span class="hljs-built_in">abs</span>(cur - pre), res);<br>        pre = cur;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (root-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>) getMinimumDifference(root-&gt;</span>right);<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然，在以上的程序中，也可以沿用上题中的两种方式，一种是用一个整型变量来记录前一个结点的值（如上）；另一种是用一个<code>TreeNode*</code>变量来记录前一个结点。后者只需要在更新res时将判断条件修改为<code>if(pre)</code>本质上都是一样</p><h3 id="迭代法-12"><a href="#迭代法-12" class="headerlink" title="迭代法"></a>迭代法</h3><p>依旧使用中序遍历迭代法，基于模板上修改</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    int getMinimumDifference(TreeNode* root) &#123;<br>        stack<span class="hljs-tag">&lt;TreeNode*&gt;</span> stk;<br>        vector<span class="hljs-tag">&lt;int&gt;</span> res;<br>        int ans = INT_MAX;<br>        TreeNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= root</span>;<br>        while(!stk.empty()||<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        &#123;</span><br><span class="hljs-title">            if</span>(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">            &#123;</span><br><span class="hljs-title">                stk</span>.push(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">                node</span> = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>;<br>            &#125;<br>            else<br>            &#123;<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= stk</span>.top();<br>                stk.pop();<br>                res.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= node-</span>&gt;right;<br>            &#125;<br>        &#125;<br>        for(int i=<span class="hljs-number">0</span>,j=<span class="hljs-number">1</span>;j<span class="hljs-tag">&lt;res.size();++j,++i)</span><br><span class="hljs-tag">        &#123;</span><br><span class="hljs-tag">            ans = min(ans,abs(res[i]-res[j]));</span><br><span class="hljs-tag">        &#125;</span><br><span class="hljs-tag">        return ans;</span><br><span class="hljs-tag">    &#125;</span><br><span class="hljs-tag">&#125;;</span><br></code></pre></td></tr></table></figure><p>同样，迭代法中也可以不用新建一个数组，最后再遍历一次数组得到答案，也是设定前一个结点，可以是整型变量存结点的值，也可以直接存一个结点来实现</p><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>本题与上一题验证二叉搜索树的遍历思路一致，只是上题判断前后两者大小关系，本题计算前后两者大小并取最小值</p><h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p>[二叉搜索树中的众数](<a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a>)</p><p>从寻找众数角度出发，通常需要借助一个数组或哈希表等来存储元的值以及对应的出现次数，先遍历一遍二叉树得到存储整棵树的数组或哈希表，再将数组或哈希表进行排序，取出排序最大的一个或多个元素，存入到结果当中。而这就需要O(N)的时间复杂度，最坏情况下所有元素都只出现一次，时间复杂度是O(2N)，空间复杂度也会很大。</p><p>上述方法仅对一般的二叉树，但在本题中是一颗二叉搜索树，也就是说是一棵已经排好序的二叉树，相同的值的结点都是邻接在一起的，因此，仅需要一次遍历，通过pre指针指向上一个结点，与当前结点比较，并统计相同值结点的个数，就能找出其众数</p><h3 id="递归法-18"><a href="#递归法-18" class="headerlink" title="递归法"></a>递归法</h3><ol><li><p>确定递归结束条件</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">if(!<span class="hljs-keyword">node</span><span class="hljs-title">)return</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定递归返回值</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">int times = <span class="hljs-number">0</span>, ttimes = <span class="hljs-number">0</span>;<br>vector<span class="hljs-tag">&lt;int&gt;</span> res;<br>TreeNode* pre = nullptr;<br>void dfs(TreeNode* <span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">&#123;</span><br><span class="hljs-title">dfs</span>(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);<br>//根结点<br>dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定递归单层逻辑</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">if (pre &amp;&amp; pre-&gt;val != <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>)<br>&#123;<br>    ttimes = <span class="hljs-number">0</span>;<br>&#125;<br>if (pre &amp;&amp; pre-&gt;val == <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>)<br>&#123;<br>    ++ttimes;<br>&#125;<br>if (ttimes == times)<br>&#123;<br>    res.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>&#125;<br>if (ttimes &gt; times)<br>&#123;<br>    times = ttimes;<br>    res.clear();<br>    res.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    vector<span class="hljs-tag">&lt;int&gt;</span> res;<br>    TreeNode* pre = nullptr;<br>    int times = <span class="hljs-number">0</span>;<br>    int ttimes = <span class="hljs-number">0</span>;<br>    void dfs(TreeNode* <span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">    &#123;</span><br><span class="hljs-title">        if</span> (!<span class="hljs-keyword">node</span><span class="hljs-title">)   return</span>;<br>        dfs(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);<br>        if (pre &amp;&amp; <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span> != pre-&gt;val)<br>        &#123;<br>            ttimes = <span class="hljs-number">0</span>;<br>        &#125;<br>        if (pre &amp;&amp; pre-&gt;val == <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>)<br>        &#123;<br>            ++ttimes;<br>        &#125;<br>        if (ttimes == times)<br>        &#123;<br>            res.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>        &#125;<br>        if (ttimes &gt; times)<br>        &#123;<br>            res.clear();<br>            times = ttimes;<br>            res.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>        &#125;<br>        pre = <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">        dfs</span>(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);<br>    &#125;<br>    vector<span class="hljs-tag">&lt;int&gt;</span> findMode(TreeNode* root) &#123;<br>        dfs(root);<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代法-13"><a href="#迭代法-13" class="headerlink" title="迭代法"></a>迭代法</h3><p>同样地，用中序迭代遍历法，而处理根结点代码与递归法中的一样</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    vector<span class="hljs-tag">&lt;int&gt;</span> findMode(TreeNode* root) &#123;<br>        stack<span class="hljs-tag">&lt;TreeNode*&gt;</span> stk;<br>        vector<span class="hljs-tag">&lt;int&gt;</span> res;<br>        TreeNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= root</span>;<br>        TreeNode* pre = nullptr;<br>        int times = <span class="hljs-number">0</span>, ttimes = <span class="hljs-number">0</span>;<br>        while(!stk.empty()||<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        &#123;</span><br><span class="hljs-title">            if</span>(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">            &#123;</span><br><span class="hljs-title">                stk</span>.push(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">                node</span> = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>;<br>            &#125;<br>            else<br>            &#123;<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= stk</span>.top();<br>                stk.pop();<br>                if(pre&amp;&amp;pre-&gt;val!=<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>)<br>                &#123;<br>                    ttimes = <span class="hljs-number">0</span>;<br>                &#125;<br>                if(pre&amp;&amp;pre-&gt;val == <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>)<br>                &#123;<br>                    ++ttimes;<br>                &#125;<br>                if(<span class="hljs-attr">ttimes=</span>=times)<br>                &#123;<br>                    res.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>                &#125;<br>                if(ttimes&gt;times)<br>                &#123;<br>                    times = ttimes;<br>                    res.clear();<br>                    res.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>                &#125;<br>                pre = <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">                node</span> = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>;<br>            &#125;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p>对本题而言，依旧是对<strong>pre指针和cur指针</strong>的同时运用，这一点上与前两题都一致，不同的是本题还需要对pre和cur指向的结点的值出现次数进行统计，而在统计这里提出针对一般情况和针对二叉搜索树的不同解法，一般情况下借助于特殊的数据结构来对元素的值及其出现次数进行统计，但在二叉搜索树下则不用，因为其本身就已经是排序好的。若是针对一般情况下，有其他数据结构支撑的，可以选取任意的遍历顺序，但针对二叉搜索树时，为了运用到它的有序性，通常都会用中序遍历，也只有中序遍历序列是有序的。在迭代法中，无非就是在处理根结点的代码上将递归法的代码照搬过来，套用在模板上。</p><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><strong>二叉树的最近公共祖先</strong></h2><p>[二叉树的最近公共祖先](<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a>)</p><p>最近公共祖先可简化成两种情况，一种是直接找到除要寻找的两结点之外的第三结点作为两结点的公共祖先，即要返回该第三结点作为结果；另一种则是其中一个结点是另一结点的祖先，则返回该结点作为结果即可。</p><h3 id="递归法-19"><a href="#递归法-19" class="headerlink" title="递归法"></a>递归法</h3><p>根据题意，这题可以用到回溯法，由于后续遍历本身就是回溯（左右中），可以先判断左右子树是否有包含要找的结点，再来判断当前结点是否是公共祖先。同时，这也是一种由底至顶的方法。</p><ol><li><p>确定递归结束条件</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> nullptr;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-string">q||</span>root==p) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></table></figure></li><li><p>确定递归返回值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">TreeNode* lowest<span class="hljs-constructor">CommonAncestor(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">p</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">q</span>)</span><br>&#123;<br>return nullptr;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>当当前结点即为要寻找的结点时，即可直接返回当前结点，向上回溯；如果没有找到，则返回空结点</p><ol start="3"><li><p>确定递归单层逻辑</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">TreeNode* ltree = lowest<span class="hljs-constructor">CommonAncestor(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>,<span class="hljs-params">p</span>,<span class="hljs-params">q</span>)</span>;<span class="hljs-comment">//左</span><br>TreeNode* rtree = lowest<span class="hljs-constructor">CommonAncestor(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>,<span class="hljs-params">p</span>,<span class="hljs-params">q</span>)</span>;<span class="hljs-comment">//右</span><br><span class="hljs-keyword">if</span>(ltree&amp;&amp;rtree)return root;  <span class="hljs-comment">//中</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!ltree&amp;&amp;rtree)return rtree;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ltree&amp;&amp;rtree)return ltree;<br>return nullptr;<br></code></pre></td></tr></table></figure><p>如果当前的根节点的左子结点和右子结点的返回值不为空（返回值为p和q），则证明当前的根节点就是他们的公共祖先，直接返回根节点；如果当前结点的左子结点为空，但右子结点不为空，则证明p或q在右子结点，直接返回右子结点；右子结点为空同理；最后，都没有找到则证明p和q都不在当前结点的子树下，返回空结点</p></li></ol><p>整体代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> NULL;<br>        <span class="hljs-keyword">if</span>(root==p||root==q)    <span class="hljs-keyword">return</span> root;<br>        TreeNode* ltree = lowestCommonAncestor(root-&gt;left,p,q);<br>        TreeNode* rtree = lowestCommonAncestor(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>(ltree&amp;&amp;rtree) <br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ltree&amp;&amp;!rtree) <br>            <span class="hljs-keyword">return</span> ltree;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!ltree&amp;&amp;rtree)<br>            <span class="hljs-keyword">return</span> rtree;<br>        <span class="hljs-keyword">return</span> NULL;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="递归hashmap查表法"><a href="#递归hashmap查表法" class="headerlink" title="递归hashmap查表法"></a>递归<code>hashmap</code>查表法</h3><p>不边递归回溯边记录判断，则需要独立遍历一次二叉树，借助<code>unordered_map&lt;int,TreeNode*&gt; fanode</code>进行父结点的记录，再将p或q通过<code>fanode</code>向上查询父结点，借助另一个<code>unordered_map&lt;int,bool&gt; cmp</code>进行有无相同父结点的判断</p><p>整体代码如下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>unordered_map&lt;int,TreeNode*&gt; fanode;<br>unordered_map&lt;int,bool&gt; cmp;<br>    void dfs(TreeNode* root)<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>left)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">fanode</span>[root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>val] = root;<br>            <span class="hljs-function"><span class="hljs-title">dfs</span>(root-&gt;</span>left);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>right)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">fanode</span>[root-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>val] = root;<br>            <span class="hljs-function"><span class="hljs-title">dfs</span>(root-&gt;</span>right);<br>        &#125;<br>    &#125;<br>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-function"><span class="hljs-title">fanode</span>[root-&gt;</span>val] = NULL;<br>        dfs(root);<br>        <span class="hljs-keyword">while</span>(p)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">cmp</span>[p-&gt;</span>val]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-function"><span class="hljs-title">p</span>=fanode[p-&gt;</span>val];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(cmp[q-&gt;</span>val])<br>                return q;<br>            <span class="hljs-function"><span class="hljs-title">q</span> = fanode[q-&gt;</span>val];<br>        &#125;<br>        return NULL;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>遍历每个结点获取对应父结点需要时间O(n)，在向上寻找p、q共同父结点时，遍历的结点数不会超过n，最坏情况下是树单独成链，总的时间复杂度是O(n)，且接近O(2n)；对于递归遍历每个结点所占用的递归栈空间最坏情况下为O(n)，而储存n个结点的哈希表空间复杂度也为O(n)，因此总的空间复杂度为O(3n)，性能与第一种解法无量级上的差异但比第一种解法要差</p><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p>通用解法是在递归的过程中直接记录和处理，这就省去了额外的时间和空间开销。在处理最近公共祖先问题上，最先想到应该由底至顶的遍历二叉树，即回溯，而后序遍历又是天生的回溯顺序。这一点上与相同用到回溯法的平衡二叉树题一致，都用到后序遍历；但在有关二叉树路径题中，因为递归的过程需要先处理根结点，所以用的是先序遍历回溯。</p><p>回溯递归使用先序遍历中，通过成员变量快速判断有无符合条件的情况发生，可以直接向上回溯，如路径之和；而使用后序遍历，都要先遍历完所有的结点，因为要用到处理结点后的返回值，先进入递归才能再判断有无发生，如由底至顶的平衡二叉树。</p><p><code>if(root==q||root==p)return root;</code>这是对结束条件的补充，为的是遇到想要查找的结点时及时返回，获取返回值，并且不必继续做无谓的遍历直至叶子结点</p><p>递归法中对于情况二的处理，只分开根结点的左、右子树作为查找对象，即在一个子树上只寻找一个目标结点，（情况二则是两个目标结点都在一个子树上，且以其中一个结点作为公共祖先返回结果），因此一旦找寻到其中一个结点，即可直接返回该结点，也正是目标结点的公共祖先。</p><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><strong>二叉搜索树的最近公共祖先</strong></h2><p>[二叉搜索树的最近公共祖先](<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a>)</p><h3 id="递归法-20"><a href="#递归法-20" class="headerlink" title="递归法"></a>递归法</h3><p>明显这道题与上题相比，需要用到二叉搜索树的特性，即有序性。</p><p>因为是要寻找公共祖先，是由底至顶的查找，所以要用后序遍历，同时符合了回溯的要求。</p><ol><li><p>确定递归结束条件</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">!root</span>)<span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br></code></pre></td></tr></table></figure><p>也可以不写，因为题目保证了能够找得到公共祖先</p></li><li><p>确定递归返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* lflag = <span class="hljs-literal">NULL</span>,*rflag = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root,TreeNode* p,TreeNode* q)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(lflag||rflag)<span class="hljs-keyword">return</span> lflag==<span class="hljs-literal">NULL</span>?rflag:lflag;<br><span class="hljs-keyword">return</span> root;<span class="hljs-comment">//中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果找到p或q则返回当前结点；如果<code>lflag</code>或<code>rflag</code>被赋值，证明找到p或者q，则返回被赋值的那个<code>flag</code></p></li><li><p>确定递归单层逻辑</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">if</span>(q-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &amp;&amp; p-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; root-&gt;</span>val)<br><span class="hljs-function"><span class="hljs-title">lflag</span> = lowestCommonAncestor(root-&gt;</span>left,p,q);<span class="hljs-comment">//左</span><br><span class="hljs-function"><span class="hljs-title">if</span>(q-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &gt; root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &amp;&amp; q-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &gt; root-&gt;</span>val)<br><span class="hljs-function"><span class="hljs-title">rflag</span> = lowestCommonAncestor(root-&gt;</span>right,p,q);<span class="hljs-comment">//右</span><br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>TreeNode* lflag=NULL, *rflag=NULL;<br>    TreeNode* lowest<span class="hljs-constructor">CommonAncestor(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">p</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">q</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!root)   return root;<br>        <span class="hljs-keyword">if</span>(p-&gt;<span class="hljs-keyword">val</span> &lt; root-&gt;<span class="hljs-keyword">val</span>&amp;&amp;q-&gt;<span class="hljs-keyword">val</span> &lt; root-&gt;<span class="hljs-keyword">val</span>)<br>        &#123;<br>            rflag = lowest<span class="hljs-constructor">CommonAncestor(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>,<span class="hljs-params">p</span>,<span class="hljs-params">q</span>)</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;<span class="hljs-keyword">val</span> &gt; root-&gt;<span class="hljs-keyword">val</span>&amp;&amp;q-&gt;<span class="hljs-keyword">val</span> &gt; root-&gt;<span class="hljs-keyword">val</span>)<br>        &#123;<br>            lflag = lowest<span class="hljs-constructor">CommonAncestor(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>,<span class="hljs-params">p</span>,<span class="hljs-params">q</span>)</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(lflag<span class="hljs-pattern-match"><span class="hljs-operator">||</span>rflag)    return lflag<span class="hljs-operator">==</span><span class="hljs-constructor">NULL</span>?rflag:lflag;</span><br><span class="hljs-pattern-match">        return root;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;;</span><br></code></pre></td></tr></table></figure><h3 id="迭代法-14"><a href="#迭代法-14" class="headerlink" title="迭代法"></a>迭代法</h3><p>在上述递归的过程中，其实就是迭代的过程</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        TreeNode* res = root;<br>        <span class="hljs-keyword">while</span>(res)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(res-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &gt; p-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span>&amp;&amp;res-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &gt; q-&gt;</span>val)<br>                <span class="hljs-function"><span class="hljs-title">res</span> = res-&gt;</span>left;<br>            <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(res-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; p-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span>&amp;&amp;res-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; q-&gt;</span>val)<br>                <span class="hljs-function"><span class="hljs-title">res</span> = res-&gt;</span>right;<br>            <span class="hljs-keyword">else</span><br>                return res;<br>        &#125;<br>        return NULL;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p>在递归法中，首先，当<code>q-&gt;val &lt; root-&gt;val &amp;&amp; p-&gt;val &gt; root-&gt;val</code>或者<code>q-&gt;val &gt;  root-&gt;val &amp;&amp; p-&gt;val &lt; root-&gt;val</code>，换句话说，当当前结点值处于p和q值的区间内，那么当前结点就一定是p和q的最近公共祖先（有序性）。其次，因为是一定能够找到公共祖先，所以单层逻辑中对中间结点的处理就是递归的返回值——直接返回当前结点（即公共祖先），这也是递归的最深一层。</p><p>相对于普通的二叉树，在寻找二叉搜索树的最近公共祖先时，可以更加的有方向性去寻找所要的结点，不需要遍历所有结点，而当找到所要找的结点时，由于没有多余遍历其他结点，也就不会遇到返回值为空的结点，对有返回值的结点处理也更加简洁（只在lflag或rflag中，直接返回结果就行），<strong>因此实际上并没使用到回溯</strong>。因为没有遍历所有结点，空间复杂度为O(1)</p><p>同样地，二叉搜索树的最近公共祖先也有两种情况，一种是直接找到除要寻找的两结点之外的第三结点作为两结点的公共祖先，即要返回该第三结点作为结果；另一种则是其中一个结点是另一结点的祖先，则返回该结点作为结果即可。对于第二种情况，只要不满足p和q结点值同时大于或者小于当前结点的值，就直接返回当前结点，而当前结点也正是它们的共同祖先（其中一个结点本身）</p><p>另外，该题也可以用普通二叉树的最近公共祖先两种做法</p><h2 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h2><p>[二叉搜索树中的插入操作](<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a>)</p><h3 id="递归法-21"><a href="#递归法-21" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* insert<span class="hljs-constructor">IntoBST(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!root)   <br>            return <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">val</span>)</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span> &lt; root-&gt;<span class="hljs-keyword">val</span>)<br>            root-&gt;left = insert<span class="hljs-constructor">IntoBST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>,<span class="hljs-params">val</span>)</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span> &gt; root-&gt;<span class="hljs-keyword">val</span>)<br>            root-&gt;right = insert<span class="hljs-constructor">IntoBST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>,<span class="hljs-params">val</span>)</span>;<br>        return  root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代法-15"><a href="#迭代法-15" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;<br>        TreeNode* newnode = new TreeNode(val);<br>        TreeNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= root</span>;<br>        if(!<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        &#123;</span><br><span class="hljs-title">            return</span> newnode;<br>        &#125;<br>        while(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        &#123;</span><br><span class="hljs-title">            if</span>(val <span class="hljs-tag">&lt; node-&gt;</span>val&amp;&amp;<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>)<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= node-</span>&gt;left;<br>            else if(val &gt; <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>&amp;&amp;<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= node-</span>&gt;right;<br>            else if(val <span class="hljs-tag">&lt; node-&gt;</span>val&amp;&amp;!<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>)<br>            &#123;<br>                <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span> = newnode;<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= newnode-</span>&gt;left;<br>            &#125;<br>            else if(val &gt; <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>&amp;&amp;!<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)<br>            &#123;<br>                <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span> = newnode;<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= newnode-</span>&gt;right;<br>            &#125;<br>        &#125;<br>        return root;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p>本题还有重新构建二叉搜索树的方法，但在本解法中只做了直接向二叉搜索树添加新结点的做法，并没有手算向二叉搜索树插入操作的代码实现方法</p><h2 id="删除二叉搜索树中的结点"><a href="#删除二叉搜索树中的结点" class="headerlink" title="删除二叉搜索树中的结点"></a><strong>删除二叉搜索树中的结点</strong></h2><p>[删除二叉搜索树中的结点](<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a>)</p><h3 id="对回溯法的理解"><a href="#对回溯法的理解" class="headerlink" title="对回溯法的理解"></a>对回溯法的理解</h3><p>首先，要做的第一步是 找到要删除结点的父结点，利用递归回溯的思想，借助栈保存当前访问结点的父结点，一旦确定当前结点是要删除的结点，则栈顶元素就是其父结点。因为要找根结点，因此选择了先序递归遍历。但缺点在于无论什么时候找到要目标结点，都会遍历整棵二叉树</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> find<span class="hljs-constructor">_fa_dfs(<span class="hljs-params">int</span> <span class="hljs-params">key</span>, <span class="hljs-params">stack</span>&lt;TreeNode<span class="hljs-operator">*</span>&gt; &amp; <span class="hljs-params">stk</span>)</span><br>&#123;<br>    TreeNode* tmp = stk.top<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (tmp-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span>key)<br>    &#123;<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tmp-&gt;left)<br>    &#123;<br>        stk.push(tmp-&gt;left);<br>        <span class="hljs-keyword">if</span> (find<span class="hljs-constructor">_fa_dfs( <span class="hljs-params">key</span>, <span class="hljs-params">stk</span>)</span>)<br>            fa = tmp;<br>        stk.pop<span class="hljs-literal">()</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tmp-&gt;right)<br>    &#123;<br>        stk.push(tmp-&gt;right);<br>        <span class="hljs-keyword">if</span> (find<span class="hljs-constructor">_fa_dfs( <span class="hljs-params">key</span>, <span class="hljs-params">stk</span>)</span>)<br>            fa = tmp;<br>        stk.pop<span class="hljs-literal">()</span>;<br>    &#125;<br>    return <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于代码中的改进点，要求当找到目标结点后要及时返回或结束递归，可加上一个判断，<code>if(fa!=nullptr)return false;</code>当找到了目标结点，<code>fa</code>结点就会被修改，因此对于遍历中不在回溯路径上的后续结点，当进入递归时就会直接返回。但如果目标结点是根结点<code>fa=nullptr</code>，则无效，依旧会遍历整棵二叉树。</p><p>另外，题中这是一颗二叉搜索树，则可以利用其特性快速找到目标结点及其父结点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">TreeNode* fa = nullptr;<br>void find_fa_dfs(TreeNode* <span class="hljs-keyword">node</span><span class="hljs-title">,int</span> key)<br>&#123;<br>    TreeNode* lnode = nullptr, * rnode = nullptr;<br>    if (!<span class="hljs-keyword">node</span><span class="hljs-title">)   return</span>;<br>    if (<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span> <span class="hljs-tag">&lt; key)</span><br><span class="hljs-tag">    &#123;</span><br><span class="hljs-tag">        fa = node;</span><br><span class="hljs-tag">        find_fa_dfs(node-&gt;</span>right, key);<br>    &#125;<br>    else if (<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span> &gt; key)<br>    &#123;<br>        fa = <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">        find_fa_dfs</span>(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>, key);<br>    &#125;<br>    else<br>        return;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归法-22"><a href="#递归法-22" class="headerlink" title="递归法"></a>递归法</h3><ol><li><p>确定递归结束条件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>ptr;<br></code></pre></td></tr></table></figure></li><li><p>确定递归返回值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">TreeNode* delete<span class="hljs-constructor">Node(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>,<span class="hljs-params">int</span> <span class="hljs-params">key</span>)</span><br>&#123;<br><br>return root;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定单层逻辑</p><p>在本题中，关键在于对不同情况的分类讨论</p><ul><li>当前结点为空，直接返回空结点</li><li>当前结点值比key大，递归进入当前结点的左子结点</li><li>当前结点值比key小，递归进入当前结点的右子结点</li><li>当前结点值等于key值，则证明找到目标删除结点<ul><li>目标结点是叶子结点，直接删除，返回空结点</li><li>目标结点有单孩子结点，孩子结点补上，作为根节点返回</li><li>目标结点有两个孩子结点，将目标结点的左孩子结点作为目标结点的右孩子结点的最左下叶子结点的左子树，右孩子结点作为根结点返回</li></ul></li><li>都不符合，则是key不存在于当前树中，无需删除，返回root</li></ul><p>整体代码如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xquery">class Solution &#123;<br>public:<br>    TreeNode* deleteNode(TreeNode*<span class="hljs-built_in"> root</span>, int<span class="hljs-built_in"> key</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>)   <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>-&gt;val &lt;<span class="hljs-built_in"> key</span>)<br>        &#123;<br>           <span class="hljs-built_in"> root</span>-&gt;right = deleteNode<span class="hljs-built_in">(root</span>-&gt;right,<span class="hljs-built_in"> key</span>);<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>-&gt;val &gt;<span class="hljs-built_in"> key</span>)<br>        &#123;<br>           <span class="hljs-built_in"> root</span>-&gt;left = deleteNode<span class="hljs-built_in">(root</span>-&gt;left,<span class="hljs-built_in"> key</span>);<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>-&gt;left &amp;&amp; <span class="hljs-built_in">!root</span>-&gt;right)<br>            &#123;<br>                <span class="hljs-keyword">delete</span><span class="hljs-built_in"> root</span>;<br>                <span class="hljs-keyword">return</span> nullptr;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>-&gt;right)<br>                <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>-&gt;left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>-&gt;left)<br>                <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>-&gt;right;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode* tmp =<span class="hljs-built_in"> root</span>-&gt;right;<br>                while (tmp-&gt;left)<br>                &#123;<br>                    tmp = tmp-&gt;left;<br>                &#125;<br>                tmp-&gt;left =<span class="hljs-built_in"> root</span>-&gt;left;<br>                TreeNode* <span class="hljs-type">node</span> =<span class="hljs-built_in"> root</span>;<br>               <span class="hljs-built_in"> root</span> =<span class="hljs-built_in"> root</span>-&gt;right;<br>                <span class="hljs-keyword">delete</span> <span class="hljs-type">node</span>;<br>                <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>重要的是，理解在每次调用递归时，返回的值是作为当前结点下删除目标结点后的新的子树</p></li></ol><h3 id="迭代法-16"><a href="#迭代法-16" class="headerlink" title="迭代法"></a>迭代法</h3><p>   模拟实现递归的过程，但会因为在分类讨论下，多出了判断当前结点是否为二叉搜索树的根结点，从而导致代码出现很多重复，也可以封装成一个函数</p>   <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>    TreeNode* deleteNode(TreeNode* root, int key) &#123;<br>        <span class="hljs-keyword">if</span> (!root)   return root;<br>        TreeNode* node = root, * fa = nullptr;<br>        <span class="hljs-keyword">while</span> (node)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span> (key &lt; node-&gt;</span>val)<br>            &#123;<br>                fa = node;<br>                <span class="hljs-function"><span class="hljs-title">node</span> = node-&gt;</span>left;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (key &gt; node-&gt;</span>val)<br>            &#123;<br>                fa = node;<br>                <span class="hljs-function"><span class="hljs-title">node</span> = node-&gt;</span>right;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (key == node-&gt;</span>val)<br>            &#123;<br>                <span class="hljs-function"><span class="hljs-title">if</span> (!node-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> &amp;&amp; !node-&gt;</span>right)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(!fa) return nullptr;<br>                    <span class="hljs-function"><span class="hljs-title">if</span>(fa-&gt;</span>val &gt; key)<br>                        <span class="hljs-function"><span class="hljs-title">fa</span>-&gt;</span>left = nullptr;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-function"><span class="hljs-title">fa</span>-&gt;</span>right = nullptr;<br>                    delete node;<br>                    return root;<br>                &#125;<br>                <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (!node-&gt;</span>left)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(!fa)<br>                        <span class="hljs-function"><span class="hljs-title">return</span> node-&gt;</span>right;<br>                    <span class="hljs-function"><span class="hljs-title">if</span> (fa-&gt;</span>val &gt; key)<br>                        <span class="hljs-function"><span class="hljs-title">fa</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = node-&gt;</span>right;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-function"><span class="hljs-title">fa</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = node-&gt;</span>right;<br>                    delete node;<br>                    return root;<br>                &#125;<br>                <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (!node-&gt;</span>right)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(!fa)<br>                        <span class="hljs-function"><span class="hljs-title">return</span> node-&gt;</span>left;<br>                    <span class="hljs-function"><span class="hljs-title">if</span> (fa-&gt;</span>val &gt; key)<br>                        <span class="hljs-function"><span class="hljs-title">fa</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = node-&gt;</span>left;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-function"><span class="hljs-title">fa</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = node-&gt;</span>left;<br>                    delete node;<br>                    return root;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    T<span class="hljs-function"><span class="hljs-title">reeNode</span>* lnode = node-&gt;</span>left;<br>                    T<span class="hljs-function"><span class="hljs-title">reeNode</span>* tmp = node-&gt;</span>right;<br>                    <span class="hljs-function"><span class="hljs-title">while</span> (tmp-&gt;</span>left)<br>                    &#123;<br>                        <span class="hljs-function"><span class="hljs-title">tmp</span> = tmp-&gt;</span>left;<br>                    &#125;<br>                    <span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span>left = lnode;<br>                    <span class="hljs-keyword">if</span> (!fa)<br>                    &#123;<br>                        <span class="hljs-function"><span class="hljs-title">node</span> = node-&gt;</span>right;<br>                        return node;<br>                    &#125;<br>                    <span class="hljs-function"><span class="hljs-title">if</span> (fa-&gt;</span>val &gt; key)<br>                        <span class="hljs-function"><span class="hljs-title">fa</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = node-&gt;</span>right;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-function"><span class="hljs-title">fa</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = node-&gt;</span>right;<br>                    delete node;<br>                    return root;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><p>对于本题中的递归法，类似其他二叉搜索树的题目，都能用到递归算法，且可以利用二叉搜索树的特性简化递归过程。这一题考查了分类讨论的多种情况，并要求在递归遍历找到目标删除结点的父结点，或根据返回值对父结点的指向作更新。同时，对比迭代法，因为不能用返回值不断向上返回新的根结点，迭代法需要找到目标结点的父结点，才能修改删除结点后父结点的指向，可得知，<strong>用函数封装后的返回值可以简便的修改二叉树结构</strong>。</p><p>在力扣编译器中，就算是叶子结点，直接将其delete掉也会报错，需要把其父结点更改为<strong>指向空结点</strong>，即断开跟不删除结点的所有连接才能不报错</p><p>递归法和迭代法的时间复杂度都是O(n)，遍历一次二叉树的结点。递归法的空间复杂度最坏情况下是O(n)，迭代法的空间复杂度是O(1)，只占用常量级的空间，因为二叉搜索树的迭代不需要用到栈或队列</p><h2 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h2><p>[修剪二叉搜索树](<a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a>)</p><h3 id="递归法-23"><a href="#递归法-23" class="headerlink" title="递归法"></a>递归法</h3><p>类比上一题，后序遍历所有二叉树结点，并将修剪过后的子树的根结点作为返回值，作为根结点的新左子结点或者新右子结点。如果当前结点值小于要求范围，根据二叉搜索树的特性，从当前结点的右子树不断向右寻找，直到值在要求范围内，并返回该结点；如果当前结点值大于要求范围，也同理</p><ol><li><p>确定递归结束条件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>ptr;<br></code></pre></td></tr></table></figure><p>当遇到空结点时返回空结点</p></li><li><p>确定递归返回值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">TreeNode* trim<span class="hljs-constructor">BST(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">low</span>, <span class="hljs-params">int</span> <span class="hljs-params">high</span>)</span><br>&#123;<br>root-&gt;left = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>root-&gt;right = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>return root;<br>&#125;<br></code></pre></td></tr></table></figure><p>让左子结点进入递归，并将新的结点作为返回值，给该结点的左子结点重新赋值</p><p>右子结点同理</p><p>全部子树修剪完成，则返回根结点</p></li><li><p>确定递归单层逻辑</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; low)<br>&#123;<br>T<span class="hljs-function"><span class="hljs-title">reeNode</span>* tmp = root-&gt;</span>right;<br><span class="hljs-function"><span class="hljs-title">while</span>(tmp &amp;&amp; tmp-&gt;</span>val &lt; low)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">tmp</span> = tmp-&gt;</span>right;<br>&#125;<br>return tmp == nullptr?nullptr:tmp;<br>&#125;<br><span class="hljs-comment">//另一边同理</span><br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;<br>        <span class="hljs-keyword">if</span> (!root)   return root;<br>        <span class="hljs-comment">//后序遍历</span><br>        <span class="hljs-function"><span class="hljs-title">root</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = trimBST(root-&gt;</span>left, low, high);<br>        <span class="hljs-function"><span class="hljs-title">root</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = trimBST(root-&gt;</span>right, low, high);<br>        <span class="hljs-function"><span class="hljs-title">if</span> (root-&gt;</span>val &lt; low)<br>        &#123;<br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* tmp = root-&gt;</span>right;<br>            <span class="hljs-function"><span class="hljs-title">while</span> (tmp &amp;&amp; tmp-&gt;</span>val &lt; low)<br>            &#123;<br>                <span class="hljs-function"><span class="hljs-title">tmp</span> = tmp-&gt;</span>right;<br>            &#125;<br>            return tmp == nullptr ? nullptr : tmp;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (root-&gt;</span>val &gt; high)<br>        &#123;<br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* tmp = root-&gt;</span>left;<br>            <span class="hljs-function"><span class="hljs-title">while</span> (tmp &amp;&amp; tmp-&gt;</span>val &gt; high)<br>            &#123;<br>                <span class="hljs-function"><span class="hljs-title">tmp</span> = tmp-&gt;</span>left;<br>            &#125;<br>            return tmp == nullptr ? nullptr : tmp;<br>        &#125;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个版本的递归中，每个结点都进入了递归，其实不需要，只是将符合范围的当前结点的左右结点送入递归即可，但不能够直接改成</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &gt; low<span class="hljs-operator"> &amp;&amp; </span>root-&gt;<span class="hljs-keyword">val</span> &lt; high)<br>&#123;<br>root-&gt;left = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>root-&gt;right = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为后面在处理中间结点的代码，相当于循环迭代处理，没有保证到根结点的子树都会进入递归，因此，可以将中间结点的处理过程修改成递归形式，整体代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* trim<span class="hljs-constructor">BST(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">low</span>, <span class="hljs-params">int</span> <span class="hljs-params">high</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!root)   return root;<br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &gt;= low<span class="hljs-operator"> &amp;&amp; </span>root-&gt;<span class="hljs-keyword">val</span> &lt;= high)<br>        &#123;<br>            root-&gt;left = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>            root-&gt;right = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &lt; low)<br>        &#123;<br>            return trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;<span class="hljs-keyword">val</span> &gt; high)<br>        &#123;<br>            return trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>        &#125;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>问题在于，会导致占用更多的栈空间，让整个程序的空间复杂度比原有的更加大。</p><p>综上所述，第一个版本的递归由于带上了部分迭代的版本，总体性能更优</p><h3 id="迭代法-17"><a href="#迭代法-17" class="headerlink" title="迭代法"></a>迭代法</h3><p>类似上一题删除二叉搜索树中的结点，迭代法需要找到目标结点的父结点，并改变父结点的指向，在本题中，需要先循环寻找到在范围之内的根结点，再分别对左子树和右子树进行循环判断和更改，循环过程是关键</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;<br>        <span class="hljs-keyword">if</span> (!root)   return root;<br>        <span class="hljs-function"><span class="hljs-title">while</span>(root&amp;&amp;(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; low || root-&gt;</span>val &gt; high))<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; low)<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>right;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>left;<br>        &#125;<br>        TreeNode* node = root;<br>        <span class="hljs-keyword">while</span>(node)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">while</span> (node-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> &amp;&amp; node-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>val &gt; high)<br>            &#123;<br>                <span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = node-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>left;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">node</span> = node-&gt;</span>right;<br>        &#125;<br>        node = root;<br>        <span class="hljs-keyword">while</span>(node)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">while</span> (node-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> &amp;&amp; node-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>val &lt; low)<br>            &#123;<br>                <span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = node-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>right;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">node</span> = node-&gt;</span>left;<br>        &#125;<br>        <br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h3><p>这两题中，迭代法由于不占用递归栈的空间，空间复杂度都为O(1)，<strong>但需要考虑的情况更加多</strong>，比递归法更为复杂</p><h2 id="将有序数组转换成二叉搜索树"><a href="#将有序数组转换成二叉搜索树" class="headerlink" title="将有序数组转换成二叉搜索树"></a>将有序数组转换成二叉搜索树</h2><p>[将有序数组转换成二叉搜索树](<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a>)</p><h3 id="递归法-24"><a href="#递归法-24" class="headerlink" title="递归法"></a>递归法</h3><ol><li><p>确定递归结束条件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">if</span>(start&lt;end)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定递归返回值</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">TreeNode*(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)<br>&#123;<br><br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定递归单层逻辑</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">nums</span>[(<span class="hljs-params">left</span> + <span class="hljs-params">right</span> + 1)</span>/<span class="hljs-number">2</span>]);<br>root-&gt;left = sorted<span class="hljs-constructor">ArrayIndexToBST(<span class="hljs-params">nums</span>, <span class="hljs-params">start</span>, <span class="hljs-params">rootindex</span> - 1)</span>;<br>root-&gt;right = sorted<span class="hljs-constructor">ArrayIndexToBST(<span class="hljs-params">nums</span>, <span class="hljs-params">rootindex</span> + 1, <span class="hljs-params">end</span>)</span>;<br></code></pre></td></tr></table></figure></li></ol><p>整体代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* sorted<span class="hljs-constructor">ArrayIndexToBST(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">start</span>, <span class="hljs-params">int</span> <span class="hljs-params">end</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">end</span> &lt; start)   return nullptr;<br>        <span class="hljs-built_in">int</span> rootindex = (<span class="hljs-keyword">end</span>+start+<span class="hljs-number">1</span>)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">nums</span>[<span class="hljs-params">rootindex</span>])</span>;<br>        root-&gt;left = sorted<span class="hljs-constructor">ArrayIndexToBST(<span class="hljs-params">nums</span>, <span class="hljs-params">start</span>, <span class="hljs-params">rootindex</span> - 1)</span>;<br>        root-&gt;right = sorted<span class="hljs-constructor">ArrayIndexToBST(<span class="hljs-params">nums</span>, <span class="hljs-params">rootindex</span> + 1, <span class="hljs-params">end</span>)</span>;<br>        return root;<br>    &#125;<br>    TreeNode* sorted<span class="hljs-constructor">ArrayToBST(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.size<span class="hljs-literal">()</span>==<span class="hljs-number">1</span>)  <br>            return <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">nums</span>[0])</span>;<br>        return sorted<span class="hljs-constructor">ArrayIndexToBST(<span class="hljs-params">nums</span>,0,<span class="hljs-params">nums</span>.<span class="hljs-params">size</span>()</span>-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代法-18"><a href="#迭代法-18" class="headerlink" title="迭代法"></a><strong>迭代法</strong></h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* sorted<span class="hljs-constructor">ArrayToBST(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>)</span> &#123;<br>        queue&lt;pair&lt;TreeNode*, <span class="hljs-built_in">int</span>&gt;&gt; que;     <span class="hljs-comment">//父结点和index</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(0)</span>;<br>        que.push(make<span class="hljs-constructor">_pair(<span class="hljs-params">nullptr</span>, <span class="hljs-params">nums</span>.<span class="hljs-params">size</span>()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>));<br><br>        <span class="hljs-keyword">while</span> (!que.empty<span class="hljs-literal">()</span>)<br>        &#123;<br>            <span class="hljs-built_in">int</span> index = que.front<span class="hljs-literal">()</span>.second;<br>            TreeNode* fa = que.front<span class="hljs-literal">()</span>.first;<br>            que.pop<span class="hljs-literal">()</span>;<br><br>            TreeNode* cur = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">nums</span>[<span class="hljs-params">index</span>])</span>;<br>            <span class="hljs-keyword">if</span> (fa<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">index</span>]</span> &lt; fa-&gt;<span class="hljs-keyword">val</span>)<br>                fa-&gt;left = cur;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fa<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">index</span>]</span> &gt; fa-&gt;<span class="hljs-keyword">val</span>)<br>                fa-&gt;right = cur;<br>            <span class="hljs-keyword">else</span><br>                root = cur;<br>            <span class="hljs-keyword">if</span> (index - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) que.push(make<span class="hljs-constructor">_pair(<span class="hljs-params">cur</span>, <span class="hljs-params">index</span> <span class="hljs-operator">/</span> 2)</span>);<br>            <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &lt; nums.size<span class="hljs-literal">()</span>)   que.push(make<span class="hljs-constructor">_pair(<span class="hljs-params">cur</span>, (<span class="hljs-params">index</span> + <span class="hljs-params">nums</span>.<span class="hljs-params">size</span>()</span> + <span class="hljs-number">1</span>)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>));<br>        &#125;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上版本的代码会死循环，原因在于条件判断进入队列，由于子区间<strong>没有边界限定</strong>，而只使用原始nums的边界，就会导致一直有实际上并不合法的结点进入队列。此时，需要有额外的容器去记录边界</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* sortedArrayToBST(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-keyword">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> nullptr;<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);   <span class="hljs-comment">// 初始根节点</span><br>        queue&lt;TreeNode*&gt; nodeQue;           <span class="hljs-comment">// 放遍历的节点</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; leftQue;                 <span class="hljs-comment">// 保存左区间下标</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; rightQue;                <span class="hljs-comment">// 保存右区间下标</span><br>        nodeQue.<span class="hljs-keyword">push</span>(root);                 <span class="hljs-comment">// 根节点入队列</span><br>        leftQue.<span class="hljs-keyword">push</span>(<span class="hljs-number">0</span>);                    <span class="hljs-comment">// 0为左区间下标初始位置</span><br>        rightQue.<span class="hljs-keyword">push</span>(nums.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>);     <span class="hljs-comment">// nums.size() - 1为右区间下标初始位置</span><br><br>        <span class="hljs-keyword">while</span> (!nodeQue.empty()) &#123;<br>            TreeNode* curNode = nodeQue.front();<br>            nodeQue.<span class="hljs-keyword">pop</span>();<br>            <span class="hljs-keyword">int</span> left = leftQue.front(); leftQue.<span class="hljs-keyword">pop</span>();<br>            <span class="hljs-keyword">int</span> right = rightQue.front(); rightQue.<span class="hljs-keyword">pop</span>();<br>            <span class="hljs-keyword">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br><br>            curNode-&gt;val = nums[mid];       <span class="hljs-comment">// 将mid对应的元素给中间节点</span><br><br>            <span class="hljs-keyword">if</span> (left &lt;= mid - <span class="hljs-number">1</span>) &#123;          <span class="hljs-comment">// 处理左区间</span><br>                curNode-&gt;left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                nodeQue.<span class="hljs-keyword">push</span>(curNode-&gt;left);<br>                leftQue.<span class="hljs-keyword">push</span>(left);<br>                rightQue.<span class="hljs-keyword">push</span>(mid - <span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (right &gt;= mid + <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">// 处理右区间</span><br>                curNode-&gt;right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                nodeQue.<span class="hljs-keyword">push</span>(curNode-&gt;right);<br>                leftQue.<span class="hljs-keyword">push</span>(mid + <span class="hljs-number">1</span>);<br>                rightQue.<span class="hljs-keyword">push</span>(right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-25"><a href="#总结-25" class="headerlink" title="总结"></a>总结</h3><p>这道题也属于修改二叉搜索树的结构，通常在处理中间结点后，可以利用递归返回值来更新二叉搜索树的左右结点，并递归下去</p><p>且迭代法要考虑的比递归法要复杂很多，在本题中，迭代法最终实现过程还是依据了递归法的过程，用边界条件作为参数，不断缩小边界，只不过<strong>在递归法中使用函数的传参代替了迭代法中用于记录这几个参数的容器</strong></p><h2 id="把二叉搜索树转换成累加树"><a href="#把二叉搜索树转换成累加树" class="headerlink" title="把二叉搜索树转换成累加树"></a>把二叉搜索树转换成累加树</h2><p>[把二叉搜索树转换成累加树](<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a>)</p><h3 id="递归法-25"><a href="#递归法-25" class="headerlink" title="递归法"></a>递归法</h3><p>灵活运用遍历顺序，根据题意，需要找最大的结点，即最右结点，再访问第二大的结点，即中间结点，最后才是左结点，实际上这就是中序遍历的逆序</p><p>整体代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>int res = <span class="hljs-number">0</span>;<br>    TreeNode* convertBST(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(!root)   <span class="hljs-keyword">return</span> nullptr;<br>        convertBST(root-&gt;right);<br>        res += root-&gt;<span class="hljs-keyword">val</span>;<br>        root-&gt;<span class="hljs-keyword">val</span> = res;<br>        convertBST(root-&gt;left);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="迭代法-19"><a href="#迭代法-19" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法所用到的也是中序遍历的模板</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    TreeNode* convertBST(TreeNode* root) &#123;<br>        if(!root)   return nullptr;<br>        int sum = <span class="hljs-number">0</span>;<br>        stack<span class="hljs-tag">&lt;TreeNode*&gt;</span> stk;<br>        TreeNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= root</span>;<br>        while(!stk.empty()||<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        &#123;</span><br><span class="hljs-title">            if</span>(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">            &#123;</span><br><span class="hljs-title">                stk</span>.push(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">                node</span> = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>;<br>            &#125;<br>            else<br>            &#123;<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= stk</span>.top();<br>                stk.pop();<br>                sum += <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>;<br>                <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span> = sum;<br>                <span class="hljs-keyword">node</span> <span class="hljs-title">= node-</span>&gt;left;<br>            &#125;<br>        &#125;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-26"><a href="#总结-26" class="headerlink" title="总结"></a>总结</h3><p>第一想法是，第一次遍历二叉树，借助数组存储每个结点的值，再遍历一次数组，对数组的值进行处理，使得每个下标对应的是累加后的数值，最后遍历一次二叉树修改原值。</p><p>这一题摆脱了常规的遍历顺序，尝试了先访问右结点的逆向中序遍历</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>这里是第一篇博客文章</title>
    <link href="/2022/10/11/%E8%BF%99%E9%87%8C%E6%98%AF%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2022/10/11/%E8%BF%99%E9%87%8C%E6%98%AF%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>this is my first blog article in my website!</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
