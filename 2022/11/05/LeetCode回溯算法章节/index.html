<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kevin346-sc.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="LeetCode回溯算法章节回溯模板12345678910void backtrace(参数)&amp;#123;	if(终止条件)		return;	for(每层中的元素)	&amp;#123;		存入结果		backtrace();调用回溯		删除存入的结果，回溯	&amp;#125;&amp;#125;   组合[组合](77. 组合 - 力扣（LeetCode）) 回溯从[1,N]中找到凑成K个数的所有组合，将[i,N]">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode回溯算法章节">
<meta property="og:url" content="https://kevin346-sc.github.io/2022/11/05/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/index.html">
<meta property="og:site_name" content="Serein’s Blog">
<meta property="og:description" content="LeetCode回溯算法章节回溯模板12345678910void backtrace(参数)&amp;#123;	if(终止条件)		return;	for(每层中的元素)	&amp;#123;		存入结果		backtrace();调用回溯		删除存入的结果，回溯	&amp;#125;&amp;#125;   组合[组合](77. 组合 - 力扣（LeetCode）) 回溯从[1,N]中找到凑成K个数的所有组合，将[i,N]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E6%A8%A1%E6%9D%BF.png">
<meta property="og:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E7%BB%84%E5%90%88.png">
<meta property="og:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg">
<meta property="og:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/IP.png">
<meta property="og:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%85%A8%E6%8E%92%E5%88%97.png">
<meta property="article:published_time" content="2022-11-05T08:03:18.000Z">
<meta property="article:modified_time" content="2022-12-04T06:35:34.000Z">
<meta property="article:author" content="Kevin Huang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E6%A8%A1%E6%9D%BF.png">


<link rel="canonical" href="https://kevin346-sc.github.io/2022/11/05/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kevin346-sc.github.io/2022/11/05/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/","path":"2022/11/05/LeetCode回溯算法章节/","title":"LeetCode回溯算法章节"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LeetCode回溯算法章节 | Serein’s Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Serein’s Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82"><span class="nav-number">1.</span> <span class="nav-text">LeetCode回溯算法章节</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.</span> <span class="nav-text">回溯模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-number">1.2.</span> <span class="nav-text">组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">1.2.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.2.</span> <span class="nav-text">回溯优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII"><span class="nav-number">1.3.</span> <span class="nav-text">组合总和III</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%96-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">回溯优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.3.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-number">1.4.</span> <span class="nav-text">电话号码的字母组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">1.4.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">1.5.</span> <span class="nav-text">组合总和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="nav-number">1.5.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%96-2"><span class="nav-number">1.5.2.</span> <span class="nav-text">回溯优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">1.5.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII"><span class="nav-number">1.6.</span> <span class="nav-text">组合总和II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="nav-number">1.6.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%96-3"><span class="nav-number">1.6.2.</span> <span class="nav-text">回溯优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">1.6.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">1.7.</span> <span class="nav-text">分割回文串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-5"><span class="nav-number">1.7.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-number">1.7.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="nav-number">1.8.</span> <span class="nav-text">复原IP地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF1"><span class="nav-number">1.8.1.</span> <span class="nav-text">回溯1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF2"><span class="nav-number">1.8.2.</span> <span class="nav-text">回溯2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-6"><span class="nav-number">1.8.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E9%9B%86"><span class="nav-number">1.9.</span> <span class="nav-text">子集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-6"><span class="nav-number">1.9.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-7"><span class="nav-number">1.9.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E9%9B%86II"><span class="nav-number">1.10.</span> <span class="nav-text">子集II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-7"><span class="nav-number">1.10.1.</span> <span class="nav-text">回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.11.</span> <span class="nav-text">递增子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-8"><span class="nav-number">1.11.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%961"><span class="nav-number">1.11.2.</span> <span class="nav-text">回溯优化1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%962"><span class="nav-number">1.11.3.</span> <span class="nav-text">回溯优化2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-number">1.11.4.</span> <span class="nav-text">拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-8"><span class="nav-number">1.11.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">1.12.</span> <span class="nav-text">全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-9"><span class="nav-number">1.12.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-9"><span class="nav-number">1.12.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97II"><span class="nav-number">1.13.</span> <span class="nav-text">全排列II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF1-1"><span class="nav-number">1.13.1.</span> <span class="nav-text">回溯1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF2-1"><span class="nav-number">1.13.2.</span> <span class="nav-text">回溯2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-10"><span class="nav-number">1.13.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B"><span class="nav-number">1.14.</span> <span class="nav-text">重新安排行程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-10"><span class="nav-number">1.14.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#special%E8%A7%A3%E6%B3%95"><span class="nav-number">1.14.2.</span> <span class="nav-text">special解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-11"><span class="nav-number">1.14.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A0%B4%E8%A7%A3%E4%BF%9D%E9%99%A9%E7%AE%B1"><span class="nav-number">1.15.</span> <span class="nav-text">破解保险箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#N%E7%9A%87%E5%90%8E"><span class="nav-number">1.16.</span> <span class="nav-text">N皇后</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-11"><span class="nav-number">1.16.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-12"><span class="nav-number">1.16.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="nav-number">1.17.</span> <span class="nav-text">解数独</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-12"><span class="nav-number">1.17.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-13"><span class="nav-number">1.17.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC"><span class="nav-number">1.18.</span> <span class="nav-text">最接近目标价格的甜点成本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-13"><span class="nav-number">1.18.1.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%96-4"><span class="nav-number">1.18.2.</span> <span class="nav-text">回溯优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-14"><span class="nav-number">1.18.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kevin Huang</p>
  <div class="site-description" itemprop="description">c++</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/11/05/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LeetCode回溯算法章节 | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode回溯算法章节
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-05 16:03:18" itemprop="dateCreated datePublished" datetime="2022-11-05T16:03:18+08:00">2022-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-04 14:35:34" itemprop="dateModified" datetime="2022-12-04T14:35:34+08:00">2022-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="LeetCode回溯算法章节"><a href="#LeetCode回溯算法章节" class="headerlink" title="LeetCode回溯算法章节"></a>LeetCode回溯算法章节</h1><h2 id="回溯模板"><a href="#回溯模板" class="headerlink" title="回溯模板"></a>回溯模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void backtrace(参数)&#123;</span><br><span class="line">	if(终止条件)</span><br><span class="line">		return;</span><br><span class="line">	for(每层中的元素)</span><br><span class="line">	&#123;</span><br><span class="line">		存入结果</span><br><span class="line">		backtrace();调用回溯</span><br><span class="line">		删除存入的结果，回溯</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E6%A8%A1%E6%9D%BF.png"></p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>[组合](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>从[1,N]中找到凑成K个数的所有组合，将[i,N]（i&#x3D;1,2,3…N）看做一棵树的不同结点，每取出一个数就把剩下的数看做该结点的子结点，叶子结点则为符合要求的结果。因此，for循环中的是不断取出一个数进入递归，结束递归后删除，再递增取下一个数，直到遇到结束条件退出递归。即for循环会遍历[1,N]中所有的元素，每添加一个元素进入数组就进入一层递归，但进入递归后若符合终止条件则会跳出，避免了N次方的时间复杂度。也相当于枚举法，但会及时止损</p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E7%BB%84%E5%90%88.png"></p>
<ol>
<li><p>确定回溯终止条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(vec.size()==k)</span><br><span class="line">&#123;</span><br><span class="line">	res.push_back(vec);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组大小符合要求时，也就是遇到了叶子结点，这一次递归就终止，并更新结果集</p>
</li>
<li><p>确定回溯返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void search(int n,int k,vector&lt;vector&lt;int&gt;&gt;&amp; res,vector&lt;int&gt;&amp; vec,int start)</span><br><span class="line">&#123;</span><br><span class="line">	不需要返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = start;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	vec.push(i);</span><br><span class="line">	search(n,k,res,vec,start+1);</span><br><span class="line">	vec.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void search(int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int start)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">            search(n, k, res, vec, i + 1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        search(n, k, res, vec, 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化"><a href="#回溯优化" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>在回溯算法当中，由于是回溯的本质就是枚举，对枚举的优化只在于剪枝，通过给定限定条件减少无必要的递归，本题也同样如此，以上版本中将start赋予到了i，却并没有考虑到start的位置要求，在某些分支中，start过于太大，导致剩下的元素不能满足k的数量要求，因此，可以对回溯进行剪枝优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void search(int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int start)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt;= n - (k - vec.size()) + 1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">            search(n, k, res, vec, i + 1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        search(n, k, res, vec, 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>剪枝的原因在于i不必从过于大的start中取值，因此将对for循环中i的循环结束语句修改，从进入递归之前剪枝</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回溯算法难点在于将题意转换成树形结构，对于树形结构可以更好的理解回溯，以及剪枝的操作</p>
<h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><h3 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h3><p>题目思路类似于上一题，只不过将取值范围固定在<code>1~9</code>之间，其余都一样</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(int k, int n, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            if (accumulate(vec.begin(), vec.end(), 0) == n)</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt;= 9; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">            traceback(k, n, res, vec, i + 1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        traceback(k, n, res, vec, 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化-1"><a href="#回溯优化-1" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>在以上版本代码中，容易看出需要优化的地方在于取值的范围是递增的，一旦有满足总和的vec数组，后续的遍历中的数组总和只会更大，因此可以忽略掉后续的遍历。类似地，同样在递归进入条件判断语句中增加限制，考虑到是用数组总和来做判断是否需要剪枝，则增加一个形参<code>sum</code>表示当前<code>vec</code>数组的总和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(int k, int n, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int index, int&amp; sum)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            if (sum == n)</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt;= 9 &amp;&amp; (n - sum) &gt;= i; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">            traceback(k, n, res, vec, i + 1, sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        traceback(k, n, res, vec, 1, sum);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在回溯法中，如果想要不重复地访问元素，则需要<code>traceback(k,n,res,vec,i+1)</code>而不是<code>traceback(k,n,res,vec,index+1)</code>，后者会在<code>i</code>遍历时，与<code>index+1</code>有重复值，且重复值只从2开始</p>
<p>本题是与上题相同的回溯思路，但不同的剪枝思路。</p>
<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>[电话号码的字母组合](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h3><p>与前些题目不同的是，没有直接能获取到要进入递归的范围，即递归树的结点，需要借助容器来获取数值范围，这里使用数组保存<code>0~9</code>所分别对应的字母。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; hashmap&#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;,</span><br><span class="line">&#123;&quot;d&quot;,&quot;e&quot;,&quot;f&quot;&#125;,</span><br><span class="line">&#123;&quot;g&quot;,&quot;h&quot;,&quot;i&quot;&#125;,</span><br><span class="line">&#123;&quot;j&quot;,&quot;k&quot;,&quot;l&quot;&#125;,</span><br><span class="line">&#123;&quot;m&quot;,&quot;n&quot;,&quot;o&quot;&#125;,</span><br><span class="line">&#123;&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;&#125;,</span><br><span class="line">&#123;&quot;t&quot;,&quot;u&quot;,&quot;v&quot;&#125;,</span><br><span class="line">&#123;&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>这里保存0,1两个空数组是为了方便索引访问直接对应</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(digits.size()==str.size())</span><br><span class="line">&#123;</span><br><span class="line">	res.push_back(str);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void traceback(vector&lt;string&gt;&amp; res, string&amp; str,const string &amp;digits,int index);</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;hashmap[digit].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str += hashmap[digit][i];</span><br><span class="line">            traceback(res,str,digits,index+1);</span><br><span class="line">            str.pop_back();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; hashmap&#123;</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">    &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;,</span><br><span class="line">    &#123;&quot;d&quot;,&quot;e&quot;,&quot;f&quot;&#125;,</span><br><span class="line">    &#123;&quot;g&quot;,&quot;h&quot;,&quot;i&quot;&#125;,</span><br><span class="line">    &#123;&quot;j&quot;,&quot;k&quot;,&quot;l&quot;&#125;,</span><br><span class="line">    &#123;&quot;m&quot;,&quot;n&quot;,&quot;o&quot;&#125;,</span><br><span class="line">    &#123;&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;&#125;,</span><br><span class="line">    &#123;&quot;t&quot;,&quot;u&quot;,&quot;v&quot;&#125;,</span><br><span class="line">    &#123;&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    void traceback(vector&lt;string&gt;&amp; res,string&amp; str,const string &amp;digits,int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str.size()==digits.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int digit = digits[index] - &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">        for(int i = 0;i&lt;hashmap[digit].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str += hashmap[digit][i];</span><br><span class="line">            traceback(res,str,digits,index+1);</span><br><span class="line">            str.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string str;</span><br><span class="line"></span><br><span class="line">        if(digits.empty())  return res;</span><br><span class="line">        traceback(res,str,digits,0);        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>由回溯过程可知，这个版本的回溯代码不需要剪枝优化。</p>
<p>在本题中，传入递归函数的<code>index</code>形参用来获取<code>digits</code>中的下一位数字，保证每次for循环的都是不同进位上的数字，也是这道题的最大变化点。并且不需要传入其余参数用于表示开始遍历的结点索引，因为需要遍历的是对应数字上的所有字母</p>
<h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>[组合总和](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-3"><a href="#回溯-3" class="headerlink" title="回溯"></a>回溯</h3><p>这道题给定一个数组和目标值，要求从数组中找到不限数量的数组元素，令其和等于目标值，并且能够重复用数组中的元素。最大的不同点在于能够重复使用数组元素，首先能想到的就是不需要index形参，不能让递归每次都从下一个元素开始遍历。</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(target == sum)</span><br><span class="line">&#123;</span><br><span class="line">	res.push_back(vec);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容易想到只要让当前数组的和等于目标值即可结束该层递归，即到达叶子结点。但是这样就会导致了死循环，因为如果一旦数组和大于目标值，则递归永远不会退出。因此需要加上对sum值的限制（在进入递归前判断）</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void traceback(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt; &amp;res,vector&lt;int&gt; &amp;vec,int target,int &amp;sum,int startindex)</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = startindex; i &lt; candidates.size() &amp;&amp; target &gt; sum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在这，startindex作为每次遍历时开始的索引下标，与[III](# 组合总和III)不同，传入到下一次递归的是<code>i</code>而不是<code>i+1</code>，这是因为<strong>允许重复元素的存在</strong></p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int target, int&amp; sum, int startindex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startindex; i &lt; candidates.size() &amp;&amp; target 》 sum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        traceback(candidates, res, vec, target, sum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化-2"><a href="#回溯优化-2" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>可以想到，如同[III](# 组合总和III)，剪枝优化的思路在于当<strong>数组递增</strong>时，一旦有满足目标值的数组元素，往后的元素再进入递归，vec数组的和都会大于目标值，因此可以剪掉，所以<strong>先给数组进行排序</strong>，然后在<strong>递归进入前加以条件的限制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int target, int&amp; sum, int startindex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startindex; i &lt; candidates.size() &amp;&amp; (target - sum) &gt;= candidates[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        int sum = 0;</span><br><span class="line">        traceback(candidates, res, vec, target, sum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>当允许重复元素出现时，在进入下一层递归时就可以传入<code>i</code>而不是<code>i+1</code>。</p>
<p>因为给出的数组非递增，需要先对数组进行排序，优化效果不明显</p>
<h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>[组合总和II](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-4"><a href="#回溯-4" class="headerlink" title="回溯"></a>回溯</h3><p>该题与[II](# 组合总和II)的区别就在于输入的<code>candidates</code>数组允许有重复元素的出现，但<strong>每个元素只能使用一次</strong>，因此传递到下一层递归中的索引就必须是<code>index+1</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int target, int&amp; sum, int startindex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startindex; i &lt; candidates.size() &amp;&amp; target &gt; sum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        traceback(candidates, res, vec, target, sum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外，如果<code>candidates</code>中有重复元素，会导致同层的结点中可能会选取一样的值进入到下一层递归中，就会导致最终结果出现有<strong>相同元素的分组</strong>，如以上版本的代码，仅修改了上一题的<code>index</code>传递值。原因在于，可能会出现保存到<code>res</code>中的元素在回溯删除之后，因为相同值的元素存在，在遍历剩余元素时又被重新添加进去。</p>
<p>可以针对这种情况设立一个<code>tmp</code>变量，先对<code>candidates</code>进行排序，<code>tmp</code>记录刚被删除的元素的值，再下一个元素被添加时判断是否等于<code>tmp</code>，只有不相等时才会被添加进去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int tmp = 0;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; vec, int target, int&amp; sum, int startindex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startindex; i &lt; candidates.size() &amp;&amp; (target-sum) &gt;= candidates[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(tmp == candidates[i])</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i+1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            tmp = candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        traceback(candidates, res, vec, target, sum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int i = startindex; i &lt; candidates.size() &amp;&amp; (target-sum) &gt;= candidates[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i &gt; startindex &amp;&amp; candidates[i] == candidates[i-1])</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            traceback(candidates, res, vec, target, sum, i+1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化-3"><a href="#回溯优化-3" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>剪枝优化过程同<a href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%96%602">上题</a>，以上版本代码已剪枝</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>candidates</code>没有重复元素，但结果输出可以有重复元素，则修改<code>index</code></p>
<p><code>candidates</code>有重复元素，但结果输出不能有重复元素，即相同元素的分组，则通过添加限制条件防止重复元素进入递归</p>
<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>[分割回文串](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-5"><a href="#回溯-5" class="headerlink" title="回溯"></a>回溯</h3><p>相比较于之前的题目，该题变化点主要集中在于递归结束判断条件，在满足回文的条件的同时，还需要<strong>将整个字符串完全分割</strong></p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg"></p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (index &gt;= s.size())</span><br><span class="line">&#123;</span><br><span class="line">    if (judge())</span><br><span class="line">       res.push_back(vec);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于不能添加重复元素进入递归，所以需要index形参，需要在对整个字符串完成分割的时候才停止递归，并且要满足回文的条件才能保存结果</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void traceback(string s, int index)</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = index; i &lt; s.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    vec.push_back(s.substr(index,i+1-index));</span><br><span class="line">    traceback(s, i + 1);</span><br><span class="line">    vec.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line">    bool judge()</span><br><span class="line">    &#123;</span><br><span class="line">        for(auto sustr:vec)</span><br><span class="line">        &#123;</span><br><span class="line">            int i = 0, j = sustr.size()-1;</span><br><span class="line">            while(i&lt;=j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(sustr[i]!=sustr[j])</span><br><span class="line">                    return false;</span><br><span class="line">                ++i,--j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void traceback(string s, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index&gt;=s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(judge())</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(s.substr(index,i+1-index));</span><br><span class="line">            traceback(s, i + 1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">        if (s.size() == 1)</span><br><span class="line">            return vector&lt;vector&lt;string&gt;&gt;&#123;&#123;s&#125;&#125;;</span><br><span class="line">        traceback(s, 0);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外，还可以在进入递归前完成对回文串的判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line"></span><br><span class="line">    bool judge(int st, int en,string s)</span><br><span class="line">    &#123;</span><br><span class="line">        while(st&lt;=en)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[st]!=s[en])</span><br><span class="line">                return false;</span><br><span class="line">            ++st,--en;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void traceback(string s, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index&gt;=s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!judge(index,i,s))</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(s.substr(index,i+1-index));</span><br><span class="line">            traceback(s, i + 1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">        if (s.size() == 1)</span><br><span class="line">            return vector&lt;vector&lt;string&gt;&gt;&#123;&#123;s&#125;&#125;;</span><br><span class="line">        traceback(s, 0);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>难点在于</p>
<ul>
<li><p><strong>切割问题</strong>转换成<strong>组合问题</strong></p>
<p>关键在于模拟出树形结构</p>
</li>
<li><p>字符串分割如何用代码实现</p>
<p>利用index，以及substr函数，把递归开始时的初值模拟为切割线</p>
</li>
<li><p>判断回文串</p>
<p>双指针法；动态规划</p>
</li>
<li><p>递归结束条件的判断</p>
</li>
</ul>
<h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>本题也属于切割问题，但切割完成的判断更为复杂，切割的IP地址分为4段，需要直接在原字符串中加上<code>&#39;.&#39;</code>表示分段，分段中的IP地址不能有前导0，不能大于255，否则都将是无效的IP。</p>
<p>转换成树形结构</p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/IP.png"></p>
<p>首先，确定判断IP段是否有效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool ok(const string&amp; s, int st, int en)</span><br><span class="line">&#123;</span><br><span class="line">	if(st &gt; en)</span><br><span class="line">		return false;</span><br><span class="line">	if(s[st] == 0 &amp;&amp; st!=en)</span><br><span class="line">		return false;</span><br><span class="line">	int num = 0;</span><br><span class="line">	for(int i = st; i &lt;= en; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		num = num*10 + (s[i] - &#x27;0&#x27;);</span><br><span class="line">		if(num &gt; 255)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仅仅是首元素为0还不一定无效，IP地址段可以只有一个0，但不能是前导0</p>
<p>计算IP地址段可以用<code>for</code>循环，逐位相加，一旦某一位已经超过255则直接返回<code>false</code></p>
<h3 id="回溯1"><a href="#回溯1" class="headerlink" title="回溯1"></a>回溯1</h3><ol>
<li><p>递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(comma == 3)</span><br><span class="line">&#123;</span><br><span class="line">	if(ok(s,index,s.size()-1))</span><br><span class="line">		res.push_back(s);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是直接在源字符串中做分割，在加了3个<code>&#39;.&#39;</code>的情况下，还需要对最后一段IP进行判断是否有效才能加入到结果集中</p>
</li>
<li><p>递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void traceback(vector&lt;string&gt;&amp; res, int comma, int index, string&amp; s)</span><br></pre></td></tr></table></figure>

<p>因为直接在源字符串上操作，并且需要找到所有有效的IP地址，因此不需要返回值。传入参数为引用，不用拷贝并且允许直接修改、删除等操作</p>
</li>
<li><p>单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i = index; i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	s.insert(s.begin() + i + 1, &#x27;.&#x27;);</span><br><span class="line">	++comma;</span><br><span class="line">	traceback(res, comma, i + 2, s);</span><br><span class="line">	--comma;</span><br><span class="line">	s.erase(s.begin() + i + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>insert</code>函数将<code>&#39;.&#39;</code>插在输入的迭代器之前，即取代输入的迭代器位置，<code>erase</code>则是删除输入迭代器当前位置上的元素。进入递归由于插入多了一位，则下一层递归中需要从<code>index = i+2</code>开始</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool ok(const string&amp; s, int st, int en)</span><br><span class="line">    &#123;</span><br><span class="line">        if (st &gt; en)</span><br><span class="line">            return false;</span><br><span class="line">        if (s[st] == &#x27;0&#x27; &amp;&amp; st != en)</span><br><span class="line">            return false;</span><br><span class="line">        int num = 0;</span><br><span class="line">        for (int i = st; i &lt;= en; i++) </span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            num = num * 10 + (s[i] - &#x27;0&#x27;);</span><br><span class="line"></span><br><span class="line">            if (num &gt; 255) </span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void traceback(vector&lt;string&gt;&amp; res, int index, int comma, string&amp; s)</span><br><span class="line">    &#123;</span><br><span class="line">        if (comma == 3)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ok(s, index, s.size() - 1))</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ok(s, index, i))</span><br><span class="line">            &#123;</span><br><span class="line">                s.insert(s.begin() + i + 1, &#x27;.&#x27;);</span><br><span class="line">                ++comma;</span><br><span class="line">                traceback(res, i + 2, comma, s);</span><br><span class="line">                --comma;</span><br><span class="line">                s.erase(s.begin() + i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        traceback(res, 0, 0, s);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="回溯2"><a href="#回溯2" class="headerlink" title="回溯2"></a>回溯2</h3><p>另外一种解法是， 不在源字符串上修改，而是将4段IP地址一段一段的加入一个空字符串中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt;ans;</span><br><span class="line">    void backtrace(string&amp; s,int cnt,int index,string&amp; str)&#123;</span><br><span class="line">        if(cnt==4 || index==s.size() )&#123;</span><br><span class="line">            if(cnt==4 &amp;&amp; index==s.size())</span><br><span class="line">                ans.push_back(str.substr(0,str.size()-1));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=3;i++)&#123;</span><br><span class="line">            if(index+i&gt;s.size()) return;</span><br><span class="line">            if(s[index]==&#x27;0&#x27; &amp;&amp; i!=1) return;</span><br><span class="line">            if(i==3 &amp;&amp; s.substr(index,i)&gt;&quot;255&quot;) return;</span><br><span class="line">            str+=s.substr(index,i);</span><br><span class="line">            str.push_back(&#x27;.&#x27;);</span><br><span class="line">            backtrace(s,cnt+1,index+i,str);</span><br><span class="line">            str = str.substr(0,str.size()-i-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        string str =&quot;&quot;;</span><br><span class="line">        backtrace(s,0,0,str);</span><br><span class="line">        return ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>回溯1是从一整段IP地址直接做分割，回溯2则是将各段分割好的小段最终才拼凑成完整的IP地址，这样做的好处是对于各段统一判断是否有效，而不用像回溯1中在添加了最后一个<code>&#39;.&#39;</code>之后，添加到结果集之前还要做一次有效判断。并且在回溯2中，判断有效更加简洁，可以利用加入的子段最多只有3位直接与”255”进行判断，而回溯1中可能会出现不止3位的IP地址，因此不能直接与”255”判断，但可以修改成<code>if(en - st == 2 &amp;&amp; s.substr(s.begin() + st, 3) &gt; &quot;255&quot;) return false;</code>以及<code>if(en - st &gt; 2)	return false;</code></p>
<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><h3 id="回溯-6"><a href="#回溯-6" class="headerlink" title="回溯"></a>回溯</h3><p>子集问题中，依旧还是回溯的总体思路，不同在于之前结束条件的判断，仅仅只是遍历到数组结尾就退出</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp;nums,vector&lt;int&gt;&amp;vec,vector&lt;vector&lt;int&gt;&gt;&amp;res,int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if(index&gt;=nums.size())</span><br><span class="line">            return;</span><br><span class="line">        for(int i = index; i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            traceback(nums,vec,res,i+1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        res.push_back(vec);</span><br><span class="line">        traceback(nums,vec,res,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>子集问题不需要有判断条件，就直接存入结果集中，相当于将树型结构上的<strong>每个结点</strong>；而组合和切割问题则是<strong>保留叶子结点</strong></p>
<h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><h3 id="回溯-7"><a href="#回溯-7" class="headerlink" title="回溯"></a>回溯</h3><p>给定输入数组中含有重复元素，但要求输出结果中不能有重复子数组，与[组合总和II](# 组合总和II)思路一致，且其余同<a href="#%E5%AD%90%E9%9B%86">子集</a>的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp;nums,vector&lt;int&gt;&amp;vec,vector&lt;vector&lt;int&gt;&gt;&amp;res,int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if(index&gt;=nums.size())</span><br><span class="line">            return;</span><br><span class="line">        for(int i = index; i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;index&amp;&amp;nums[i]==nums[i-1])</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            traceback(nums,vec,res,i+1);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        res.push_back(vec);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        traceback(nums,vec,res,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>[递增子序列](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/increasing-subsequences/">491. 递增子序列 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-8"><a href="#回溯-8" class="headerlink" title="回溯"></a>回溯</h3><p>这道题需要理解的几个关键点：</p>
<ul>
<li>要求是子序列，则不能对其排序，有点类似于分割问题但可以只取两边不取中间，即<code>[1,2,3]</code>选<code>[1,3]</code></li>
<li>要求是非严格递增，则在进入递归前应先进行判断，</li>
<li>输入数组中可能会有重复元素，但输出不能包含重复子数组</li>
</ul>
<p>可知，需要在<strong>不能排序</strong>的情况下，还要在递归过程中排除重复项，回溯的时候应该借助容器来帮助<strong>辨别重复项</strong>，容易想到用<code>unordered_set</code>容器储存结果用于去除重复项，然后遍历容器将没有重复的元素依次存放到<code>vector</code>中，但是，不能直接定义<code>unordered_set&lt;vector&lt;int&gt;&gt;</code>，还要有自定义的哈希函数。因此可以<strong>转换思路，在每一层的结点循环中设置一个<code>unordered_set</code>，即单单不允许这一层有重复被选数</strong>，这就避免重复项进入递归，因为前一个所选就囊括了后面所有相同数的子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt;&amp; vec,int index)</span><br><span class="line">    &#123;</span><br><span class="line">        unordered_set&lt;int&gt; uset;</span><br><span class="line">        if(index&gt;=nums.size())</span><br><span class="line">            return;</span><br><span class="line">        for(int i = index;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;index&amp;&amp;nums[i]==nums[i-1])</span><br><span class="line">                continue;</span><br><span class="line">            if(!vec.empty() &amp;&amp; nums[i]&lt;vec.back())</span><br><span class="line">                continue;</span><br><span class="line">            if(uset.find(nums[i])!=uset.end())</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            uset.insert(nums[i]);</span><br><span class="line">            if(vec.size()&gt;1)</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            traceback(nums,res,vec,i+1);</span><br><span class="line">            vec.pop_back();            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        traceback(nums,res,vec,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化1"><a href="#回溯优化1" class="headerlink" title="回溯优化1"></a>回溯优化1</h3><p>以上版本的代码，用到了<code>unordered_set</code>，又因为总数据量较小，可以用<code>vector</code>替代<code>unordered_set</code>以减少开销</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt;&amp; vec,int index)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; used(201,0);</span><br><span class="line">        if(index&gt;=nums.size())</span><br><span class="line">            return;</span><br><span class="line">        for(int i = index;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;index&amp;&amp;nums[i]==nums[i-1])</span><br><span class="line">                continue;</span><br><span class="line">            if(!vec.empty() &amp;&amp; nums[i]&lt;vec.back())</span><br><span class="line">                continue;</span><br><span class="line">            if(used[nums[i]+100]==1)</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            used[nums[i]+100] = 1;</span><br><span class="line">            if(vec.size()&gt;1)</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            traceback(nums,res,vec,i+1);</span><br><span class="line">            vec.pop_back();            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        traceback(nums,res,vec,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="回溯优化2"><a href="#回溯优化2" class="headerlink" title="回溯优化2"></a>回溯优化2</h3><p>另一种回溯模板的解法，不需要用到额外的容器来记录，但较难理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp;nums,int cur,int last)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur&gt;=nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(vec.size()&gt;1)</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[cur]&gt;=last)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(nums[cur]);</span><br><span class="line">            traceback(nums,cur+1,nums[cur]);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[cur]!=last)</span><br><span class="line">            traceback(nums,cur+1,last);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        traceback(nums,0,-101);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>选择合法项：只有<code>cur</code>值大于等于<code>last</code>，才会选择该元素（添加到vec中）</p>
<p><strong>不借助容器就能排除重复项：只有<code>last</code>和<code>cur</code>指向的值不相同时，才会不选择该结点（不添加到<code>vec</code>中），也就是说当有多个重复元素时，只选最后一个以避免重复</strong></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>另一种回溯模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">vector&lt;int&gt; temp;</span><br><span class="line">void dfs(int cur, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if (cur == nums.size()) &#123;</span><br><span class="line">        // 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span><br><span class="line">        if (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果选择当前元素</span><br><span class="line">    temp.push_back(nums[cur]);</span><br><span class="line">    dfs(cur + 1, nums);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    // 如果不选择当前元素</span><br><span class="line">    dfs(cur + 1, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[子集](# 子集)新解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">    void traceback(int cur, vector&lt;int&gt;&amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur&gt;=nums.size())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vec.push_back(nums[cur]);</span><br><span class="line">        traceback(cur+1,nums);</span><br><span class="line">        vec.pop_back();</span><br><span class="line">        </span><br><span class="line">        traceback(cur+1,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        traceback(0,nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[子集II](# 子集II)新解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">    void traceback(int cur, vector&lt;int&gt;&amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur&gt;=nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec.push_back(nums[cur]);</span><br><span class="line">        traceback(cur+1,nums);</span><br><span class="line">        vec.pop_back();</span><br><span class="line"></span><br><span class="line">        while(cur &lt; nums.size()-1 &amp;&amp; nums[cur]==nums[cur+1])</span><br><span class="line">            ++cur;</span><br><span class="line">        traceback(cur+1,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        traceback(0,nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>该题最关键是在不排序的前提下，排除重复项进入递归，需要借助容器，<strong>并且是在每层递归中重新定义一个容器，从而避免同层相同元素进入递归</strong></p>
<p>另一种回溯模板，<strong>不对应树形结构</strong>，因而更难理解；优先处理更多元素的情况，但因其一层两次递归，时间复杂度更高，但指针使用更加灵活，减少对容器的使用，降低空间复杂度</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><h3 id="回溯-9"><a href="#回溯-9" class="headerlink" title="回溯"></a>回溯</h3><p>排列问题，容易得知，每次递归时需要从0开始遍历数组，这就意味着不能像组合总和一样代入index对递归进行限制。并且，需要借助容器来记录遍历的当前值是否有被使用过。将全排列转化成树形结构，则同一个树枝上不能够有重复值，那么就可以借助全局的<code>vector</code>进行记录，与<code>vec</code>同步增删元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; nums, int index,vector&lt;int&gt; &amp;used)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (used[nums[i] + 10] == 1)</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            used[nums[i] + 10] = 1;</span><br><span class="line">            traceback(nums, index + 1,used);</span><br><span class="line">            used[nums[i] + 10] = 0;</span><br><span class="line">            vec.pop_back();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; used(21, 0);</span><br><span class="line">        traceback(nums, 0,used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与[递增子序列](# 递增子序列)一样，可以通过<code>unordered_set</code>以及<code>vector</code>来记录，<code>vector</code>在数组样本小的情况下性能更加优越</p>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li>组合之和：只能往后选取（排列顺序不影响结果），故需要用index记录每次递归开始选取的位置；去重则通过排序后再对当前值进行是否与前值重复判断</li>
<li>分割：与组合之和差别在于终止条件，分割必须要字符串全部分割</li>
<li>子集：与组合之和差别在于子集的每个结点都是结果集</li>
<li>全排列：不需要index记录每次递归开始选取的位置，因为有排列顺序要求；去重因为没有index，需要借助容器来记录是否被选取过，通常选<code>vector</code></li>
</ul>
<h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><h3 id="回溯1-1"><a href="#回溯1-1" class="headerlink" title="回溯1"></a>回溯1</h3><p>在[全排列](# 全排列)基础上，输入数组可能会有重复值，即不仅在树枝上不能够有重复值，在树层上也不允许有重复值的存在，但是不能直接加上<strong>排序后再判断当前值与前一值是否相等的</strong>去重操作。因为重复值的存在，当在同一条路径上，即树枝上允许有重复值的存在（来源于不同的等值元素），针对树枝上的重复值，可以借助<code>vector</code>先遍历<code>nums</code>记录每个数值的个数，用来判断这个树枝上是否还能使用该数值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; nums, int index,vector&lt;int&gt; &amp;used)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (used[nums[i] + 10] == 0)//树枝去重</span><br><span class="line">                continue;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1])//树层去重，同时防止树枝上取已取过的值</span><br><span class="line">                continue;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            --used[nums[i] + 10];</span><br><span class="line">            traceback(nums, index + 1,used);</span><br><span class="line">            ++used[nums[i] + 10];</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; used(21, 0);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        for(int i:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++used[i+10];</span><br><span class="line">        &#125;</span><br><span class="line">        traceback(nums, 0,used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>关键语句在于<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])	continue;</code>，既做到了对同一层上的结点去重，也做到在一棵树枝上对取过的值的去重（全排列的要求，相当于全排列中的used数组）</strong></p>
<h3 id="回溯2-1"><a href="#回溯2-1" class="headerlink" title="回溯2"></a>回溯2</h3><p>另一种做法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt; &amp;used)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vec.size() == nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;used[i-1]==false)//树层去重</span><br><span class="line">                continue;</span><br><span class="line">            if(used[i]==false)//树枝去重</span><br><span class="line">            &#123;</span><br><span class="line">                used[i]=true;</span><br><span class="line">                vec.push_back(nums[i]);</span><br><span class="line">                traceback(nums,used);</span><br><span class="line">                used[i]=false;</span><br><span class="line">                vec.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;bool&gt; used(nums.size(), false);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        traceback(nums,used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直观的用<code>used</code>数组表示原始数组中的每一个值是否使用过，是对全排列的进一步改进。不只是加上直接加上<strong>排序后再判断当前值与前一值是否相等的</strong>去重操作，为了防止树枝上的多余去重，额外增加了<code>&amp;&amp;used[i-1]==false</code>，限定了只在树层上去重，而不影响树枝上对等值元素的取用</p>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>在全排列的基础上，只增加<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])	continue;</code>语句会导致竖向上首元素会被重复加入（因为i从0开始），而语句本意是跳过横向重复结点和跳过已加入的竖向重复结点，因此，要么选择再增加对跳过竖向结点的限制，如[回溯2](# 回溯2)用额外<code>used</code>数组记录每个元素是否被访问过，如果前一个元素未被访问<code>nums[i-1]==false</code>，且满足当前元素与前一个元素相同<code>i&gt;0 &amp;&amp; nums[i]==nums[i-1]</code>，证明这是在横向上的重复结点（树层），应当跳过，而竖向上如果再次访问访问过的结点<code>used[i]==true</code>，则会执行跳过，不重复加入结果中（另一个角度，如果在满足当前元素与前一个元素相同<code>i&gt;0 &amp;&amp; nums[i]==nums[i-1]</code>时，前一个元素被访问过<code>nums[i-1]==true</code>，此时当前元素也可以被跳过，保留的是横向上的结点，而竖向重复结点被跳过）；要么在<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])	continue;</code>语句不能跳过已加入的竖向重复结点和横向重复结点的情况下，限制加入的重复结点数量如[回溯1](# 回溯1)用<code>used</code>数组记录每一个结点的数量，那么当i从开始时，只会最多加入原数组数量的元素，一旦超过就会被跳过。以上两种算法过程都如下图，</p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%85%A8%E6%8E%92%E5%88%97.png"></p>
<h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a><strong>重新安排行程</strong></h2><h3 id="回溯-10"><a href="#回溯-10" class="headerlink" title="回溯"></a>回溯</h3><p>本题中，关键点在于</p>
<ul>
<li>记录出发机场和目标机场的容器，同时还要记录是否访问过，防止死循环</li>
<li>回溯的终止条件，因为一定存在合理路径，所以机票数+1 &#x3D; 机场数</li>
<li>容器按字典序排列目标机场，若访问字典序较高的目标机场时，该机场是死胡同，则应返回或者回溯</li>
<li>回溯的返回值应该是bool类型，用返回值来判断是否应该回溯（删除死胡同元素）</li>
</ul>
<ol>
<li><p>递归终止条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(tickets.size()==res.size()-1)</span><br><span class="line">&#123;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool traceback(vector&lt;string&gt;&amp;res,vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span><br></pre></td></tr></table></figure>

<p>当返回值为true时，意味着已添加到结果集的元素符合要求，应该直接返回，而不应回溯（删除）；但当返回值为false时，代表着根据字典序优先访问到的这个机场无法再访问其他机场，是个死胡同，应该回溯（pop_back)</p>
</li>
<li><p>递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for(auto const &amp; ticket:tickets[res[res.size()-1]])</span><br><span class="line">&#123;</span><br><span class="line">	if(ticket.second&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		res.push_back(ticket.first);</span><br><span class="line">		ticket.second--;</span><br><span class="line">		if(traceback(res,tickets))	return true;</span><br><span class="line">		ticket.second++;</span><br><span class="line">		res.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure>
<p>上述代码在取目的机场的map时，使用范围for循环，<code>auto &amp;ticket:tickets[res[res.size()-1]]</code>等价于<code>pair&lt;const string,int&gt; &amp;ticket:tickets[res[res.size()-1]]</code>，其中因为map的key值不能改变，所以一定要用const引用，或者只是用副本<code>pair&lt;string,int&gt;ticket:tickets[res[res.size()-1]]</code>。而当不使用范围for循环时，类型符就要更改为<code>map&lt;const string, int&gt;&amp; ticket = tickets[res[res.size()-1]]</code>，因为赋值需要同样的类型或者可转变的类型，而pair不能转变为map</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;</span><br><span class="line">    bool traceback(vector&lt;string&gt;&amp; res, vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span><br><span class="line">    &#123;</span><br><span class="line">        if (res.size() == tickets.size() + 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto&amp; target:targets[res[res.size()-1]])</span><br><span class="line">        &#123;</span><br><span class="line">            if(target.second&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                target.second--;</span><br><span class="line">                res.push_back(target.first);</span><br><span class="line">                if(traceback(res,tickets))return true;</span><br><span class="line">                res.pop_back();</span><br><span class="line">                target.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        res.push_back(&quot;JFK&quot;);</span><br><span class="line">        for (auto ticket : tickets)</span><br><span class="line">        &#123;</span><br><span class="line">            targets[ticket[0]][ticket[1]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        traceback(res, tickets);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="special解法"><a href="#special解法" class="headerlink" title="special解法"></a>special解法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, std::greater&lt;string&gt;&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; stk;</span><br><span class="line"></span><br><span class="line">    void dfs(const string&amp; curr) &#123;</span><br><span class="line">        while (vec.count(curr) &amp;&amp; vec[curr].size() &gt; 0) &#123;</span><br><span class="line">            string tmp = vec[curr].top();</span><br><span class="line">            vec[curr].pop();</span><br><span class="line">            dfs(move(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        stk.emplace_back(curr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;</span><br><span class="line">        for (auto&amp; it : tickets) &#123;</span><br><span class="line">            vec[it[0]].emplace(it[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(&quot;JFK&quot;);</span><br><span class="line"></span><br><span class="line">        reverse(stk.begin(), stk.end());</span><br><span class="line">        return stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>按字典序从<code>priority_queue</code>中访问目标机场，对新访问的机场进行深度有限搜索，并删除访问过的机场，直到该机场是最后一个机场，则添加到数组当中，再不断返回，将之前访问过的机场也添加到数组中，最后将数组逆序即为结果集</p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>该题巧妙选择容器，记录复杂的信息，用<code>unordered_map</code>记录出发机场和目标机场，是因为不需要对出发机场进行排序，为了减少开销，用<code>map&lt;string,int&gt;</code>按字典序记录目标机场及机票数，不使用<code>multiset</code>单纯记录目标机场，就是为了防止同一张机票的重复访问，防止死循环</p>
<p>在第二种解法中，使用不用的容器来记录，通过优先队列来按字典序记录目标机场，每次访问只需要<code>p.top()</code>，访问时间复杂度是O(1)，删除的时间复杂度是O(logm)</p>
<h2 id="破解保险箱"><a href="#破解保险箱" class="headerlink" title="破解保险箱"></a>破解保险箱</h2><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a><strong>N皇后</strong></h2><p>[N皇后](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a>)</p>
<p>要求在<code>n*n</code>的棋盘上放置n个皇后，并且皇后互相不能攻击，即同行同列包括斜角线上不能有两个皇后</p>
<p>逐行遍历棋盘，因为只需要在一行中摆放一个皇后，则不需要两层循环遍历，同时还要有判断是否冲突的函数</p>
<p>首先，根据规则判断在该位置上放置皇后是否会被攻击</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool noattack(vector&lt;string&gt;&amp; chessboard, int n, int index, int row)</span><br><span class="line">&#123;</span><br><span class="line">	//列</span><br><span class="line">	for(int i = 0;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][index] == &#x27;Q&#x27;)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//左上角斜线</span><br><span class="line">	for(int i = row - 1, j = index - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][j] == &#x27;Q&#x27;)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//右上角斜线</span><br><span class="line">	for(int i = row - 1, j = index + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][j] == &#x27;Q&#x27;)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是每一行遍历，因此不需要判断同行是否还有其他皇后；也因为是逐行往下遍历，不需要判断下方是否还有其他皇后，仅判断左上和右上方即可</p>
<h3 id="回溯-11"><a href="#回溯-11" class="headerlink" title="回溯"></a>回溯</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(chessboard.size()==n)</span><br><span class="line">&#123;</span><br><span class="line">	res.push_back(chessboard);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不断添加单行到棋盘中，当棋盘中数量达到n时，就是一个符合要求的棋盘摆法</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void traceback(...)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为可能有多种不同符合规则的摆法，因此返回值为void，遍历所有可能值再返回</p>
</li>
<li><p>确定单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (noattack(chessboard, n,index,i))</span><br><span class="line">    &#123;</span><br><span class="line">        chessboard[index][i] = &#x27;Q&#x27;;</span><br><span class="line">        traceback(res, n, chessboard, index + 1);</span><br><span class="line">        chessboard[index][i] = &#x27;.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对单行棋盘中皇后的摆放位置进行枚举，再递归进入下一行，如果发生相互攻击（遍历完所有值都不符合要求）则进行回溯，不发生攻击则继续递归下一行，直到满足要求</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool noattack(const vector&lt;string&gt;&amp; chessboard, int n, int row, int column)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt;= row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (chessboard[i][column] == &#x27;Q&#x27;)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = row - 1, j = column - 1; i &gt;= 0 &amp;&amp;j &gt;= 0; --i, --j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (chessboard[i][j] == &#x27;Q&#x27;)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = row - 1, j = column + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (chessboard[i][j] == &#x27;Q&#x27;)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void traceback(vector&lt;vector&lt;string&gt;&gt;&amp; res, int n, vector&lt;string&gt;&amp; chessboard, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index &gt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(chessboard);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (noattack(chessboard, n,index,i))</span><br><span class="line">            &#123;</span><br><span class="line">                chessboard[index][i] = &#x27;Q&#x27;;</span><br><span class="line">                traceback(res, n, chessboard, index + 1);</span><br><span class="line">                chessboard[index][i] = &#x27;.&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; chessboard(n, string(n, &#x27;.&#x27;));</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        traceback(res, n, chessboard, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>该题的关键点在于</p>
<ul>
<li>不需要两层循环，虽然是二维棋盘，但N皇后中不需要在二维棋盘的每一个点上都要放置皇后，仅是<strong>判断当前的点是否能放，因此使用单层循环</strong></li>
<li>回溯不需要返回值，是因为要寻找<strong>所有可行的棋盘摆放</strong>，应当<strong>用全局变量或者引用返回</strong>，同时要遍历所有情况；若只需要找到<strong>一种可行的棋盘</strong>，则返回值应为**<code>bool</code><strong>，一旦找到则</strong>返回<code>true</code>退出递归**</li>
<li>不需要对同行皇后进行判断，是因为对<strong>同行位置进行遍历时，肯定不会发生同一行同时有两个皇后出现</strong>，一旦某一个位置能够摆放皇后，就会马上<strong>进入到下一层递归</strong>，即到下一行的遍历，而后面回溯回本行时，又会将原位置的皇后删除，再从下一位进行遍历</li>
</ul>
<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a><strong>解数独</strong></h2><p>[解数独](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a>)</p>
<p>与上题<a href="#N%E7%9A%87%E5%90%8E">N皇后</a>相比，解数独也是在一个二维棋盘上，但不仅要判断该点是否会有冲突，还要在遍历时在每个点上都要填充数字，也就是说，不能像上题一样，如果是单层循环，填完该位置上的数字就进入递归，遍历下一行。因此需要两层循环，填完数字后进入递归，还是从刚填过的位置开始继续填。</p>
<p>同样，首先需要根据规则判断是否有冲突</p>
<ul>
<li>同行不能有重复数字</li>
<li>同列不能有重复数字</li>
<li>同一个3x3格子不能有重复数字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool ok(vector&lt;vector&lt;char&gt;&gt; &amp; chessboard,int row, int col, int tmp)</span><br><span class="line">&#123;</span><br><span class="line">	//判断列</span><br><span class="line">	for(int i = row;i&lt;9;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][col]==tmp+&#x27;0&#x27;)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//判断行</span><br><span class="line">	for(int j = 0;j&lt;9;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[row][j]==tmp+&#x27;0&#x27;)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//判断9宫格</span><br><span class="line">	int subrow = (row / 3) * 3;	//0,1,2行等于0, 3,4,5行等于3，6,7,8行等于6</span><br><span class="line">	int subcol = (col / 3) * 3;	</span><br><span class="line">	for(int i = subrow; i &lt; subrow + 3; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j = subcol; j &lt; subcol + 3; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(board[i][j]==tmp+&#x27;0&#x27;)</span><br><span class="line">				return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，需要多次的循环来完成一次的判断。则可以用哈希表的方法，先储存已有的数字，然后在一次循环完成冲突的判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//全局变量</span><br><span class="line">int row[9][10] &#123;0&#125;;</span><br><span class="line">int col[9][10] &#123;0&#125;;</span><br><span class="line">int subbox[9][10] &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">//先完成对棋盘上已有数字的存储</span><br><span class="line">for(int i = 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">	for(int j = 0; j &lt; 9; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][j]!=&#x27;.&#x27;)</span><br><span class="line">		&#123;</span><br><span class="line">			int tmp = chessboard[i][j]-&#x27;0&#x27;;</span><br><span class="line">			row[i][tmp] = 1;</span><br><span class="line">			col[j][tmp] = 1;</span><br><span class="line">			subbox[j/3 + (i/3)*3][tmp] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ok(int i, int j, int tmp)</span><br><span class="line">&#123;</span><br><span class="line">	if(row[i][tmp]==1)</span><br><span class="line">		return false;</span><br><span class="line">	if(col[j][tmp]==1)</span><br><span class="line">		return false;</span><br><span class="line">	if(subbox[j/3+(i/3)*3][tmp]==1)</span><br><span class="line">		return false;</span><br><span class="line">	row[i][tmp] = 1;</span><br><span class="line">	col[j][tmp] = 1;</span><br><span class="line">	subbox[j/3+(i/3)*3][tmp] = 1;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将三种规则分别替换为三个用二维数组记录的哈希表，行表（row）用第一维表示对应的行数，用第二维表示该行上出现过的数字<code>0-9</code>，如果出现过则置为1，列表（col）同理；由于9宫格中刚好有九个数字，也可以用同样的方法来记录，将棋盘上行列号映射为9个不同的9宫格序号，再记录出现过的数字</p>
<h3 id="回溯-12"><a href="#回溯-12" class="headerlink" title="回溯"></a>回溯</h3><ol>
<li><p>确定递归结束条件</p>
<p>因为结束时，总是需要遍历棋盘上所有位置，当遍历结束也就是递归的结束，因此不需要递归的结束条件</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool traceback(vector&lt;vector&lt;char&gt;&gt;&amp; chessboard, int row, int col)</span><br></pre></td></tr></table></figure>

<p>因为只需要寻找到一种符合的答案，一旦遇到有，则应立即退出递归并返回</p>
</li>
<li><p>递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;9;i++)</span><br><span class="line">&#123;</span><br><span class="line">	for(int j = 0;j&lt;9;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(chessboard[i][j]==&#x27;.&#x27;)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int tmp = 1;tmp&lt;10;tmp++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(ok(i,j,tmp))</span><br><span class="line">				&#123;</span><br><span class="line">					chessboard[i][j]=tmp+&#x27;0&#x27;;</span><br><span class="line">					if(traceback(chessboard)) return true;</span><br><span class="line">					chessboard[i][j]=&#x27;.&#x27;;</span><br><span class="line">					row[i][tmp] = 0;</span><br><span class="line">					col[j][tmp] = 0;</span><br><span class="line">					subbox[j/3+(i/3)*3][tmp] = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int row[9][10] = &#123;0&#125;,column[9][10] = &#123;0&#125;, subbox[9][10] = &#123;0&#125;;</span><br><span class="line">    bool ok(int i, int j, int tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        if(row[i][tmp]==1)</span><br><span class="line">            return false;</span><br><span class="line">        if(column[j][tmp]==1)</span><br><span class="line">            return false;</span><br><span class="line">        if(subbox[j/3+(i/3)*3][tmp]==1)</span><br><span class="line">            return false;</span><br><span class="line">        row[i][tmp] = 1;</span><br><span class="line">        column[j][tmp] = 1;</span><br><span class="line">        subbox[j/3+(i/3)*3][tmp] = 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool traceback(vector&lt;vector&lt;char&gt;&gt;&amp; board)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 0;i&lt;9;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0;j&lt;9;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(board[i][j]==&#x27;.&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    for(int tmp = 1;tmp&lt;10;tmp++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if(ok(i,j,tmp))</span><br><span class="line">                        &#123;</span><br><span class="line">                            board[i][j] = tmp+&#x27;0&#x27;;</span><br><span class="line">                            if(traceback(board)) return true;</span><br><span class="line">                            board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                            row[i][tmp] = 0;</span><br><span class="line">                            column[j][tmp] = 0;</span><br><span class="line">                            subbox[j/3+(i/3)*3][tmp] = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        for(int i = 0;i&lt;9;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0;j&lt;9;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(board[i][j]!=&#x27;.&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    int tmp = board[i][j]-&#x27;0&#x27;;</span><br><span class="line">                    row[i][tmp] = 1;</span><br><span class="line">                    column[j][tmp] = 1;</span><br><span class="line">                    subbox[j/3+(i/3)*3][tmp] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        traceback(board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>该题的关键点在于</p>
<ul>
<li>递归中需要用双层循环，<strong>如果单层循环，则在该行填入一个数字之后进入递归，不管传入怎样的参数都不能使继续填充该行并且完成换行继续填充</strong></li>
<li>递归不需要结束条件，因为题目需要对棋盘上所有点都进行一次遍历，递归结束时就是得到结果时，即遍历结束即为递归结束</li>
<li>递归需要返回值，题目保证能找到一个有效的解决方案，且最多只有一个解，因此返回bool值，当找到时，即遍历完棋盘，就返回true；当在棋盘上某一个点遍历完9个数字都没有合适结果时，应当返回false，令上一层递归进行回溯。也就是说，有返回值如bool类型，可以通过判断返回值（如果为真）可以避免进一步递归，同时还能让进入多余分支的递归及时退出，防止了死循环（如本题，在没有递归结束条件的情况下，如果不用返回值限制则会导致死循环）；而无返回值的通常是要遍历所有分支，从中找到所有解</li>
<li>一次循环即可完成对数独是否有效的判断，借助哈希表，将一维的数据通过二维的哈希表进行重复性判断</li>
</ul>
<h2 id="最接近目标价格的甜点成本"><a href="#最接近目标价格的甜点成本" class="headerlink" title="最接近目标价格的甜点成本"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/closest-dessert-cost/">最接近目标价格的甜点成本</a></h2><p>该题要求从必选数组<code>base</code>中选择一份基料，以及从可选数组<code>topping</code>中选择0份、1份或者2份配料，组成的冰淇淋总价格最接近<code>target</code>且成本最低</p>
<h3 id="回溯-13"><a href="#回溯-13" class="headerlink" title="回溯"></a>回溯</h3><p>容易想到，给定数据量较少，可以用回溯算法对数组进行遍历，用<code>set</code>保存可行的方案，并最终选择最合适的一个价格返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    set&lt;int&gt; vec;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; toppingCosts, int target, int index, int res)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index == toppingCosts.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt; toppingCosts.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += toppingCosts[i];</span><br><span class="line">            vec.insert(res);</span><br><span class="line">            traceback(toppingCosts, target, i + 1, res);</span><br><span class="line">            res += toppingCosts[i];</span><br><span class="line">            vec.insert(res);</span><br><span class="line">            traceback(toppingCosts, target, i + 1, res);</span><br><span class="line">            res -= toppingCosts[i] * 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int closestCost(vector&lt;int&gt;&amp; baseCosts, vector&lt;int&gt;&amp; toppingCosts, int target) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        //int m = toppingCosts.size();</span><br><span class="line">        //for (int i = 0; i &lt; m; i++)</span><br><span class="line">        //&#123;</span><br><span class="line">        //    toppingCosts.push_back(toppingCosts[i]);</span><br><span class="line">        //&#125;</span><br><span class="line">        for (int i = 0; i &lt; baseCosts.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = baseCosts[i];</span><br><span class="line">            vec.insert(res);</span><br><span class="line">            traceback(toppingCosts, target, 0, res);</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        for (auto it: vec)</span><br><span class="line">        &#123;</span><br><span class="line">            if (abs(target - it) &lt; abs(ans - target))</span><br><span class="line">                ans = it;</span><br><span class="line">            else if(abs(target - it == abs(ans-target)))</span><br><span class="line">                ans = it &lt; ans? it:ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><del>因为最多可以添加两份配料，则将原数组<code>topping</code>中的元素都复制一遍，再进行回溯</del>，但会超时</p>
<p>则可以对数组<code>topping</code>中的同一个元素进行两次回溯递归，分别将一份和两份配料的价格传递到递归当中</p>
<p>无论价格是多少，都会被存入到<code>set</code>当中，因为难以在存入结果之前对结果的合法性进行判断，所以只能被动地存入所有结果，最后在遍历所有结果的时候，选取最合适的结果</p>
<h3 id="回溯优化-4"><a href="#回溯优化-4" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>优化在只需要用O(1)的空间存储结果，存储的不再是所有结果，而是最合适的结果，并对其进行维护</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int ans = INT_MAX;</span><br><span class="line">    void traceback(vector&lt;int&gt;&amp; toppingCosts, int target, int index, int res)</span><br><span class="line">    &#123;</span><br><span class="line">        if (abs(target-ans) &gt; abs(res-target))</span><br><span class="line">            ans = res;</span><br><span class="line">        if(abs(target-ans) == abs(res-target) &amp;&amp; res &lt; ans )</span><br><span class="line">            ans = res;</span><br><span class="line">        if(res &gt; target)</span><br><span class="line">            return;</span><br><span class="line">        for (int i = index; i &lt; toppingCosts.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            traceback(toppingCosts, target, i + 1, res + toppingCosts[i]);</span><br><span class="line">            traceback(toppingCosts, target, i + 1, res+ 2 * toppingCosts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int closestCost(vector&lt;int&gt;&amp; baseCosts, vector&lt;int&gt;&amp; toppingCosts, int target) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; baseCosts.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = baseCosts[i];</span><br><span class="line">            traceback(toppingCosts, target, 0, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><strong>回溯算法的题目要注意回溯参数<code>i</code>与 <code>index</code>，如果是<code>i</code>，则是允许元素重复加入结果集，在本题中，使用<code>i</code>作为参数传递而不是<code>i+1</code>，则意味着可以使用任意数量的配料<code>topping</code>，不符合题意；添加元素到结果集时，向递归函数传递的参数永远都是<code>i</code>而不是<code>index</code></strong></p>
<p><strong>因为有必选数组和可选数组的存在，对必选数组进行<code>for</code>循环遍历，再进行回溯，保证结果集中有必选数组的元素；而必选数组中又可以对不同数量的元素重复使用（同一个元素最多两次），则可以通过两次回溯调用来实现</strong></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/10/18/C3P%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="prev" title="C3P阅读笔记">
                  <i class="fa fa-chevron-left"></i> C3P阅读笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/11/09/C3P%E7%AC%AC%E4%B8%89%E3%80%81%E5%9B%9B%E9%83%A8%E5%88%86/" rel="next" title="C3P第三部分">
                  C3P第三部分 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
