

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Kevin Huang">
  <meta name="keywords" content="">
  
    <meta name="description" content="LeetCode回溯算法章节回溯模板12345678910void backtrace(参数)&amp;#123;	if(终止条件)		return;	for(每层中的元素)	&amp;#123;		存入结果		backtrace();调用回溯		删除存入的结果，回溯	&amp;#125;&amp;#125;   组合[组合](77. 组合 - 力扣（LeetCode）) 回溯从[1,N]中找到凑成K个数的所有组合，将[i,N]">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode回溯算法章节">
<meta property="og:url" content="https://kevin346-sc.github.io/2022/11/05/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/index.html">
<meta property="og:site_name" content="Serein’s Blog">
<meta property="og:description" content="LeetCode回溯算法章节回溯模板12345678910void backtrace(参数)&amp;#123;	if(终止条件)		return;	for(每层中的元素)	&amp;#123;		存入结果		backtrace();调用回溯		删除存入的结果，回溯	&amp;#125;&amp;#125;   组合[组合](77. 组合 - 力扣（LeetCode）) 回溯从[1,N]中找到凑成K个数的所有组合，将[i,N]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E6%A8%A1%E6%9D%BF.png">
<meta property="og:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E7%BB%84%E5%90%88.png">
<meta property="og:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg">
<meta property="og:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/IP.png">
<meta property="og:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%85%A8%E6%8E%92%E5%88%97.png">
<meta property="article:published_time" content="2022-11-05T08:03:18.000Z">
<meta property="article:modified_time" content="2022-12-04T06:35:34.000Z">
<meta property="article:author" content="Kevin Huang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kevin346-sc.github.io/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E6%A8%A1%E6%9D%BF.png">
  
  
  
  <title>LeetCode回溯算法章节 - Serein’s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kevin346-sc.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="LeetCode回溯算法章节"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-05 16:03" pubdate>
          2022年11月5日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          99 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">LeetCode回溯算法章节</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="LeetCode回溯算法章节"><a href="#LeetCode回溯算法章节" class="headerlink" title="LeetCode回溯算法章节"></a>LeetCode回溯算法章节</h1><h2 id="回溯模板"><a href="#回溯模板" class="headerlink" title="回溯模板"></a>回溯模板</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">backtrace</span>(参数)&#123;<br>	<span class="hljs-built_in">if</span>(终止条件)<br>		return;<br>	<span class="hljs-built_in">for</span>(每层中的元素)<br>	&#123;<br>		存入结果<br>		<span class="hljs-built_in">backtrace</span>();调用回溯<br>		删除存入的结果，回溯<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E6%A8%A1%E6%9D%BF.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>[组合](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>从[1,N]中找到凑成K个数的所有组合，将[i,N]（i&#x3D;1,2,3…N）看做一棵树的不同结点，每取出一个数就把剩下的数看做该结点的子结点，叶子结点则为符合要求的结果。因此，for循环中的是不断取出一个数进入递归，结束递归后删除，再递增取下一个数，直到遇到结束条件退出递归。即for循环会遍历[1,N]中所有的元素，每添加一个元素进入数组就进入一层递归，但进入递归后若符合终止条件则会跳出，避免了N次方的时间复杂度。也相当于枚举法，但会及时止损</p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E7%BB%84%E5%90%88.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><p>确定回溯终止条件</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(vec.size()<span class="hljs-operator">=</span><span class="hljs-operator">=</span>k)<br>&#123;<br>	res.push_back(vec)<span class="hljs-comment">;</span><br>	return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当数组大小符合要求时，也就是遇到了叶子结点，这一次递归就终止，并更新结果集</p>
</li>
<li><p>确定回溯返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res,vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> start)</span></span><br><span class="hljs-function"></span>&#123;<br>	不需要返回值<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i = start;i&lt;=n;i++)<br>&#123;<br>	vec<span class="hljs-selector-class">.push</span>(i);<br>	<span class="hljs-built_in">search</span>(n,k,res,vec,start+<span class="hljs-number">1</span>);<br>	vec<span class="hljs-selector-class">.pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> start)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == k)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= n; ++i)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">search</span>(n, k, res, vec, i + <span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">search</span>(n, k, res, vec, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="回溯优化"><a href="#回溯优化" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>在回溯算法当中，由于是回溯的本质就是枚举，对枚举的优化只在于剪枝，通过给定限定条件减少无必要的递归，本题也同样如此，以上版本中将start赋予到了i，却并没有考虑到start的位置要求，在某些分支中，start过于太大，导致剩下的元素不能满足k的数量要求，因此，可以对回溯进行剪枝优化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> start)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == k)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= n - (k - vec.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; ++i)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">search</span>(n, k, res, vec, i + <span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">search</span>(n, k, res, vec, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>剪枝的原因在于i不必从过于大的start中取值，因此将对for循环中i的循环结束语句修改，从进入递归之前剪枝</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回溯算法难点在于将题意转换成树形结构，对于树形结构可以更好的理解回溯，以及剪枝的操作</p>
<h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><h3 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h3><p>题目思路类似于上一题，只不过将取值范围固定在<code>1~9</code>之间，其余都一样</p>
<p>整体代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == k)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>) == n)<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt;= <span class="hljs-number">9</span>; i++)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">traceback</span>(k, n, res, vec, i + <span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">traceback</span>(k, n, res, vec, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="回溯优化-1"><a href="#回溯优化-1" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>在以上版本代码中，容易看出需要优化的地方在于取值的范围是递增的，一旦有满足总和的vec数组，后续的遍历中的数组总和只会更大，因此可以忽略掉后续的遍历。类似地，同样在递归进入条件判断语句中增加限制，考虑到是用数组总和来做判断是否需要剪枝，则增加一个形参<code>sum</code>表示当前<code>vec</code>数组的总和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span>&amp; sum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == k)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (sum == n)<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt;= <span class="hljs-number">9</span> &amp;&amp; (n - sum) &gt;= i; i++)<br>        &#123;<br>            sum += i;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">traceback</span>(k, n, res, vec, i + <span class="hljs-number">1</span>, sum);<br>            sum -= i;<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">traceback</span>(k, n, res, vec, <span class="hljs-number">1</span>, sum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在回溯法中，如果想要不重复地访问元素，则需要<code>traceback(k,n,res,vec,i+1)</code>而不是<code>traceback(k,n,res,vec,index+1)</code>，后者会在<code>i</code>遍历时，与<code>index+1</code>有重复值，且重复值只从2开始</p>
<p>本题是与上题相同的回溯思路，但不同的剪枝思路。</p>
<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>[电话号码的字母组合](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h3><p>与前些题目不同的是，没有直接能获取到要进入递归的范围，即递归树的结点，需要借助容器来获取数值范围，这里使用数组保存<code>0~9</code>所分别对应的字母。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt;&gt; hashmap&#123;<br>    &#123;&#125;,<br>    &#123;&#125;,<br>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>&#125; &#125;;<br></code></pre></td></tr></table></figure>

<p>这里保存0,1两个空数组是为了方便索引访问直接对应</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(digits.size()<span class="hljs-operator">=</span><span class="hljs-operator">=</span>str.size())<br>&#123;<br>	res.push_back(str)<span class="hljs-comment">;</span><br>	return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traceback</span>(<span class="hljs-params">vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; res, <span class="hljs-built_in">string</span>&amp; str,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;digits,<span class="hljs-built_in">int</span> index</span>)</span>;<br></code></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;hashmap[digit].size();i++)<br>        &#123;<br>            <span class="hljs-built_in">str</span> += hashmap[digit][i];<br>            traceback(res,<span class="hljs-built_in">str</span>,digits,<span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">str</span>.pop_back();<br>        &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; hashmap&#123;<br>        &#123;&#125;,<br>        &#123;&#125;,<br>    &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;z&quot;</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">void</span> traceback(vector&lt;string&gt;&amp; res,string&amp; <span class="hljs-built_in">str</span>,<span class="hljs-keyword">const</span> string &amp;digits,<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">str</span>.size()==digits.size())<br>        &#123;<br>            res.push_back(<span class="hljs-built_in">str</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> digit = digits[<span class="hljs-keyword">index</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;hashmap[digit].size();i++)<br>        &#123;<br>            <span class="hljs-built_in">str</span> += hashmap[digit][i];<br>            traceback(res,<span class="hljs-built_in">str</span>,digits,<span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">str</span>.pop_back();<br>        &#125;<br>    &#125;<br>    vector&lt;string&gt; letterCombinations(string digits) &#123;<br>        vector&lt;string&gt; res;<br>        string <span class="hljs-built_in">str</span>;<br><br>        <span class="hljs-keyword">if</span>(digits.empty())  <span class="hljs-keyword">return</span> res;<br>        traceback(res,<span class="hljs-built_in">str</span>,digits,<span class="hljs-number">0</span>);        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>由回溯过程可知，这个版本的回溯代码不需要剪枝优化。</p>
<p>在本题中，传入递归函数的<code>index</code>形参用来获取<code>digits</code>中的下一位数字，保证每次for循环的都是不同进位上的数字，也是这道题的最大变化点。并且不需要传入其余参数用于表示开始遍历的结点索引，因为需要遍历的是对应数字上的所有字母</p>
<h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>[组合总和](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-3"><a href="#回溯-3" class="headerlink" title="回溯"></a>回溯</h3><p>这道题给定一个数组和目标值，要求从数组中找到不限数量的数组元素，令其和等于目标值，并且能够重复用数组中的元素。最大的不同点在于能够重复使用数组元素，首先能想到的就是不需要index形参，不能让递归每次都从下一个元素开始遍历。</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(target <span class="hljs-operator">=</span><span class="hljs-operator">=</span> sum)<br>&#123;<br>	res.push_back(vec)<span class="hljs-comment">;</span><br>	return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>容易想到只要让当前数组的和等于目标值即可结束该层递归，即到达叶子结点。但是这样就会导致了死循环，因为如果一旦数组和大于目标值，则递归永远不会退出。因此需要加上对sum值的限制（在进入递归前判断）</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res,<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;vec,<span class="hljs-type">int</span> <span class="hljs-built_in">target</span>,<span class="hljs-type">int</span> &amp;<span class="hljs-built_in">sum</span>,<span class="hljs-type">int</span> startindex)<br></code></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">for (<span class="hljs-built_in">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-keyword">target</span> &gt; <span class="hljs-built_in">sum</span>; i++)<br>        &#123;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-keyword">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            vec.pop_back();<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>在这，startindex作为每次遍历时开始的索引下标，与[III](# 组合总和III)不同，传入到下一次递归的是<code>i</code>而不是<code>i+1</code>，这是因为<strong>允许重复元素的存在</strong></p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span>&amp; <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> startindex)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)<br>        &#123;<br>            res.push_back(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">target</span> 》 <span class="hljs-built_in">sum</span>; i++)<br>        &#123;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            vec.pop_back();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="回溯优化-2"><a href="#回溯优化-2" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>可以想到，如同[III](# 组合总和III)，剪枝优化的思路在于当<strong>数组递增</strong>时，一旦有满足目标值的数组元素，往后的元素再进入递归，vec数组的和都会大于目标值，因此可以剪掉，所以<strong>先给数组进行排序</strong>，然后在<strong>递归进入前加以条件的限制</strong></p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span>&amp; <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> startindex)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)<br>        &#123;<br>            res.push_back(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; (<span class="hljs-built_in">target</span> - <span class="hljs-built_in">sum</span>) &gt;= candidates[i]; i++)<br>        &#123;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            vec.pop_back();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec;<br>        sort(candidates.begin(), candidates.end());<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>当允许重复元素出现时，在进入下一层递归时就可以传入<code>i</code>而不是<code>i+1</code>。</p>
<p>因为给出的数组非递增，需要先对数组进行排序，优化效果不明显</p>
<h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>[组合总和II](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-4"><a href="#回溯-4" class="headerlink" title="回溯"></a>回溯</h3><p>该题与[II](# 组合总和II)的区别就在于输入的<code>candidates</code>数组允许有重复元素的出现，但<strong>每个元素只能使用一次</strong>，因此传递到下一层递归中的索引就必须是<code>index+1</code>。</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span>&amp; <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> startindex)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)<br>        &#123;<br>            res.push_back(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">target</span> &gt; <span class="hljs-built_in">sum</span>; i++)<br>        &#123;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            vec.pop_back();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>此外，如果<code>candidates</code>中有重复元素，会导致同层的结点中可能会选取一样的值进入到下一层递归中，就会导致最终结果出现有<strong>相同元素的分组</strong>，如以上版本的代码，仅修改了上一题的<code>index</code>传递值。原因在于，可能会出现保存到<code>res</code>中的元素在回溯删除之后，因为相同值的元素存在，在遍历剩余元素时又被重新添加进去。</p>
<p>可以针对这种情况设立一个<code>tmp</code>变量，先对<code>candidates</code>进行排序，<code>tmp</code>记录刚被删除的元素的值，再下一个元素被添加时判断是否等于<code>tmp</code>，只有不相等时才会被添加进去。</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br><span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span>&amp; <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> startindex)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)<br>        &#123;<br>            res.push_back(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; (<span class="hljs-built_in">target</span>-<span class="hljs-built_in">sum</span>) &gt;= candidates[i]; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmp == candidates[i])<br>                <span class="hljs-keyword">continue</span>;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            tmp = candidates[i];<br>            vec.pop_back();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum2(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        sort(candidates.begin(),candidates.end());<br>        traceback(candidates, res, vec, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>另一种方法</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fortran">for (<span class="hljs-built_in">int</span> i = startindex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; (<span class="hljs-keyword">target</span>-<span class="hljs-built_in">sum</span>) &gt;= candidates[i]; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; startindex &amp;&amp; candidates[i] == candidates[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            vec.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            traceback(candidates, res, vec, <span class="hljs-keyword">target</span>, <span class="hljs-built_in">sum</span>, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            vec.pop_back();<br>        &#125;<br></code></pre></td></tr></table></figure>

<h3 id="回溯优化-3"><a href="#回溯优化-3" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>剪枝优化过程同<a href="#%E5%9B%9E%E6%BA%AF%E4%BC%98%E5%8C%96%602">上题</a>，以上版本代码已剪枝</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>candidates</code>没有重复元素，但结果输出可以有重复元素，则修改<code>index</code></p>
<p><code>candidates</code>有重复元素，但结果输出不能有重复元素，即相同元素的分组，则通过添加限制条件防止重复元素进入递归</p>
<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>[分割回文串](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-5"><a href="#回溯-5" class="headerlink" title="回溯"></a>回溯</h3><p>相比较于之前的题目，该题变化点主要集中在于递归结束判断条件，在满足回文的条件的同时，还需要<strong>将整个字符串完全分割</strong></p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (index &gt;<span class="hljs-operator">=</span> s.size())<br>&#123;<br>    if (judge())<br>       res.push_back(vec)<span class="hljs-comment">;</span><br>    return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于不能添加重复元素进入递归，所以需要index形参，需要在对整个字符串完成分割的时候才停止递归，并且要满足回文的条件才能保存结果</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> traceback(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> index)<br></code></pre></td></tr></table></figure>
</li>
<li><p>确定单层逻辑</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = index; i &lt; s.size<span class="hljs-literal">()</span>; ++i)<br>&#123;<br>    vec.push<span class="hljs-constructor">_back(<span class="hljs-params">s</span>.<span class="hljs-params">substr</span>(<span class="hljs-params">index</span>,<span class="hljs-params">i</span>+1-<span class="hljs-params">index</span>)</span>);<br>    traceback(s, i + <span class="hljs-number">1</span>);<br>    vec.pop<span class="hljs-constructor">_back()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    vector&lt;string&gt; vec;<br>    string str;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> sustr:vec)<br>        &#123;<br>            <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = sustr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;=j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(sustr[i]!=sustr[j])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                ++i,--j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (index&gt;=s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>())<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(index,i+<span class="hljs-number">1</span>-index));<br>            <span class="hljs-built_in">traceback</span>(s, i + <span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> vector&lt;vector&lt;string&gt;&gt;&#123;&#123;s&#125;&#125;;<br>        <span class="hljs-built_in">traceback</span>(s, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>此外，还可以在进入递归前完成对回文串的判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    vector&lt;string&gt; vec;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> en,string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(st&lt;=en)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[st]!=s[en])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ++st,--en;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (index&gt;=s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judge</span>(index,i,s))<br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(index,i+<span class="hljs-number">1</span>-index));<br>            <span class="hljs-built_in">traceback</span>(s, i + <span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> vector&lt;vector&lt;string&gt;&gt;&#123;&#123;s&#125;&#125;;<br>        <span class="hljs-built_in">traceback</span>(s, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>难点在于</p>
<ul>
<li><p><strong>切割问题</strong>转换成<strong>组合问题</strong></p>
<p>关键在于模拟出树形结构</p>
</li>
<li><p>字符串分割如何用代码实现</p>
<p>利用index，以及substr函数，把递归开始时的初值模拟为切割线</p>
</li>
<li><p>判断回文串</p>
<p>双指针法；动态规划</p>
</li>
<li><p>递归结束条件的判断</p>
</li>
</ul>
<h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>本题也属于切割问题，但切割完成的判断更为复杂，切割的IP地址分为4段，需要直接在原字符串中加上<code>&#39;.&#39;</code>表示分段，分段中的IP地址不能有前导0，不能大于255，否则都将是无效的IP。</p>
<p>转换成树形结构</p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/IP.png" srcset="/img/loading.gif" lazyload></p>
<p>首先，确定判断IP段是否有效</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> ok(<span class="hljs-keyword">const</span> string&amp; s, <span class="hljs-built_in">int</span> st, <span class="hljs-built_in">int</span> en)<br>&#123;<br>	<span class="hljs-keyword">if</span>(st &gt; en)<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	<span class="hljs-keyword">if</span>(s[st] == <span class="hljs-number">0</span> &amp;&amp; st!=en)<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = st; i &lt;= en; i++)<br>	&#123;<br>		<span class="hljs-built_in">num</span> = <span class="hljs-built_in">num</span>*<span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span> &gt; <span class="hljs-number">255</span>)<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果仅仅是首元素为0还不一定无效，IP地址段可以只有一个0，但不能是前导0</p>
<p>计算IP地址段可以用<code>for</code>循环，逐位相加，一旦某一位已经超过255则直接返回<code>false</code></p>
<h3 id="回溯1"><a href="#回溯1" class="headerlink" title="回溯1"></a>回溯1</h3><ol>
<li><p>递归结束条件</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">if</span>(comma == <span class="hljs-number">3</span>)<br>&#123;<br>	<span class="hljs-built_in">if</span>(ok(s,index,s.size()-<span class="hljs-number">1</span>))<br>		res<span class="hljs-selector-class">.push_back</span>(s);<br>	return;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为是直接在源字符串中做分割，在加了3个<code>&#39;.&#39;</code>的情况下，还需要对最后一段IP进行判断是否有效才能加入到结果集中</p>
</li>
<li><p>递归返回值</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">void traceback(vector<span class="hljs-symbol">&lt;string&gt;</span>&amp; <span class="hljs-keyword">res</span>, <span class="hljs-keyword">int</span> comma, <span class="hljs-keyword">int</span> <span class="hljs-built_in">index</span>, <span class="hljs-built_in">string</span>&amp; s)<br></code></pre></td></tr></table></figure>

<p>因为直接在源字符串上操作，并且需要找到所有有效的IP地址，因此不需要返回值。传入参数为引用，不用拷贝并且允许直接修改、删除等操作</p>
</li>
<li><p>单层逻辑</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">index</span>; i &lt; s.size(); i++)<br>&#123;<br>	s.<span class="hljs-keyword">insert</span>(s.<span class="hljs-keyword">begin</span>() + i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>	++comma;<br>	traceback(res, comma, i + <span class="hljs-number">2</span>, s);<br>	<span class="hljs-comment">--comma;</span><br>	s.erase(s.<span class="hljs-keyword">begin</span>() + i + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>insert</code>函数将<code>&#39;.&#39;</code>插在输入的迭代器之前，即取代输入的迭代器位置，<code>erase</code>则是删除输入迭代器当前位置上的元素。进入递归由于插入多了一位，则下一层递归中需要从<code>index = i+2</code>开始</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">ok</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-built_in">int</span> st, <span class="hljs-built_in">int</span> en</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (st &gt; en)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (s[st] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; st != en)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = st; i &lt;= en; i++) <br>        &#123;<br><br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>            <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traceback</span>(<span class="hljs-params">vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; res, <span class="hljs-built_in">int</span> index, <span class="hljs-built_in">int</span> comma, <span class="hljs-built_in">string</span>&amp; s</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (comma == <span class="hljs-number">3</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ok(s, index, s.size() - <span class="hljs-number">1</span>))<br>            &#123;<br>                res.push_back(s);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = index; i &lt; s.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ok(s, index, i))<br>            &#123;<br>                s.insert(s.begin() + i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                ++comma;<br>                traceback(res, i + <span class="hljs-number">2</span>, comma, s);<br>                --comma;<br>                s.erase(s.begin() + i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">restoreIpAddresses</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> &#123;<br>        vector&lt;<span class="hljs-built_in">string</span>&gt; res;<br>        traceback(res, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, s);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="回溯2"><a href="#回溯2" class="headerlink" title="回溯2"></a>回溯2</h3><p>另外一种解法是， 不在源字符串上修改，而是将4段IP地址一段一段的加入一个空字符串中</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt;ans;<br>    <span class="hljs-keyword">void</span> backtrace(string&amp; s,<span class="hljs-built_in">int</span> cnt,<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>,string&amp; <span class="hljs-built_in">str</span>)&#123;<br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span> || <span class="hljs-keyword">index</span>==s.size() )&#123;<br>            <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span> &amp;&amp; <span class="hljs-keyword">index</span>==s.size())<br>                ans.push_back(<span class="hljs-built_in">str</span>.substr(<span class="hljs-number">0</span>,<span class="hljs-built_in">str</span>.size()<span class="hljs-number">-1</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span>+i&gt;s.size()) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(s[<span class="hljs-keyword">index</span>]==<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; i!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span> &amp;&amp; s.substr(<span class="hljs-keyword">index</span>,i)&gt;<span class="hljs-string">&quot;255&quot;</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-built_in">str</span>+=s.substr(<span class="hljs-keyword">index</span>,i);<br>            <span class="hljs-built_in">str</span>.push_back(<span class="hljs-string">&#x27;.&#x27;</span>);<br>            backtrace(s,cnt+<span class="hljs-number">1</span>,<span class="hljs-keyword">index</span>+i,<span class="hljs-built_in">str</span>);<br>            <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span>.substr(<span class="hljs-number">0</span>,<span class="hljs-built_in">str</span>.size()-i<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    vector&lt;string&gt; restoreIpAddresses(string s) &#123;<br>        string <span class="hljs-built_in">str</span> =<span class="hljs-string">&quot;&quot;</span>;<br>        backtrace(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">str</span>);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>回溯1是从一整段IP地址直接做分割，回溯2则是将各段分割好的小段最终才拼凑成完整的IP地址，这样做的好处是对于各段统一判断是否有效，而不用像回溯1中在添加了最后一个<code>&#39;.&#39;</code>之后，添加到结果集之前还要做一次有效判断。并且在回溯2中，判断有效更加简洁，可以利用加入的子段最多只有3位直接与”255”进行判断，而回溯1中可能会出现不止3位的IP地址，因此不能直接与”255”判断，但可以修改成<code>if(en - st == 2 &amp;&amp; s.substr(s.begin() + st, 3) &gt; &quot;255&quot;) return false;</code>以及<code>if(en - st &gt; 2)	return false;</code></p>
<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><h3 id="回溯-6"><a href="#回溯-6" class="headerlink" title="回溯"></a>回溯</h3><p>子集问题中，依旧还是回溯的总体思路，不同在于之前结束条件的判断，仅仅只是遍历到数组结尾就退出</p>
<p>整体代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums,vector&lt;<span class="hljs-type">int</span>&gt;&amp;vec,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;res,<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&gt;=nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-built_in">traceback</span>(nums,vec,res,i+<span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(vec);<br>        <span class="hljs-built_in">traceback</span>(nums,vec,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>子集问题不需要有判断条件，就直接存入结果集中，相当于将树型结构上的<strong>每个结点</strong>；而组合和切割问题则是<strong>保留叶子结点</strong></p>
<h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><h3 id="回溯-7"><a href="#回溯-7" class="headerlink" title="回溯"></a>回溯</h3><p>给定输入数组中含有重复元素，但要求输出结果中不能有重复子数组，与[组合总和II](# 组合总和II)思路一致，且其余同<a href="#%E5%AD%90%E9%9B%86">子集</a>的处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums,vector&lt;<span class="hljs-type">int</span>&gt;&amp;vec,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;res,<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&gt;=nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-built_in">traceback</span>(nums,vec,res,i+<span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(vec);<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">traceback</span>(nums,vec,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>[递增子序列](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/increasing-subsequences/">491. 递增子序列 - 力扣（LeetCode）</a>)</p>
<h3 id="回溯-8"><a href="#回溯-8" class="headerlink" title="回溯"></a>回溯</h3><p>这道题需要理解的几个关键点：</p>
<ul>
<li>要求是子序列，则不能对其排序，有点类似于分割问题但可以只取两边不取中间，即<code>[1,2,3]</code>选<code>[1,3]</code></li>
<li>要求是非严格递增，则在进入递归前应先进行判断，</li>
<li>输入数组中可能会有重复元素，但输出不能包含重复子数组</li>
</ul>
<p>可知，需要在<strong>不能排序</strong>的情况下，还要在递归过程中排除重复项，回溯的时候应该借助容器来帮助<strong>辨别重复项</strong>，容易想到用<code>unordered_set</code>容器储存结果用于去除重复项，然后遍历容器将没有重复的元素依次存放到<code>vector</code>中，但是，不能直接定义<code>unordered_set&lt;vector&lt;int&gt;&gt;</code>，还要有自定义的哈希函数。因此可以<strong>转换思路，在每一层的结点循环中设置一个<code>unordered_set</code>，即单单不允许这一层有重复被选数</strong>，这就避免重复项进入递归，因为前一个所选就囊括了后面所有相同数的子序列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br>        <span class="hljs-keyword">if</span>(index&gt;=nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(!vec.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i]&lt;vec.<span class="hljs-built_in">back</span>())<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(uset.<span class="hljs-built_in">find</span>(nums[i])!=uset.<span class="hljs-built_in">end</span>())<br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            uset.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-built_in">traceback</span>(nums,res,vec,i+<span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();            <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">traceback</span>(nums,res,vec,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="回溯优化1"><a href="#回溯优化1" class="headerlink" title="回溯优化1"></a>回溯优化1</h3><p>以上版本的代码，用到了<code>unordered_set</code>，又因为总数据量较小，可以用<code>vector</code>替代<code>unordered_set</code>以减少开销</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(<span class="hljs-number">201</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span>(index&gt;=nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(!vec.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i]&lt;vec.<span class="hljs-built_in">back</span>())<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[nums[i]+<span class="hljs-number">100</span>]==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[nums[i]+<span class="hljs-number">100</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-built_in">traceback</span>(nums,res,vec,i+<span class="hljs-number">1</span>);<br>            vec.<span class="hljs-built_in">pop_back</span>();            <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">traceback</span>(nums,res,vec,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="回溯优化2"><a href="#回溯优化2" class="headerlink" title="回溯优化2"></a>回溯优化2</h3><p>另一种回溯模板的解法，不需要用到额外的容器来记录，但较难理解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums,<span class="hljs-type">int</span> cur,<span class="hljs-type">int</span> last)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur&gt;=nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)<br>                res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[cur]&gt;=last)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>            <span class="hljs-built_in">traceback</span>(nums,cur+<span class="hljs-number">1</span>,nums[cur]);<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[cur]!=last)<br>            <span class="hljs-built_in">traceback</span>(nums,cur+<span class="hljs-number">1</span>,last);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">traceback</span>(nums,<span class="hljs-number">0</span>,<span class="hljs-number">-101</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>选择合法项：只有<code>cur</code>值大于等于<code>last</code>，才会选择该元素（添加到vec中）</p>
<p><strong>不借助容器就能排除重复项：只有<code>last</code>和<code>cur</code>指向的值不相同时，才会不选择该结点（不添加到<code>vec</code>中），也就是说当有多个重复元素时，只选最后一个以避免重复</strong></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>另一种回溯模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>vector&lt;<span class="hljs-type">int</span>&gt; temp;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == nums.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>() &amp;&amp; <span class="hljs-built_in">notVisited</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果选择当前元素</span><br>    temp.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>    <span class="hljs-built_in">dfs</span>(cur + <span class="hljs-number">1</span>, nums);<br>    temp.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-comment">// 如果不选择当前元素</span><br>    <span class="hljs-built_in">dfs</span>(cur + <span class="hljs-number">1</span>, nums);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>[子集](# 子集)新解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur&gt;=nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br><br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        vec.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>        <span class="hljs-built_in">traceback</span>(cur+<span class="hljs-number">1</span>,nums);<br>        vec.<span class="hljs-built_in">pop_back</span>();<br>        <br>        <span class="hljs-built_in">traceback</span>(cur+<span class="hljs-number">1</span>,nums);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">traceback</span>(<span class="hljs-number">0</span>,nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>[子集II](# 子集II)新解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur&gt;=nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        vec.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>        <span class="hljs-built_in">traceback</span>(cur+<span class="hljs-number">1</span>,nums);<br>        vec.<span class="hljs-built_in">pop_back</span>();<br><br>        <span class="hljs-keyword">while</span>(cur &lt; nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> &amp;&amp; nums[cur]==nums[cur+<span class="hljs-number">1</span>])<br>            ++cur;<br>        <span class="hljs-built_in">traceback</span>(cur+<span class="hljs-number">1</span>,nums);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">traceback</span>(<span class="hljs-number">0</span>,nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>该题最关键是在不排序的前提下，排除重复项进入递归，需要借助容器，<strong>并且是在每层递归中重新定义一个容器，从而避免同层相同元素进入递归</strong></p>
<p>另一种回溯模板，<strong>不对应树形结构</strong>，因而更难理解；优先处理更多元素的情况，但因其一层两次递归，时间复杂度更高，但指针使用更加灵活，减少对容器的使用，降低空间复杂度</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><h3 id="回溯-9"><a href="#回溯-9" class="headerlink" title="回溯"></a>回溯</h3><p>排列问题，容易得知，每次递归时需要从0开始遍历数组，这就意味着不能像组合总和一样代入index对递归进行限制。并且，需要借助容器来记录遍历的当前值是否有被使用过。将全排列转化成树形结构，则同一个树枝上不能够有重复值，那么就可以借助全局的<code>vector</code>进行记录，与<code>vec</code>同步增删元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index,vector&lt;<span class="hljs-type">int</span>&gt; &amp;used)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (used[nums[i] + <span class="hljs-number">10</span>] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[nums[i] + <span class="hljs-number">10</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">traceback</span>(nums, index + <span class="hljs-number">1</span>,used);<br>            used[nums[i] + <span class="hljs-number">10</span>] = <span class="hljs-number">0</span>;<br>            vec.<span class="hljs-built_in">pop_back</span>();<br><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(<span class="hljs-number">21</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-built_in">traceback</span>(nums, <span class="hljs-number">0</span>,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>与[递增子序列](# 递增子序列)一样，可以通过<code>unordered_set</code>以及<code>vector</code>来记录，<code>vector</code>在数组样本小的情况下性能更加优越</p>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li>组合之和：只能往后选取（排列顺序不影响结果），故需要用index记录每次递归开始选取的位置；去重则通过排序后再对当前值进行是否与前值重复判断</li>
<li>分割：与组合之和差别在于终止条件，分割必须要字符串全部分割</li>
<li>子集：与组合之和差别在于子集的每个结点都是结果集</li>
<li>全排列：不需要index记录每次递归开始选取的位置，因为有排列顺序要求；去重因为没有index，需要借助容器来记录是否被选取过，通常选<code>vector</code></li>
</ul>
<h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><h3 id="回溯1-1"><a href="#回溯1-1" class="headerlink" title="回溯1"></a>回溯1</h3><p>在[全排列](# 全排列)基础上，输入数组可能会有重复值，即不仅在树枝上不能够有重复值，在树层上也不允许有重复值的存在，但是不能直接加上<strong>排序后再判断当前值与前一值是否相等的</strong>去重操作。因为重复值的存在，当在同一条路径上，即树枝上允许有重复值的存在（来源于不同的等值元素），针对树枝上的重复值，可以借助<code>vector</code>先遍历<code>nums</code>记录每个数值的个数，用来判断这个树枝上是否还能使用该数值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index,vector&lt;<span class="hljs-type">int</span>&gt; &amp;used)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (used[nums[i] + <span class="hljs-number">10</span>] == <span class="hljs-number">0</span>)<span class="hljs-comment">//树枝去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<span class="hljs-comment">//树层去重，同时防止树枝上取已取过的值</span><br>                <span class="hljs-keyword">continue</span>;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            --used[nums[i] + <span class="hljs-number">10</span>];<br>            <span class="hljs-built_in">traceback</span>(nums, index + <span class="hljs-number">1</span>,used);<br>            ++used[nums[i] + <span class="hljs-number">10</span>];<br>            vec.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(<span class="hljs-number">21</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:nums)<br>        &#123;<br>            ++used[i+<span class="hljs-number">10</span>];<br>        &#125;<br>        <span class="hljs-built_in">traceback</span>(nums, <span class="hljs-number">0</span>,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>关键语句在于<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])	continue;</code>，既做到了对同一层上的结点去重，也做到在一棵树枝上对取过的值的去重（全排列的要求，相当于全排列中的used数组）</strong></p>
<h3 id="回溯2-1"><a href="#回溯2-1" class="headerlink" title="回溯2"></a>回溯2</h3><p>另一种做法</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;used[i<span class="hljs-number">-1</span>]==<span class="hljs-literal">false</span>)<span class="hljs-comment">//树层去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[i]==<span class="hljs-literal">false</span>)<span class="hljs-comment">//树枝去重</span><br>            &#123;<br>                used[i]=<span class="hljs-literal">true</span>;<br>                vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">traceback</span>(nums,used);<br>                used[i]=<span class="hljs-literal">false</span>;<br>                vec.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">traceback</span>(nums,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>直观的用<code>used</code>数组表示原始数组中的每一个值是否使用过，是对全排列的进一步改进。不只是加上直接加上<strong>排序后再判断当前值与前一值是否相等的</strong>去重操作，为了防止树枝上的多余去重，额外增加了<code>&amp;&amp;used[i-1]==false</code>，限定了只在树层上去重，而不影响树枝上对等值元素的取用</p>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>在全排列的基础上，只增加<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])	continue;</code>语句会导致竖向上首元素会被重复加入（因为i从0开始），而语句本意是跳过横向重复结点和跳过已加入的竖向重复结点，因此，要么选择再增加对跳过竖向结点的限制，如[回溯2](# 回溯2)用额外<code>used</code>数组记录每个元素是否被访问过，如果前一个元素未被访问<code>nums[i-1]==false</code>，且满足当前元素与前一个元素相同<code>i&gt;0 &amp;&amp; nums[i]==nums[i-1]</code>，证明这是在横向上的重复结点（树层），应当跳过，而竖向上如果再次访问访问过的结点<code>used[i]==true</code>，则会执行跳过，不重复加入结果中（另一个角度，如果在满足当前元素与前一个元素相同<code>i&gt;0 &amp;&amp; nums[i]==nums[i-1]</code>时，前一个元素被访问过<code>nums[i-1]==true</code>，此时当前元素也可以被跳过，保留的是横向上的结点，而竖向重复结点被跳过）；要么在<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])	continue;</code>语句不能跳过已加入的竖向重复结点和横向重复结点的情况下，限制加入的重复结点数量如[回溯1](# 回溯1)用<code>used</code>数组记录每一个结点的数量，那么当i从开始时，只会最多加入原数组数量的元素，一旦超过就会被跳过。以上两种算法过程都如下图，</p>
<p><img src="/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/%E5%85%A8%E6%8E%92%E5%88%97.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a><strong>重新安排行程</strong></h2><h3 id="回溯-10"><a href="#回溯-10" class="headerlink" title="回溯"></a>回溯</h3><p>本题中，关键点在于</p>
<ul>
<li>记录出发机场和目标机场的容器，同时还要记录是否访问过，防止死循环</li>
<li>回溯的终止条件，因为一定存在合理路径，所以机票数+1 &#x3D; 机场数</li>
<li>容器按字典序排列目标机场，若访问字典序较高的目标机场时，该机场是死胡同，则应返回或者回溯</li>
<li>回溯的返回值应该是bool类型，用返回值来判断是否应该回溯（删除死胡同元素）</li>
</ul>
<ol>
<li><p>递归终止条件</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">if</span>(tickets.<span class="hljs-keyword">size</span>()==res.<span class="hljs-keyword">size</span>()-<span class="hljs-number">1</span>)<br>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>递归返回值</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lsl">bool traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">string</span>&gt;&amp;res,<span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">string</span>&gt;&gt;&amp; tickets)<br></code></pre></td></tr></table></figure>

<p>当返回值为true时，意味着已添加到结果集的元素符合要求，应该直接返回，而不应回溯（删除）；但当返回值为false时，代表着根据字典序优先访问到的这个机场无法再访问其他机场，是个死胡同，应该回溯（pop_back)</p>
</li>
<li><p>递归单层逻辑</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">for</span>(auto const &amp; ticket:tickets[res[res.size()<span class="hljs-number">-1</span>]])<br>&#123;<br>	<span class="hljs-keyword">if</span>(ticket.<span class="hljs-keyword">second</span>&gt;<span class="hljs-number">0</span>)<br>	&#123;<br>		res.push_back(ticket.<span class="hljs-keyword">first</span>);<br>		ticket.<span class="hljs-keyword">second</span><span class="hljs-comment">--;</span><br>		<span class="hljs-keyword">if</span>(traceback(res,tickets))	<span class="hljs-literal">return</span> <span class="hljs-literal">true</span>;<br>		ticket.<span class="hljs-keyword">second</span>++;<br>		res.pop_back();<br>	&#125;<br>&#125;<br><span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>
<p>上述代码在取目的机场的map时，使用范围for循环，<code>auto &amp;ticket:tickets[res[res.size()-1]]</code>等价于<code>pair&lt;const string,int&gt; &amp;ticket:tickets[res[res.size()-1]]</code>，其中因为map的key值不能改变，所以一定要用const引用，或者只是用副本<code>pair&lt;string,int&gt;ticket:tickets[res[res.size()-1]]</code>。而当不使用范围for循环时，类型符就要更改为<code>map&lt;const string, int&gt;&amp; ticket = tickets[res[res.size()-1]]</code>，因为赋值需要同样的类型或者可转变的类型，而pair不能转变为map</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;string, map&lt;string, <span class="hljs-type">int</span>&gt;&gt; targets;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;string&gt;&amp; res, vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() == tickets.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; target:targets[res[res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(target.second&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                target.second--;<br>                res.<span class="hljs-built_in">push_back</span>(target.first);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traceback</span>(res,tickets))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                res.<span class="hljs-built_in">pop_back</span>();<br>                target.second++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ticket : tickets)<br>        &#123;<br>            targets[ticket[<span class="hljs-number">0</span>]][ticket[<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        <span class="hljs-built_in">traceback</span>(res, tickets);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="special解法"><a href="#special解法" class="headerlink" title="special解法"></a>special解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, std::greater&lt;string&gt;&gt;&gt; vec;<br><br>    vector&lt;string&gt; stk;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; curr)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (vec.<span class="hljs-built_in">count</span>(curr) &amp;&amp; vec[curr].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>            string tmp = vec[curr].<span class="hljs-built_in">top</span>();<br>            vec[curr].<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-built_in">move</span>(tmp));<br>        &#125;<br>        stk.<span class="hljs-built_in">emplace_back</span>(curr);<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : tickets) &#123;<br>            vec[it[<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace</span>(it[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br><br>        <span class="hljs-built_in">reverse</span>(stk.<span class="hljs-built_in">begin</span>(), stk.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> stk;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>按字典序从<code>priority_queue</code>中访问目标机场，对新访问的机场进行深度有限搜索，并删除访问过的机场，直到该机场是最后一个机场，则添加到数组当中，再不断返回，将之前访问过的机场也添加到数组中，最后将数组逆序即为结果集</p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>该题巧妙选择容器，记录复杂的信息，用<code>unordered_map</code>记录出发机场和目标机场，是因为不需要对出发机场进行排序，为了减少开销，用<code>map&lt;string,int&gt;</code>按字典序记录目标机场及机票数，不使用<code>multiset</code>单纯记录目标机场，就是为了防止同一张机票的重复访问，防止死循环</p>
<p>在第二种解法中，使用不用的容器来记录，通过优先队列来按字典序记录目标机场，每次访问只需要<code>p.top()</code>，访问时间复杂度是O(1)，删除的时间复杂度是O(logm)</p>
<h2 id="破解保险箱"><a href="#破解保险箱" class="headerlink" title="破解保险箱"></a>破解保险箱</h2><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a><strong>N皇后</strong></h2><p>[N皇后](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a>)</p>
<p>要求在<code>n*n</code>的棋盘上放置n个皇后，并且皇后互相不能攻击，即同行同列包括斜角线上不能有两个皇后</p>
<p>逐行遍历棋盘，因为只需要在一行中摆放一个皇后，则不需要两层循环遍历，同时还要有判断是否冲突的函数</p>
<p>首先，根据规则判断在该位置上放置皇后是否会被攻击</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">bool</span> noattack(vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">row</span>)<br>&#123;<br>	//列<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(chessboard[i][<span class="hljs-keyword">index</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>	<br>	//左上角斜线<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">row</span> - <span class="hljs-number">1</span>, j = <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--, j--)</span><br>	&#123;<br>		<span class="hljs-keyword">if</span>(chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>	<br>	//右上角斜线<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-keyword">row</span> - <span class="hljs-number">1</span>, j = <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i<span class="hljs-comment">--, j++)</span><br>	&#123;<br>		<span class="hljs-keyword">if</span>(chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为是每一行遍历，因此不需要判断同行是否还有其他皇后；也因为是逐行往下遍历，不需要判断下方是否还有其他皇后，仅判断左上和右上方即可</p>
<h3 id="回溯-11"><a href="#回溯-11" class="headerlink" title="回溯"></a>回溯</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if(chessboard.size()<span class="hljs-operator">=</span><span class="hljs-operator">=</span>n)<br>&#123;<br>	res.push_back(chessboard)<span class="hljs-comment">;</span><br>	return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>不断添加单行到棋盘中，当棋盘中数量达到n时，就是一个符合要求的棋盘摆法</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">void</span></span> traceback(...)<br><br></code></pre></td></tr></table></figure>

<p>因为可能有多种不同符合规则的摆法，因此返回值为void，遍历所有可能值再返回</p>
</li>
<li><p>确定单层逻辑</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++)<br>&#123;<br>    <span class="hljs-built_in">if</span> (noattack(chessboard, <span class="hljs-built_in">n</span>,<span class="hljs-built_in">index</span>,i))<br>    &#123;<br>        chessboard[<span class="hljs-built_in">index</span>][i] = &#x27;Q&#x27;;<br>        traceback(res, <span class="hljs-built_in">n</span>, chessboard, <span class="hljs-built_in">index</span> + <span class="hljs-number">1</span>);<br>        chessboard[<span class="hljs-built_in">index</span>][i] = &#x27;.&#x27;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对单行棋盘中皇后的摆放位置进行枚举，再递归进入下一行，如果发生相互攻击（遍历完所有值都不符合要求）则进行回溯，不发生攻击则继续递归下一行，直到满足要求</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">noattack</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= row; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][column] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = column - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp;j &gt;= <span class="hljs-number">0</span>; --i, --j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = column + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; --i, ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; res, <span class="hljs-type">int</span> n, vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= n)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(chessboard);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">noattack</span>(chessboard, n,index,i))<br>            &#123;<br>                chessboard[index][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                <span class="hljs-built_in">traceback</span>(res, n, chessboard, index + <span class="hljs-number">1</span>);<br>                chessboard[index][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">chessboard</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-built_in">traceback</span>(res, n, chessboard, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>该题的关键点在于</p>
<ul>
<li>不需要两层循环，虽然是二维棋盘，但N皇后中不需要在二维棋盘的每一个点上都要放置皇后，仅是<strong>判断当前的点是否能放，因此使用单层循环</strong></li>
<li>回溯不需要返回值，是因为要寻找<strong>所有可行的棋盘摆放</strong>，应当<strong>用全局变量或者引用返回</strong>，同时要遍历所有情况；若只需要找到<strong>一种可行的棋盘</strong>，则返回值应为**<code>bool</code><strong>，一旦找到则</strong>返回<code>true</code>退出递归**</li>
<li>不需要对同行皇后进行判断，是因为对<strong>同行位置进行遍历时，肯定不会发生同一行同时有两个皇后出现</strong>，一旦某一个位置能够摆放皇后，就会马上<strong>进入到下一层递归</strong>，即到下一行的遍历，而后面回溯回本行时，又会将原位置的皇后删除，再从下一位进行遍历</li>
</ul>
<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a><strong>解数独</strong></h2><p>[解数独](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a>)</p>
<p>与上题<a href="#N%E7%9A%87%E5%90%8E">N皇后</a>相比，解数独也是在一个二维棋盘上，但不仅要判断该点是否会有冲突，还要在遍历时在每个点上都要填充数字，也就是说，不能像上题一样，如果是单层循环，填完该位置上的数字就进入递归，遍历下一行。因此需要两层循环，填完数字后进入递归，还是从刚填过的位置开始继续填。</p>
<p>同样，首先需要根据规则判断是否有冲突</p>
<ul>
<li>同行不能有重复数字</li>
<li>同列不能有重复数字</li>
<li>同一个3x3格子不能有重复数字</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp; chessboard,<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> tmp)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//判断列</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row;i&lt;<span class="hljs-number">9</span>;i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(chessboard[i][col]==tmp+<span class="hljs-string">&#x27;0&#x27;</span>)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//判断行</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(chessboard[row][j]==tmp+<span class="hljs-string">&#x27;0&#x27;</span>)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//判断9宫格</span><br>	<span class="hljs-type">int</span> subrow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;	<span class="hljs-comment">//0,1,2行等于0, 3,4,5行等于3，6,7,8行等于6</span><br>	<span class="hljs-type">int</span> subcol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = subrow; i &lt; subrow + <span class="hljs-number">3</span>; i++)<br>	&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = subcol; j &lt; subcol + <span class="hljs-number">3</span>; j++)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(board[i][j]==tmp+<span class="hljs-string">&#x27;0&#x27;</span>)<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可知，需要多次的循环来完成一次的判断。则可以用哈希表的方法，先储存已有的数字，然后在一次循环完成冲突的判断</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs prolog">//全局变量<br>int row[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] &#123;<span class="hljs-number">0</span>&#125;;<br>int col[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] &#123;<span class="hljs-number">0</span>&#125;;<br>int subbox[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] &#123;<span class="hljs-number">0</span>&#125;;<br><br>//先完成对棋盘上已有数字的存储<br>for(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br>	for(int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++)<br>	&#123;<br>		if(chessboard[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>)<br>		&#123;<br>			int tmp = chessboard[i][j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>			row[i][tmp] = <span class="hljs-number">1</span>;<br>			col[j][tmp] = <span class="hljs-number">1</span>;<br>			subbox[j/<span class="hljs-number">3</span> + (i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>&#125;<br><br>bool ok(int i, int j, int tmp)<br>&#123;<br>	if(row[i][tmp]==<span class="hljs-number">1</span>)<br>		return false;<br>	if(col[j][tmp]==<span class="hljs-number">1</span>)<br>		return false;<br>	if(subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp]==<span class="hljs-number">1</span>)<br>		return false;<br>	row[i][tmp] = <span class="hljs-number">1</span>;<br>	col[j][tmp] = <span class="hljs-number">1</span>;<br>	subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">1</span>;<br>	return true;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将三种规则分别替换为三个用二维数组记录的哈希表，行表（row）用第一维表示对应的行数，用第二维表示该行上出现过的数字<code>0-9</code>，如果出现过则置为1，列表（col）同理；由于9宫格中刚好有九个数字，也可以用同样的方法来记录，将棋盘上行列号映射为9个不同的9宫格序号，再记录出现过的数字</p>
<h3 id="回溯-12"><a href="#回溯-12" class="headerlink" title="回溯"></a>回溯</h3><ol>
<li><p>确定递归结束条件</p>
<p>因为结束时，总是需要遍历棋盘上所有位置，当遍历结束也就是递归的结束，因此不需要递归的结束条件</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traceback</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; chessboard, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span><br></code></pre></td></tr></table></figure>

<p>因为只需要寻找到一种符合的答案，一旦遇到有，则应立即退出递归并返回</p>
</li>
<li><p>递归单层逻辑</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs prolog">for(int i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>	for(int j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>	&#123;<br>		if(chessboard[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>		&#123;<br>			for(int tmp = <span class="hljs-number">1</span>;tmp&lt;<span class="hljs-number">10</span>;tmp++)<br>			&#123;<br>				if(ok(i,j,tmp))<br>				&#123;<br>					chessboard[i][j]=tmp+<span class="hljs-string">&#x27;0&#x27;</span>;<br>					if(traceback(chessboard)) return true;<br>					chessboard[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>					row[i][tmp] = <span class="hljs-number">0</span>;<br>					col[j][tmp] = <span class="hljs-number">0</span>;<br>					subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">0</span>;<br>				&#125;<br>			&#125;<br>			return false;<br>		&#125;<br>	&#125;<br>&#125;<br>return true;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs prolog">class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>int row[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;,column[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;, subbox[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    bool ok(int i, int j, int tmp)<br>    &#123;<br>        if(row[i][tmp]==<span class="hljs-number">1</span>)<br>            return false;<br>        if(column[j][tmp]==<span class="hljs-number">1</span>)<br>            return false;<br>        if(subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp]==<span class="hljs-number">1</span>)<br>            return false;<br>        row[i][tmp] = <span class="hljs-number">1</span>;<br>        column[j][tmp] = <span class="hljs-number">1</span>;<br>        subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">1</span>;<br>        return true;<br>    &#125;<br>    bool traceback(vector&lt;vector&lt;char&gt;&gt;&amp; board)<br>    &#123;<br>        for(int i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>        &#123;<br>            for(int j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>            &#123;<br>                if(board[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                &#123;<br>                    for(int tmp = <span class="hljs-number">1</span>;tmp&lt;<span class="hljs-number">10</span>;tmp++)<br>                    &#123;<br>                        if(ok(i,j,tmp))<br>                        &#123;<br>                            board[i][j] = tmp+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                            if(traceback(board)) return true;<br>                            board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                            row[i][tmp] = <span class="hljs-number">0</span>;<br>                            column[j][tmp] = <span class="hljs-number">0</span>;<br>                            subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">0</span>;<br>                        &#125;<br>                    &#125;<br>                    return false;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return true;<br>    &#125;<br>    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;<br>        for(int i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>        &#123;<br>            for(int j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>            &#123;<br>                if(board[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>)<br>                &#123;<br>                    int tmp = board[i][j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                    row[i][tmp] = <span class="hljs-number">1</span>;<br>                    column[j][tmp] = <span class="hljs-number">1</span>;<br>                    subbox[j/<span class="hljs-number">3</span>+(i/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][tmp] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        traceback(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>该题的关键点在于</p>
<ul>
<li>递归中需要用双层循环，<strong>如果单层循环，则在该行填入一个数字之后进入递归，不管传入怎样的参数都不能使继续填充该行并且完成换行继续填充</strong></li>
<li>递归不需要结束条件，因为题目需要对棋盘上所有点都进行一次遍历，递归结束时就是得到结果时，即遍历结束即为递归结束</li>
<li>递归需要返回值，题目保证能找到一个有效的解决方案，且最多只有一个解，因此返回bool值，当找到时，即遍历完棋盘，就返回true；当在棋盘上某一个点遍历完9个数字都没有合适结果时，应当返回false，令上一层递归进行回溯。也就是说，有返回值如bool类型，可以通过判断返回值（如果为真）可以避免进一步递归，同时还能让进入多余分支的递归及时退出，防止了死循环（如本题，在没有递归结束条件的情况下，如果不用返回值限制则会导致死循环）；而无返回值的通常是要遍历所有分支，从中找到所有解</li>
<li>一次循环即可完成对数独是否有效的判断，借助哈希表，将一维的数据通过二维的哈希表进行重复性判断</li>
</ul>
<h2 id="最接近目标价格的甜点成本"><a href="#最接近目标价格的甜点成本" class="headerlink" title="最接近目标价格的甜点成本"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/closest-dessert-cost/">最接近目标价格的甜点成本</a></h2><p>该题要求从必选数组<code>base</code>中选择一份基料，以及从可选数组<code>topping</code>中选择0份、1份或者2份配料，组成的冰淇淋总价格最接近<code>target</code>且成本最低</p>
<h3 id="回溯-13"><a href="#回溯-13" class="headerlink" title="回溯"></a>回溯</h3><p>容易想到，给定数据量较少，可以用回溯算法对数组进行遍历，用<code>set</code>保存可行的方案，并最终选择最合适的一个价格返回</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    set&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-type">void</span> traceback(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; toppingCosts, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> res)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (index == toppingCosts.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; toppingCosts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            res += toppingCosts[i];<br>            vec.insert(res);<br>            traceback(toppingCosts, <span class="hljs-built_in">target</span>, i + <span class="hljs-number">1</span>, res);<br>            res += toppingCosts[i];<br>            vec.insert(res);<br>            traceback(toppingCosts, <span class="hljs-built_in">target</span>, i + <span class="hljs-number">1</span>, res);<br>            res -= toppingCosts[i] * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> closestCost(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; baseCosts, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; toppingCosts, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//int m = toppingCosts.size();</span><br>        <span class="hljs-comment">//for (int i = 0; i &lt; m; i++)</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    toppingCosts.push_back(toppingCosts[i]);</span><br>        <span class="hljs-comment">//&#125;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; baseCosts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            res = baseCosts[i];<br>            vec.insert(res);<br>            traceback(toppingCosts, <span class="hljs-built_in">target</span>, <span class="hljs-number">0</span>, res);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br>        <span class="hljs-keyword">for</span> (auto it: vec)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">target</span> - it) &lt; <span class="hljs-built_in">abs</span>(ans - <span class="hljs-built_in">target</span>))<br>                ans = it;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">target</span> - it == <span class="hljs-built_in">abs</span>(ans-<span class="hljs-built_in">target</span>)))<br>                ans = it &lt; ans? it:ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><del>因为最多可以添加两份配料，则将原数组<code>topping</code>中的元素都复制一遍，再进行回溯</del>，但会超时</p>
<p>则可以对数组<code>topping</code>中的同一个元素进行两次回溯递归，分别将一份和两份配料的价格传递到递归当中</p>
<p>无论价格是多少，都会被存入到<code>set</code>当中，因为难以在存入结果之前对结果的合法性进行判断，所以只能被动地存入所有结果，最后在遍历所有结果的时候，选取最合适的结果</p>
<h3 id="回溯优化-4"><a href="#回溯优化-4" class="headerlink" title="回溯优化"></a>回溯优化</h3><p>优化在只需要用O(1)的空间存储结果，存储的不再是所有结果，而是最合适的结果，并对其进行维护</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> ans = INT_MAX;<br>    void traceback(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; toppingCosts, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span>, <span class="hljs-built_in">int</span> res)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-keyword">target</span>-ans) &gt; <span class="hljs-built_in">abs</span>(res-<span class="hljs-keyword">target</span>))<br>            ans = res;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-keyword">target</span>-ans) == <span class="hljs-built_in">abs</span>(res-<span class="hljs-keyword">target</span>) &amp;&amp; res &lt; ans )<br>            ans = res;<br>        <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-keyword">target</span>)<br>            <span class="hljs-keyword">return</span>;<br>        for (<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">index</span>; i &lt; toppingCosts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            traceback(toppingCosts, <span class="hljs-keyword">target</span>, i + <span class="hljs-number">1</span>, res + toppingCosts[i]);<br>            traceback(toppingCosts, <span class="hljs-keyword">target</span>, i + <span class="hljs-number">1</span>, res+ <span class="hljs-number">2</span> * toppingCosts[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">int</span> closestCost(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; baseCosts, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; toppingCosts, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; baseCosts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            res = baseCosts[i];<br>            traceback(toppingCosts, <span class="hljs-keyword">target</span>, <span class="hljs-number">0</span>, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><strong>回溯算法的题目要注意回溯参数<code>i</code>与 <code>index</code>，如果是<code>i</code>，则是允许元素重复加入结果集，在本题中，使用<code>i</code>作为参数传递而不是<code>i+1</code>，则意味着可以使用任意数量的配料<code>topping</code>，不符合题意；添加元素到结果集时，向递归函数传递的参数永远都是<code>i</code>而不是<code>index</code></strong></p>
<p><strong>因为有必选数组和可选数组的存在，对必选数组进行<code>for</code>循环遍历，再进行回溯，保证结果集中有必选数组的元素；而必选数组中又可以对不同数量的元素重复使用（同一个元素最多两次），则可以通过两次回溯调用来实现</strong></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>LeetCode回溯算法章节</div>
      <div>https://kevin346-sc.github.io/2022/11/05/LeetCode回溯算法章节/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Kevin Huang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/09/C3P%E7%AC%AC%E4%B8%89%E3%80%81%E5%9B%9B%E9%83%A8%E5%88%86/" title="C3P第三部分">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C3P第三部分</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/18/C3P%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="C3P阅读笔记">
                        <span class="hidden-mobile">C3P阅读笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
