<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kevin346-sc.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="LeetCode贪心算法章节分发饼干思路以每个人的胃口作为阈值，只有给够饼干才能满足，那么为了满足更多的人，则应根据胃口有小到大排序，在饼干数量一定情况下，先满足胃口小的可以让更多人得到满足 12345678910111213141516171819202122class Solution &amp;#123;public:    int findContentChildren(vector&lt;int">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode贪心算法章节">
<meta property="og:url" content="https://kevin346-sc.github.io/2022/11/15/LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/index.html">
<meta property="og:site_name" content="Serein’s Blog">
<meta property="og:description" content="LeetCode贪心算法章节分发饼干思路以每个人的胃口作为阈值，只有给够饼干才能满足，那么为了满足更多的人，则应根据胃口有小到大排序，在饼干数量一定情况下，先满足胃口小的可以让更多人得到满足 12345678910111213141516171819202122class Solution &amp;#123;public:    int findContentChildren(vector&lt;int">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-15T08:13:21.000Z">
<meta property="article:modified_time" content="2022-12-12T03:40:02.000Z">
<meta property="article:author" content="Kevin Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kevin346-sc.github.io/2022/11/15/LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kevin346-sc.github.io/2022/11/15/LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/","path":"2022/11/15/LeetCode贪心算法章节/","title":"LeetCode贪心算法章节"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LeetCode贪心算法章节 | Serein’s Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Serein’s Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82"><span class="nav-number">1.</span> <span class="nav-text">LeetCode贪心算法章节</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="nav-number">1.1.</span> <span class="nav-text">分发饼干</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">1.1.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="nav-number">1.2.</span> <span class="nav-text">摆动序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83"><span class="nav-number">1.2.2.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E8%A7%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">动规</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">1.3.</span> <span class="nav-text">最大子数组和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E8%A7%84-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">动规</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B2%BB"><span class="nav-number">1.3.3.</span> <span class="nav-text">分治</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">1.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII"><span class="nav-number">1.4.</span> <span class="nav-text">买卖股票最佳时机II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E8%A7%84-2"><span class="nav-number">1.4.2.</span> <span class="nav-text">动规</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">1.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-number">1.5.</span> <span class="nav-text">跳跃游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-3"><span class="nav-number">1.5.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII"><span class="nav-number">1.6.</span> <span class="nav-text">跳跃游戏II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-4"><span class="nav-number">1.6.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-number">1.6.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">1.7.</span> <span class="nav-text">K 次取反后最大化的数组和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="nav-number">1.7.1.</span> <span class="nav-text">暴力解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%831"><span class="nav-number">1.7.2.</span> <span class="nav-text">贪心1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%832"><span class="nav-number">1.7.3.</span> <span class="nav-text">贪心2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-6"><span class="nav-number">1.7.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="nav-number">1.8.</span> <span class="nav-text">加油站</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95-1"><span class="nav-number">1.8.1.</span> <span class="nav-text">暴力解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E4%BC%98%E5%8C%96"><span class="nav-number">1.8.2.</span> <span class="nav-text">暴力优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E5%86%8D%E4%BC%98%E5%8C%96"><span class="nav-number">1.8.3.</span> <span class="nav-text">暴力再优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-5"><span class="nav-number">1.8.4.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83special"><span class="nav-number">1.8.5.</span> <span class="nav-text">贪心special</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-7"><span class="nav-number">1.8.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="nav-number">1.9.</span> <span class="nav-text">分发糖果</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%831-1"><span class="nav-number">1.9.1.</span> <span class="nav-text">贪心1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%832-1"><span class="nav-number">1.9.2.</span> <span class="nav-text">贪心2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-8"><span class="nav-number">1.9.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">1.10.</span> <span class="nav-text">根据身高重建队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-6"><span class="nav-number">1.10.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E4%BC%98%E5%8C%96"><span class="nav-number">1.10.2.</span> <span class="nav-text">贪心优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-9"><span class="nav-number">1.10.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="nav-number">1.11.</span> <span class="nav-text">用最少数量的箭引爆气球</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%831-2"><span class="nav-number">1.11.1.</span> <span class="nav-text">贪心1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%832-2"><span class="nav-number">1.11.2.</span> <span class="nav-text">贪心2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-10"><span class="nav-number">1.11.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="nav-number">1.12.</span> <span class="nav-text">无重叠区间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-7"><span class="nav-number">1.12.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-11"><span class="nav-number">1.12.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="nav-number">1.13.</span> <span class="nav-text">划分字母区间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-8"><span class="nav-number">1.13.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-12"><span class="nav-number">1.13.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">1.14.</span> <span class="nav-text">合并区间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%831-3"><span class="nav-number">1.14.1.</span> <span class="nav-text">贪心1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%832-3"><span class="nav-number">1.14.2.</span> <span class="nav-text">贪心2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-13"><span class="nav-number">1.14.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">1.15.</span> <span class="nav-text">单调递增的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-9"><span class="nav-number">1.15.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-14"><span class="nav-number">1.15.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAI"><span class="nav-number">1.16.</span> <span class="nav-text">买卖股票最佳时机I</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-10"><span class="nav-number">1.16.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-15"><span class="nav-number">1.16.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.17.</span> <span class="nav-text">监控二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-11"><span class="nav-number">1.17.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-16"><span class="nav-number">1.17.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89"><span class="nav-number">1.18.</span> <span class="nav-text">通过最少操作次数使数组的和相等</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-12"><span class="nav-number">1.18.1.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-17"><span class="nav-number">1.18.2.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kevin Huang</p>
  <div class="site-description" itemprop="description">c++</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/11/15/LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LeetCode贪心算法章节 | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode贪心算法章节
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-15 16:13:21" itemprop="dateCreated datePublished" datetime="2022-11-15T16:13:21+08:00">2022-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-12 11:40:02" itemprop="dateModified" datetime="2022-12-12T11:40:02+08:00">2022-12-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="LeetCode贪心算法章节"><a href="#LeetCode贪心算法章节" class="headerlink" title="LeetCode贪心算法章节"></a>LeetCode贪心算法章节</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>以每个人的胃口作为阈值，只有给够饼干才能满足，那么为了满足更多的人，则应根据胃口有小到大排序，在饼干数量一定情况下，先满足胃口小的可以让更多人得到满足</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">        if(s.size()==0) return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        sort(g.begin(),g.end());</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        int i=0, j=0;</span><br><span class="line">        while(i&lt;g.size() &amp;&amp; j&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(g[i]&lt;=s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(g[i]&gt;s[j])</span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目中用到的贪心算法思想，局部最优就是<strong>小饼干先喂饱小胃口</strong>，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**</p>
<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><strong>摆动序列</strong></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>根据数组前后差值关系，求出最长的摆动子序列，其中，子序列也可以删除原序列的某个元素。也就是说，不改变序列顺序，忽略非摆动的子序列，从中找到摆动子序列并拼接，求出最大的长度。</p>
<p>局部最优就是通过删除在单一坡度（单调序列）上的元素，使其出现两个峰值，如在<code>5,1,4,6,3</code>中，<code>1,4,6</code>为单一坡度，在删除元素4之后，就变成摆动序列，或者延长了摆动序列。实际操作中，可以忽略掉单调坡上的元素，只取两端，统计使出现峰值的转折点元素</p>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p><code>res</code>初始为1（默认最右面有一个峰值），此时<code>cursub</code>&gt; 0 &amp;&amp;<code>presub</code>&lt;&#x3D; 0，那么res++（计算了左面的峰值），最后得到的<code>res</code>就是2（峰值个数为2即摆动序列长度为2）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()&lt;=1)  return nums.size();</span><br><span class="line">        int res = 1;</span><br><span class="line">        int presub = 0;</span><br><span class="line">        int cursub = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size() - 1;i++)</span><br><span class="line">        &#123;  </span><br><span class="line">            cursub = nums[i + 1] - nums[i];</span><br><span class="line">            if((cursub &gt; 0 &amp;&amp; presub &lt;= 0)||(cursub &lt; 0 &amp;&amp; presub &gt;= 0))</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                presub = cursub;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述版本中，判断条件为<code>presub &lt;= 0</code>和<code>presub&gt; = 0</code>，让<code>presub</code>等于0也进入结果集收集，是因为在一开始<code>presub</code>为0。另外，考虑到出现相邻相同元素时，此时<code>cursub=0</code>，不会被统计到结果中，并且，<code>presub</code>也不会更新成0，就是为了阻止非严格单调序列也会被统计到，如<code>1,5,3,3,2</code>，如果每次都更新<code>presub</code>，令<code>presub=cursub</code>，当遇到相同元素时，所有相同元素不被统计成摆动序列（因为<code>cursub=0</code>)，但相同元素的下一个元素无论是否符合摆动，都会被统计成摆动序列里（因为此时<code>presub=0</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()&lt;=1)  return nums.size();</span><br><span class="line">        int res = 1;</span><br><span class="line">        int presub = 0;</span><br><span class="line">        int cursub = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size() - 1;i++)</span><br><span class="line">        &#123;  </span><br><span class="line">            cursub = nums[i + 1] - nums[i];</span><br><span class="line">            if(cursub==0)   continue;</span><br><span class="line">            if(cursub*presub &lt;= 0)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            presub = cursub;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上版本使用不同方法判断摆动，<code>cursub * presub &lt;= 0</code>，还要增加<code>if(cursub==0)   continue;</code>，当遇到相同元素时，<code>cursub=0</code>则直接跳过当次循环，也不会更新<code>presub</code>，直到遇到不同的元素。也就是相当于去重处理</p>
<h3 id="动规"><a href="#动规" class="headerlink" title="动规"></a>动规</h3><p>利用动态规划思想</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>保持区间波动，只需要把单调区间上的元素移除就可以了，通过局部最优达到全局最优</p>
<p>本题关键在于对摆动子序列的统计判断条件，即当遇到相同元素时如何处理</p>
<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><strong>最大子数组和</strong></h2><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>寻找相加和最大时的子数组，与上题不同，上题不允许排序但能删掉中间的元素，是一种拼凑的子序列，本题要求是连续的子数组，容易想到的是用两层for循环以及双指针解法，其中，双层for循环能够实现但会导致超时，时间复杂度为O(n^2)；双指针法其实并不能够在单次循环中实现，在有正负交错的情况下，不能找到最大子数组的边界点。</p>
<p>贪心算法的局部最优思路路是，在求和过程中，一旦求和值为负数，则应舍弃掉之前的子序列，再重新从下一个元素开始求和</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res = INT_MIN;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            if(sum&gt;res)</span><br><span class="line">                res = sum;</span><br><span class="line">            if(sum&lt;0)</span><br><span class="line">                sum = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>当遇到连续正数时，<code>sum</code>一直增长并更新<code>res</code></li>
<li>当遇到连续负数时，第一个负数与<code>INT_MIN</code>对比肯定会更新到<code>res</code>中，后面的负数再更新到保持为0的<code>sum</code>中，最后跟已存到<code>res</code>的第一个负数做大小比较，取较大值</li>
<li>当遇到正数+负数+正数时，访问到负数时，只要<code>sum</code>值还没变为负数，都会一直扩大子序列，因为可能后面还会有正数使得子序列和更大，而当后面一直是负数直到<code>sum&lt;0</code>，那么就会重新开始计算子序列的最大和，因为从下一个正数开始的子序列和必然比负数大，这也是为何是<code>if(sum&lt;0)</code>而不是<code>if(nums[i]&lt;0)</code></li>
<li>时间复杂度为O(n)，遍历数组所有元素一次，空间复杂度为O(1)，占用常数级空间存放变量</li>
</ul>
<h3 id="动规-1"><a href="#动规-1" class="headerlink" title="动规"></a>动规</h3><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治的思想与递归回溯有些类似，通过划分子区间，直到区间元素个数为1，再回升合并，更新维护相应的变量，直到回到原始数组区间。因此，关键在于1. 要维护的信息 2. 如何在合并区间时更新这些信息</p>
<ol>
<li><code>lsum</code>维护包含左端点在内的最大子序列和</li>
<li><code>rsum</code>维护包含右端点在内的最大子序列和</li>
<li><code>isum</code>维护区间数组的最大子序列和</li>
<li><code>sum</code>维护区间数组的总和</li>
</ol>
<p>在合并<code>s1</code>和<code>s2</code>区间时，为了维护<code>isum</code>即最终求取的结果，都会用到以上的信息，这也是需要维护以上信息的原因</p>
<ol>
<li><code>sum = s1.sum + s2.sum</code>数组总和直接相加</li>
<li><code>lsum = max(s1.sum, s1.sum + s2.lsum)</code>取原左区间<code>lsum</code>和合并区间<code>lsum</code>即<code>s1.sum+s2.lsum</code>的最大值</li>
<li><code>rsum</code>同上</li>
<li><code>isum</code>有三种可能，可以是左区间的<code>isum</code>，也可能是右区间的<code>isum</code>，还有一种可能是合并之后跨越两个区间，此时<code>isum = s1.rsum + s2.lsum</code></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    struct status&#123;</span><br><span class="line">        int lsum, rsum, isum, sum;</span><br><span class="line">    &#125;;</span><br><span class="line">    status pushup(status&amp;s1, status&amp;s2)</span><br><span class="line">    &#123;</span><br><span class="line">        int sum = s1.sum + s2.sum;</span><br><span class="line">        int lsum = max(s1.lsum, s1.sum+s2.lsum);</span><br><span class="line">        int rsum = max(s2.rsum, s2.sum+s1.rsum);</span><br><span class="line">        int isum = max(max(s1.isum,s2.isum), s1.rsum+s2.lsum);</span><br><span class="line">        return (status) &#123;lsum, rsum, isum, sum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    status get(vector&lt;int&gt;&amp; nums, int st, int en)</span><br><span class="line">    &#123;</span><br><span class="line">        if(st==en)</span><br><span class="line">        &#123;</span><br><span class="line">            return (status) &#123;nums[st],nums[st],nums[st],nums[st]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (st + en) &gt;&gt; 1;</span><br><span class="line">        status s1 = get(nums, st, mid);</span><br><span class="line">        status s2 = get(nums, mid+1, en);</span><br><span class="line">        return pushup(s1,s2);</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        return get(nums,0,nums.size()-1).isum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，遍历数组所有元素一次，空间复杂度O(log n)，递归占用了栈空间</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>贪心算法能够在遍历数组的时候遇到子数组和为负数时及时舍弃，再重新从零开始，也是其贪的局部最优思想。</p>
<p>分治算法</p>
<ul>
<li>在于不断切割子区间，利用递归回溯思想把问题转化求解子区间的问题，<strong>最关键的地方在于合并区间时对信息的更新维护</strong></li>
<li>如果在合并区间上要存取的信息较多，函数参数冗杂，<strong>可以通过结构体来实现信息的传递</strong></li>
<li>虽然分治算法时间复杂度与贪心相同，且空间复杂度上由于递归比贪心要差，但分治算法<strong>构建了线段树</strong>，<strong>能做到快速访问任何子区间上的最大子序列和</strong>，访问的时间复杂度为O(log n)，对于<strong>大规模查询</strong>的情况下，这种方法的优势便体现了出来</li>
</ul>
<h2 id="买卖股票最佳时机II"><a href="#买卖股票最佳时机II" class="headerlink" title="买卖股票最佳时机II"></a>买卖股票最佳时机II</h2><h3 id="贪心-2"><a href="#贪心-2" class="headerlink" title="贪心"></a>贪心</h3><p>用贪心思想较为简单，由于没有买入卖出次数限制，只考虑每天的盈亏情况，再把所有盈余的情况相加即可</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0;i &lt; prices.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i+1]-prices[i]&gt;0)</span><br><span class="line">                res += prices[i+1] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动规-2"><a href="#动规-2" class="headerlink" title="动规"></a>动规</h3><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>贪心算法中，局部最优是将最大利润划分成每天能获取的利润，贪在只获取盈余的部分，舍弃亏钱的部分</p>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><h3 id="贪心-3"><a href="#贪心-3" class="headerlink" title="贪心"></a>贪心</h3><p>通过for循环里从头开始遍历数组的所有元素，借助一个变量<code>tmp</code>记录当前元素下往前所能达到的最大范围，并且在遍历过程中不断更新这个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(tmp&lt;0)  return false;</span><br><span class="line">            tmp = max(tmp, nums[i]);</span><br><span class="line">            --tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>贪心算法思想中局部最优是 当前位置下能够到达的最远范围，即<code>tmp</code>变量，贪在了不断更新当前位置下的最远范围，通过这个来判断能否到达目的位置</p>
<h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a><strong>跳跃游戏II</strong></h2><h3 id="贪心-4"><a href="#贪心-4" class="headerlink" title="贪心"></a>贪心</h3><p>贪心算法局部最优在于<strong>寻找当前能覆盖的最大范围</strong>，在遍历数组时遇到这个最大范围的边界点，则更新在遍历时遇到的最大范围以及更新跳数，即遇到了上一个最大范围则需要进行下一跳</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        int en = 0;</span><br><span class="line">        for(int i =0;i&lt;nums.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = max(nums[i]+i,tmp);</span><br><span class="line">            if(i == en)</span><br><span class="line">            &#123;</span><br><span class="line">                en = tmp;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>与上一题解法相比，都是用一次的数组遍历，但上题中<strong>记录的是以当前位置作为基准，所能到达的最远距离</strong>，且在<strong>遍历每一个点时都会更新这个距离</strong>；而这一题中因为能确保到达数组的最后一个位置，<strong>记录的是能够覆盖的最大范围</strong>，且<strong>只在到达了上一个最大范围时才更新这个范围</strong></p>
<h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>不断通过排序，对最小的元素进行取反，直到剩余取反次数为0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        while(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[0] = -nums[0];</span><br><span class="line">            sort(nums.begin(),nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心1"><a href="#贪心1" class="headerlink" title="贪心1"></a>贪心1</h3><p>显然，有着很多的重复排序操作，考虑只进行一次遍历和排序</p>
<p>由于有正数和负数，可以通过由小到大排序数组并分类讨论</p>
<ul>
<li><strong>如果当前最小元素是正数，且剩余取反次数是偶数，则可以直接返回</strong></li>
<li><strong>如果当前最小元素是正数，且剩余取反次数是奇数，则重新排序对最小值进行取反再返回</strong></li>
<li>如果当前最小元素是负数，且剩余取反次数大于0，则直接取反并移动到下一个元素</li>
<li>如果移动到下一个元素超出数组范围，且剩余取反次数大于0，则移动到数组首元素，这种情况下，原数组全为负数而此时数组全为正数，则只需判断剩余取反次数的奇偶性。</li>
</ul>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int res = accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        int i = 0;</span><br><span class="line">        while( k &amp;&amp; i&lt;nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i] &gt;= 0 &amp;&amp; k % 2 == 0)</span><br><span class="line">                break;</span><br><span class="line">            else if(nums[i] &gt;= 0 &amp;&amp; k % 2 != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                sort(nums.begin(),nums.end());</span><br><span class="line">                nums[0] = -nums[0];</span><br><span class="line">                res += 2*nums[0];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = -nums[i];</span><br><span class="line">            res += nums[i]*2;</span><br><span class="line">            ++i;</span><br><span class="line">            --k;</span><br><span class="line">            if(k &amp;&amp; i == nums.size())       //全负数且k &gt;= num.size()</span><br><span class="line">                i = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="贪心2"><a href="#贪心2" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种解法，用不同的方式排序，按照<strong>绝对值大小</strong>进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        return abs(a) &gt; abs(b);</span><br><span class="line">    &#125;</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int res = accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">        sort(nums.begin(),nums.end(),cmp);</span><br><span class="line">        int i = 0;</span><br><span class="line">        while( k &amp;&amp; i &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]&lt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">                res += 2*nums[i];</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k &amp;&amp; k%2!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[nums.size()-1] *= -1;</span><br><span class="line">            res += 2*nums[nums.size()-1];</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>贪心算法局部最优是将最小的负数取反，最大化数组和。</p>
<p>取到最小的负数就需要对数组的排序，可以有两种不同的排序方式，按值从小到大排序和按绝对值从小到大排序。从小到大排序会导致在对所有负数取反 而剩余取反次数大于零时，额外需要排序来对最小的整数进行取反。按绝对值排序则可以解决这个问题，当数组全为正数时，可直接根据剩余取反次数是否对数组末尾元素或首元素进行取反</p>
<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><strong>加油站</strong></h2><p>容易想到的是暴力解法，判断能否循环一圈，只需要在循环中间油量不会变为负数即返回<code>true</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool ok(vector&lt;int&gt;&amp; gas,vector&lt;int&gt;&amp; cost, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        int times = 1;</span><br><span class="line">        int tank = gas[index];</span><br><span class="line">        while(times &lt;= gas.size())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tank -= cost[index];</span><br><span class="line">            if(tank&lt;0)</span><br><span class="line">                return false;</span><br><span class="line">            index++;</span><br><span class="line">            if(index&gt;gas.size()-1)</span><br><span class="line">                index = 0;</span><br><span class="line">            tank += gas[index];</span><br><span class="line">            times++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>遍历数组，判断以当前元素开始能否循环一圈，但时间复杂度会达到O(n^2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool ok(vector&lt;int&gt;&amp; gas,vector&lt;int&gt;&amp; cost, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        int times = 1;</span><br><span class="line">        int tank = gas[index];</span><br><span class="line">        while(times &lt;= gas.size())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tank -= cost[index];</span><br><span class="line">            if(tank&lt;0)</span><br><span class="line">                return false;</span><br><span class="line">            index++;</span><br><span class="line">            if(index&gt;gas.size()-1)</span><br><span class="line">                index = 0;</span><br><span class="line">            tank += gas[index];</span><br><span class="line">            times++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = -1;</span><br><span class="line">        int tank = 0;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(gas[i] &lt; cost[i])</span><br><span class="line">                continue;</span><br><span class="line">            if(ok(gas,cost,i))</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="暴力优化"><a href="#暴力优化" class="headerlink" title="暴力优化"></a>暴力优化</h3><p>在暴力法中，每次都会有重复的遍历，因此可以借助容器记录遍历过的元素，记录<strong>该元素能走到最远的地方</strong>以及<strong>剩余的油量</strong>，下一次当再次遍历到该元素时则直接跳到保存的最远地方同时加上剩余的油量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        vector&lt;int&gt; dist(gas.size(),-1);</span><br><span class="line">        vector&lt;int&gt; tmp(gas.size());</span><br><span class="line">        int res = -1;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            int cur = gas[i];</span><br><span class="line">            while(cur-cost[j]&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                cur -= cost[j];</span><br><span class="line">                j = (j+1) % gas.size();</span><br><span class="line">                if(dist[j]!=-1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur += tmp[j];</span><br><span class="line">                    j = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    cur += gas[j];</span><br><span class="line">                if(j==i &amp;&amp; cur&gt;= 0)</span><br><span class="line">                    return i;</span><br><span class="line">            &#125;</span><br><span class="line">            dist[i] = j;</span><br><span class="line">            tmp[i] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然减少了重复访问的时间，利用了空间换取时间的思想，但对时间提升并不明显，依然是超出时间限制。</p>
<h3 id="暴力再优化"><a href="#暴力再优化" class="headerlink" title="暴力再优化"></a>暴力再优化</h3><p>进一步考虑，<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，也就是说，在遍历过程中，遍历完<code>i</code>之后即可直接跳转到<code>j+1</code>位置上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = -1;</span><br><span class="line">        vector&lt;int&gt; dist(gas.size(),-1);</span><br><span class="line">        vector&lt;int&gt; tmp(gas.size());</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            int cur = gas[i];</span><br><span class="line">            while(cur-cost[j]&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                cur -= cost[j];</span><br><span class="line">                j = (j+1)%gas.size();</span><br><span class="line">                if(dist[j]!=-1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur += tmp[j];</span><br><span class="line">                    j = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    cur += gas[j];</span><br><span class="line">                if(i == j)</span><br><span class="line">                    return i;</span><br><span class="line">            &#125;</span><br><span class="line">            dist[i] = j;</span><br><span class="line">            tmp[i] = cur;</span><br><span class="line">            if(i&lt;j)</span><br><span class="line">                i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以不借助数组，只占用常数级空间，显得更为简洁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = -1;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            int cur = gas[i];</span><br><span class="line">            while(cur-cost[j]&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                cur -= cost[j];</span><br><span class="line">                j = (j+1)%gas.size();</span><br><span class="line">                cur += gas[j];</span><br><span class="line">                if(i == j)</span><br><span class="line">                    return i;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i &lt; j)</span><br><span class="line">                i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心-5"><a href="#贪心-5" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int cursum = 0, tosum = 0;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int tmp = gas[i] - cost[i];</span><br><span class="line">            cursum += tmp;</span><br><span class="line">            tosum += tmp;</span><br><span class="line">            if(cursum &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">            	cursum = 0;</span><br><span class="line">            	res = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tosum &lt; 0)</span><br><span class="line">        	return -1;</span><br><span class="line">        else</span><br><span class="line">        	return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>贪心算法<strong>局部最优在于找到符合当前油量足以到达下一站点的位置</strong>，借助<code>cursum</code>来记录，一旦<code>cursum</code>小于零，即在<code>i</code>站点出发不能够循环一圈，就马上从下一个站点重新出发，并把<code>cursum</code>置零</p>
<p>同样使用到上述的一个条件——<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，那么此时就应该从<code>j+1</code>继续遍历</p>
<p>同时记录总油量，来判断是否存在任何站点都无法循环一圈的情况</p>
<h3 id="贪心special"><a href="#贪心special" class="headerlink" title="贪心special"></a>贪心special</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int tosum = 0;</span><br><span class="line">        int tmpsum = 0;</span><br><span class="line">        int mintmp = INT_MAX;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpsum = gas[i] - cost[i];</span><br><span class="line">            tosum += tmpsum;</span><br><span class="line">            if(tosum &lt; mintmp)</span><br><span class="line">                mintmp = tosum;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tosum&lt;0)    return -1;</span><br><span class="line">        if(mintmp &gt;= 0)     return 0;</span><br><span class="line">        for(int i = gas.size()-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpsum = gas[i] - cost[i];</span><br><span class="line">            mintmp += tmpsum;</span><br><span class="line">            if(mintmp &gt;=0)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有如下几种情况：</p>
<ol>
<li>任何一个站点都无法循环一圈，遍历一遍数组后<code>tosum</code>小于0，则返回-1</li>
<li>从0开始遍历一遍数组后，<code>tosum</code>大于0且中途油箱最小值<code>mintmp</code>都大于0，则可以循环一圈，且从位置0开始，返回0</li>
<li>从0开始遍历一遍数组后，<code>tosum</code>大于0但中途油箱最小值<code>mintmp</code>小于0，则可以循环一圈，但不从位置0开始，逆向遍历数组，不断加上路径某个站点净获得油量，当<code>mintmp</code>大于等于0时，即从该位置开始可以循环一圈</li>
</ol>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>本题的关键点在于理解到<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，由暴力解法优化而来的方法，因为都是在遍历数组时要直接模拟一圈循环，因此时间复杂度上会比贪心算法只遍历一遍数组要慢，但却有很好的优化方向，<strong>通过减少重复过程优化</strong>以及<strong>通过空间换取时间优化</strong>。贪心算法贪在了<strong>从当前站点出发，累加<code>tmp</code>的和<code>curSum</code>一旦小于0就要舍弃，新的起始位置至少要是j+1</strong></p>
<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><strong>分发糖果</strong></h2><h3 id="贪心1-1"><a href="#贪心1-1" class="headerlink" title="贪心1"></a>贪心1</h3><p>尽可能少的分发糖果，则每个人初始化为1，<code>for</code>循环遍历一次数组，根据当前元素与其前后元素对比，有以下情况</p>
<ul>
<li><p>若一直递增或递减</p>
<ul>
<li><p>当前元素<code>i</code>大于<code>i-1</code>，那么<code>tmp++</code>表示当前分发的糖果数量要比<code>i-1</code>多一个</p>
</li>
<li><p>当前元素<code>i</code>小于<code>i-1</code>，则同样<code>tmp++</code>，只考虑总数量</p>
</li>
</ul>
</li>
<li><p>若遇到转折点，用<code>cur</code>记录当前的趋势，即<code>cur&gt;0</code>表示递增，<code>cur&lt;0</code>递减，<code>cur==0</code>表示第一个值或相等值</p>
<ul>
<li>从<code>cur&gt;=0</code>变成<code>cur&lt;0</code>，<code>tmp</code>重新置为1，<code>tmp++</code>后再加入到总数量中，即在转折点之后应该分发两个糖果</li>
<li>从<code>cur&lt;=0</code>变成<code>cur&gt;0</code>时，<code>tmp</code>就应该置为0，<code>tmp++</code>后再加入到总数量中，因为分数比前一个小，分发的糖果就应该重置为1，同时要区分<code>cur&lt;0</code>和<code>cur==0</code>的情况</li>
</ul>
</li>
</ul>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        int cur = 0;</span><br><span class="line">        for(int i = 0; i &lt; ratings.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i == 0 || ratings[i] == ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = 1;</span><br><span class="line">                res += tmp;</span><br><span class="line">                cur = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &gt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                if(cur &lt;= 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = 1;</span><br><span class="line">                    tmp = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                ++tmp;</span><br><span class="line">                res += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &lt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                if(cur &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = -1;</span><br><span class="line">                    tmp = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(cur == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = -1;</span><br><span class="line">                    tmp = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                ++tmp;</span><br><span class="line">                res += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述忽略了一种特殊情况——<strong>当递增序列转折成递减序列，且递减序列长度大于等于递增序列后，转折点分发的糖果要再随递增序列增加而增加</strong>，因为转折点既属于递增也属于递减序列，<strong>它的糖果数量由两条序列中较长的一条决定</strong></p>
<p>因此，只是记录序列的转折情况是不足够的，**需要同时记录下递增序列<code>inc</code>和递减序列的长度<code>dec</code>**，以及当前序列的长度<code>tmp</code>，也相当于当前应分发的糖果数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        int inc = 0, dec = 0;</span><br><span class="line">        for(int i = 0; i &lt; ratings.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i == 0 || ratings[i] == ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = 1;</span><br><span class="line">                res += tmp;</span><br><span class="line">                inc = 1;</span><br><span class="line">                dec = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &gt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                ++tmp;</span><br><span class="line">                res += tmp;</span><br><span class="line">                dec = 0;</span><br><span class="line">                inc = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &lt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                ++dec;</span><br><span class="line">                if(dec == inc)</span><br><span class="line">                    ++dec;</span><br><span class="line">                res += dec;               </span><br><span class="line">                tmp = 1; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心2-1"><a href="#贪心2-1" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种思路是，分开两次从头至尾和从尾至头遍历数组，分别完成两条规则，从头至尾遍历保证右边分数高的糖果多于左边分数低的，从尾至头遍历保证左边分数高的糖果多于右边分数低的。</p>
<p>贪心算法局部最优在于保证当前糖果数量与上一个的糖果数量满足规则要求，但每次遍历只能满足一条规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        vector&lt;int&gt; can(ratings.size(),1);</span><br><span class="line">        for(int i = 1; i&lt;ratings.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ratings[i]&gt;ratings[i-1])</span><br><span class="line">                can[i] = can[i-1] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = ratings.size()-2; i&gt;= 0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ratings[i] &gt; ratings[i+1])</span><br><span class="line">                can[i] = max(can[i], can[i+1]+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(can.begin(),can.end(),0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>贪心1中思路更直接，但需要考虑的情况会更复杂，需要注意到<strong>转折序列中，递增和递减序列长度对转折点的影响</strong></p>
<p>贪心2分别使用了两次贪心策略，让题目要求更简洁明了</p>
<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><strong>根据身高重建队列</strong></h2><p>本题中，数组<code>[h, k]</code>序号为<code>i</code>，这意味着 身高为<code>h</code>，并且在队列前面还有<code>k</code>个身高高于或等于<code>h</code>的人，要求在于对打乱的<code>i</code>重新排序成正确顺序，使得<code>h</code>和<code>k</code>排列符合规则</p>
<h3 id="贪心-6"><a href="#贪心-6" class="headerlink" title="贪心"></a>贪心</h3><p>在一次遍历中，并不能做到满足两条规则，需要分两步走，根据规则各自使用贪心策略。<strong>首先，对于数组的第0个元素，即身高，排列时的局部最优在于当前身高小于上一个身高，也就是按照降序排列身高</strong>。而对于第1个元素k，根据规则，应当按照升序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a[0] != b[0])</span><br><span class="line">		return a[0] &gt; b[0];</span><br><span class="line">	else</span><br><span class="line">		return a[1] &lt; b[1];</span><br><span class="line">&#125;</span><br><span class="line">sort(people.begin(), people.end(), cmp);</span><br></pre></td></tr></table></figure>

<p>排列过后，数组<code>people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</code>顺序变为<code>[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</code>，可知，根据规则，在空的结果集中插入数组，贪心策略局部最优在于优先插入身高较高（即遍历排列后的数组）且其k较低的，如下插入过程所示，这样可以满足插入后的数组满足要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[7,0]</span><br><span class="line">[7,0],[7,1]</span><br><span class="line">[7,0],[6,1],[7,1]</span><br><span class="line">[5,0],[7,0],[6,1],[7,1]</span><br><span class="line">[5,0],[7,0],[5,2],[6,1],[7,1]</span><br><span class="line">[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]</span><br></pre></td></tr></table></figure>

<p><strong>第二步中的贪心优先处理身高较高的，在较高的排列完成后，就算再插入次高的元素也不会影响排列，依旧符合规则，在插入次高元素时，由于规则要求在此元素之前要有k个身高大于等于其身高的元素，因此，可以直接在位置k插入，使得局部上最优。</strong></p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2)</span><br><span class="line">    &#123;</span><br><span class="line">        if (v1[0] != v2[0])</span><br><span class="line">            return v1[0] &gt; v2[0];</span><br><span class="line">        else</span><br><span class="line">            return v1[1] &lt; v2[1];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(), cmp);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (int i = 0; i &lt; people.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.insert(res.begin() + people[i][1],people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在定义<code>cmp</code>函数时，将其定义为<code>static</code>静态函数是因为在类内定义函数，如果定义成非静态函数，则函数属于类的对象，而非类共有的函数，也就是说会隐式传递了<code>this</code>指针，那么类的对象在调用该函数的时候，就会通过指针隐式传递到函数参数列表中，来区分是哪一个对象调用函数，非静态函数实际参数为<code>bool cmp(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2, Solution* this)</code></strong></p>
<h3 id="贪心优化"><a href="#贪心优化" class="headerlink" title="贪心优化"></a>贪心优化</h3><p>在上一版本中的代码中，借助数组来记录结果，而数组在进行<code>insert</code>操作时，时间复杂度为O(n)，显得并不高效，因此可以借助链表来完成多次的插入操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2)</span><br><span class="line">    &#123;</span><br><span class="line">        if (v1[0] != v2[0])</span><br><span class="line">            return v1[0] &gt; v2[0];</span><br><span class="line">        else</span><br><span class="line">            return v1[1] &lt; v2[1];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(), cmp);</span><br><span class="line">        list&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (int i = 0; i &lt; people.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            auto index = people[i][1];</span><br><span class="line">            auto iter = res.begin();</span><br><span class="line">            while(index--)</span><br><span class="line">            &#123;</span><br><span class="line">                iter++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.insert(iter,people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;vector&lt;int&gt;&gt; (res.begin(),res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在调整迭代器位置时，还可以使用<code>advance</code>标准库函数，<code>advance(it,n)</code>可以让迭代器<code>it</code>往前移动<code>n</code>个位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto index = people[i][1];</span><br><span class="line">auto iter = res.begin();</span><br><span class="line">advance(iter, index);</span><br><span class="line">res.insert(iter, people[i]);</span><br></pre></td></tr></table></figure>

<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>与[上一题](# 分发糖果)比较，都是需要分两步走，把规则拆分成两步再分别使用贪心策略，这一题中最关键点在于在第二步中的贪心策略，<strong>局部最优在于插入一个元素时，只考虑当前规则是要求只有k个值在其前面，因此可以直接插入到第k个位置上，并且插入之后也不会影响已经插入的元素，符合规则</strong></p>
<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><strong>用最少数量的箭引爆气球</strong></h2><p>这道题中，使用数量尽可能少的箭引爆更多的气球，首先，可以用过排序让带有重叠区间的数组分布在一起，而排序则又可以分为两种，分别是根据开始位置和结束位置，对应了不同方向的思路</p>
<h3 id="贪心1-2"><a href="#贪心1-2" class="headerlink" title="贪心1"></a>贪心1</h3><p>按照开始位置来进行排序，定义排序函数，开始位置小的会排在前面，如果开始位置相同，则结束位置更小的排在前面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a[0]==b[0])</span><br><span class="line">		return a[1] &lt; b[1];</span><br><span class="line">	return a[0] &lt; b[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，对于数组<code>[[10,16],[2,8],[1,6],[7,12]]</code>将会排序成<code>[[1,6],[2,8],[7,12],[10,16]]</code>，接着，为了追求最少数量的箭，在区间尽可能排序成重复的基础上，<strong>局部最优在于取重复数组区间的最小的结束位置</strong>，并在该位置上射出弓箭，这样就能尽可能覆盖到更多的不同区间，即引爆更多的气球</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[0]!=b[0])</span><br><span class="line">            return a[0] &lt; b[0];</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        if(points.size()==0)    return 0;</span><br><span class="line">        int res = points.size();</span><br><span class="line">        sort(points.begin(), points.end(),cmp);</span><br><span class="line">        int en = points[0][1];</span><br><span class="line">        for(int i = 1; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(en &gt;= points[i][0]) //有重叠 </span><br><span class="line">            &#123;</span><br><span class="line">                res--;</span><br><span class="line">                en = min(points[i][1], en); </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                en = points[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用一个变量<code>en</code>来记录重复区间结束位置，<code>if(en &gt;= points[i][0])	en = min(points[i][1], en)</code>当遇到有重叠区间时，应对<code>en</code>进行更新，令其等于 <strong>当前区间的结束位置</strong> 和 <strong>原结束位置</strong> 的最小值，而不是直接赋值等于当前区间的结束位置或上一个区间的结束位置。也因为不需要返回原数组，可以在原数组上直接修改结束位置，只需要判断上一个区间的结束位置，并不断对其进行维护<code>points[i][1] = min(points[i-1][1], points[i][1])</code></p>
<h3 id="贪心2-2"><a href="#贪心2-2" class="headerlink" title="贪心2"></a>贪心2</h3><p>另外一种方法是用不同的排序方法，按照区间的结束位置来进行排序，结束位置较小的则排在前面，如果结束位置相同则让开始位置较小的靠前（这一步不影响）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a[1]==b[1])</span><br><span class="line">		return a[0] &lt; b[0];</span><br><span class="line">	return a[1] &lt; b[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种排序下，只需要判断<strong>当前区间的开始位置与重复区间的结束位置是否有重叠</strong>，用<code>en</code>来对重复区间的结束位置进行记录，如果没有则需要增加弓箭的数量，而如果开始位置小于等于上一个区间的结束位置，则无论如何两个区间都会有重叠，并且<strong>有重叠时不用对<code>en</code>进行更新，保持原来的重复区间结束位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        if(points.size()==0)    return 0;</span><br><span class="line">        int res = 1;</span><br><span class="line">        sort(points.begin(), points.end(),cmp);</span><br><span class="line">        int en = points[0][1];</span><br><span class="line">        for(int i = 1; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(en &lt; points[i][0]) //无重叠 </span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                en = points[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>两种排序方法引出两种对重叠区间不同的判断方式，且都是用到了贪心策略，<strong>尽可能让当前区间的开始元素与记录区间的结束元素有重叠，即通过排序再加上尽量去重叠区间的最大值，则可以覆盖到更多区间</strong></p>
<p>第一种排序方式，<strong>按区间的开始位置升序排列</strong>，借助变量<code>en</code>记录有重复区间的结束位置，不论是否有重叠区间，都要对<code>en</code>进行维护，<strong>当有重叠时，<code>en</code>取当前区间的结束位置和原结束位置的最小值</strong>；当没有重叠时，<code>en</code>则取当前区间的结束位置</p>
<p>第二种排序方式，<strong>按区间的结束位置升序排列</strong>，同样借助变量<code>en</code>对重叠区间的结束位置进行记录，因为是根据结束位置进行了排序，<strong>当有重叠时，对<code>en</code>不需要进行维护，因为<code>en</code>的值已经是当前包括之前所有区间的结束位置的最小值</strong>；在没有重叠时，<code>en</code>也同样取当前区间的结束位置</p>
<p>时间复杂度为O(n log n + n)，为排序消耗的时间和遍历数组的时间，空间复杂度为O(log n)，排序所占用的栈空间，最坏情况下为O(n)，需要n次的递归调用</p>
<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>该题与[上一题](# 用最少数量的箭引爆气球)比较相像，都是有关于重叠的区间，而这题要求的是找出导致重叠的区间并将其删除，返回要删除的个数</p>
<h3 id="贪心-7"><a href="#贪心-7" class="headerlink" title="贪心"></a>贪心</h3><p>类似的，首先需要排序，让重叠的区间尽可能靠近，这里按照区间的结束位置升序排列，但对于相同的结束位置的区间，应该考虑到<strong>优先删除开始位置更小的区间</strong>，因为<strong>开始位置小，所覆盖的区间更大，出现与其他区间相互重叠的可能性也更大</strong>。因此遍历顺序应该是先确定区间结束位置更小，并且区间内所覆盖的范围也要更小，当遇到有重叠的区间则应该增加删除的数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[1]==b[1])</span><br><span class="line">            return a[0] &gt; b[0];</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(intervals.size()==1)</span><br><span class="line">            return res;</span><br><span class="line">        sort(intervals.begin(),intervals.end(),cmp);</span><br><span class="line">        int en = intervals[0][1];</span><br><span class="line">        for(int i = 1; i &lt; intervals.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(en &gt; intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                en = intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>该题中，<strong>局部优化在于按照区间的结束位置排序，并且要将范围更小的区间排列在先，是为了占用更小的空间，减少重叠的发生</strong></p>
<p>同样的，这题也可以<strong>按照区间的开始位置排序，这时要将范围更大的区间排列在先，并且是采用从右往左的遍历方式</strong>，也是出于相同的原因</p>
<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><strong>划分字母区间</strong></h2><p>首先看到划分字符串想到的是回溯法，但在这题中并不需要暴力搜索。题目要求的是同一个字母只出现在一个分段中，而且只有分段最多的分法正确</p>
<p>首先需要遍历一次，得到所有字母对应的下标，借助可变数组来保存每个字母最后一次出现的下标位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; hashmap(26);</span><br><span class="line">for(int i = 0; i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	hashmap[s[i]-&#x27;a&#x27;] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="贪心-8"><a href="#贪心-8" class="headerlink" title="贪心"></a>贪心</h3><p>在得到每个字母对应最远的下标后，使用贪心策略，局部最优在于<strong>一个分段尽可能小，但同时还要包含出现过的字母的所有范围</strong>，再对字符串进行遍历，对于一个片段，划分完成时，当前下标与哈希表中字母的最后一次出现的下标位置相同，并且，在遍历的过程中，对<code>tmp</code>更新为 <strong>当前字母的最远距离</strong> 和 <strong>原字母的最远距离</strong> 的较大值，也就是将<code>tmp</code>保持为该片段中含有的字母出现的最大位置或最远距离。也就是说，在一个片段中，划分只与该片段中有最长距离的字母有关，在遍历过程中，不断更新这个字母，当遍历到该字母的最长距离时，即一个片段的划分完成</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; partitionLabels(string s) &#123;</span><br><span class="line">        vector&lt;int&gt; hashmap(26);</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int tmp = 0, count = 1;</span><br><span class="line">        for(int i = 0; i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hashmap[s[i] - &#x27;a&#x27;] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = max(tmp, hashmap[s[i]-&#x27;a&#x27;]);</span><br><span class="line">            if(i==tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count);</span><br><span class="line">                count = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在该题中十分巧妙，贪在<strong>当前片段下，要让片段尽可能小的同时还要保证出现过的字母只在该片段中出现</strong>。这就需要借助哈希表来记录<strong>每个字母最后一次出现的位置</strong>，即它们各自的最大距离；在对字符串遍历过程中，还要维护<strong>保证每个出现过的字母的最远距离</strong>，这个距离就是这个片段长度的<strong>最小长度</strong></p>
<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>该题要求对有重叠的区间进行最大化合并，返回合并后的区间</p>
<p>类似于之前的有关重叠区间题目，该题也是将各区间进行排序后，再使用贪心策略，将尽可能多的区间进行合并</p>
<h3 id="贪心1-3"><a href="#贪心1-3" class="headerlink" title="贪心1"></a>贪心1</h3><p>先按照区间的结束位置升序排列，结束位置较小的排在前面。因为开始位置不影响结果，所以可不给出排序规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于区间数组<code>[[1,10],[2,5],[6,9]]</code>则会排序变为<code>[[2,5],[6,9],[1,10]]</code>，接着，为了能够合并更多的区间，借助变量<code>tmp</code>取值为重叠区间的结束位置，<strong>正向遍历数组</strong>，当遇到<code>tmp &lt; intervals[i][0]</code>时代表没有重叠区间，则直接把该区间加入到结果集中，但当遍历到<code>[1,10]</code>时，该区间已将前面全部区间所包含，导致不正确的原因是遍历方式选择不正确，在该题中，<strong>如果按照区间的结束位置来排列，则遍历顺序应该是从尾到头的逆向遍历</strong></p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 1) return intervals;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int st = intervals[intervals.size()-1][0], en = intervals[intervals.size()-1][1];</span><br><span class="line">        for (int i = intervals.size()-1; i &gt;= 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (st &lt;= intervals[i][1]) // 有重叠</span><br><span class="line">            &#123;</span><br><span class="line">                st = min(st, intervals[i][0]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(vector&lt;int&gt; &#123;st, en&#125;);</span><br><span class="line">                st = intervals[i][0];</span><br><span class="line">                en = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(vector&lt;int&gt; &#123;st,en&#125;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心2-3"><a href="#贪心2-3" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种方式则是<strong>按照开始位置升序排列，此时，应该正向遍历数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[0] &lt; b[0];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 1) return intervals;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int st = intervals[0][0], en = intervals[0][1];</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (en &gt;= intervals[i][0]) // 有重叠</span><br><span class="line">            &#123;</span><br><span class="line">                en = max(intervals[i][1], en);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(vector&lt;int&gt; &#123;st, en&#125;);</span><br><span class="line">                st = intervals[i][0];</span><br><span class="line">                en = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(vector&lt;int&gt; &#123;st,en&#125;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>该题与<a href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4">无重叠区间</a>相比有相反的感觉，都是要找到重叠区间的部分，但后者是优先寻找到范围更小的区间，是为了减少重叠的可能性；而这题是要优先找到范围更大的区间，就是为了要尽可能多的重叠区间。也因此，<strong>要根据不同的目的，针对不同排序方式下选用不同的遍历顺序</strong></p>
<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>该题要求返回小于等于给定输入的尽可能大的数，并且返回值按位非严格递增，如给定<code>98</code>则返回<code>89</code></p>
<h3 id="贪心-9"><a href="#贪心-9" class="headerlink" title="贪心"></a>贪心</h3><p>要求返回的数尽可能大，那么局部最优在于先从低位修改，这也确定了遍历顺序是从右往左，如果<code>num[i]</code>大于<code>num[i+1]</code>，不符合按位递增规则，则<code>num[i]--; num[i+1]=&#39;9&#39;;</code>。但是如果给定输入为<code>1000</code>，只修改为<code>900</code>，而原本应该为<code>999</code>，因此，需要另外借助变量记录开始修改为9的位置，即<code>i+1</code>处，在<code>i+1</code>往后的位置都应该赋值为9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int monotoneIncreasingDigits(int n) &#123;</span><br><span class="line">        string num = to_string(n);</span><br><span class="line">        int flag = num.size();</span><br><span class="line">        for (int i = num.size() - 1; i &gt; 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (num[i -1] &gt; num[i])</span><br><span class="line">            &#123;</span><br><span class="line">                num[i - 1]--;</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = flag; i &lt; num.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i] = &#x27;9&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return stoi(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(log n)，n为输入的数，log n对应其位数，空间复杂度为O(log n)，占用log n的空间来存放数的每一位</p>
<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在于 <strong>为了取到最大值，从数的低位开始修改</strong>，这就确定了从右往左的遍历顺序；还需要有标志位来记录需要变为9的所有位置</p>
<h2 id="买卖股票最佳时机I"><a href="#买卖股票最佳时机I" class="headerlink" title="买卖股票最佳时机I"></a><strong>买卖股票最佳时机I</strong></h2><p>与[同系列的上一题](# 买卖股票最佳时机II)相比，该题还增加了手续费，相当于限制了买卖次数，需要找到除去手续费后的最大利润，而不能像上一题那样无限制买入卖出</p>
<h3 id="贪心-10"><a href="#贪心-10" class="headerlink" title="贪心"></a>贪心</h3><p>思路依旧还是 希望能够在最低点买入，然后在最高点卖出，而因为有了手续费，还会有新的情况需要考虑到：<strong>如何知道当前点是最高点</strong></p>
<p>贪心策略就是用于解决这个问题，首先遍历寻找最低点进行买入，并维护<code>buy = prices[l]+fee</code>，此时<code>l</code>为最低点，如果遍历到该点利润大于零，可以虚拟地卖出了这只股票，利润值增加<code>profit += prices[sh] - buy = prices[sh] - prices[l] -fee</code>，此时<code>sh</code>为次高点，并且已经扣除了手续费，模拟在这个次高点虚拟卖出，同时还要更新买入价格为 <strong>当前股票价格</strong>，即<code>buy = prices[sh]</code>，如此一来，当遍历到下一个点发现股票价格还在上涨时<code>prices[h]&gt;prices[sh]</code>，则又虚拟的假设成在这个最高点上卖出了股票，由于买入价格的更新，利润值更新为<code>profit += prices[h] - buy = prices[h] -prices[sh] </code>，可以看出，根据这时候获得的利润，可以模拟出<strong>最低点买入而在最高点卖出</strong>的过程</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int buy = prices[0] + fee;</span><br><span class="line">        for(int i = 0; i &lt; prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i]+fee &lt; buy)</span><br><span class="line">                buy = prices[i] + fee;</span><br><span class="line">            else if(prices[i] &gt; buy)</span><br><span class="line">            &#123;</span><br><span class="line">                res += prices[i] - buy;</span><br><span class="line">                buy = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>相同思路，而不必将<code>buy</code>维护成最低买入点与手续费的和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int buy = prices[0];</span><br><span class="line">        for(int i = 0; i &lt; prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i] &lt; buy)</span><br><span class="line">                buy = prices[i] ;</span><br><span class="line">            else if(prices[i] &gt; buy + fee)</span><br><span class="line">            &#123;</span><br><span class="line">                res += prices[i] - buy - fee;</span><br><span class="line">                buy = prices[i]-fee;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在该题中体现在 <strong>遇到次高点时虚拟的卖出，更新利润的同时也更新买入价格，即虚拟地在该点买入</strong>，这也是局部最优的所在</p>
<p>遍历数组的时候，会有以下三种情况：</p>
<ul>
<li>该点比买入点更低，则更新买入的最低点</li>
<li>该点比买入点和手续费的和更高，即利润大于0，此时虚拟地卖出，更新利润以及更新买入点，也为后续更高点准备</li>
<li>该点在<code>[低买入点+手续费，高卖出点]</code>范围，即没有利润，则此时不会卖出，不进行任何操作</li>
</ul>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a><strong>监控二叉树</strong></h2><p>题目要求添加最少的监控，覆盖到所有的二叉树结点</p>
<p>一开始，想到根据父结点的值来判断当前结点是否需要添加监控，如果父结点值为0，则为当前结点添加监控；反之亦然。同时使用层序迭代遍历二叉树即可完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1;</span><br><span class="line">        int res = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;//还要存父结点</span><br><span class="line">        //层序遍历</span><br><span class="line">        TreeNode* pre, *cur;</span><br><span class="line">        que.push(nullptr);</span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i = 0; i &lt; que.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pre = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line"></span><br><span class="line">                if(pre &amp;&amp; pre-&gt;val == 0 &amp;&amp; (cur-&gt;left||cur-&gt;right))</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    cur-&gt;val = 1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(cur-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(cur);</span><br><span class="line">                    que.push(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(cur-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(cur);</span><br><span class="line">                    que.push(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然而，这种方法下，当遇到的二叉树<strong>添加监控的结点的孙子结点是叶子结点时，则无法做到监控的全覆盖</strong></p>
<h3 id="贪心-11"><a href="#贪心-11" class="headerlink" title="贪心"></a>贪心</h3><p>采用贪心策略，局部最优在于<strong>为了添加的监控数量最少，则只给叶子结点的父结点添加监控</strong></p>
<p>针对以上，结点值会有三种状态：<strong>0表示无覆盖，1表示有监控，2表示被覆盖</strong>。增加结点值为 2 是为了方便表示叶子结点等的状态，进而，二叉树的遍历顺序应为<strong>后序遍历</strong>，先遍历子结点再遍历中间结点，由下至上的遍历顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(TreeNode* node, int&amp; res)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node)		//遇到空结点应返回2</span><br><span class="line">			return 2;</span><br><span class="line">		int l = dfs(node-&gt;left, res);</span><br><span class="line">		int r = dfs(node-&gt;right, res);</span><br><span class="line">		</span><br><span class="line">		if(l == 2 &amp;&amp; r == 2)</span><br><span class="line">         	return 0;</span><br><span class="line">         if(l == 0 || r == 0)</span><br><span class="line">         &#123;</span><br><span class="line">         	res++;</span><br><span class="line">         	return 1;</span><br><span class="line">         &#125;</span><br><span class="line">         if(l == 1 || r == 1)</span><br><span class="line">         	return 2;</span><br><span class="line">         </span><br><span class="line">         return -1;</span><br><span class="line">	&#125;</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(dfs(root, res) == 0)</span><br><span class="line">        	res++;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(log n)，最坏情况下为O(n)</p>
<p>因为后序遍历中，中间结点的处理情况需要用到其左右子结点的值来判断，因此，<strong>将当前结点的值作为递归函数的返回值</strong>。</p>
<p>根据左右子结点的值来判断当前当前结点的值，有四种情况：</p>
<ul>
<li>左右子结点都是有覆盖，则当前结点返回0，表示无覆盖</li>
<li>左右子结点有任意一个无覆盖，则当前结点应添加监控，返回1</li>
<li>左右子结点有任意一个有监控，则当前结点返回2，表示有覆盖</li>
<li>在对除根结点外的所有结点遍历结束后，对于根结点，可能会出现根结点未覆盖的情况，因此还需要对根结点的返回值进行一次判断，若返回0则需要再添加一个监控</li>
</ul>
<h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>该题中局部最优在于 <strong>不让叶子结点添加监控，而让叶子结点的父结点添加监控</strong>，在此基础上，推导出3种不同结点值的状况，并进行分类讨论</p>
<h2 id="通过最少操作次数使数组的和相等"><a href="#通过最少操作次数使数组的和相等" class="headerlink" title="通过最少操作次数使数组的和相等"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/">通过最少操作次数使数组的和相等</a></strong></h2><p>该题给定两个数组，限定数组元素值均为1~6，任意修改数组元素，使得两个数组和相等，返回操作次数</p>
<h3 id="贪心-12"><a href="#贪心-12" class="headerlink" title="贪心"></a>贪心</h3><p>采用贪心策略，局部最优在于优先让数组和大的数组元素改为1，数组和小的数组元素改为6，最快速逼近两个数组的和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        int n1 = nums1.size();</span><br><span class="line">        int n2 = nums2.size();</span><br><span class="line">        if(n1*6 &lt; n2 || n2 * 6 &lt; n1 )</span><br><span class="line">            return -1;</span><br><span class="line">        int sub = accumulate(nums1.begin(), nums1.end(),0)-accumulate(nums2.begin(), nums2.end(),0);</span><br><span class="line">        if(sub &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums1, nums2);</span><br><span class="line">            sub = -sub;</span><br><span class="line">        &#125;</span><br><span class="line">        //要求nums1 减小， nums2 增大</span><br><span class="line">        vector&lt;int&gt; cnt(6);</span><br><span class="line">        for(auto n:nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[n-1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto n:nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[6-n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 5, res = 0;;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i*cnt[i] &gt;= sub)</span><br><span class="line">                return res + (sub+i-1)/i;</span><br><span class="line">            res += cnt[i];</span><br><span class="line">            sub -= i*cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>让<code>nums1</code>的和比<code>nums2</code>的和大，即让<code>nums1</code>减小，<code>让nums2</code>增大；</p>
<p>分别遍历两个数组，借助<code>vector</code>容器记录两个数组中能够减小或增大的最大范围，如<code>cnt[4]</code>含义是数组中原始值为5或者为2的元素有<code>cnt[4]</code>个；</p>
<p>最后遍历<code>vector</code>容器，若当前减小或增大的最大范围能够覆盖两个数组的和的差，即<code>i*cnt[i] &gt;= sub</code>，意味着仅需要对当前<code>cnt[i]</code>个元素减小或增大<code>i</code>就能够让两个数组的和相等，否则，因为遍历顺序优先遍历修改范围更大的元素，所以先让这些元素对数组差进行填补，再遍历更小范围的元素；</p>
<p>返回值中<code>return res + (sub+i-1)/i;</code>而不是直接返回<code>return res + sub / i;</code>，若<code>sub</code>不能整除<code>i</code>，直接返回会有余数导致结果偏小不正确，若返回<code>return res + sub / i + 1</code>，此时若<code>sub</code>能整除<code>i</code>，没有余数又导致结果偏大不正确。因此<code>sub + i - 1</code>向上取整解决了这个问题</p>
<h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>局部最优在于<strong>优先让数组中修改范围更大的元素进行修改，以最快速度填补数组和之差</strong></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/11/09/C3P%E7%AC%AC%E4%B8%89%E3%80%81%E5%9B%9B%E9%83%A8%E5%88%86/" rel="prev" title="C3P第三部分">
                  <i class="fa fa-chevron-left"></i> C3P第三部分
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/12/02/DP%E7%AB%A0%E8%8A%82/" rel="next" title="DP章节">
                  DP章节 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
