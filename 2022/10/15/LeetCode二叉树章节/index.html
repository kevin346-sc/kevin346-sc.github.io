<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kevin346-sc.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="LeetCode二叉树章节二叉树的递归遍历形式固定，相对简单，不同遍历仅仅改变代码顺序  先序递归遍历  1234567891011121314151617181920212223242526272829&#x2F;&#x2F;中左右&#x2F;&#x2F;            1&#x2F;&#x2F;         &#x2F;     \&#x2F;&#x2F;        2       3&#x2F;&#x2F;       &#x2F;  \    &#x2F;  \&#x2F;&#x2F;      4    5  6">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode贪心算法章节">
<meta property="og:url" content="https://kevin346-sc.github.io/2022/10/15/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AB%A0%E8%8A%82/index.html">
<meta property="og:site_name" content="Serein’s Blog">
<meta property="og:description" content="LeetCode二叉树章节二叉树的递归遍历形式固定，相对简单，不同遍历仅仅改变代码顺序  先序递归遍历  1234567891011121314151617181920212223242526272829&#x2F;&#x2F;中左右&#x2F;&#x2F;            1&#x2F;&#x2F;         &#x2F;     \&#x2F;&#x2F;        2       3&#x2F;&#x2F;       &#x2F;  \    &#x2F;  \&#x2F;&#x2F;      4    5  6">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rjwc2zvww.hn-bkt.clouddn.com/invert2-tree.jpg?e=1666095210&token=nvUz3pCbpAvvS7EDBSYy4y-3Z_w8Q5E-JegZiINf:Asr154wbRoPorJIjGWPjLHwOz3k=">
<meta property="og:image" content="https://kevin346-sc.github.io/invert1-tree.jpg">
<meta property="og:image" content="https://kevin346-sc.github.io/invert2-tree.jpg">
<meta property="og:image" content="http://rjwc2zvww.hn-bkt.clouddn.com/invert1-tree.jpg?e=1666095256&token=nvUz3pCbpAvvS7EDBSYy4y-3Z_w8Q5E-JegZiINf:oS9ISvGEMgbb3DZszw7vezLUNjA=">
<meta property="article:published_time" content="2022-10-15T08:13:21.000Z">
<meta property="article:modified_time" content="2022-11-24T00:28:24.000Z">
<meta property="article:author" content="Kevin Huang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rjwc2zvww.hn-bkt.clouddn.com/invert2-tree.jpg?e=1666095210&token=nvUz3pCbpAvvS7EDBSYy4y-3Z_w8Q5E-JegZiINf:Asr154wbRoPorJIjGWPjLHwOz3k=">


<link rel="canonical" href="https://kevin346-sc.github.io/2022/10/15/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AB%A0%E8%8A%82/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kevin346-sc.github.io/2022/10/15/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AB%A0%E8%8A%82/","path":"2022/10/15/LeetCode二叉树章节/","title":"LeetCode贪心算法章节"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LeetCode贪心算法章节 | Serein’s Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Serein’s Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AB%A0%E8%8A%82"><span class="nav-number">1.</span> <span class="nav-text">LeetCode二叉树章节</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="nav-number">1.1.</span> <span class="nav-text">二叉树的递归遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.</span> <span class="nav-text">二叉树的迭代遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.3.</span> <span class="nav-text">翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="nav-number">1.3.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.4.</span> <span class="nav-text">对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.5.</span> <span class="nav-text">二叉树最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-2"><span class="nav-number">1.5.1.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-2"><span class="nav-number">1.5.2.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">1.5.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#N%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.6.</span> <span class="nav-text">N叉树最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-3"><span class="nav-number">1.6.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-3"><span class="nav-number">1.6.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">1.6.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.7.</span> <span class="nav-text">二叉树最小深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-4"><span class="nav-number">1.7.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-4"><span class="nav-number">1.7.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">1.7.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-number">1.8.</span> <span class="nav-text">完全二叉树的结点个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-5"><span class="nav-number">1.8.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-5"><span class="nav-number">1.8.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#special%E8%A7%A3%E6%B3%95"><span class="nav-number">1.8.3.</span> <span class="nav-text">special解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-number">1.8.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.9.</span> <span class="nav-text">平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B1%E9%A1%B6%E8%87%B3%E5%BA%95%E6%B3%95"><span class="nav-number">1.9.1.</span> <span class="nav-text">由顶至底法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B1%E5%BA%95%E8%87%B3%E9%A1%B6%E6%B3%95"><span class="nav-number">1.9.2.</span> <span class="nav-text">由底至顶法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-6"><span class="nav-number">1.9.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="nav-number">1.10.</span> <span class="nav-text">二叉树的所有路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-6"><span class="nav-number">1.10.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-7"><span class="nav-number">1.10.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="nav-number">1.11.</span> <span class="nav-text">左叶子之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-7"><span class="nav-number">1.11.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-6"><span class="nav-number">1.11.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-8"><span class="nav-number">1.11.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="nav-number">1.12.</span> <span class="nav-text">找树左下角的值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-8"><span class="nav-number">1.12.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-7"><span class="nav-number">1.12.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-9"><span class="nav-number">1.12.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C"><span class="nav-number">1.13.</span> <span class="nav-text">路径之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-9"><span class="nav-number">1.13.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-8"><span class="nav-number">1.13.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-10"><span class="nav-number">1.13.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8CII"><span class="nav-number">1.14.</span> <span class="nav-text">路径之和II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-10"><span class="nav-number">1.14.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-11"><span class="nav-number">1.14.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.15.</span> <span class="nav-text">从中序和后序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-11"><span class="nav-number">1.15.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">1.15.2.</span> <span class="nav-text">迭代法？？？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-12"><span class="nav-number">1.15.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.16.</span> <span class="nav-text">从先序和中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-12"><span class="nav-number">1.16.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-13"><span class="nav-number">1.16.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.17.</span> <span class="nav-text">最大二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-13"><span class="nav-number">1.17.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88special%E8%A7%A3%E6%B3%95"><span class="nav-number">1.17.2.</span> <span class="nav-text">单调栈special解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-14"><span class="nav-number">1.17.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.18.</span> <span class="nav-text">合并二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-14"><span class="nav-number">1.18.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-9"><span class="nav-number">1.18.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%B3%95%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">1.18.3.</span> <span class="nav-text">指针法？？？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-15"><span class="nav-number">1.18.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-number">1.19.</span> <span class="nav-text">二叉搜索树中的搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-15"><span class="nav-number">1.19.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-10"><span class="nav-number">1.19.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-16"><span class="nav-number">1.19.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.20.</span> <span class="nav-text">验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-16"><span class="nav-number">1.20.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-11"><span class="nav-number">1.20.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-17"><span class="nav-number">1.20.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="nav-number">1.21.</span> <span class="nav-text">二叉搜索树的最小绝对差</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-17"><span class="nav-number">1.21.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-12"><span class="nav-number">1.21.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-18"><span class="nav-number">1.21.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="nav-number">1.22.</span> <span class="nav-text">二叉搜索树中的众数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-18"><span class="nav-number">1.22.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-13"><span class="nav-number">1.22.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-19"><span class="nav-number">1.22.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">1.23.</span> <span class="nav-text">二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-19"><span class="nav-number">1.23.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92hashmap%E6%9F%A5%E8%A1%A8%E6%B3%95"><span class="nav-number">1.23.2.</span> <span class="nav-text">递归hashmap查表法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-20"><span class="nav-number">1.23.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">1.24.</span> <span class="nav-text">二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-20"><span class="nav-number">1.24.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-14"><span class="nav-number">1.24.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-21"><span class="nav-number">1.24.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">1.25.</span> <span class="nav-text">二叉搜索树的插入操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-21"><span class="nav-number">1.25.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-15"><span class="nav-number">1.25.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-22"><span class="nav-number">1.25.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9"><span class="nav-number">1.26.</span> <span class="nav-text">删除二叉搜索树中的结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.26.1.</span> <span class="nav-text">对回溯法的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-22"><span class="nav-number">1.26.2.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-16"><span class="nav-number">1.26.3.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-23"><span class="nav-number">1.26.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.27.</span> <span class="nav-text">修剪二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-23"><span class="nav-number">1.27.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-17"><span class="nav-number">1.27.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-24"><span class="nav-number">1.27.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.28.</span> <span class="nav-text">将有序数组转换成二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-24"><span class="nav-number">1.28.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-18"><span class="nav-number">1.28.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-25"><span class="nav-number">1.28.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-number">1.29.</span> <span class="nav-text">把二叉搜索树转换成累加树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-25"><span class="nav-number">1.29.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-19"><span class="nav-number">1.29.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-26"><span class="nav-number">1.29.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kevin Huang</p>
  <div class="site-description" itemprop="description">c++</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/10/15/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LeetCode贪心算法章节 | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode贪心算法章节
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-15 16:13:21" itemprop="dateCreated datePublished" datetime="2022-10-15T16:13:21+08:00">2022-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-24 08:28:24" itemprop="dateModified" datetime="2022-11-24T08:28:24+08:00">2022-11-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="LeetCode二叉树章节"><a href="#LeetCode二叉树章节" class="headerlink" title="LeetCode二叉树章节"></a>LeetCode二叉树章节</h1><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><p>形式固定，相对简单，不同遍历仅仅改变代码顺序</p>
<ul>
<li>先序递归遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中左右</span></span><br><span class="line"><span class="comment">//            1</span></span><br><span class="line"><span class="comment">//         /     \</span></span><br><span class="line"><span class="comment">//        2       3</span></span><br><span class="line"><span class="comment">//       /  \    /  \</span></span><br><span class="line"><span class="comment">//      4    5  6    7     遍历顺序 1 - 2 - 4 - 5 - 3 - 6 - 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(nullprt),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x,TreeNode* leftnode, TreeNode* rightnode):<span class="built_in">val</span>(x),<span class="built_in">left</span>(leftnode),<span class="built_in">right</span>(rightnode)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(TreeNode* root)</span><span class="comment">//用数组返回储存遍历的结点的值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);	<span class="comment">//中</span></span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);	 	<span class="comment">//左</span></span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);	 	<span class="comment">//右</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>中序递归遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左中右</span></span><br><span class="line"><span class="comment">//            1</span></span><br><span class="line"><span class="comment">//         /     \</span></span><br><span class="line"><span class="comment">//        2       3</span></span><br><span class="line"><span class="comment">//       /  \    /  \</span></span><br><span class="line"><span class="comment">//      4    5  6    7     遍历顺序 4 - 2 - 5 - 1 - 6 - 3 - 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x,TreeNode* left,TreeNode* right):<span class="built_in">val</span>(x),<span class="built_in">left</span>(left),<span class="built_in">right</span>(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);          <span class="comment">//左</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);	  <span class="comment">//中</span></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);		 <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>后序递归遍历<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右中</span></span><br><span class="line"><span class="comment">//            1</span></span><br><span class="line"><span class="comment">//         /     \</span></span><br><span class="line"><span class="comment">//        2       3</span></span><br><span class="line"><span class="comment">//       /  \    /  \</span></span><br><span class="line"><span class="comment">//      4    5  6    7     遍历顺序 4 - 5 - 2 - 6 - 7 - 3 - 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x,TreeNode* left,TreeNode* right):<span class="built_in">val</span>(x),<span class="built_in">left</span>(left),<span class="built_in">right</span>(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;left);		<span class="comment">//左</span></span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;right);		<span class="comment">//右</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);	<span class="comment">//中</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><p>先、中、后序遍历均属于DFS（深度优先搜索算法），借助栈实现</p>
<p>而层序遍历为BFS（广度优先搜索算法），借助队列实现</p>
<ul>
<li>先序迭代遍历</li>
</ul>
<p>对于先序迭代遍历（中左右）和后序迭代遍历（左右中），<strong>访问顺序</strong>和<strong>处理顺序</strong>相同，仅需要改变入栈顺序，再翻转数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//中左右</span><br><span class="line">//            1</span><br><span class="line">//         /     \</span><br><span class="line">//        2       3</span><br><span class="line">//       /  \    /  \</span><br><span class="line">//      4    5  6    7     遍历顺序 1 - 2 - 4 - 5 - 3 - 6 - 7</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">int val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line"></span><br><span class="line">TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">TreeNode(int x):val(x),left(nullprt),right(nullptr)&#123;&#125;</span><br><span class="line">TreeNode(int x,TreeNode* leftnode, TreeNode* rightnode):val(x),left(leftnode),right(rightnode)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">    vector&lt;int&gt; preorder(TreeNode* root)//用数组返回储存遍历的结点的值</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        while(!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        	TreeNode* node = stk.top();</span><br><span class="line">        	stk.pop();</span><br><span class="line">        	res.push_back(node-&gt;val);				//中</span><br><span class="line">        	if(node-&gt;right) stk.push(node-&gt;right);	 //右，保证空结点不入栈</span><br><span class="line">        	if(node-&gt;left) stk.push(node-&gt;left);	 //左，保证空结点不入栈</span><br><span class="line">        	//由于栈的先进后出，后进先出的特性，先将右节点入栈，再将左节点入栈</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>后序迭代遍历<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//左右中</span><br><span class="line">//            1</span><br><span class="line">//         /     \</span><br><span class="line">//        2       3</span><br><span class="line">//       /  \    /  \</span><br><span class="line">//      4    5  6    7     遍历顺序 4 - 5 - 2 - 6 - 7 - 3 - 1</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">int val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line"></span><br><span class="line">TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">TreeNode(int x):val(x),left(nullprt),right(nullptr)&#123;&#125;</span><br><span class="line">TreeNode(int x,TreeNode* leftnode, TreeNode* rightnode):val(x),left(leftnode),right(rightnode)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">    vector&lt;int&gt; preorder(TreeNode* root)//用数组返回储存遍历的结点的值</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        while(!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        	TreeNode* node = stk.top();</span><br><span class="line">        	stk.pop();</span><br><span class="line">        	res.push_back(node-&gt;val);				//中</span><br><span class="line">        	if(node-&gt;left) stk.push(node-&gt;left);	 //左，保证空结点不入栈</span><br><span class="line">        	if(node-&gt;right) stk.push(node-&gt;right);	 //右，保证空结点不入栈</span><br><span class="line">        	//由于栈的先进后出，后进先出的特性，先将左节点入栈，再将右节点入栈，翻转后符合左右中</span><br><span class="line">        &#125;</span><br><span class="line">        return reverse(res.begin(),res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>中序迭代遍历</li>
</ul>
<p>而中序迭代遍历（左中右）先访问中间结点，但先处理左结点（存入数组），故需要额外用<em><strong>cur指针</strong></em>不断指向最左结点并将沿路左结点入栈，先处理左结点随后不断回退读取中间结点和右结点完成遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//左中右</span><br><span class="line">//            1</span><br><span class="line">//         /     \</span><br><span class="line">//        2       3</span><br><span class="line">//       /  \    /  \</span><br><span class="line">//      4    5  6    7     遍历顺序 4 - 2 - 5 - 1 - 6 - 3 - 7</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    vector&lt;int&gt; inorder(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        while(!stk.empty()||!cur)</span><br><span class="line">        &#123;</span><br><span class="line">        	if(!cur) 				//cur已指向最左结点的左结点(nullptr)</span><br><span class="line">        	&#123;</span><br><span class="line">        		TreeNode* node = stk.top();</span><br><span class="line">                 stk.pop();</span><br><span class="line">                 res.push_back(node-&gt;val);					//中</span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">                 if(node-&gt;right) stk.push(node-&gt;right);		 //右      有漏洞</span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">        	&#125;</span><br><span class="line">        	else					//cur不指向空结点时</span><br><span class="line">        	&#123;</span><br><span class="line">        		stk.push(cur);							   //左，且保证空结点不入栈</span><br><span class="line">                 cur = cur-&gt;left;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码段有漏洞，原因在于<code> if(node-&gt;right) stk.push(node-&gt;right)</code> ，没有考虑到当前右结点还有左结点的可能性，从而导致没有完全遍历。因此，并不需要创建新节点<code> TreeNode* node</code> ，而是继续赋值给<code>cur</code>指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(!cur)</span><br><span class="line">&#123;</span><br><span class="line">    cur = stk.top();</span><br><span class="line">    stk.pop();</span><br><span class="line">    cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续让<code>cur</code> 指针指向子树中的最左结点，完成遍历。</p>
<ul>
<li>层序迭代遍历<br>因为需要边访问（入）边处理结点（出），栈无法满足使用需求，因此使用队列完成层序迭代遍历<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//            1</span><br><span class="line">//         /     \</span><br><span class="line">//        2       3</span><br><span class="line">//       /  \    /  \</span><br><span class="line">//      4    5  6    7     遍历顺序 1 - 2 - 3 - 4 - 5 - 6 - 7</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">	vector&lt;int&gt; levelorder(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return res;</span><br><span class="line">		queue&lt;TreeNode*&gt; que;</span><br><span class="line">		que.push(root);</span><br><span class="line">		while(!que.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int qsize = que.size();</span><br><span class="line">			for(int i = 0; i&lt;qsize;i++)</span><br><span class="line">			&#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                res.push_back(node-&gt;val);</span><br><span class="line">                if(node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>[LeetCode226](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（LeetCode）</a>)</p>
<p>给你一颗二叉树的根节点<code>root</code>，翻转这棵二叉树，并返回其根节点。</p>
<p>示例1：</p>
<p><img src="http://rjwc2zvww.hn-bkt.clouddn.com/invert2-tree.jpg?e=1666095210&token=nvUz3pCbpAvvS7EDBSYy4y-3Z_w8Q5E-JegZiINf:Asr154wbRoPorJIjGWPjLHwOz3k=" alt="示例1"></p>
<p><img src="/invert1-tree.jpg" alt="aa"></p>
<div align="center"> <img src="/invert2-tree.jpg"/> </div>
示例2：

<p><img src="http://rjwc2zvww.hn-bkt.clouddn.com/invert1-tree.jpg?e=1666095256&token=nvUz3pCbpAvvS7EDBSYy4y-3Z_w8Q5E-JegZiINf:oS9ISvGEMgbb3DZszw7vezLUNjA=" alt="示例2"></p>
<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>首先，可以考虑<em><strong>递归</strong></em>，并使用<code>swap(TreeNode* left,TreeNode* right)</code>函数完成左右子结点的交换，即翻转。考虑到处理顺序，可以使用先序递归遍历。</p>
<ol>
<li>确定递归的终止条件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root) return root;</span><br></pre></td></tr></table></figure>
①不判断<code>root-&gt;left</code>或<code>root-&gt;right</code>是否为空，会导致也将叶子结点也进行翻转，造成一定的浪费；②或递归前判断是否空结点，空结点不进入到下一层递归；③或考虑<code>root-&gt;left</code>或<code>root-&gt;right</code>是否为空，减少对叶子结点翻转的时间开销。</li>
<li>确定递归的返回值<br>由题目要求返回翻转后的根节点可知返回root结点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root)</span><br><span class="line">return root;</span><br></pre></td></tr></table></figure></li>
<li>单层递归中的逻辑处理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swap(root-&gt;left,root-&gt;right);</span><br><span class="line">if(root-&gt;let) invertTree(root-&gt;left);</span><br><span class="line">if(root-&gt;right) invertTree(root-&gt;right);</span><br></pre></td></tr></table></figure>
整体代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//全部非空结点都对其子结点进行翻转，多耗费O(2^(h-1))的时间，h为二叉树层高</span><br><span class="line">//①</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        swap(root-&gt;left,root-&gt;right);</span><br><span class="line">	    if(root-&gt;left) invertTree(root-&gt;left);</span><br><span class="line">	    if(root-&gt;right) invertTree(root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//对子结点进行判断，非子结点才进行递归，子结点不进入递归</span><br><span class="line">//②</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        if(!root-&gt;left&amp;&amp;!root-&gt;right) return root;  //子结点则退出递归</span><br><span class="line">        if(root-&gt;left&amp;&amp;(root-&gt;left-&gt;left||root-&gt;left-&gt;right)) invertTree(root-&gt;left);//判断是否子结点</span><br><span class="line">        if(root-&gt;right&amp;&amp;(root-&gt;right-&gt;left||root-&gt;right-&gt;right)) invertTree(root-&gt;right);</span><br><span class="line">        swap(root-&gt;left,root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//如果是子结点则退出递归，非子结点和子结点都进入递归</span><br><span class="line">//③</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        if(!root-&gt;left&amp;&amp;!root-&gt;right) return root;</span><br><span class="line">        swap(root-&gt;left,root-&gt;right);</span><br><span class="line">	    if(root-&gt;left) invertTree(root-&gt;left);</span><br><span class="line">	    if(root-&gt;right) invertTree(root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在对结点的子结点的子结点进行判断时，要注意结点的子结点的空指针判断！</p>
<p><code>if(root-&gt;left-&gt;left||root-&gt;left-&gt;right)</code>则忽略掉了<code>root-&gt;left</code>是空结点的可能性，</p>
<p>应改为<code>if(root-&gt;left&amp;&amp;(root-&gt;left-&gt;left||root-&gt;left-&gt;right))</code></p>
<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>下面是迭代的解法</p>
<p>很容易想到层序迭代遍历，对每个结点进行遍历然后对其子结点进行翻转；亦或者用先序迭代遍历和后序迭代遍历，都能达到翻转整棵二叉树的效果。唯独不能使用中序迭代遍历，因为左中右的处理顺序，在处理<em><strong>中间结点</strong></em>时，会将原来的左右子树也翻转，这就导致按照左中右来翻转二叉树，实际上是左中左的翻转操作顺序。</p>
<p><em><strong>迭代解法不再考虑子结点是否为空，统一只判断当前结点是否为空，即也对叶子结点进行翻转</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    </span><br><span class="line">    TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//层序迭代遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        	int qsize = que.size();</span><br><span class="line">        	for(int i = 0; i&lt;qsize;i++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		TreeNode* node = que.front();</span><br><span class="line">        		que.pop();</span><br><span class="line">        		swap(node-&gt;left,node-&gt;right);</span><br><span class="line">        		if(node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">        		if(node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//先序迭代遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return root;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        while(!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        	TreeNode* node = stk.top();</span><br><span class="line">        	stk.pop();</span><br><span class="line">        	swap(node-&gt;left,node-&gt;right);				//中</span><br><span class="line">        	if(node-&gt;right) stk.push(node-&gt;right);		//右</span><br><span class="line">        	if(node-&gt;left) stk.push(node-&gt;left);		//左</span><br><span class="line">        	//swap(node-&gt;left,node-&gt;right);				//中，后序遍历</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>翻转二叉树题目中，主要需要注意到对结束条件的判断以及后续要处理结点的条件约束，如是否需要处理叶子结点。如果设定要非叶子结点才能进入判断即<code>!root-&gt;left-&gt;left||!root-&gt;left-&gt;right</code>，需要先加入判断<code>root-&gt;left!=nullptr</code>保证孙子结点能够被合法访问</p>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>[对称二叉树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">Loading Question… - 力扣（LeetCode）</a>)</p>
<p>检查以<code>root</code>为根节点的树是否对称</p>
<h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>首先，可以想到递归法，递归函数传入两个结点，判断其值是否相等，并把下一个要判断的结点放入递归栈中</p>
<ol>
<li>判断递归结束条件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(!root) return true;</span><br><span class="line"></span><br><span class="line">if(left==nullptr&amp;&amp;right==nullptr) return true;</span><br><span class="line">if(left-&gt;val!=right-&gt;val) return false;</span><br></pre></td></tr></table></figure></li>
<li>递归返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool judge(TreeNode* left,TreeNode* right)</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure></li>
<li>单层递归函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(left-&gt;val==right-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    judge(left-&gt;left,right-&gt;right);</span><br><span class="line">    judge(right-&gt;left,left-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right; </span><br><span class="line">    TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    TreeNode(int x,TreeNode* left,TreeNode* right):val(x),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//递归判断平衡二叉树</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	bool judge(TreeNode* left,TreeNode* right)</span><br><span class="line">	&#123;</span><br><span class="line">		if(left==nullptr&amp;&amp;right==nullptr)	return true;</span><br><span class="line">		if(left==nullptr&amp;&amp;right!=nullptr)	return false;</span><br><span class="line">		if(left!=nullptr&amp;&amp;right==nullptr)	return false;</span><br><span class="line">        bool flagleft,flagright;</span><br><span class="line">		if(left-&gt;val!=right-&gt;val)	return false;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			flagleft = judge(left-&gt;left,right-&gt;right);</span><br><span class="line">			flagright = judge(left-&gt;right,right-&gt;left);</span><br><span class="line">		&#125;</span><br><span class="line">        return flagleft&amp;&amp;flagright;</span><br><span class="line">	&#125;</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return true;</span><br><span class="line">        bool flag = judge(root-&gt;left,root-&gt;right);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a><strong>迭代法</strong></h3><p>选择层序迭代遍历最为恰当</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//层序迭代遍历</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	bool isSymmetric(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root-&gt;left);</span><br><span class="line">        que.push(root-&gt;right);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* left = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            TreeNode* right = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(left==nullptr&amp;&amp;right==nullptr)	continue;</span><br><span class="line">            else if(left==nullptr&amp;&amp;right!=nullptr)	return false;</span><br><span class="line">            else if(left!=nullptr&amp;&amp;right==nullptr)	return false;</span><br><span class="line">            else if(left-&gt;val!=right-&gt;val)	return false;</span><br><span class="line">            que.push(left-&gt;left);</span><br><span class="line">            que.push(right-&gt;right);</span><br><span class="line">            que.push(left-&gt;right);</span><br><span class="line">            que.push(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这道题主要要对不同情况进行分类判断，并且要注意后续进行<strong>两两判断</strong>的结点，递归法更为清晰；迭代法则需要注意当<code>left==nullptr&amp;&amp;right==nullptr</code>时并不能直接返回<code>true</code>与递归法不同，因为递归法返回的是上一层递归，仍需要继续对其他结点进行判断，因此在使用迭代法时需要对返回值特别注重，另外，在迭代法中不能强行按照模板<code>for(int i = 0;i&lt;que.size();i++</code>，在本题中，由于每次处理所读取的队头元素并不只有一个，因为不能用队列数量来给定处理结点的次数。 </p>
<h2 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h2><p>[二叉树最大深度](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">Loading Question… - 力扣（LeetCode）</a>)</p>
<p>对于求最大深度，可以首先想到层序迭代遍历，用<code>level</code>来记录深度，每执行一轮就<code>level++</code>，最后返回<code>level</code>输出答案。层序迭代遍历时间复杂度为O(n)，n为结点数，空间复杂度最大为O(n)</p>
<h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	int maxDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		int level = 0;</span><br><span class="line">		queue&lt;TreeNode*&gt; que;</span><br><span class="line">		que.push(root);</span><br><span class="line">		while(!que.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int qsize = que.size();</span><br><span class="line">			for(int i =0;i&lt;qsize;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				TreeNode* node = que.front();</span><br><span class="line">				que.pop();</span><br><span class="line">				if(node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">				if(node-&gt;right)	que.push(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			level++;</span><br><span class="line">		&#125;</span><br><span class="line">		return level;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h3><p>先序递归遍历</p>
<ol>
<li>确定递归终止判断条件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root-&gt;left&amp;&amp;!root-&gt;right)	return level;</span><br></pre></td></tr></table></figure></li>
<li>确定返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private: int level = 0;</span><br><span class="line">int maxDepth(TreeNode* root)</span><br><span class="line">return level;</span><br></pre></td></tr></table></figure></li>
<li>确定单层递归函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void dfs(TreeNode* node,int level)</span><br><span class="line">level++;				//中</span><br><span class="line">dfs(root-&gt;left,level);	 //左</span><br><span class="line">dfs(root-&gt;right,level);	 //右</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">int res = 0;</span><br><span class="line">	void dfs(TreeNode* node, int level)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node) return;</span><br><span class="line">		res = max(level,res);			//中</span><br><span class="line">		dfs(node-&gt;left,level+1);		//左</span><br><span class="line">		dfs(node-&gt;right,level+1);		//右</span><br><span class="line">	&#125;</span><br><span class="line">	int maxDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		dfs(root,1);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后序递归遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">int res = 0;</span><br><span class="line">	int dfs(TreeNode* node)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node) return 0;</span><br><span class="line">		int llevel = dfs(node-&gt;left);</span><br><span class="line">		int rlevel = dfs(node-&gt;right);</span><br><span class="line">		return max(llevel,rlevel)+1;</span><br><span class="line">	&#125;</span><br><span class="line">	int maxDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		res = dfs(root);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归法时间复杂度O(n)，空间复杂度为O(h)，h为树高</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>层序遍历迭代法更容易理解，但付出空间复杂度可能更高的代价；递归法有先序递归遍历和后序递归遍历，先序递归遍历是<em><strong>由顶至底</strong></em>的遍历顺序，求的是从根节点开始的二叉树<em><strong>深度</strong></em>，而后序递归遍历则是<strong>由底至顶</strong>的遍历顺序，求的是从叶子结点开始的二叉树<em><strong>高度</strong></em>。也正因如此，先序递归遍历首先处理中间结点，<code>level++</code>，不需要返回值；而后序递归遍历最后处理中间结点，在此之前已得出子结点的高度，则需要返回值并加一，表示返回当前的高度。</p>
<h2 id="N叉树最大深度"><a href="#N叉树最大深度" class="headerlink" title="N叉树最大深度"></a>N叉树最大深度</h2><h3 id="递归法-3"><a href="#递归法-3" class="headerlink" title="递归法"></a>递归法</h3><p>后序递归遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(Node* node)</span><br><span class="line">	&#123;</span><br><span class="line">		int res = 0;</span><br><span class="line">		if(!node) return 0;</span><br><span class="line">		for(Node* child : node-&gt;children)</span><br><span class="line">		&#123;</span><br><span class="line">			int clevel = dfs(child);</span><br><span class="line">			res = max(res,clevel);</span><br><span class="line">		&#125;</span><br><span class="line">		return res+1;</span><br><span class="line">	&#125;</span><br><span class="line">	int maxDepth(Node* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		int res = dfs(root);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先序递归遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">int res = 0;</span><br><span class="line">	void dfs(Node* node,int level)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node) return;</span><br><span class="line">		res = max(res,level);</span><br><span class="line">		for(Node* child : node-&gt;children)</span><br><span class="line">			dfs(child,level+1);</span><br><span class="line">	&#125;</span><br><span class="line">	int maxDepth(Node* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		dfs(root,1);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	int maxDepth(Node* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		int level = 0;</span><br><span class="line">		queue&lt;Node*&gt; que;</span><br><span class="line">		que.push(root);</span><br><span class="line">		while(!que.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int qsize = que.size();</span><br><span class="line">			for(int i =0;i&lt;qsize;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				Node* node = que.front();</span><br><span class="line">				que.pop();</span><br><span class="line">				for(Node* child:node-&gt;children)</span><br><span class="line">					que.push(child);</span><br><span class="line">			&#125;</span><br><span class="line">			level++;</span><br><span class="line">		&#125;</span><br><span class="line">		return level;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>与二叉树最大深度如出一辙。注意如何获取<code>children</code>结点，</p>
<p><code>vector&lt;Node *&gt; children = root-&gt;children;</code></p>
<p><code>for(auto child:children)</code></p>
<h2 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h2><p>[二叉树最小深度](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-4"><a href="#递归法-4" class="headerlink" title="递归法"></a><em><strong>递归法</strong></em></h3><p>先序递归遍历</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(!root-&gt;left&amp;&amp;root-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">	res = min(res,level);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定返回值</p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dfs(TreeNode* root, int level)</span><br><span class="line">return;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>确定单层递归逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(root-&gt;left,level+1);</span><br><span class="line">dfs(root-&gt;right,level+1);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">int res = INT_MAX;</span><br><span class="line">	void dfs(TreeNode* node, int level)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node-&gt;left&amp;&amp;!node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">        	res = min(res,level);						//中</span><br><span class="line">        	return;</span><br><span class="line">        &#125;</span><br><span class="line">		if(node-&gt;left)	dfs(node-&gt;left,level+1);		//左</span><br><span class="line">		if(node-&gt;right)	dfs(node-&gt;right,level+1);		//右</span><br><span class="line">	&#125;</span><br><span class="line">	int minDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		dfs(root,1);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同理，后序遍历做法模仿二叉树最大深度，整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(TreeNode* node)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node-&gt;left&amp;&amp;!node-&gt;right)</span><br><span class="line">        	return 0;</span><br><span class="line">        int llevel = INT_MAX,rlevel = INT_MAX;</span><br><span class="line">        if(node-&gt;left)</span><br><span class="line">		    llevel = dfs(node-&gt;left);		//左</span><br><span class="line">		if(node-&gt;right)</span><br><span class="line">            rlevel = dfs(node-&gt;right);		 //右</span><br><span class="line">		return min(llevel,rlevel) + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	int minDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		return dfs(root) + 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>另一种后序递归遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getDepth(TreeNode* node) &#123;</span><br><span class="line">        if (node == NULL) return 0;</span><br><span class="line">        // 当一个左子树为空，右不为空，这时并不是最低点</span><br><span class="line">        if (node-&gt;left == NULL &amp;&amp; node-&gt;right != NULL) &#123; </span><br><span class="line">            return 1 + getDepth(node-&gt;right);</span><br><span class="line">        &#125;   </span><br><span class="line">        // 当一个右子树为空，左不为空，这时并不是最低点</span><br><span class="line">        if (node-&gt;left != NULL &amp;&amp; node-&gt;right == NULL) &#123; </span><br><span class="line">            return 1 + getDepth(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        int result = 1 + min(leftDepth, rightDepth);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">    	if(!root)	return 0;</span><br><span class="line">        return getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-4"><a href="#迭代法-4" class="headerlink" title="迭代法"></a>迭代法</h3><p>层序迭代遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">	int minDepth(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!root) return 0;</span><br><span class="line">		int res =INT_MAX;</span><br><span class="line">		int level = 1;</span><br><span class="line">		queue&lt;TreeNode*&gt; que;</span><br><span class="line">		que.push(root);</span><br><span class="line">		while(!que.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int qsize = que.size();</span><br><span class="line">			for(int i = 0; i &lt; qsize; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				TreeNode* node = que.front();</span><br><span class="line">				que.pop();</span><br><span class="line">				if(!node-&gt;left&amp;&amp;!node-&gt;right)//只有到达叶子结点才更新res</span><br><span class="line">				&#123;</span><br><span class="line">					res = min(res,level);</span><br><span class="line">				&#125;</span><br><span class="line">				if(node-&gt;left)	que.push(node-&gt;left);</span><br><span class="line">				if(node-&gt;right)	que.push(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			level++;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>这题的突破点主要在于理解只有在到达叶子结点时才是二叉树的深度，即[2,null,3,null,4,null,5,null,6]的最小深度不是1，而是5。另外，在递归遍历中，可以根据不同的递归判断（判断是否让该结点进入下一层递归），来确定不同的返回值，如<code>if(!node)	return 0;</code>或<code>if(!node-&gt;left&amp;&amp;!node-&gt;right)</code>，并且如果是后者，需要先判断<code>node</code>结点本身是否为空，否则会报错；如果是前者，则必须保证能够让单亲结点进入递归（否则直接返回错误的最小深度）</p>
<h2 id="完全二叉树的结点个数"><a href="#完全二叉树的结点个数" class="headerlink" title="完全二叉树的结点个数"></a><strong>完全二叉树的结点个数</strong></h2><p>[完全二叉树的结点个数](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a>)</p>
<p>最直观的做法就是遍历每个结点，非空则计数+1，直至遇到空结点，可采用先序、中序和后序的递归遍历、迭代遍历法，也可以用层序迭代遍历法</p>
<h3 id="递归法-5"><a href="#递归法-5" class="headerlink" title="递归法"></a>递归法</h3><p>先序递归遍历</p>
<ol>
<li>确定递归结束条件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!node) return;</span><br></pre></td></tr></table></figure></li>
<li>确定返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">void dfs(TreeNode* node)</span><br><span class="line">return;</span><br></pre></td></tr></table></figure></li>
<li>确定单层逻辑<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum++;</span><br><span class="line">dfs(node-&gt;left);</span><br><span class="line">dfs(node-&gt;right);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sums = 0;</span><br><span class="line">    void dfs(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">    	if(!node)	return;</span><br><span class="line">    	sums++;</span><br><span class="line">    	dfs(node-&gt;left);</span><br><span class="line">    	dfs(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">    	if(!root)	return 0;</span><br><span class="line">    	dfs(root);</span><br><span class="line">        return sums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="迭代法-5"><a href="#迭代法-5" class="headerlink" title="迭代法"></a>迭代法</h3><p>中序迭代遍历法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	</span><br><span class="line">	TreeNode():val(0),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">	TreeNode(int val):val(val),left(nullprt),right(nullprt)&#123;&#125;</span><br><span class="line">	TreeNode(int val,TreeNode*left,TreeNode*right):val(val),left(left),right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">    	if(!root)	return 0;</span><br><span class="line">        //中序迭代遍历</span><br><span class="line">        int res = 0;</span><br><span class="line">    	stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line">        while(cur!=nullptr||!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            if(!cur)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = stk.top();stk.pop();</span><br><span class="line">                res++;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="special解法"><a href="#special解法" class="headerlink" title="special解法"></a><em><strong>special解法</strong></em></h3><p>然而，以上方法都只是遍历所有结点才能确定结点个数，只是单纯当成一个普通的二叉树，时间复杂度都是O(n)。可以利用完全二叉树的性质来减小时间复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/*对于一颗完全二叉树，如果找到最底层是n，可以用公式计算前n-1层的结点数`2^(n-1)-1`再加上第n层的结点</span><br><span class="line"></span><br><span class="line">对于第n层上的结点，利用二分法不断缩小范围来找到最后一个结点</span><br><span class="line"></span><br><span class="line">			  1</span><br><span class="line">		   /      \</span><br><span class="line">		  2        3</span><br><span class="line">		 / \      / \</span><br><span class="line">		4   5    6   7</span><br><span class="line"></span><br><span class="line">给定二分法的范围，通过序号的二进制数顺序即可判断结点是否存在，如在level = 3，序号为6的结点，二进制数为110，取除最高位剩下的即10,从根节点出发，1代表右子树，0代表左子树，则根节点的右子树的左子树即为该节点;再如level = 4，序号为9的结点，除最高位剩下的二进制数为001，即代表从根节点出发，其左子树的左子树的右子树即为该结点</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	bool is_exist(TreeNode* root, int level, int index)</span><br><span class="line">	&#123;</span><br><span class="line">		int cmp = 1&lt;&lt;(level - 2);</span><br><span class="line">		//cmp 用作取序号index对应位置上的数</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">		while(node!=nullptr&amp;&amp;cmp)</span><br><span class="line">		&#123;</span><br><span class="line">			if(cmp&amp;index)</span><br><span class="line">				node = node-&gt;right;</span><br><span class="line">			else</span><br><span class="line">				node = node-&gt;left;</span><br><span class="line">			cmp &gt;&gt;= 1;</span><br><span class="line">		&#125;</span><br><span class="line">		return node!=nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">    	if(!root)	return 0;</span><br><span class="line">    	//先循环左子树找出树高</span><br><span class="line">    	int level = 1;</span><br><span class="line">    	TreeNode* node = root;</span><br><span class="line">    	while(node-&gt;left)</span><br><span class="line">    	&#123;</span><br><span class="line">    		level++;</span><br><span class="line">    		node = node-&gt;left;</span><br><span class="line">    	&#125;</span><br><span class="line">    	//这时node结点为二叉树最大深度的最左结点</span><br><span class="line">    	int left = 1 &lt;&lt; (level - 1), right = (1 &lt;&lt; level) - 1;</span><br><span class="line">    	//left 指向最大深度的最左结点，right 指向最大深度的最右结点</span><br><span class="line">    	while(left &lt; right)</span><br><span class="line">    	&#123;</span><br><span class="line">    		int mid = left + (right - left + 1) / 2;	//+1为了防止死循环</span><br><span class="line">    		if(is_exist(root,level,mid))</span><br><span class="line">    			left = mid;</span><br><span class="line">    		else</span><br><span class="line">    			right = mid -1;</span><br><span class="line">    	&#125;</span><br><span class="line">    	//此时，mid即为最大结点序号</span><br><span class="line">     	return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于上述程序的时间复杂度，循环查找二叉树最大深度<code>O(logn)</code>，二分法时间复杂度<code>O(logn)</code>，但嵌套了时间复杂度为O(log n)<code>的结点存在判断算法，因此总的时间复杂度为</code>O(log n+log n^2)&#96;</p>
<blockquote>
<p>时间复杂度：O(log^2 n)，其中 n 是完全二叉树的节点数。</p>
<p>首先需要 O(h)的时间得到完全二叉树的最大层数，其中 h 是完全二叉树的最大层数；使用二分查找确定节点个数时，需要查找的次数为 O(log2^h)&#x3D;O(h)，每次查找需要遍历从根节点开始的一条长度为 h 的路径，需要 O(h)的时间，因此二分查找的总时间复杂度是 O(h^2)。因此总时间复杂度是 O(h^2)，由于完全二叉树满足 2^h &lt;&#x3D; n &lt;&#x3D;2^(h+1)，因此有 O(h)&#x3D;O(log n)，O(h^2)&#x3D;O(\log^2 n)</p>
</blockquote>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>在题目中的位运算解法中，需要弄清楚完全二叉树的特殊性质，即结点按顺序从左到右依次填满，以及可以通过序号反推从根节点开始到该结点的路径，并且清楚位运算中<code>1 &lt;&lt; n</code>等价于<code>1*2^n</code>，在运算时间上位运算也会更有优势，再结合二分法即可在小于O(n)的时间复杂度内完成</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h2><p>[平衡二叉树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（LeetCode）</a>)</p>
<h3 id="由顶至底法"><a href="#由顶至底法" class="headerlink" title="由顶至底法"></a>由顶至底法</h3><p>最容易想到的一种方法就是分别求出左右子树的高度，再根据两者的差值进行判断。若是用先序遍历（求树深）的方法来做，需要有更多变量来保存临时树深和最大树深，因此更适合用后序遍历来做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(TreeNode* node)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node)	return 0;</span><br><span class="line">        int llevel = dfs(node-&gt;left);</span><br><span class="line">        int rlevel = dfs(node-&gt;right);</span><br><span class="line">		return max(llevel,rlevel)+1;</span><br><span class="line">	&#125;</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">		if(!root)	return true;</span><br><span class="line">        if(abs(dfs(root-&gt;right)-dfs(root-&gt;left))&gt;1)</span><br><span class="line">            return false;</span><br><span class="line">		return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述方法还有个bug，没有考虑到子树本身是否平衡，因此需要再对子树进行平衡判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(TreeNode* node)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node)	return 0;</span><br><span class="line">         int llevel = dfs(node-&gt;left);</span><br><span class="line">         int rlevel = dfs(node-&gt;right);</span><br><span class="line">		return max(llevel,rlevel)+1;</span><br><span class="line">	&#125;</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">		if(!root)	return true;</span><br><span class="line">         if(abs(dfs(root-&gt;right)-dfs(root-&gt;left))&gt;1)</span><br><span class="line">            return false;</span><br><span class="line">		return isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于进行了大量的重复运算，最坏情况下时间复杂度为O(n^2)</p>
<h3 id="由底至顶法"><a href="#由底至顶法" class="headerlink" title="由底至顶法"></a><em><strong>由底至顶法</strong></em></h3><p>上述代码中，重复运算的原因在于子树高度时一旦遇到子树的子树不平衡时，没有及时向上返回，而是只返回最大深度，这就导致了还要对子树的子树进行额外的重复运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dfs(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node)	return 0;</span><br><span class="line">        int llevel = dfs(node-&gt;left);</span><br><span class="line">        if (llevel == -1)	return -1;</span><br><span class="line">        int rlevel = dfs(node-&gt;right);</span><br><span class="line">        if (rlevel == -1)	return -1;</span><br><span class="line">        return abs(llevel - rlevel) &gt; 1 ? -1 : max(llevel, rlevel) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        if (!root)	return true;</span><br><span class="line">        return dfs(root) != -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，最多每个结点运算一次</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>进一步理解求树深用先序遍历，求树高用后序遍历。在做判断二叉树是否符合某种要求题目时，不仅要考虑根节点，还要考虑其子树是否同样符合。</p>
<p>由底至顶法提到，涉及到判断树是否符合某种条件时，一旦遇到不符合的，应立即向上返回，避免做其他开销，只需要加多判断语句，在本题中，形象上看起来就像是由底至顶地判断</p>
<h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a><strong>二叉树的所有路径</strong></h2><p>[二叉树的所有路径](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-6"><a href="#递归法-6" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!node-&gt;left&amp;&amp;!node-&gt;right)</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归返回值</p>
<p>​	递归结束时即遇到了叶子结点，则证明改路径结束，应该返回整条路径并输出到res中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void traversal(TreeNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	//将path整条打印成&quot;node1-&gt;node2-&gt;...-&gt;noden&quot;格式</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(node-&gt;left) </span><br><span class="line">&#123;</span><br><span class="line">	traversal(node-&gt;left);</span><br><span class="line">	path.pop_back();//回溯</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">if(node-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">	traversal(node-&gt;right);</span><br><span class="line">	path.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void traversal(TreeNode* node, vector&lt;string&gt; &amp;res, vector&lt;TreeNode*&gt; &amp;path)</span><br><span class="line">    &#123;</span><br><span class="line">        path.push_back(node);</span><br><span class="line">        if (!node-&gt;left&amp;&amp;!node-&gt;right)//叶子结点则路径结束</span><br><span class="line">        &#123;</span><br><span class="line">            string str;</span><br><span class="line">            for (int i = 0; i &lt; path.size() - 1; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                str += to_string(path[i]-&gt;val);</span><br><span class="line">                str += &quot;-&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            str += to_string(path.back()-&gt;val);</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(node-&gt;left)  traversal(node-&gt;left, res, path);</span><br><span class="line">        if(node-&gt;right) traversal(node-&gt;right, res, path);</span><br><span class="line">        path.pop_back();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;TreeNode*&gt;path;</span><br><span class="line">        traversal(root, res, path);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>本题是第一次遇到回溯算法，在二叉树中的回溯算法结合递归可能较难以理解，需要多加模拟回溯过程，体验不同的回溯方式可以更好理解。因为要求按顺序打印路径，此题就需要用先序遍历（先打印的是根结点），但一般来说，回溯法使用后序遍历更简便</p>
<h2 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h2><p>[左叶子之和](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和 - 力扣（LeetCode）</a>)</p>
<p>首先要清楚如何判断是否是左叶子结点，哪种情况下才能算是左叶子，例如<code>[1,null,2]</code>中并不存在左叶子。因此可以得到关键判断语句<code>if(root-&gt;left&amp;&amp;!root-&gt;left-&gt;left&amp;&amp;!root-&gt;left-&gt;right)</code>，这是解题的关键</p>
<h3 id="递归法-7"><a href="#递归法-7" class="headerlink" title="递归法"></a>递归法</h3><p>后序递归遍历</p>
<ol>
<li><p>确定递归结束条件</p>
<p>遇到左叶子或者遇到叶子结点即返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(root-&gt;left&amp;&amp;!root-&gt;left-&gt;left&amp;&amp;!root-&gt;left-&gt;right) return lsum+rsum+root-&gt;left-&gt;val;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int dfs(TreeNode* node)</span><br><span class="line">int lsum = 0,rsum = 0;</span><br><span class="line">return lsum + rsum;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(node-&gt;left)	dfs(root-&gt;left);</span><br><span class="line">if(node-&gt;right)	dfs(root-&gt;right);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dfs(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">        int lsum = 0,rsum = 0;</span><br><span class="line">        if (node-&gt;left) </span><br><span class="line">            lsum = sumOfLeftLeaves(node-&gt;left);</span><br><span class="line">        if (node-&gt;right) </span><br><span class="line">            rsum = sumOfLeftLeaves(node-&gt;right);</span><br><span class="line">        if (node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)//左叶子结点</span><br><span class="line">            return node-&gt;left-&gt;val+lsum+rsum;</span><br><span class="line">        return lsum + rsum;</span><br><span class="line">    &#125;</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if (!root-&gt;left &amp;&amp; !root-&gt;right) return 0;</span><br><span class="line">        return dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为在进入递归之前加上了结点是否为空的判断，因此在递归结束判断条件中并不是传统的<code>if(!node)</code>判断，只需要判断是否为左叶子即可</p>
<p>先序递归遍历</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int res = 0;</span><br><span class="line">    void dfs(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)//左叶子结点</span><br><span class="line">            res += node-&gt;left-&gt;val;</span><br><span class="line">        if (node-&gt;left) sumOfLeftLeaves(node-&gt;left);</span><br><span class="line">        if (node-&gt;right) sumOfLeftLeaves(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if (!root-&gt;left &amp;&amp; !root-&gt;right) return 0;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先序递归遍历代码只是对左叶子的判断语句提前，符合先序遍历中左右的结点处理顺序</p>
<h3 id="迭代法-6"><a href="#迭代法-6" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法采用层序迭代遍历，代码思路较为简单直接</p>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)   </span><br><span class="line">            return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        TreeNode* node;</span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            for(int i = 0;i&lt;size;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    node = que.front();</span><br><span class="line">                    que.pop();</span><br><span class="line">                    if(node-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        que.push(node-&gt;left);</span><br><span class="line">                        if(node-&gt;left-&gt;left == nullptr&amp;&amp;node-&gt;left-&gt;right ==nullptr)</span><br><span class="line">                            res+=node-&gt;left-&gt;val;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(node-&gt;right)</span><br><span class="line">                        que.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>本题的关键点在于理解左叶子结点，如何对左叶子结点进行判断，需要通过父结点，判断其是否为左孩子，再判断是否为叶子结点，算是扩展了一种解题的新思路</p>
<h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value">找树左下角的值</a></p>
<p>本题中，需要找到左下角的结点，即需要最大深度和最左边的叶子结点，则可以利用先序（中、后序同样也可以）递归遍历的特点，先访问左结点再访问右结点，即<strong>只要记录下当前深度和最大深度</strong>，若是当前深度大于最大深度，则更新最大深度，并把当前的结点作为左下角的结点；若当前深度等于最大深度，则不更新，因为当前结点仅仅只是最大深度，一定不是左下角的点；若当前深度小于最大深度则同理。</p>
<h3 id="递归法-8"><a href="#递归法-8" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root) return;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int res = 0;</span><br><span class="line">int height = -1;</span><br><span class="line">void dfs(TreeNode* node, int level)</span><br></pre></td></tr></table></figure>
</li>
<li><p>单层递归逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(level &gt; height)//当前深度为最大深度</span><br><span class="line">&#123;</span><br><span class="line">	height = level;</span><br><span class="line">	res = node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">if(node-&gt;left)	dfs(node-&gt;left);</span><br><span class="line">if(node-&gt;right)	dfs(node-&gt;right);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int res = 0;</span><br><span class="line">int height = -1;</span><br><span class="line">    void dfs(TreeNode* node,int level)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!node)   return;</span><br><span class="line">        if(height &lt; level)//如遇到更大深度的，则直接修改res，且只遇到第一个更深的结点才修改</span><br><span class="line">        &#123;</span><br><span class="line">            res = node-&gt;val;</span><br><span class="line">            height = level;</span><br><span class="line">        &#125;   </span><br><span class="line">        if(node-&gt;left) dfs(node-&gt;left,level + 1);</span><br><span class="line">        if(node-&gt;right) dfs(node-&gt;right,level + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">        if(!root-&gt;left&amp;&amp;!root-&gt;right)   return root-&gt;val;</span><br><span class="line">        dfs(root,1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在本题递归解法中，实际上也有使用到回溯的过程，即在判断<code>node-&gt;left</code>进入递归时，应对当前深度加一，退出递归后又要将当前深度减一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth = INT_MIN;</span><br><span class="line">    int result;</span><br><span class="line">    void traversal(TreeNode* root, int depth) &#123;</span><br><span class="line">        if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123;</span><br><span class="line">            if (depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                result = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;left) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            traversal(root-&gt;left, depth);</span><br><span class="line">            depth--; // 回溯</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;right) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            traversal(root-&gt;right, depth);</span><br><span class="line">            depth--; // 回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">        traversal(root, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-7"><a href="#迭代法-7" class="headerlink" title="迭代法"></a>迭代法</h3><p>层序迭代法更为直观理解，只要在每一层遍历时，存入第一个结点的值即为结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        if (root != NULL) que.push(root);</span><br><span class="line">        int result = 0;</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                if (i == 0) result = node-&gt;val; // 记录最后一行第一个元素</span><br><span class="line">                if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>两种方法的时间复杂度为O(n)，其中若是链式结构，递归法空间复杂度为O(n)，若是完全二叉树，迭代法空间复杂度O(n&#x2F;2)。递归法用到了回溯的思想，但可以将其隐藏起来，并不会对结果产生影响。</p>
<h2 id="路径之和"><a href="#路径之和" class="headerlink" title="路径之和"></a>路径之和</h2><p>[路径之和](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-9"><a href="#递归法-9" class="headerlink" title="递归法"></a>递归法</h3><p>很明显这道题需要用到回溯的思想，与寻找二叉树所有路径题相似，通过深度优先遍历递归寻找到一条“路径”（指从根节点到叶子结点的完整路径），再比较路径上结点的值是否与target值相等。需要注意的是在回退上一层父结点时，需要将加入的子结点及时pop出去，即回溯（删除结点）发生在访问到叶子结点的时候。</p>
<p>根据题意，因为要先处理中间结点，更适合用先序遍历</p>
<ol>
<li><p>确定递归结束条件</p>
<p>因为在进入递归前先判断结点是否为空，则递归结束条件不是结点为空，而是当前结点到达路径终点，即结点是叶子结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root-&gt;left&amp;&amp;!root-&gt;right)</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int lflag = false;</span><br><span class="line">int rflag = false;</span><br><span class="line">bool dfs(TreeNode* node,vector&lt;int&gt;&amp; vec,int target)</span><br><span class="line">&#123;</span><br><span class="line">	return lflag||rflag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定单层递归逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vec.push_back(node);</span><br><span class="line">if(node-&gt;left) </span><br><span class="line">&#123;</span><br><span class="line">	lflag = dfs(node-&gt;left,vec,target);</span><br><span class="line">	vec.pop_back();//回溯</span><br><span class="line">&#125;</span><br><span class="line">if(node-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">	rflag = dfs(node-&gt;right,vec,target);</span><br><span class="line">	vec.pop_back();//回溯</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lflag = false, rflag = false;</span><br><span class="line">    bool dfs(TreeNode* node, vector&lt;int&gt;&amp; vec, int target)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(node-&gt;val);</span><br><span class="line">        if (!node-&gt;left &amp;&amp; !node-&gt;right)//遇到叶子结点则路径结束</span><br><span class="line">        &#123;</span><br><span class="line">            if (accumulate(vec.begin(), vec.end(), 0) == target)</span><br><span class="line">                return true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            lflag = lflag||dfs(node-&gt;left, vec, target);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        if (node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            rflag = rflag||dfs(node-&gt;right, vec, target);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        return lflag || rflag;</span><br><span class="line">    &#125;</span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (!root)  return false;</span><br><span class="line">        vector &lt;int&gt; vec;</span><br><span class="line">        return dfs(root, vec, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该版本代码在任何情况下都需要遍历所有结点，因此时间复杂度是O(n)，最坏情况下的空间复杂度是O(n)。可以先判断flag的值是否有被修改成true，如果有，则证明存在一条路径符合要求，此时即可直接返回true，只需要添加以下语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(lflag||rflag) return true;</span><br></pre></td></tr></table></figure>

<p>修改过的版本有类似于平衡二叉树中由底至顶法的意思，一旦遇到有符合的路径就要及时返回，避免额外开销</p>
<h3 id="迭代法-8"><a href="#迭代法-8" class="headerlink" title="迭代法"></a>迭代法</h3><p>先序迭代遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (!root) return false;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, int&gt;&gt; stk;</span><br><span class="line">        stk.push(make_pair(root, root-&gt;val));</span><br><span class="line">        while (!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = stk.top().first;</span><br><span class="line">            int tmp = stk.top().second;</span><br><span class="line">            stk.pop();</span><br><span class="line">            if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; targetSum==tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(make_pair(node-&gt;right, node-&gt;right-&gt;val + tmp));</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(make_pair(node-&gt;left, node-&gt;left-&gt;val + tmp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>在递归法中，需要注意与二叉树的所有路径题目不同的是，应该在每次调用递归之后马上进行回溯，即删除结点，这也是个良好的习惯，二叉树的所有路径题中只是因为没有返回值，才导致可以有多个回溯方式，但理论上应统一回溯只发生在递归结束之后。并且根据题目应该遇到合适路径就要立即返回，不需要再做额外的递归开销</p>
<p>在迭代法中，依旧使用stack进行先序遍历，但不能只存储<code>TreeNode*</code>结点，还要存储上当前结点的路径总和值，当遇到叶子结点并且路径总和值与target值相等时，即可直接返回true。其他迭代遍历版本亦是如此</p>
<h2 id="路径之和II"><a href="#路径之和II" class="headerlink" title="路径之和II"></a>路径之和II</h2><p>[路径之和](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-10"><a href="#递归法-10" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* node, vector&lt;int&gt;&amp;path,vector&lt;vector&lt;int&gt;&gt; &amp;res,int target)</span><br><span class="line">    &#123;</span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        if(!node-&gt;left&amp;&amp;!node-&gt;right)//遇到叶子结点则当前路径结束</span><br><span class="line">        &#123;</span><br><span class="line">            if(accumulate(path.begin(),path.end(),0)==target)</span><br><span class="line">                res.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(node-&gt;left,path,res,target);</span><br><span class="line">            path.pop_back();//回溯</span><br><span class="line">        &#125;</span><br><span class="line">        if(node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(node-&gt;right,path,res,target);</span><br><span class="line">            path.pop_back();//回溯</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(!root)   return res;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        dfs(root,path,res,targetSum);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>与路径之和思路一致，只不过换了方式存储结果和路径结点的值，其他都如出一辙</p>
<h2 id="从中序和后序遍历序列构造二叉树"><a href="#从中序和后序遍历序列构造二叉树" class="headerlink" title="从中序和后序遍历序列构造二叉树"></a><strong>从中序和后序遍历序列构造二叉树</strong></h2><p>[从中序和后序遍历序列构造二叉树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-11"><a href="#递归法-11" class="headerlink" title="递归法"></a>递归法</h3><p>大致思路如下</p>
<ol>
<li><p>从中序遍历和后序遍历比对，先从后序遍历找到最后一个值，即为根节点的值，在中序遍历序列找到该值并分割</p>
</li>
<li><p>根据中序遍历分割得到的左右段区间，即为该结点的左右子树，根据左子树区间长度，获取后序遍历中前一部分相等长度的区间，即获得左子树的中序遍历和后序遍历序列，再进入递归运算，返回值作为根节点的左子树；右子树区间同理</p>
</li>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(postorder.size()==0)	return nullprt;</span><br></pre></td></tr></table></figure>

<p>当递归到获取到空的数组时则证明递归结束</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* buildtree(vector&lt;int&gt;&amp; inorder,vector&lt;int&gt;&amp; postorder)</span><br><span class="line">&#123;</span><br><span class="line">	TreeNode* root = new TreeNode(postorder.back());</span><br><span class="line">	if(postorder.size()==1)	return root;</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回当前的结点作为根节点</p>
</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = buildtree(**新的中序遍历序列数组**，**新的后序遍历序列数组**);</span><br><span class="line">root-&gt;right = buildtree(**新的中序遍历序列数组**，**新的后序遍历序列数组**);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if(postorder.size()==0) return nullptr;</span><br><span class="line">        TreeNode* root = new TreeNode(postorder[postorder.size()-1]);</span><br><span class="line">        if(postorder.size()==1) return root;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i; i &lt; inorder.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(inorder[i]==postorder[postorder.size()-1])</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; tmp(inorder.begin(),inorder.begin()+i);</span><br><span class="line">        vector&lt;int&gt; tmp1(postorder.begin(),postorder.begin()+i);</span><br><span class="line">        TreeNode* lnode = buildTree(tmp,tmp1);</span><br><span class="line">        root-&gt;left = lnode;</span><br><span class="line">        vector&lt;int&gt; tmp2(inorder.begin()+i+1,inorder.end());</span><br><span class="line">        vector&lt;int&gt; tmp3(postorder.begin()+i,postorder.end()-1);</span><br><span class="line">        TreeNode* rnode = buildTree(tmp2,tmp3);</span><br><span class="line">        root-&gt;right = rnode;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码较为直观，容易理解，但每次递归都会产生很多新的数组，而且不必要；在寻找<code>i</code>即分割序号时，每次递归都要遍历数组来查找，浪费较多时间。因此，在代码改进上可以只传递两个原有的数组，两组新数组的边界点来达到减少内存开销；通过使用<code>hashmap</code>存储元素和下标实现对时间开销的减少</p>
<p>改进后的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int, int&gt; hashmap;</span><br><span class="line">    int index;</span><br><span class="line">    TreeNode* traversal(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int lboarder, int rboarder)//lboarder代表的是左子树的左边界点，rboarder代表的是右子树的右边界点</span><br><span class="line">    &#123;</span><br><span class="line">        if (rboarder &lt; lboarder) return nullptr;</span><br><span class="line">        int rinb = hashmap[postorder[index]] + 1;</span><br><span class="line">        int linb = hashmap[postorder[index]] - 1;</span><br><span class="line">        TreeNode* root = new TreeNode(postorder[index--]);</span><br><span class="line">        if (rboarder == lboarder) return root;</span><br><span class="line">        //分割点：hashmap[postorder[index]],为根节点</span><br><span class="line">        root-&gt;right = traversal(inorder, postorder, rinb, rboarder);</span><br><span class="line">        root-&gt;left = traversal(inorder, postorder, lboarder, linb);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        index = postorder.size() - 1;</span><br><span class="line">        for (const auto&amp; num : inorder)</span><br><span class="line">        &#123;</span><br><span class="line">            hashmap[num] = i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return traversal(inorder, postorder, 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法？？？"><a href="#迭代法？？？" class="headerlink" title="迭代法？？？"></a>迭代法？？？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if (postorder.size() == 0) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        auto root = new TreeNode(postorder[postorder.size() - 1]);</span><br><span class="line">        auto s = stack&lt;TreeNode*&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        int inorderIndex = inorder.size() - 1;</span><br><span class="line">        for (int i = int(postorder.size()) - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            int postorderVal = postorder[i];</span><br><span class="line">            auto node = s.top();</span><br><span class="line">            if (node-&gt;val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node-&gt;right = new TreeNode(postorderVal);</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while (!s.empty() &amp;&amp; s.top()-&gt;val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = s.top();</span><br><span class="line">                    s.pop();</span><br><span class="line">                    inorderIndex--;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;left = new TreeNode(postorderVal);</span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>递归解法中，解法思路类似于手算构造二叉树过程，但在程序当中，若要低开销的算法，又有很多的小问题小细节需要注意。通常来说，递归解法最好要另外创建一个函数，方便传递不同数量或类型的参数。在本题中，若想要传入数组的大小<code>size</code>，与另一个边界值组成一个区间的形参，如<code>(inorder,postorder,size,lboarder,rboarded)</code>，就要<strong>仔细考虑<code>lboarder</code>和<code>rboarder</code>所需要代表是哪一个边界值</strong>，如果是左子树的左边界和右子树的右边界点，那么可以得以实现；而如果是左子树的右边界和右子树的左边界，那么无法实现，因为已经知道<code>index</code>代表分割点的位置，即+1或-1就可以知道这两个边界点，<strong>两个参数实际上只是一个参数</strong>，所以无法实现，必须再传入其他的参数。因此也可以直接传入四个边界点作为形参。</p>
<h2 id="从先序和中序遍历序列构造二叉树"><a href="#从先序和中序遍历序列构造二叉树" class="headerlink" title="从先序和中序遍历序列构造二叉树"></a>从先序和中序遍历序列构造二叉树</h2><p>[从先序和中序遍历序列构造二叉树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-12"><a href="#递归法-12" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int, int&gt; hashmap;</span><br><span class="line">    int index;</span><br><span class="line">    TreeNode* traversal(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int size, int lboarder, int rboarder)</span><br><span class="line">    &#123;</span><br><span class="line">        if (size == 0) return nullptr;</span><br><span class="line">        TreeNode* root = new TreeNode(postorder[index--]);</span><br><span class="line">        if (size == 1) return root;</span><br><span class="line">        //分割点：hashmap[postorder[rboarder]],为根节点</span><br><span class="line">        int lsize = hashmap[postorder[rboarder]];</span><br><span class="line">        int rsize = size - hashmap[postorder[rboarder]] - 1;</span><br><span class="line">        lboarder = hashmap[postorder[rboarder]] - 1;</span><br><span class="line">        rboarder = hashmap[postorder[rboarder]] + 1;</span><br><span class="line">        root-&gt;right = traversal(inorder, postorder, rsize, rboarder, rboarder + rsize - 1);</span><br><span class="line">        root-&gt;left = traversal(inorder, postorder, lsize, lboarder - lsize + 1, lboarder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        index = postorder.size() - 1;</span><br><span class="line">        for (const auto&amp; num : inorder)</span><br><span class="line">        &#123;</span><br><span class="line">            hashmap[num] = i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return traversal(inorder, postorder, postorder.size(), 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>与上一题思路一样。但能发现，要构造出唯一的二叉树，无论是先序还是后序遍历序列，都必须要有中序遍历序列，这是因为只有中序遍历序列才能得到左右子树的分界线，仅靠先序和后序遍历根本无法得知左右子树的分区间。</p>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><p>[最大二叉树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-13"><a href="#递归法-13" class="headerlink" title="递归法"></a>递归法</h3><p>本题中，与构造二叉树题有些许相似，都是需要用到数组的区间来构造二叉树，但这题需要额外找到当前区间的最大值来做根节点并递归</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(lboarder&gt;rboarder)	return nullptr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* traversal(vector&lt;int&gt;&amp;nums,int lboarder,int rboarder)</span><br><span class="line">&#123;</span><br><span class="line">	return 根节点;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//find_maximum并创建根节点root</span><br><span class="line">root-&gt;left = traversal(nums,lboarder,index-1);</span><br><span class="line">root-&gt;right = traversal(nums,index+1,rboarder);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int root_val;</span><br><span class="line">    int find_maximum(const vector&lt;int&gt;&amp; nums, int l, int r)//返回最大元素的下标值</span><br><span class="line">    &#123;</span><br><span class="line">        root_val = 0;</span><br><span class="line">        int root_index = 0;</span><br><span class="line">        for (int i = l; i &lt;= r; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &gt; root_val)</span><br><span class="line">            &#123;</span><br><span class="line">                root_index = i;</span><br><span class="line">                root_val = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root_index;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* traversal(vector&lt;int&gt;&amp; nums, int lboarder, int rboarder)</span><br><span class="line">    &#123;</span><br><span class="line">        if (lboarder &gt; rboarder) return nullptr;</span><br><span class="line">        int mid = find_maximum(nums, lboarder, rboarder);</span><br><span class="line">        TreeNode* root = new TreeNode(root_val);</span><br><span class="line">        if (lboarder == rboarder)  return root;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = traversal(nums, lboarder, mid - 1);</span><br><span class="line">        root-&gt;right = traversal(nums, mid + 1, rboarder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* root = new TreeNode(nums[0]);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        return traversal(nums, 0, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单调栈special解法"><a href="#单调栈special解法" class="headerlink" title="单调栈special解法"></a><strong>单调栈special解法</strong></h3><p>针对找到当前最大值元素作为根节点，联想到单调栈实现，并根据在栈中元素关系确定左右子树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* root = new TreeNode(-1);</span><br><span class="line">        for(int i = 0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = new TreeNode(nums[i]);</span><br><span class="line">            while(!stk.empty()&amp;&amp;nums[i]&gt;stk.top()-&gt;val)//栈顶有元素且比当前元素小，则栈顶元素作当前元素的左子结点</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* cur = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                node-&gt;left = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(!stk.empty())//栈还有元素，则比当前元素大，当前元素为栈顶元素的右子结点</span><br><span class="line">            &#123;</span><br><span class="line">                stk.top()-&gt;right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(node);</span><br><span class="line">            if(root-&gt;val&lt;node-&gt;val)</span><br><span class="line">                root = node;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>在递归法中，根据构造二叉树题中的经验，创建额外的递归函数，并以左右子树区间为形参，再将遍历找到最大元素进行函数封装，避免了每次递归创建新的数组的额外开销。时间复杂度为O(n^2)，最坏情况下数组每个元素都会被遍历一次的同时寻找最大元素也会遍历一遍数组，即此时为递增或递减数组；空间复杂度最坏情况下，<code>nums</code>为递减数组或递增数组，需要递归n层，此时空间复杂度为O(n)</p>
<p>针对不断找到最大元素这个点，提出单调栈来优化，在元素存入单调栈的过程中，不断剔除比当前元素小的栈顶元素，并将栈顶元素作为当前元素的左子结点；遇到比当前元素大的栈顶元素，则把当前元素作为栈顶元素的右子结点。时间复杂度为O(n)，数组每个元素最多只被遍历一次；空间复杂度为O(n)，最坏情况下递减或递增数组需要大小为n的栈空间</p>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><h3 id="递归法-14"><a href="#递归法-14" class="headerlink" title="递归法"></a>递归法</h3><p>先序遍历递归</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root1&amp;&amp;!root2)	return nullptr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* mergeTrees(TreeNode* root1,TreeNode* root2)</span><br><span class="line">&#123;</span><br><span class="line">	return root1;	//直接在root1上操作，避免新建树产生的额外开销</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root1-&gt;val += root2-&gt;val;</span><br><span class="line">root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        if (!root1 &amp;&amp; !root2)  return nullptr;</span><br><span class="line">        if (root1 &amp;&amp; !root2) return root1;</span><br><span class="line">        else if (!root1 &amp;&amp; root2)  return root2;</span><br><span class="line">        else</span><br><span class="line">            root1-&gt;val += root2-&gt;val;								//中</span><br><span class="line">        root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);			  //左</span><br><span class="line">        root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);		  //右</span><br><span class="line">        return root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于中间结点的处理语句，只要更改相对于左右结点处理语句的顺序，就可以实现不同顺序递归遍历二叉树，而不对结果造成影响</p>
<h3 id="迭代法-9"><a href="#迭代法-9" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        if(!root1)  return root2;</span><br><span class="line">        if(!root2)  return root1;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root1);</span><br><span class="line">        que.push(root2);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node1 = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            TreeNode* node2 = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            node1-&gt;val += node2-&gt;val;</span><br><span class="line">            if(node1-&gt;left&amp;&amp;node2-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(node1-&gt;left);</span><br><span class="line">                que.push(node2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            if(node1-&gt;right&amp;&amp;node2-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(node1-&gt;right);</span><br><span class="line">                que.push(node2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            if(!node1-&gt;left&amp;&amp;node2-&gt;left)</span><br><span class="line">                node1-&gt;left = node2-&gt;left;</span><br><span class="line">            if(!node1-&gt;right&amp;&amp;node2-&gt;right)</span><br><span class="line">                node1-&gt;right = node2-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="指针法？？？"><a href="#指针法？？？" class="headerlink" title="指针法？？？"></a>指针法？？？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void process(TreeNode** t1, TreeNode** t2) &#123;</span><br><span class="line">        if ((*t1) == NULL &amp;&amp; (*t2) == NULL) return;</span><br><span class="line">        if ((*t1) != NULL &amp;&amp; (*t2) != NULL) &#123;</span><br><span class="line">            (*t1)-&gt;val += (*t2)-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((*t1) == NULL &amp;&amp; (*t2) != NULL) &#123;</span><br><span class="line">            *t1 = *t2;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((*t1) != NULL &amp;&amp; (*t2) == NULL) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        process(&amp;((*t1)-&gt;left), &amp;((*t2)-&gt;left));</span><br><span class="line">        process(&amp;((*t1)-&gt;right), &amp;((*t2)-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;</span><br><span class="line">        process(&amp;t1, &amp;t2);</span><br><span class="line">        return t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>这道题提醒了同时在处理两颗二叉树时的操作，类似于对称二叉树，考虑的需要更加复杂。</p>
<h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><p>[二叉搜索树中的搜索](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a>)</p>
<p>根据二叉搜索树的特性，左子结点值小于根节点值小于右子结点值，通过判断当前结点的值与所要求的值的大小，快速找到所要求的值的方向，可以有递归法和迭代法实现</p>
<h3 id="递归法-15"><a href="#递归法-15" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return nullprt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* searchBST(TreeNode* root,int val)</span><br><span class="line">if(root-&gt;val==val)	return root;</span><br><span class="line">return nullptr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归单层逻辑</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(root-&gt;val &gt; val) 		searchBST(root-&gt;left, val);</span><br><span class="line">else if(root-&gt;val &lt; val)	searchBST(root-&gt;right, val);</span><br><span class="line">else	return root;</span><br></pre></td></tr></table></figure>

<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">        if(!root)   return nullptr;</span><br><span class="line">        if(root-&gt;val==val)  return root;</span><br><span class="line">        return root-&gt;val &gt; val? searchBST(root-&gt;left,val): searchBST(root-&gt;right,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-10"><a href="#迭代法-10" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">    	TreeNode* node = root;</span><br><span class="line">    	while(node)</span><br><span class="line">    	&#123;</span><br><span class="line">			if(node-&gt;val)	return node;</span><br><span class="line">			if(node-&gt;val &gt; node)</span><br><span class="line">				node = node-&gt;left;</span><br><span class="line">			else if(node-&gt;val &lt; node)</span><br><span class="line">				node = node-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>根据二叉搜索树的特性，能够极大地简化了代码的复杂程度。在递归法中，由于二叉搜索树有方向性，从而不用考虑是否需要回溯，如平衡二叉树和路径之和题；在迭代法中，二叉搜索树则不需要借助栈或者队列完成对二叉树的遍历，也是因为其特有的方向性。</p>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>[验证二叉搜索树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-16"><a href="#递归法-16" class="headerlink" title="递归法"></a>递归法</h3><p>对于本题，先想到验证二叉搜索树的方法是 左子结点的值小于根节点的值小于右子结点的值，再对整棵二叉树进行该过程的递归遍历。但这就掉入一个坑中，因为二叉搜索树不仅需要当前的左右子结点与根节点符合规律，还要整棵左右子树都要符合规律，即根节点的左子树上的所有结点都要比根节点要小，同理右子树也是，但这种方法显然无法满足。</p>
<p>因此，借助于中序遍历，若一棵二叉树时二叉搜索树，则中序遍历序列为递增的序列，只要通过一个变量记录最大值，并递归检查当前结点的值是否要比最大值要大，就可以判断是否为二叉搜索树。另外，这个变量为了符合数据大小的要求，结点最小值为INT_MIN，则可以将该变量设为LONG_MIN；或者可以设为前一个结点pre</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return true</span><br></pre></td></tr></table></figure>

<p>当前结点为空时，也为二叉搜索树，返回true</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int tmp = LONG_MIN;</span><br><span class="line">bool isValidBST(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">	bool lflag = true,rflag = true;</span><br><span class="line">	</span><br><span class="line">	return lflag&amp;&amp;rflag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lflag = isValidBST(root-&gt;left);</span><br><span class="line">if(tmp &gt;= root-&gt;val)	return false;</span><br><span class="line">rflag = isValidBST(root-&gt;right);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下（使用<code>long long</code>变量）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">long long maxi = LONG_MIN;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return true;</span><br><span class="line">        bool lflag = true, rflag = true;</span><br><span class="line">        if(root-&gt;left)  lflag = isValidBST(root-&gt;left);</span><br><span class="line">        if(root-&gt;val &gt; maxi)    </span><br><span class="line">            maxi = root-&gt;val;</span><br><span class="line">        else    </span><br><span class="line">            return false;</span><br><span class="line">        if(root-&gt;right) rflag = isValidBST(root-&gt;right);</span><br><span class="line">        return lflag&amp;&amp;rflag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（使用前一个结点变量）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">TreeNode* pre = nullptr;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return true;</span><br><span class="line">        bool lflag = true, rflag = true;</span><br><span class="line">        if(root-&gt;left)  lflag = isValidBST(root-&gt;left);</span><br><span class="line">        if(!pre||pre-&gt;val &lt; root-&gt;val)</span><br><span class="line">            pre = root;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">        if(root-&gt;right) rflag = isValidBST(root-&gt;right);</span><br><span class="line">        return lflag&amp;&amp;rflag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-11"><a href="#迭代法-11" class="headerlink" title="迭代法"></a>迭代法</h3><p>使用中序迭代遍历法，只需稍微修改即可,对应地，迭代法也可以用一个long long变量或者前一个结点来存储最大值，下面只给出long long变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return true;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        long long tmp = LONG_MIN;</span><br><span class="line">        while(!stk.empty()||node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node=node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                node = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                if(tmp &gt;= node-&gt;val)</span><br><span class="line">                    return false;</span><br><span class="line">                tmp = node-&gt;val;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>为了验证一棵二叉搜索树，要将其当成一棵普通二叉树来看待，就不能利用二叉搜索树的特性。在判断时，需要注意<strong>左子树小于根节点小于右子树</strong>，而不只是单单的左子结点小于根节点小于右子结点，再结合中序遍历，可以利用严格单调有序性来判断一棵树是否为二叉搜索树，这时就要用到一个变量来记录当前下的最大结点值，结合所给定数据范围，可以将这个变量设为LONG_MIN来完成所有INT数据的测试；但如果测试数据中<strong>出现了LONG型数据</strong>，那可以将这个变量设为一个<strong>树的结点类型</strong>，用于存储前一个结点，这就不用考虑数据的类型和大小范围。</p>
<p>对于迭代法，则是基于中序迭代遍历模板的改变版，同样也有两种不同类型变量。两种方法的时间复杂度和空间复杂度都是O(n)，最坏情况下是一条链。</p>
<h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><p>[二叉搜索树的最小绝对差](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-17"><a href="#递归法-17" class="headerlink" title="递归法"></a>递归法</h3><p>根据题意，因为是<strong>任意两个结点的差</strong>，依旧可以使用中序遍历的方法对二叉树进行遍历，且因为中序遍历序列严格单调递增，则可以通过对相邻两个结点的值进行判断来获取最小绝对差。此外，该题中，既可以先用数组存储所有结点的值，再遍历一次数组进行判断；也可以通过一个结点变量，记录前一个结点的值，从而在遍历二叉树过程中就完成对绝对差的记录</p>
<p>中序递归遍历+转换成数组计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">int ans = INT_MAX;</span><br><span class="line">    void dfs(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root)   return;</span><br><span class="line">        if(root-&gt;left)  dfs(root-&gt;left);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        if(root-&gt;right) dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        int i = 1, j = 0;</span><br><span class="line">        for(i,j;i&lt;res.size();i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = min(ans,abs(res[i]-res[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>记录前一个结点与当前结点进行判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int res = INT_MAX;</span><br><span class="line">    int pre = -1,cur = -1;</span><br><span class="line">    int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">        if (!root)   return 0;</span><br><span class="line">        if (root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = root-&gt;left-&gt;val;</span><br><span class="line">            getMinimumDifference(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = root-&gt;val;</span><br><span class="line">        //if(pre!=-1)即可</span><br><span class="line">        if (pre!=-1&amp;&amp;abs(cur - pre))</span><br><span class="line">            res = min(abs(cur - pre), res);</span><br><span class="line">        pre = cur;</span><br><span class="line">        if (root-&gt;right) getMinimumDifference(root-&gt;right);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，在以上的程序中，也可以沿用上题中的两种方式，一种是用一个整型变量来记录前一个结点的值（如上）；另一种是用一个<code>TreeNode*</code>变量来记录前一个结点。后者只需要在更新res时将判断条件修改为<code>if(pre)</code>本质上都是一样</p>
<h3 id="迭代法-12"><a href="#迭代法-12" class="headerlink" title="迭代法"></a>迭代法</h3><p>依旧使用中序遍历迭代法，基于模板上修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while(!stk.empty()||node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                node = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                res.push_back(node-&gt;val);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0,j=1;j&lt;res.size();++j,++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = min(ans,abs(res[i]-res[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，迭代法中也可以不用新建一个数组，最后再遍历一次数组得到答案，也是设定前一个结点，可以是整型变量存结点的值，也可以直接存一个结点来实现</p>
<h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>本题与上一题验证二叉搜索树的遍历思路一致，只是上题判断前后两者大小关系，本题计算前后两者大小并取最小值</p>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p>[二叉搜索树中的众数](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a>)</p>
<p>从寻找众数角度出发，通常需要借助一个数组或哈希表等来存储元的值以及对应的出现次数，先遍历一遍二叉树得到存储整棵树的数组或哈希表，再将数组或哈希表进行排序，取出排序最大的一个或多个元素，存入到结果当中。而这就需要O(N)的时间复杂度，最坏情况下所有元素都只出现一次，时间复杂度是O(2N)，空间复杂度也会很大。</p>
<p>上述方法仅对一般的二叉树，但在本题中是一颗二叉搜索树，也就是说是一棵已经排好序的二叉树，相同的值的结点都是邻接在一起的，因此，仅需要一次遍历，通过pre指针指向上一个结点，与当前结点比较，并统计相同值结点的个数，就能找出其众数</p>
<h3 id="递归法-18"><a href="#递归法-18" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!node)	return;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int times = 0, ttimes = 0;</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">TreeNode* pre = nullptr;</span><br><span class="line">void dfs(TreeNode* node)</span><br><span class="line">&#123;</span><br><span class="line">	dfs(node-&gt;left);</span><br><span class="line">	//根结点</span><br><span class="line">	dfs(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (pre &amp;&amp; pre-&gt;val != node-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    ttimes = 0;</span><br><span class="line">&#125;</span><br><span class="line">if (pre &amp;&amp; pre-&gt;val == node-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    ++ttimes;</span><br><span class="line">&#125;</span><br><span class="line">if (ttimes == times)</span><br><span class="line">&#123;</span><br><span class="line">    res.push_back(node-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">if (ttimes &gt; times)</span><br><span class="line">&#123;</span><br><span class="line">    times = ttimes;</span><br><span class="line">    res.clear();</span><br><span class="line">    res.push_back(node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    TreeNode* pre = nullptr;</span><br><span class="line">    int times = 0;</span><br><span class="line">    int ttimes = 0;</span><br><span class="line">    void dfs(TreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node)   return;</span><br><span class="line">        dfs(node-&gt;left);</span><br><span class="line">        if (pre &amp;&amp; node-&gt;val != pre-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ttimes = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pre &amp;&amp; pre-&gt;val == node-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ttimes;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ttimes == times)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ttimes &gt; times)</span><br><span class="line">        &#123;</span><br><span class="line">            res.clear();</span><br><span class="line">            times = ttimes;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        dfs(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-13"><a href="#迭代法-13" class="headerlink" title="迭代法"></a>迭代法</h3><p>同样地，用中序迭代遍历法，而处理根结点代码与递归法中的一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        TreeNode* pre = nullptr;</span><br><span class="line">        int times = 0, ttimes = 0;</span><br><span class="line">        while(!stk.empty()||node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                node = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                if(pre&amp;&amp;pre-&gt;val!=node-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    ttimes = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if(pre&amp;&amp;pre-&gt;val == node-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++ttimes;</span><br><span class="line">                &#125;</span><br><span class="line">                if(ttimes==times)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                if(ttimes&gt;times)</span><br><span class="line">                &#123;</span><br><span class="line">                    times = ttimes;</span><br><span class="line">                    res.clear();</span><br><span class="line">                    res.push_back(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = node;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p>对本题而言，依旧是对<strong>pre指针和cur指针</strong>的同时运用，这一点上与前两题都一致，不同的是本题还需要对pre和cur指向的结点的值出现次数进行统计，而在统计这里提出针对一般情况和针对二叉搜索树的不同解法，一般情况下借助于特殊的数据结构来对元素的值及其出现次数进行统计，但在二叉搜索树下则不用，因为其本身就已经是排序好的。若是针对一般情况下，有其他数据结构支撑的，可以选取任意的遍历顺序，但针对二叉搜索树时，为了运用到它的有序性，通常都会用中序遍历，也只有中序遍历序列是有序的。在迭代法中，无非就是在处理根结点的代码上将递归法的代码照搬过来，套用在模板上。</p>
<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><strong>二叉树的最近公共祖先</strong></h2><p>[二叉树的最近公共祖先](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a>)</p>
<p>最近公共祖先可简化成两种情况，一种是直接找到除要寻找的两结点之外的第三结点作为两结点的公共祖先，即要返回该第三结点作为结果；另一种则是其中一个结点是另一结点的祖先，则返回该结点作为结果即可。</p>
<h3 id="递归法-19"><a href="#递归法-19" class="headerlink" title="递归法"></a>递归法</h3><p>根据题意，这题可以用到回溯法，由于后续遍历本身就是回溯（左右中），可以先判断左右子树是否有包含要找的结点，再来判断当前结点是否是公共祖先。同时，这也是一种由底至顶的方法。</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return nullptr;</span><br><span class="line">if(root==q||root==p) return root;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当当前结点即为要寻找的结点时，即可直接返回当前结点，向上回溯；如果没有找到，则返回空结点</p>
<ol start="3">
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* ltree = lowestCommonAncestor(root-&gt;left,p,q);				//左</span><br><span class="line">TreeNode* rtree = lowestCommonAncestor(root-&gt;right,p,q);			//右</span><br><span class="line">if(ltree&amp;&amp;rtree)	return root;								  //中</span><br><span class="line">else if(!ltree&amp;&amp;rtree)	return rtree;</span><br><span class="line">else if(ltree&amp;&amp;rtree)	return ltree;</span><br><span class="line">return nullptr;</span><br></pre></td></tr></table></figure>

<p>如果当前的根节点的左子结点和右子结点的返回值不为空（返回值为p和q），则证明当前的根节点就是他们的公共祖先，直接返回根节点；如果当前结点的左子结点为空，但右子结点不为空，则证明p或q在右子结点，直接返回右子结点；右子结点为空同理；最后，都没有找到则证明p和q都不在当前结点的子树下，返回空结点</p>
</li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(!root)   return NULL;</span><br><span class="line">        if(root==p||root==q)    return root;</span><br><span class="line">        TreeNode* ltree = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* rtree = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        if(ltree&amp;&amp;rtree) </span><br><span class="line">            return root;</span><br><span class="line">        else if(ltree&amp;&amp;!rtree) </span><br><span class="line">            return ltree;</span><br><span class="line">        else if(!ltree&amp;&amp;rtree)</span><br><span class="line">            return rtree;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归hashmap查表法"><a href="#递归hashmap查表法" class="headerlink" title="递归hashmap查表法"></a>递归<code>hashmap</code>查表法</h3><p>不边递归回溯边记录判断，则需要独立遍历一次二叉树，借助<code>unordered_map&lt;int,TreeNode*&gt; fanode</code>进行父结点的记录，再将p或q通过<code>fanode</code>向上查询父结点，借助另一个<code>unordered_map&lt;int,bool&gt; cmp</code>进行有无相同父结点的判断</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">unordered_map&lt;int,TreeNode*&gt; fanode;</span><br><span class="line">unordered_map&lt;int,bool&gt; cmp;</span><br><span class="line">    void dfs(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            fanode[root-&gt;left-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            fanode[root-&gt;right-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        fanode[root-&gt;val] = NULL;</span><br><span class="line">        dfs(root);</span><br><span class="line">        while(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cmp[p-&gt;val]=true;</span><br><span class="line">            p=fanode[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        while(q)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cmp[q-&gt;val])</span><br><span class="line">                return q;</span><br><span class="line">            q = fanode[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>遍历每个结点获取对应父结点需要时间O(n)，在向上寻找p、q共同父结点时，遍历的结点数不会超过n，最坏情况下是树单独成链，总的时间复杂度是O(n)，且接近O(2n)；对于递归遍历每个结点所占用的递归栈空间最坏情况下为O(n)，而储存n个结点的哈希表空间复杂度也为O(n)，因此总的空间复杂度为O(3n)，性能与第一种解法无量级上的差异但比第一种解法要差</p>
<h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p>通用解法是在递归的过程中直接记录和处理，这就省去了额外的时间和空间开销。在处理最近公共祖先问题上，最先想到应该由底至顶的遍历二叉树，即回溯，而后序遍历又是天生的回溯顺序。这一点上与相同用到回溯法的平衡二叉树题一致，都用到后序遍历；但在有关二叉树路径题中，因为递归的过程需要先处理根结点，所以用的是先序遍历回溯。</p>
<p>回溯递归使用先序遍历中，通过成员变量快速判断有无符合条件的情况发生，可以直接向上回溯，如路径之和；而使用后序遍历，都要先遍历完所有的结点，因为要用到处理结点后的返回值，先进入递归才能再判断有无发生，如由底至顶的平衡二叉树。</p>
<p><code>if(root==q||root==p)	return root;</code>这是对结束条件的补充，为的是遇到想要查找的结点时及时返回，获取返回值，并且不必继续做无谓的遍历直至叶子结点</p>
<p>递归法中对于情况二的处理，只分开根结点的左、右子树作为查找对象，即在一个子树上只寻找一个目标结点，（情况二则是两个目标结点都在一个子树上，且以其中一个结点作为公共祖先返回结果），因此一旦找寻到其中一个结点，即可直接返回该结点，也正是目标结点的公共祖先。</p>
<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><strong>二叉搜索树的最近公共祖先</strong></h2><p>[二叉搜索树的最近公共祖先](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-20"><a href="#递归法-20" class="headerlink" title="递归法"></a>递归法</h3><p>明显这道题与上题相比，需要用到二叉搜索树的特性，即有序性。</p>
<p>因为是要寻找公共祖先，是由底至顶的查找，所以要用后序遍历，同时符合了回溯的要求。</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return root;</span><br></pre></td></tr></table></figure>

<p>也可以不写，因为题目保证了能够找得到公共祖先</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* lflag = NULL,*rflag = NULL;</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root,TreeNode* p,TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">	if(lflag||rflag)	return lflag==NULL?rflag:lflag;</span><br><span class="line">	return root;										//中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果找到p或q则返回当前结点；如果<code>lflag</code>或<code>rflag</code>被赋值，证明找到p或者q，则返回被赋值的那个<code>flag</code></p>
</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(q-&gt;val &lt; root-&gt;val &amp;&amp; p-&gt;val &lt; root-&gt;val)</span><br><span class="line">	lflag = lowestCommonAncestor(root-&gt;left,p,q);			//左</span><br><span class="line">if(q-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)</span><br><span class="line">	rflag = lowestCommonAncestor(root-&gt;right,p,q);			//右</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">TreeNode* lflag=NULL, *rflag=NULL;</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(!root)   return root;</span><br><span class="line">        if(p-&gt;val &lt; root-&gt;val&amp;&amp;q-&gt;val &lt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            rflag = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        if(p-&gt;val &gt; root-&gt;val&amp;&amp;q-&gt;val &gt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            lflag = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        if(lflag||rflag)    return lflag==NULL?rflag:lflag;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-14"><a href="#迭代法-14" class="headerlink" title="迭代法"></a>迭代法</h3><p>在上述递归的过程中，其实就是迭代的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        TreeNode* res = root;</span><br><span class="line">        while(res)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res-&gt;val &gt; p-&gt;val&amp;&amp;res-&gt;val &gt; q-&gt;val)</span><br><span class="line">                res = res-&gt;left;</span><br><span class="line">            else if(res-&gt;val &lt; p-&gt;val&amp;&amp;res-&gt;val &lt; q-&gt;val)</span><br><span class="line">                res = res-&gt;right;</span><br><span class="line">            else</span><br><span class="line">                return res;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p>在递归法中，首先，当<code>q-&gt;val &lt; root-&gt;val &amp;&amp; p-&gt;val &gt; root-&gt;val</code>或者<code>q-&gt;val &gt;  root-&gt;val &amp;&amp; p-&gt;val &lt; root-&gt;val</code>，换句话说，当当前结点值处于p和q值的区间内，那么当前结点就一定是p和q的最近公共祖先（有序性）。其次，因为是一定能够找到公共祖先，所以单层逻辑中对中间结点的处理就是递归的返回值——直接返回当前结点（即公共祖先），这也是递归的最深一层。</p>
<p>相对于普通的二叉树，在寻找二叉搜索树的最近公共祖先时，可以更加的有方向性去寻找所要的结点，不需要遍历所有结点，而当找到所要找的结点时，由于没有多余遍历其他结点，也就不会遇到返回值为空的结点，对有返回值的结点处理也更加简洁（只在lflag或rflag中，直接返回结果就行），<strong>因此实际上并没使用到回溯</strong>。因为没有遍历所有结点，空间复杂度为O(1)</p>
<p>同样地，二叉搜索树的最近公共祖先也有两种情况，一种是直接找到除要寻找的两结点之外的第三结点作为两结点的公共祖先，即要返回该第三结点作为结果；另一种则是其中一个结点是另一结点的祖先，则返回该结点作为结果即可。对于第二种情况，只要不满足p和q结点值同时大于或者小于当前结点的值，就直接返回当前结点，而当前结点也正是它们的共同祖先（其中一个结点本身）</p>
<p>另外，该题也可以用普通二叉树的最近公共祖先两种做法</p>
<h2 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h2><p>[二叉搜索树中的插入操作](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-21"><a href="#递归法-21" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        if(!root)   </span><br><span class="line">            return new TreeNode(val);</span><br><span class="line">        if(val &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = insertIntoBST(root-&gt;left,val);</span><br><span class="line">        else if(val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = insertIntoBST(root-&gt;right,val);</span><br><span class="line">        return  root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-15"><a href="#迭代法-15" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        TreeNode* newnode = new TreeNode(val);</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        if(!node)</span><br><span class="line">        &#123;</span><br><span class="line">            return newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        while(node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(val &lt; node-&gt;val&amp;&amp;node-&gt;left)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            else if(val &gt; node-&gt;val&amp;&amp;node-&gt;right)</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            else if(val &lt; node-&gt;val&amp;&amp;!node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left = newnode;</span><br><span class="line">                node = newnode-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(val &gt; node-&gt;val&amp;&amp;!node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right = newnode;</span><br><span class="line">                node = newnode-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p>本题还有重新构建二叉搜索树的方法，但在本解法中只做了直接向二叉搜索树添加新结点的做法，并没有手算向二叉搜索树插入操作的代码实现方法</p>
<h2 id="删除二叉搜索树中的结点"><a href="#删除二叉搜索树中的结点" class="headerlink" title="删除二叉搜索树中的结点"></a><strong>删除二叉搜索树中的结点</strong></h2><p>[删除二叉搜索树中的结点](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a>)</p>
<h3 id="对回溯法的理解"><a href="#对回溯法的理解" class="headerlink" title="对回溯法的理解"></a>对回溯法的理解</h3><p>首先，要做的第一步是 找到要删除结点的父结点，利用递归回溯的思想，借助栈保存当前访问结点的父结点，一旦确定当前结点是要删除的结点，则栈顶元素就是其父结点。因为要找根结点，因此选择了先序递归遍历。但缺点在于无论什么时候找到要目标结点，都会遍历整棵二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool find_fa_dfs(int key, stack&lt;TreeNode*&gt; &amp; stk)</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* tmp = stk.top();</span><br><span class="line">    if (tmp-&gt;val == key)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (tmp-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        stk.push(tmp-&gt;left);</span><br><span class="line">        if (find_fa_dfs( key, stk))</span><br><span class="line">            fa = tmp;</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    if (tmp-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        stk.push(tmp-&gt;right);</span><br><span class="line">        if (find_fa_dfs( key, stk))</span><br><span class="line">            fa = tmp;</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于代码中的改进点，要求当找到目标结点后要及时返回或结束递归，可加上一个判断，<code>if(fa!=nullptr)return false;</code>当找到了目标结点，<code>fa</code>结点就会被修改，因此对于遍历中不在回溯路径上的后续结点，当进入递归时就会直接返回。但如果目标结点是根结点<code>fa=nullptr</code>，则无效，依旧会遍历整棵二叉树。</p>
<p>另外，题中这是一颗二叉搜索树，则可以利用其特性快速找到目标结点及其父结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* fa = nullptr;</span><br><span class="line">void find_fa_dfs(TreeNode* node,int key)</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* lnode = nullptr, * rnode = nullptr;</span><br><span class="line">    if (!node)   return;</span><br><span class="line">    if (node-&gt;val &lt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        fa = node;</span><br><span class="line">        find_fa_dfs(node-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (node-&gt;val &gt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        fa = node;</span><br><span class="line">        find_fa_dfs(node-&gt;left, key);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归法-22"><a href="#递归法-22" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return nullptr;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* deleteNode(TreeNode* root,int key)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定单层逻辑</p>
<p>在本题中，关键在于对不同情况的分类讨论</p>
<ul>
<li>当前结点为空，直接返回空结点</li>
<li>当前结点值比key大，递归进入当前结点的左子结点</li>
<li>当前结点值比key小，递归进入当前结点的右子结点</li>
<li>当前结点值等于key值，则证明找到目标删除结点<ul>
<li>目标结点是叶子结点，直接删除，返回空结点</li>
<li>目标结点有单孩子结点，孩子结点补上，作为根节点返回</li>
<li>目标结点有两个孩子结点，将目标结点的左孩子结点作为目标结点的右孩子结点的最左下叶子结点的左子树，右孩子结点作为根结点返回</li>
</ul>
</li>
<li>都不符合，则是key不存在于当前树中，无需删除，返回root</li>
</ul>
<p>整体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        if (!root)   return root;</span><br><span class="line">        if (root-&gt;val &lt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (root-&gt;val &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                delete root;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!root-&gt;right)</span><br><span class="line">                return root-&gt;left;</span><br><span class="line">            else if (!root-&gt;left)</span><br><span class="line">                return root-&gt;right;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* tmp = root-&gt;right;</span><br><span class="line">                while (tmp-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = tmp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp-&gt;left = root-&gt;left;</span><br><span class="line">                TreeNode* node = root;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">                delete node;</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重要的是，理解在每次调用递归时，返回的值是作为当前结点下删除目标结点后的新的子树</p>
</li>
</ol>
<h3 id="迭代法-16"><a href="#迭代法-16" class="headerlink" title="迭代法"></a>迭代法</h3><p>   模拟实现递归的过程，但会因为在分类讨论下，多出了判断当前结点是否为二叉搜索树的根结点，从而导致代码出现很多重复，也可以封装成一个函数</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        if (!root)   return root;</span><br><span class="line">        TreeNode* node = root, * fa = nullptr;</span><br><span class="line">        while (node)</span><br><span class="line">        &#123;</span><br><span class="line">            if (key &lt; node-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                fa = node;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (key &gt; node-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                fa = node;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (key == node-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!node-&gt;left &amp;&amp; !node-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(!fa) return nullptr;</span><br><span class="line">                    if(fa-&gt;val &gt; key)</span><br><span class="line">                        fa-&gt;left = nullptr;</span><br><span class="line">                    else</span><br><span class="line">                        fa-&gt;right = nullptr;</span><br><span class="line">                    delete node;</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!node-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(!fa)</span><br><span class="line">                        return node-&gt;right;</span><br><span class="line">                    if (fa-&gt;val &gt; key)</span><br><span class="line">                        fa-&gt;left = node-&gt;right;</span><br><span class="line">                    else</span><br><span class="line">                        fa-&gt;right = node-&gt;right;</span><br><span class="line">                    delete node;</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!node-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(!fa)</span><br><span class="line">                        return node-&gt;left;</span><br><span class="line">                    if (fa-&gt;val &gt; key)</span><br><span class="line">                        fa-&gt;left = node-&gt;left;</span><br><span class="line">                    else</span><br><span class="line">                        fa-&gt;right = node-&gt;left;</span><br><span class="line">                    delete node;</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* lnode = node-&gt;left;</span><br><span class="line">                    TreeNode* tmp = node-&gt;right;</span><br><span class="line">                    while (tmp-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp = tmp-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp-&gt;left = lnode;</span><br><span class="line">                    if (!fa)</span><br><span class="line">                    &#123;</span><br><span class="line">                        node = node-&gt;right;</span><br><span class="line">                        return node;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (fa-&gt;val &gt; key)</span><br><span class="line">                        fa-&gt;left = node-&gt;right;</span><br><span class="line">                    else</span><br><span class="line">                        fa-&gt;right = node-&gt;right;</span><br><span class="line">                    delete node;</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><p>对于本题中的递归法，类似其他二叉搜索树的题目，都能用到递归算法，且可以利用二叉搜索树的特性简化递归过程。这一题考查了分类讨论的多种情况，并要求在递归遍历找到目标删除结点的父结点，或根据返回值对父结点的指向作更新。同时，对比迭代法，因为不能用返回值不断向上返回新的根结点，迭代法需要找到目标结点的父结点，才能修改删除结点后父结点的指向，可得知，<strong>用函数封装后的返回值可以简便的修改二叉树结构</strong>。</p>
<p>在力扣编译器中，就算是叶子结点，直接将其delete掉也会报错，需要把其父结点更改为<strong>指向空结点</strong>，即断开跟不删除结点的所有连接才能不报错</p>
<p>递归法和迭代法的时间复杂度都是O(n)，遍历一次二叉树的结点。递归法的空间复杂度最坏情况下是O(n)，迭代法的空间复杂度是O(1)，只占用常量级的空间，因为二叉搜索树的迭代不需要用到栈或队列</p>
<h2 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h2><p>[修剪二叉搜索树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-23"><a href="#递归法-23" class="headerlink" title="递归法"></a>递归法</h3><p>类比上一题，后序遍历所有二叉树结点，并将修剪过后的子树的根结点作为返回值，作为根结点的新左子结点或者新右子结点。如果当前结点值小于要求范围，根据二叉搜索树的特性，从当前结点的右子树不断向右寻找，直到值在要求范围内，并返回该结点；如果当前结点值大于要求范围，也同理</p>
<ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!root)	return nullptr;</span><br></pre></td></tr></table></figure>

<p>当遇到空结点时返回空结点</p>
</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* trimBST(TreeNode* root, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">	root-&gt;left = trimBST(root-&gt;left,low,high);</span><br><span class="line">	root-&gt;right = trimBST(root-&gt;right,low,high);</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让左子结点进入递归，并将新的结点作为返回值，给该结点的左子结点重新赋值</p>
<p>右子结点同理</p>
<p>全部子树修剪完成，则返回根结点</p>
</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(root-&gt;val &lt; low)</span><br><span class="line">&#123;</span><br><span class="line">	TreeNode* tmp = root-&gt;right;</span><br><span class="line">	while(tmp &amp;&amp; tmp-&gt;val &lt; low)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = tmp-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	return tmp == nullptr?nullptr:tmp;</span><br><span class="line">&#125;</span><br><span class="line">//另一边同理</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if (!root)   return root;</span><br><span class="line">        //后序遍历</span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, low, high);</span><br><span class="line">        if (root-&gt;val &lt; low)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp = root-&gt;right;</span><br><span class="line">            while (tmp &amp;&amp; tmp-&gt;val &lt; low)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = tmp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            return tmp == nullptr ? nullptr : tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;val &gt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp = root-&gt;left;</span><br><span class="line">            while (tmp &amp;&amp; tmp-&gt;val &gt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            return tmp == nullptr ? nullptr : tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个版本的递归中，每个结点都进入了递归，其实不需要，只是将符合范围的当前结点的左右结点送入递归即可，但不能够直接改成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(root-&gt;val &gt; low &amp;&amp; root-&gt;val &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">	root-&gt;left = trimBST(root-&gt;left,low,high);</span><br><span class="line">	root-&gt;right = trimBST(root-&gt;right,low,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为后面在处理中间结点的代码，相当于循环迭代处理，没有保证到根结点的子树都会进入递归，因此，可以将中间结点的处理过程修改成递归形式，整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if (!root)   return root;</span><br><span class="line">        if(root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = trimBST(root-&gt;left,low,high);</span><br><span class="line">            root-&gt;right = trimBST(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;val &lt; low)</span><br><span class="line">        &#123;</span><br><span class="line">            return trimBST(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;val &gt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            return trimBST(root-&gt;left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题在于，会导致占用更多的栈空间，让整个程序的空间复杂度比原有的更加大。</p>
<p>综上所述，第一个版本的递归由于带上了部分迭代的版本，总体性能更优</p>
<h3 id="迭代法-17"><a href="#迭代法-17" class="headerlink" title="迭代法"></a>迭代法</h3><p>类似上一题删除二叉搜索树中的结点，迭代法需要找到目标结点的父结点，并改变父结点的指向，在本题中，需要先循环寻找到在范围之内的根结点，再分别对左子树和右子树进行循环判断和更改，循环过程是关键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if (!root)   return root;</span><br><span class="line">        while(root&amp;&amp;(root-&gt;val &lt; low || root-&gt;val &gt; high))</span><br><span class="line">        &#123;</span><br><span class="line">            if(root-&gt;val &lt; low)</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            else</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while(node)</span><br><span class="line">        &#123;</span><br><span class="line">            while (node-&gt;right &amp;&amp; node-&gt;right-&gt;val &gt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right = node-&gt;right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        node = root;</span><br><span class="line">        while(node)</span><br><span class="line">        &#123;</span><br><span class="line">            while (node-&gt;left &amp;&amp; node-&gt;left-&gt;val &lt; low)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left = node-&gt;left-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h3><p>这两题中，迭代法由于不占用递归栈的空间，空间复杂度都为O(1)，<strong>但需要考虑的情况更加多</strong>，比递归法更为复杂</p>
<h2 id="将有序数组转换成二叉搜索树"><a href="#将有序数组转换成二叉搜索树" class="headerlink" title="将有序数组转换成二叉搜索树"></a>将有序数组转换成二叉搜索树</h2><p>[将有序数组转换成二叉搜索树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-24"><a href="#递归法-24" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li><p>确定递归结束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(start&lt;end)	return nullptr;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeNode*(vector&lt;int&gt;&amp;nums,int start,int end)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>确定递归单层逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* root = new TreeNode(nums[(left + right + 1)/2]);</span><br><span class="line">root-&gt;left = sortedArrayIndexToBST(nums, start, rootindex - 1);</span><br><span class="line">root-&gt;right = sortedArrayIndexToBST(nums, rootindex + 1, end);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayIndexToBST(vector&lt;int&gt;&amp; nums, int start, int end)</span><br><span class="line">    &#123;</span><br><span class="line">        if (end &lt; start)   return nullptr;</span><br><span class="line">        int rootindex = (end+start+1) / 2;</span><br><span class="line">        TreeNode* root = new TreeNode(nums[rootindex]);</span><br><span class="line">        root-&gt;left = sortedArrayIndexToBST(nums, start, rootindex - 1);</span><br><span class="line">        root-&gt;right = sortedArrayIndexToBST(nums, rootindex + 1, end);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()==1)  </span><br><span class="line">            return new TreeNode(nums[0]);</span><br><span class="line">        return sortedArrayIndexToBST(nums,0,nums.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="迭代法-18"><a href="#迭代法-18" class="headerlink" title="迭代法"></a><strong>迭代法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        queue&lt;pair&lt;TreeNode*, int&gt;&gt; que;     //父结点和index</span><br><span class="line">        TreeNode* root = new TreeNode(0);</span><br><span class="line">        que.push(make_pair(nullptr, nums.size() / 2));</span><br><span class="line"></span><br><span class="line">        while (!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int index = que.front().second;</span><br><span class="line">            TreeNode* fa = que.front().first;</span><br><span class="line">            que.pop();</span><br><span class="line"></span><br><span class="line">            TreeNode* cur = new TreeNode(nums[index]);</span><br><span class="line">            if (fa &amp;&amp; nums[index] &lt; fa-&gt;val)</span><br><span class="line">                fa-&gt;left = cur;</span><br><span class="line">            else if (fa &amp;&amp; nums[index] &gt; fa-&gt;val)</span><br><span class="line">                fa-&gt;right = cur;</span><br><span class="line">            else</span><br><span class="line">                root = cur;</span><br><span class="line">            if (index - 1 &gt;= 0) que.push(make_pair(cur, index / 2));</span><br><span class="line">            if (index + 1 &lt; nums.size())   que.push(make_pair(cur, (index + nums.size() + 1) / 2));</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上版本的代码会死循环，原因在于条件判断进入队列，由于子区间<strong>没有边界限定</strong>，而只使用原始nums的边界，就会导致一直有实际上并不合法的结点进入队列。此时，需要有额外的容器去记录边界</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 0) return nullptr;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = new TreeNode(0);   // 初始根节点</span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQue;           // 放遍历的节点</span><br><span class="line">        queue&lt;int&gt; leftQue;                 // 保存左区间下标</span><br><span class="line">        queue&lt;int&gt; rightQue;                // 保存右区间下标</span><br><span class="line">        nodeQue.push(root);                 // 根节点入队列</span><br><span class="line">        leftQue.push(0);                    // 0为左区间下标初始位置</span><br><span class="line">        rightQue.push(nums.size() - 1);     // nums.size() - 1为右区间下标初始位置</span><br><span class="line"></span><br><span class="line">        while (!nodeQue.empty()) &#123;</span><br><span class="line">            TreeNode* curNode = nodeQue.front();</span><br><span class="line">            nodeQue.pop();</span><br><span class="line">            int left = leftQue.front(); leftQue.pop();</span><br><span class="line">            int right = rightQue.front(); rightQue.pop();</span><br><span class="line">            int mid = left + ((right - left) / 2);</span><br><span class="line"></span><br><span class="line">            curNode-&gt;val = nums[mid];       // 将mid对应的元素给中间节点</span><br><span class="line"></span><br><span class="line">            if (left &lt;= mid - 1) &#123;          // 处理左区间</span><br><span class="line">                curNode-&gt;left = new TreeNode(0);</span><br><span class="line">                nodeQue.push(curNode-&gt;left);</span><br><span class="line">                leftQue.push(left);</span><br><span class="line">                rightQue.push(mid - 1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (right &gt;= mid + 1) &#123;         // 处理右区间</span><br><span class="line">                curNode-&gt;right = new TreeNode(0);</span><br><span class="line">                nodeQue.push(curNode-&gt;right);</span><br><span class="line">                leftQue.push(mid + 1);</span><br><span class="line">                rightQue.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-25"><a href="#总结-25" class="headerlink" title="总结"></a>总结</h3><p>这道题也属于修改二叉搜索树的结构，通常在处理中间结点后，可以利用递归返回值来更新二叉搜索树的左右结点，并递归下去</p>
<p>且迭代法要考虑的比递归法要复杂很多，在本题中，迭代法最终实现过程还是依据了递归法的过程，用边界条件作为参数，不断缩小边界，只不过<strong>在递归法中使用函数的传参代替了迭代法中用于记录这几个参数的容器</strong></p>
<h2 id="把二叉搜索树转换成累加树"><a href="#把二叉搜索树转换成累加树" class="headerlink" title="把二叉搜索树转换成累加树"></a>把二叉搜索树转换成累加树</h2><p>[把二叉搜索树转换成累加树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a>)</p>
<h3 id="递归法-25"><a href="#递归法-25" class="headerlink" title="递归法"></a>递归法</h3><p>灵活运用遍历顺序，根据题意，需要找最大的结点，即最右结点，再访问第二大的结点，即中间结点，最后才是左结点，实际上这就是中序遍历的逆序</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int res = 0;</span><br><span class="line">    TreeNode* convertBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return nullptr;</span><br><span class="line">        convertBST(root-&gt;right);</span><br><span class="line">        res += root-&gt;val;</span><br><span class="line">        root-&gt;val = res;</span><br><span class="line">        convertBST(root-&gt;left);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-19"><a href="#迭代法-19" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法所用到的也是中序遍历的模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* convertBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)   return nullptr;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while(!stk.empty()||node)</span><br><span class="line">        &#123;</span><br><span class="line">            if(node)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                node = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                node-&gt;val = sum;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-26"><a href="#总结-26" class="headerlink" title="总结"></a>总结</h3><p>第一想法是，第一次遍历二叉树，借助数组存储每个结点的值，再遍历一次数组，对数组的值进行处理，使得每个下标对应的是累加后的数值，最后遍历一次二叉树修改原值。</p>
<p>这一题摆脱了常规的遍历顺序，尝试了先访问右结点的逆向中序遍历</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/10/11/%E8%BF%99%E9%87%8C%E6%98%AF%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" rel="prev" title="这里是第一篇博客文章">
                  <i class="fa fa-chevron-left"></i> 这里是第一篇博客文章
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/10/18/C3P%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="next" title="C3P阅读笔记">
                  C3P阅读笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
