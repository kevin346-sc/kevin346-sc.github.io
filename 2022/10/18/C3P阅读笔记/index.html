

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Kevin Huang">
  <meta name="keywords" content="">
  
    <meta name="description" content="第一部分第二章——变量和基本类型char类型及其扩展   类型 含义 最小尺寸    char 字符 8bit   wchar_t 宽字符 16bit   char16_t Unicode字符 16bit   char32_t Unicode字符 32bit   wchar_t确保可以存放机器最大扩展字符集中的任一个字符，char16_t和char32_t为Unicode字符集服务 类型转换如果赋">
<meta property="og:type" content="article">
<meta property="og:title" content="C3P阅读笔记">
<meta property="og:url" content="https://kevin346-sc.github.io/2022/10/18/C3P%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Serein’s Blog">
<meta property="og:description" content="第一部分第二章——变量和基本类型char类型及其扩展   类型 含义 最小尺寸    char 字符 8bit   wchar_t 宽字符 16bit   char16_t Unicode字符 16bit   char32_t Unicode字符 32bit   wchar_t确保可以存放机器最大扩展字符集中的任一个字符，char16_t和char32_t为Unicode字符集服务 类型转换如果赋">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-18T08:13:20.000Z">
<meta property="article:modified_time" content="2022-11-16T06:32:04.000Z">
<meta property="article:author" content="Kevin Huang">
<meta property="article:tag" content="notes">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C3P阅读笔记 - Serein’s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kevin346-sc.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C3P阅读笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-18 16:13" pubdate>
          2022年10月18日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          204 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C3P阅读笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="第二章——变量和基本类型"><a href="#第二章——变量和基本类型" class="headerlink" title="第二章——变量和基本类型"></a>第二章——变量和基本类型</h2><h3 id="char类型及其扩展"><a href="#char类型及其扩展" class="headerlink" title="char类型及其扩展"></a>char类型及其扩展</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody><tr>
<td><code>char</code></td>
<td>字符</td>
<td>8bit</td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td>宽字符</td>
<td>16bit</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>Unicode字符</td>
<td>16bit</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>Unicode字符</td>
<td>32bit</td>
</tr>
</tbody></table>
<p><code>wchar_t</code>确保可以存放机器最大扩展字符集中的任一个字符，char16_t和char32_t为Unicode字符集服务</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>如果赋予一个取值区间之外的值，如<code>unsigned char</code>（8bit）表示0-255，赋予-2，则-2对256取模后的余数，实际结果为254(数据类型所占位数而定)</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>默认的，整形字面值数据类型是带符号数，即<code>int</code>；浮点型默认数据类型为<code>double</code>，因为float精度不够且双精度浮点数计算代价与单精度差不多；字符串字面值结尾处会多一个空字符<code>\0</code>，字符串字面值的实际长度要比它的内容多1；若两个字符串字面值位置紧邻且仅由<em><strong>空格、缩进和换行符</strong></em>分割时，实际上是一个整体</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\n</span> 换行符		<span class="hljs-string">\t</span> 横向制表符		<span class="hljs-string">\v</span> 纵向制表符		<span class="hljs-string">\b</span> 退格符		<span class="hljs-string">\r</span> 回车符(清空当前行并回到行首)<br></code></pre></td></tr></table></figure>

<p>如果反斜线后的八进制数字超过三个，只有前三个与反斜线构成转义序列；如果跟着十六进制数字，则所有十六进制数字都参与构成转义序列</p>
<h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><table>
<thead>
<tr>
<th>前缀&#x2F;后缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>Unicode16字符</td>
<td><code>char16_t</code></td>
</tr>
<tr>
<td>U</td>
<td>Unicode32字符</td>
<td><code>char32_t</code></td>
</tr>
<tr>
<td>L</td>
<td>宽字符</td>
<td><code>wchar_t</code></td>
</tr>
<tr>
<td>u8</td>
<td>UTF-8</td>
<td><code>char</code></td>
</tr>
<tr>
<td>整型后缀</td>
<td></td>
<td></td>
</tr>
<tr>
<td>u&#x2F;U</td>
<td>无符号型</td>
<td><code>unsigned</code></td>
</tr>
<tr>
<td>l&#x2F;L</td>
<td></td>
<td><code>long</code></td>
</tr>
<tr>
<td>ll&#x2F;LL</td>
<td></td>
<td><code>long long</code></td>
</tr>
<tr>
<td>浮点型后缀</td>
<td></td>
<td></td>
</tr>
<tr>
<td>f&#x2F;F</td>
<td></td>
<td><code>float</code></td>
</tr>
<tr>
<td>l&#x2F;L</td>
<td></td>
<td><code>long double</code></td>
</tr>
</tbody></table>
<p>整型字面值不能添加浮点型后缀F</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>如果使用列表初始化且初始值存在信息丢失的风险，则会报错，如<code>int a = &#123;3.14&#125;</code></p>
<ol>
<li>在任何函数体之外的变量会被初始化为0</li>
<li>在函数体内部的内置型变量不会被初始化，其未定义，不可被访问</li>
<li>类不初始化则由类自己定义</li>
</ol>
<p>变量声明规定了变量的类型和名字，定义则为其开辟空间</p>
<p>变量声明：在变量名前添加关键字 <code>extern</code>，如<code>extern int i;</code>。但如果包含了初始值，就变成了定义：<code>extern double pi = 3.14;</code></p>
<p>变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。</p>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>同时存在全局和局部变量时，已定义局部变量的作用域中可用<code>::reused</code>显式访问全局变量reused。</p>
<h3 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h3><p>引用类型的初始值必须是一个<em><strong>对象</strong></em>（不能是字面值），必须在定义时给引用赋初值</p>
<p>指针本身就是一个对象，可以不赋初值</p>
<p>引用自加——引用的对象加一</p>
<p>指针自加——指针指向下一个类型，即向后偏移一个类型的大小</p>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a><code>void*</code>指针</h3><p>可以存放任意对象的地址，但不能访问对象</p>
<ol>
<li>与其它指针比较</li>
<li>当做函数的输入或输出</li>
<li>赋值给另一个<code>void*</code>指针</li>
</ol>
<h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3><p><code>int i = 0; </code></p>
<p><code>int* b = &amp;i; </code></p>
<p><code>int * &amp; a = b;</code></p>
<p><code>i</code>是整型变量，<code>b</code>是指向整型变量<code>i</code>的整型指针，<code>a</code>是指向整型指针<code>b</code>的整型引用</p>
<p><code>*a = 1;</code>通过引用对整型变量进行访问和修改</p>
<h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a><code>const</code>限定符</h3><p><code>const</code>对象一旦创建就不能被修改，因此在定义时必须赋初值</p>
<p><code>const int ci = 0; int i = ci; </code>	<code>const</code>的常量特征只在被修改时显示，因此可以用常量值赋初值</p>
<h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a><code>const</code>的引用</h3><p>即为对常量的引用，且无法对引用对象进行修改(常量引用)</p>
<p><code>const int ci = 30; const int &amp; cr = ci</code></p>
<p>则<code>cr</code>为对<code>ci</code>的常量引用</p>
<p>常量引用初始化时能够用字面值赋值，而引用不能，且能够用任意表达式进行初始化</p>
<p><code>const</code>引用的也可以不是常量，因为引用对象本身不是常量，即时不能通过引用修改对象，但能通过其他途径来修改。</p>
<h3 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a><em><strong>常量指针和指针常量</strong></em></h3><p><code>const int ci = 30; int const* cptr =&amp;ci;</code> 则<code>cptr</code>为指向常量的<code>int</code>指针，且因为其是指针，可以不用初始化</p>
<p>常量指针指向的也可以不是常量，只是不能通过指针改变对象的值，但仍可以通过其他途径修改。底层<code>const</code></p>
<p><code>const int ci = 30; const int *const ptrc = &amp;ci;</code>则<code>ptrc</code>为指针常量，是一个指向整型常量的<code>const int</code>指针常量</p>
<p><code>int i = 30; int *const ptri = &amp;i;</code>则<code>prti</code>为指针常量，是一个指向整型字面量的<code>int</code>指针常量。顶层<code>const</code></p>
<p>相同地，指针常量指向的也可以不是常量，只是不能更改指针常量本身的指向，但仍可以通过其他途径修改对象的值</p>
<h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>声明为<code>constexpr</code>的变量一定是一个常量（顶层<code>const</code>），且必须用常量表达式初始化。一个<code>constexpr</code>指针的初始值必须为0或者<code>nullptr</code>或者是存在某个固定地址的对象；定义于所有函数体之外的对象其地址固定不变，此时能用于初始化<code>constexpr</code>指针。</p>
<p><code>constexpr int *q = nullptr</code>则q为指向整数的指针常量</p>
<h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a><em><strong>处理类型</strong></em></h3><p><code>using SI = Sales_item;</code> 类型别名</p>
<p><code>typedef char *pstring; </code>			<code>pstring</code>为<code>char*</code>类型，指向<code>char</code>类型的指针</p>
<p> <code>const pstring cstr = 0; </code>			<code>cstr</code>为指向<code>char</code>的指针常量，注意与下一个式子的区别</p>
<p> <code>const char *cstr = 0; </code>				<code>cstr</code>为指向<code>char</code>的常量指针</p>
<p><code>decltype</code>返回表达式结果或变量对应的类型；如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型；如果表达式或者变量加多一层括号，则也将得到引用类型</p>
<p><code>const int ci = 0;decltype(ci) x = 0</code>则x的类型为<code>const int</code></p>
<p><code>int i = 30; decltype(*p) c = i</code>则p的类型为引用类型</p>
<p><code>decltype ((i)) d = i</code>则d的类型也为引用类型</p>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><ul>
<li><code>#indef</code>已定义时为真</li>
<li><code>#inndef</code>未定义时为真</li>
<li>头文件保护符的名称需要唯一，且保持全部大写。养成良好习惯，不论是否该头文件被包含，要加保护符。</li>
</ul>
<h2 id="第三章——字符串、向量和数组"><a href="#第三章——字符串、向量和数组" class="headerlink" title="第三章——字符串、向量和数组"></a>第三章——字符串、向量和数组</h2><h3 id="string对象"><a href="#string对象" class="headerlink" title="string对象"></a>string对象</h3><p>如果提供一个字符串字面值给string对象初始化，则该字面值中除了最后的空字符其他所有字符都被拷贝到string对象</p>
<ul>
<li><p>string io：</p>
<ul>
<li><code>string word; cin&gt;&gt;word</code>忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止</li>
<li><code>string word; while(cin&gt;&gt;word)</code>读取到文件结束符或非法输入时停止 Ctrl+Z</li>
<li><code>getline</code>：读取一整行，<strong>包括空白符</strong>，直到换行符，但不会将换行符存到string对象中</li>
<li>string line; while(getline(cin,line))</li>
</ul>
</li>
<li><p><code>s.size()</code>返回的时<code>string::size_type</code>类型，记住是一个<strong>无符号</strong>类型的值，不要和<code>int</code>混用</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">void<span class="hljs-built_in"> check </span>(size_type i,<span class="hljs-built_in"> const </span>string &amp;msg)<span class="hljs-built_in"> const</span><br><span class="hljs-built_in"></span>&#123;<br>	if(i&gt;=data-&gt;size())<br>	<span class="hljs-built_in">	throw </span>out_of_range(msg);<br>&#125;<br>当i小于0，会自动转换成正整数，即i = i + UINT_MAX;<br></code></pre></td></tr></table></figure>


</li>
<li><p><code>s1+s2</code>使用时，保证至少一侧是string类型。<code>string s1 = &quot;hello&quot; + &quot;world&quot; // 错误，两侧均为字符串字面值</code></p>
</li>
</ul>
<p><code>cctype</code>头文件中的标准函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>isalnum(c)</code></td>
<td>当<code>c</code>是字母或数字时为真</td>
</tr>
<tr>
<td><code>isalpha(c)</code></td>
<td>当<code>c</code>是字母时为真</td>
</tr>
<tr>
<td><code>iscntrl(c)</code></td>
<td>当<code>c</code>是控制字符时为真</td>
</tr>
<tr>
<td><code>isdigit(c)</code></td>
<td>当<code>c</code>是数字时为真</td>
</tr>
<tr>
<td><code>isgraph(c)</code></td>
<td>当<code>c</code>不是空格但可以打印时为真</td>
</tr>
<tr>
<td><code>islower(c)</code></td>
<td>当<code>c</code>是小写字母时为真</td>
</tr>
<tr>
<td><code>isprint(c)</code></td>
<td>当<code>c</code>是可打印字符时为真</td>
</tr>
<tr>
<td><code>ispunct(c)</code></td>
<td>当<code>c</code>是标点符号时为真</td>
</tr>
<tr>
<td><code>isspace(c)</code></td>
<td>当<code>c</code>是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</td>
</tr>
<tr>
<td><code>isupper(c)</code></td>
<td>当<code>c</code>是大写字母时为真</td>
</tr>
<tr>
<td><code>isxdigit(c)</code></td>
<td>当<code>c</code>是十六进制数字时为真</td>
</tr>
<tr>
<td><code>tolower(c)</code></td>
<td>当<code>c</code>是大写字母，输出对应的小写字母；否则原样输出<code>c</code></td>
</tr>
<tr>
<td><code>toupper(c)</code></td>
<td>当<code>c</code>是小写字母，输出对应的大写字母；否则原样输出<code>c</code></td>
</tr>
</tbody></table>
<h3 id="vector对象"><a href="#vector对象" class="headerlink" title="vector对象"></a>vector对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;		<span class="hljs-comment">//v1中有10个元素，默认值为0</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v2&#123;<span class="hljs-number">10</span>&#125;;		<span class="hljs-comment">//v2中有1个元素，值为10</span><br></code></pre></td></tr></table></figure>

<p>如果初始化用的是圆括号，则提供的值是用来构造vector对象；</p>
<p>如果初始化用的是花括号，则表示列表初始化vector对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; v3&#123;<span class="hljs-number">10</span>&#125;;		<span class="hljs-comment">//v3中有10个元素，默认值为空</span><br></code></pre></td></tr></table></figure>

<p>当初始化用了花括号的形式，但提供的值又无法列表初始化，则编译器会尝试用默认值初始化vector对象</p>
<p>因为范围for循环语句内不应改变其所遍历序列的大小，因此不能用范围for循环向vector添加元素</p>
<p>size返回值的类型是由vector定义的size_type类型即<code>vector&lt;int&gt;::size_type</code></p>
<p>用下标访问vector，下标类型应是size_type类型，可以通过<code>auto</code>或者<code>decltype</code>获取</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran">for(decltype(ivec.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">index</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">index</span>&lt;=<span class="hljs-number">10</span>;<span class="hljs-built_in">index</span>++)<br>	ivec.push_back(ix);<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">### vector迭代器
</code></pre>
<p><code>*iter.mem</code>等同于<code>iter-&gt;mem</code></p>
<p><code>vector&lt;int&gt;::iterator it1; </code>					&#x2F;&#x2F;<code>it1</code>能够读写元素</p>
<p><code>vector&lt;int&gt;::const_iterator it2;</code>			&#x2F;&#x2F;it2只能读元素，不能写</p>
<p>两个迭代器之间的运算只有减法运算，返回值类型为<code>difference_type</code></p>
<p><code>difference_type</code>返回带符号整数，所得结果是右侧迭代器向前移动能追上左侧迭代器的距离</p>
<p>迭代器与整数值之间有加法运算</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的大小确定不变，不能随意向数组中增加元素</p>
<p>数组声明时，其中维度必须是<em><strong>常量表达式</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> cnt = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> sz = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">30</span>];			<span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span> arr[cnt];			<span class="hljs-comment">//报错，cnt不是常量表达式</span><br><span class="hljs-type">int</span> ve[sz];				<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure>

<p><em><strong>字符数组在用字符串字面值初始化时，会自动添加表示字符串结束的空字符</strong></em></p>
<p><em><strong>不允许数组拷贝初始化，也不允许用数组给其他数组赋值</strong></em></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-built_in">int</span> a2[] = a;			<span class="hljs-comment">//报错，不允许数组拷贝初始化</span><br>a2 = a;					<span class="hljs-comment">//报错，不允许用数组赋值</span><br></code></pre></td></tr></table></figure>



<p>数组下标类型为<code>size_t</code>（头文件cstddef），而vector和string的下标类型为<code>size_type</code></p>
<h3 id="复杂数组"><a href="#复杂数组" class="headerlink" title="复杂数组"></a>复杂数组</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> *ptrs[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">int</span> (*parray)[<span class="hljs-number">10</span>]=&amp;arr;<br><span class="hljs-built_in">int</span> (&amp;<span class="hljs-built_in">array</span>)[<span class="hljs-number">10</span>]=arr;<br></code></pre></td></tr></table></figure>

<p><code>ptrs</code>是一个数组，包含了10个整型指针——指针数组</p>
<p> <code>parray</code>是一个指针，指向一个有10个整型元素的数组——数组指针</p>
<p><code>array</code>是一个引用，引用对象是一个有10个整型元素的数组</p>
<p><code>int *(&amp;array)[10]=ptrs</code>则是一个引用，引用对象是一个有10个整型指针的数组</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>数组名就是数组首元素的指针</p>
<p><code>string *p2=nums;		//等价于p2 = &amp;nums[0];</code></p>
<p>auto可以推断数组名得到指针类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>;			<span class="hljs-comment">//ia2是一个指针，指向数组ia首元素</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia3</span><span class="hljs-params">(&amp;ia[<span class="hljs-number">0</span>])</span></span>;		<span class="hljs-comment">//同上</span><br></code></pre></td></tr></table></figure>

<p>但当用decltype时则不一样</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">decltype</span>(ia) ia4;		<span class="hljs-comment">//获取到的是ia的数组类型，即ia4是一个整型数组</span><br></code></pre></td></tr></table></figure>

<h3 id="数组的库函数"><a href="#数组的库函数" class="headerlink" title="数组的库函数"></a>数组的库函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia);		<span class="hljs-comment">//beg指向首元素</span><br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia);		<span class="hljs-comment">//last指向尾元素</span><br></code></pre></td></tr></table></figure>

<p>当两个数组指针相减时，返回的类型为<code>ptrdiff_t</code>；vector和string返回的类型为<code>difference_type</code>，都是一种带符号类型</p>
<p>数组下标可以是负数，而vector的下标只能是正整数</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> *p = &amp;ia[<span class="hljs-number">2</span>];			<span class="hljs-comment">//p指向数组第三个元素</span><br><span class="hljs-built_in">int</span> j = p[<span class="hljs-number">-2</span>];				<span class="hljs-comment">//指向数组ia的首元素</span><br></code></pre></td></tr></table></figure>

<h3 id="C风格的字符串-不推荐使用"><a href="#C风格的字符串-不推荐使用" class="headerlink" title="C风格的字符串(不推荐使用)"></a>C风格的字符串(不推荐使用)</h3><p>会在字符串最后一个字符后面跟着一个空字符(<code>\0</code>)</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">char</span> ca[] = &#123;<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> ca1[] = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>C标准库String函数，定义在<code>&lt;cstring&gt;</code> 中：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><code>strlen(p)</code></td>
<td>返回<code>p</code>的长度，空字符不计算在内</td>
</tr>
<tr>
<td><code>strcmp(p1, p2)</code></td>
<td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td>
</tr>
<tr>
<td><code>strcat(p1, p2)</code></td>
<td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td>
</tr>
<tr>
<td><code>strcpy(p1, p2)</code></td>
<td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code></td>
</tr>
</tbody></table>
<p>C风格字符串不支持运算符操作，如<code>+,-,==</code>，因为操作的是指针而非字符串本身，并无意义</p>
<h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><p>允许使用string对象给C风格字符串初始化</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello!&quot;</span><span class="hljs-comment">;</span><br>const char *str <span class="hljs-operator">=</span> s.c_str()<span class="hljs-comment">;	//c_str()返回一个C风格的字符串，即一个指针，并在数组最后加上空字符结束</span><br></code></pre></td></tr></table></figure>

<p>使用数组给vector初始化</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(begin(ia),end(ia))</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>数组的数组，由内而外的顺序理解</p>
<p>使用范围for循环访问多维数组时，外层循环需要使用引用类型，这是为了在内层循环数组被自动转成指针</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(const auto &amp;<span class="hljs-built_in">row</span>: ia)<br>&#123;<br>	<span class="hljs-keyword">for</span>(auto <span class="hljs-built_in">col</span>:<span class="hljs-built_in">row</span>)<br>		cout &lt;&lt; <span class="hljs-built_in">col</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 如果不加引用</span><br><span class="hljs-keyword">for</span>(auto <span class="hljs-built_in">row</span>: ia)<br>	<span class="hljs-keyword">for</span>(auto <span class="hljs-built_in">col</span>:<span class="hljs-built_in">row</span>)<br>		<span class="hljs-comment">//此时row转成指针，类型为int* 因此在内层循环时就会报错</span><br></code></pre></td></tr></table></figure>

<p>利用别名代替，使多维数组降维访问</p>
<p><code>using int_array int[4];	</code></p>
<p><code>typedef int int_array[4];</code></p>
<p>编写3个不同版本的程序，令其均能输出<code>ia</code>的元素。<br>版本1使用范围<code>for</code>语句管理迭代过程；版本2和版本3都使用普通<code>for</code>语句，其中版本2要求使用下标运算符，版本3要求使用指针。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout; <span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <br>    &#123; <br>        &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;,<br>        &#123; <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;,<br>        &#123; <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span> &#125;<br>    &#125;;<br>    <br>	<span class="hljs-comment">//范围for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p:arr)<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q:p)<br>    		cout &lt;&lt; q &lt;&lt; endl;<br>    <span class="hljs-comment">//范围for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-built_in">int</span> (&amp;p)[<span class="hljs-number">4</span>]:arr)<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> q:p)<br>    		cout &lt;&lt; q &lt;&lt; endl;<br>    		<br>    <span class="hljs-comment">//下标for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j&lt;arr[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)<br>    		cout &lt;&lt; arr[i][j] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">//指针for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> *p = <span class="hljs-built_in">begin</span>(arr); p! = <span class="hljs-built_in">end</span>(arr); p++)<br>    &#123;<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> *q = <span class="hljs-built_in">begin</span>(*p);q!= end（*p);q++)<br>    		cout &lt;&lt; *q &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//指针for</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span>(*p)[<span class="hljs-number">4</span>]=arr;p &lt; arr.<span class="hljs-built_in">size</span>();p++)<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> *q = *p;q &lt; arr[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();q++)<br>    		cout &lt;&lt; *q &lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="第四章——表达式"><a href="#第四章——表达式" class="headerlink" title="第四章——表达式"></a>第四章——表达式</h2><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>当一个对象被用作左值时，使用的是对象的身份（在内存中的位置）；</p>
<p>当一个对象被用作右值时，使用的是对象的值</p>
<p>解引用符返回的结果是左值</p>
<p>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">decltype</span>(*p);		<span class="hljs-comment">//返回引用类型int&amp;</span><br><span class="hljs-built_in">decltype</span>(&amp;p);		<span class="hljs-comment">//返回指针类型int**，即指向整型指针的指针</span><br></code></pre></td></tr></table></figure>

<p>表达式的结果是左值，decltype得到引用类型；表达式的结果是右值，decltype得到指针类型</p>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>运算对象和运算结果都是右值</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bool b <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br>bool b2 <span class="hljs-operator">=</span> -b<span class="hljs-comment">;		//b2依然为true</span><br></code></pre></td></tr></table></figure>

<p>参与取余运算的运算对象都为整数类型</p>
<p><code>(-m)/n,m/(-n)</code>结果都为<code>-(m/n)</code></p>
<p><code>m%(-n)</code>结果为<code>m%n</code>，<code>(-m)%n</code>结果为<code>-(m%n)</code></p>
<p>逻辑和关系运算符运算对象和运算结果都是右值</p>
<h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p>前置递增运算符将对象本身作为左值返回，后置递增则将对象原始值的副本作为右值返回。后置需要将原始值存储下来以便返回这个未修改的内容，如果不需要修改前的值，应直接使用前置递增</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">auto <span class="hljs-built_in">iter</span> = vi.begin();<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">iter</span>!=vi.end()&amp;&amp;*<span class="hljs-built_in">iter</span>&gt;=<span class="hljs-number">0</span>)<br>	cout&lt;&lt;*<span class="hljs-built_in">iter</span>++&lt;&lt;endl;	// 输出当前值，指针向前移<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>后置递增运算符高于解引用运算符</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">vec</span>[ival++]&lt;=<span class="hljs-built_in">vec</span>[ival];		<span class="hljs-comment">//表达式未定义,应改为</span><br><span class="hljs-built_in">vec</span>[ival]&lt;=<span class="hljs-built_in">vec</span>[ival+<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure>

<p>不应在运算符左右两边都用到一个变量，并且右侧还改变其值</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">while</span><span class="hljs-comment">(beg!=s.end()</span> &amp;&amp; !isspace<span class="hljs-comment">(*beg)</span>)<br>	*beg = toupper<span class="hljs-comment">(*beg++)</span>;			<span class="hljs-comment">//未定义</span><br></code></pre></td></tr></table></figure>



<p>假设<code>iter</code>的类型是<code>vector::iterator</code>, 说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a) *iter++;<br>(b) (*iter)++;<br>(c) *iter.<span class="hljs-built_in">empty</span>();<br>(d) iter-&gt;<span class="hljs-built_in">empty</span>();<br>(e) ++*iter;<br>(f) iter++-&gt;<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure>

<p>解：</p>
<ul>
<li>(a)合法。返回迭代器所指向的元素，然后迭代器递增。</li>
<li>(b)不合法。因为<code>vector</code>元素类型是<code>string</code>，没有<code>++</code>操作。</li>
<li>(c)不合法。这里应该加括号。</li>
<li>(d)合法。判断迭代器当前的元素是否为空。</li>
<li>(e)不合法。<code>string</code>类型没有<code>++</code>操作。</li>
<li>(f)合法。判断迭代器当前元素是否为空，然后迭代器递增。</li>
</ul>
<h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><ul>
<li>对引用类型执行sizeof运算得到引用对象的类型大小</li>
<li>对解引用指针类型执行sizeof运算得到指针指向对象的类型大小，指针可以不有效</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，而不会把数组转换成指针</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，与对象中元素个数或所占空间大小无关</li>
</ul>
<p>通过查看STL源码可以看到vector有四个成员变量<br>   _A  allocator; </p>
<p>   iterator  _First,  _Last,  _End; </p>
<p>所以<code>sizeof(vec)</code>会返回4个字节即16bit</p>
<h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><p>隐式转换</p>
<ul>
<li><p>常见的char、bool、short能存在int就会转换成int，否则提升为<code>unsigned int</code></p>
</li>
<li><p><code>wchar_t,char16_t,char32_t</code>提升为整型中<code>int,long,long long ……</code>最小的，且能容纳原类型所有可能值的类型</p>
</li>
<li><p>当数组被用作<code>decltype</code>关键字的参数，或者作为取地址符(&amp;)、<code>sizeof</code>及<code>typeid</code>等运算符的运算对象时，转换不发生</p>
</li>
</ul>
<p>显示转换</p>
<ul>
<li><p><strong>static_cast</strong>：任何明确定义的类型转换，只要不包含底层const，都可以使用。 <code>double slope = static_cast&lt;double&gt;(j);</code></p>
</li>
<li><p><strong>dynamic_cast</strong>：支持运行时类型识别</p>
</li>
<li><p><strong>const_cast</strong>：只能改变运算对象的底层const，一般可用于去除const性质。 <code>const char *pc; char *p = const_cast&lt;char*&gt;(pc)</code>只有其可以改变常量属性，通常用在<em><strong>函数重载</strong></em></p>
</li>
<li><p><strong>reinterpret_cast</strong>：通常为运算对象的位模式提供低层次上的重新解释，实际上仍为原类型</p>
</li>
</ul>
<h2 id="第五章——语句"><a href="#第五章——语句" class="headerlink" title="第五章——语句"></a>第五章——语句</h2><h3 id="悬垂else"><a href="#悬垂else" class="headerlink" title="悬垂else"></a>悬垂else</h3><p>有多个if时，else只与离它最近的尚未匹配的if匹配或者在想要匹配的if语句下加上花括号，以控制执行路径</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>case关键字和它对应的值一起被称为case标签，其必须是整型常量表达式</p>
<p>如果某个case标签匹配成功，将从改标签开始往后顺序执行所有case分支，因此需要添加break语句</p>
<p>若以一个空的default标签作为结束，则必须跟上一个空语句或者空块</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(init-statement<span class="hljs-comment">;condition;expression)</span><br>	statement<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>在init-statement中可以定义多个对象，但只能有一条声明语句，即所有变量的基础类型都必须相同</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">for(<span class="hljs-name">decltype</span>(<span class="hljs-name">v</span>.size() ) i=0,sz = v.size()<span class="hljs-comment">; i != sz; ++i)</span><br>	v.push_back(<span class="hljs-name">v</span>[i])<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>for语句也可以省略掉任意一部分，但要以一条空语句代替，即要保留分号</p>
<p><code>if(cin.eof())</code>可以读取<code>eof</code>文件结束符，可以用<code>Ctrl+z</code>代替</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常处理包括：</p>
<ul>
<li><strong>throw表达式</strong>：异常检测部分使用 <code>throw</code>表达式来表示它遇到了无法处理的问题。我们说 <code>throw</code>引发 <code>raise</code>了异常。</li>
<li><strong>try语句块</strong>：以 <code>try</code>关键词开始，以一个或多个 <code>catch</code>字句结束。 <code>try</code>语句块中的代码抛出的异常通常会被某个 <code>catch</code>捕获并处理。 <code>catch</code>子句也被称为<strong>异常处理代码</strong>。</li>
<li><strong>异常类</strong>：用于在 <code>throw</code>表达式和相关的 <code>catch</code>子句之间传递异常的具体信息</li>
</ul>
<p>try语句块内声明的变量在块外部无法访问，在catch子句内也无法访问</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-keyword">while</span>(cin &gt;&gt; item1 &gt;&gt; item2)&#123;<br>	<span class="hljs-keyword">try</span>&#123;<br>		<span class="hljs-keyword">if</span>(item1.isbn()!=item2.isbn())<br>			<span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">&quot;Data must refer to same ISBN&quot;</span>);<br>		<span class="hljs-comment">//如果没有抛出异常，则表示两个isbn是相同的</span><br>		cout &lt;&lt; item1 + item2 &lt;&lt; <span class="hljs-literal">endl</span>;<br>	&#125;<span class="hljs-keyword">catch</span>(runtime_error err)&#123;<br>		<span class="hljs-comment">//异常处理代码，提醒用户异常，询问是否继续</span><br>		cout &lt;&lt; err.what() &lt;&lt; <span class="hljs-literal">endl</span><br>			&lt;&lt; <span class="hljs-string">&quot;Try again? Enter y or n&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>		char c;<br>		cin &gt;&gt; c;<br>		<span class="hljs-keyword">if</span>(!cin || c == <span class="hljs-string">&#x27;n&#x27;</span>)<br>			<span class="hljs-built_in">break</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>处理程序中，<code>err.what()</code>的返回值是C风格字符串，返回初始化<code>runtime_error</code>对象时的string对象的副本</p>
<p>如果异常抛出，但最终没有找到任何匹配的catch语句，程序转到名为<code>terminate</code>的标准库函数，一般将导致程序非正常退出</p>
<p><stdexcept>头文件定义的异常类</p>
<table>
<thead>
<tr>
<th><code>exception</code></th>
<th>最常见的问题</th>
</tr>
</thead>
<tbody><tr>
<td><code>runtime_error</code></td>
<td>只有在运行时才能检测出来的问题</td>
</tr>
<tr>
<td><code>range_error</code></td>
<td>结果超出有意义的值域范围</td>
</tr>
<tr>
<td><code>overflow_error</code></td>
<td>计算上溢</td>
</tr>
<tr>
<td><code>underflow_error</code></td>
<td>计算下溢</td>
</tr>
<tr>
<td><code>logic_error</code></td>
<td>逻辑错误</td>
</tr>
<tr>
<td><code>domain_error</code></td>
<td>参数对应的结果值不存在</td>
</tr>
<tr>
<td><code>invalid_argument</code></td>
<td>无效参数</td>
</tr>
<tr>
<td><code>length_error</code></td>
<td>试图创建一个超出该类型最大长度的对象</td>
</tr>
<tr>
<td><code>out_of_range</code></td>
<td>使用一个超出有效范围的值</td>
</tr>
</tbody></table>
<p>对于<code>exception</code>，<code>bad_alloc</code>，<code>bad_cast</code>只能默认初始化而不允许提供初始值</p>
<h2 id="第六章——函数"><a href="#第六章——函数" class="headerlink" title="第六章——函数"></a>第六章——函数</h2><h3 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h3><p>当执行指针拷贝操作时，拷贝的是指针的值，可以通过指针改变所指的对象的值，但不改变指针本身</p>
<p>编写一个函数，使用指针形参交换两个整数的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* p,<span class="hljs-type">int</span>* q)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> tmp = *p;<br>	*p = *q;<br>	*q = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>	<span class="hljs-built_in">swap</span>(&amp;a,&amp;b);<br>	cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><ul>
<li><p>使用引用可以避免额外空间开销</p>
</li>
<li><p>还可以利用引用形参返回额外信息</p>
</li>
</ul>
<p><em><strong>右值实参不能用作引用形参</strong></em></p>
<h3 id="常量形参"><a href="#常量形参" class="headerlink" title="常量形参"></a><em><strong>常量形参</strong></em></h3><p>尽量使用常量引用，因为如果是普通引用如字符串，将无法接收<em><strong>字符字面值常量</strong></em>以及<em><strong>常量字符串</strong></em></p>
<p>不能把const对象、结果为该类型的表达式、字面值或者需要类型转换的对象传递给普通的引用形参</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组——不允许拷贝，不允许赋值给其他数组，使用数组时通常会将其转换成指针</p>
<p>数组形参只能以<code>const int *</code>类型传参，但可以有不同形式</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* pa)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> pa[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> pa[<span class="hljs-number">10</span>])</span></span>;	<span class="hljs-comment">//维度以实参为主</span><br></code></pre></td></tr></table></figure>

<p>三种形式等价</p>
<h3 id="管理数组指针形参"><a href="#管理数组指针形参" class="headerlink" title="管理数组指针形参"></a>管理数组指针形参</h3><ol>
<li><p>使用标记指定数组长度</p>
<p>如C风格字符串，自带有空字符，遇到空字符时即停止，但数组没有明显标记</p>
<p><code>void print(const char *cp)</code></p>
</li>
<li><p>使用标准库规范</p>
<p>传递指向数组首元素和尾元素的指针，<code>begin</code>和<code>end</code>函数</p>
<p><code>void print(const int *beg,const int *end)</code></p>
</li>
<li><p>显示传递表示数组大小的形参</p>
<p><code>void print(const int ia[],size_t size)</code></p>
</li>
</ol>
<h3 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h3><p>形参可以是数组的引用，且<em><strong>维度</strong></em>是类型的一部分，但绑定了维度就意味着函数只能作用于固定维度的数组</p>
<p><code>void print(int (&amp;arr)[10])</code></p>
<h3 id="多维数组形参"><a href="#多维数组形参" class="headerlink" title="多维数组形参"></a>多维数组形参</h3><p>数组第二维以及后面所有维度的大小都是数组类型的一部分，不能省略</p>
<p><code>void print(int (*arr)[10])</code>指针指向10个整数数组，等价于<code>void print(int arr[][10])</code></p>
<p><code>void print(int *arr [10])</code>则代表10个整型指针的数组</p>
<h3 id="处理命令行选项"><a href="#处理命令行选项" class="headerlink" title="处理命令行选项"></a>处理命令行选项</h3><p><code>int main(int argc,char* argv[])</code>等价于<code>int main(int argc,char**argv)</code></p>
<p>其中第一个形参表示数组中字符串的数量，第二个形参表示数组，元素是指向C风格字符串的指针</p>
<p>argv中的实参0保存程序的名字，往后是用户输入的实参，最后一个指针之后的元素值保证是0</p>
<h3 id="可变形参的函数"><a href="#可变形参的函数" class="headerlink" title="可变形参的函数"></a>可变形参的函数</h3><ul>
<li><p>如果所有的实参类型相同，可以传递一个名为<code>initializer_list</code>的标准库类型，表示某种特定类型的值的数组</p>
<p><code>initializer_list</code>对象中的元素永远是常量值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-type">const</span>&amp; il)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : il) sum += i;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> il = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;; <span class="hljs-comment">//可变长度</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">sum</span>(il) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果类型不相同，可以用可变参数模板</p>
</li>
<li><p>省略符，一般只用于与C函数机交互的接口程序</p>
</li>
</ul>
<h3 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h3><p>调用一个返回引用的函数得到左值，其他返回类型得到右值</p>
<p>函数返回类型不能是数组或者函数，但可以是指向数组或者函数的指针</p>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a><em><strong>返回数组指针</strong></em></h3><ul>
<li><code>Type (*function (parameter_list))[dimension]</code>如<code>int (*func(int i)[10])</code>表明需要实参类型是int，函数调用结果返回的是指针类型，指针指向的是个大小为10的整型数组，</li>
<li>使用类型别名： <code>typedef int arrT[10];</code> 或者 <code>using arrT = int[10;]</code>，然后 <code>arrT* func() &#123;...&#125;</code></li>
<li>使用 <code>decltype</code>： <code>int odd[] = &#123;1,2,3,4,5&#125;; decltype(odd) *arrPtr(int i) &#123;...&#125;</code></li>
<li><strong>尾置返回类型</strong>： 在形参列表后面以一个<code>-&gt;</code>开始：<code>auto func(int i) -&gt; int(*)[10]</code></li>
</ul>
<p>编写一个函数声明，使其返回数组的引用并且该数组包含10个string对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">string (&amp;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>)[<span class="hljs-number">10</span>];				<span class="hljs-comment">//初始版本</span><br><br>typedef string str_arr[<span class="hljs-number">10</span>];			<span class="hljs-comment">//类型别名</span><br>str_arr&amp; <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br><br>auto <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>-&gt;string(&amp;)[<span class="hljs-number">10</span>];			<span class="hljs-comment">//尾置返回类型</span><br><br>string s[<span class="hljs-number">10</span>];						<span class="hljs-comment">//decltype关键字</span><br>decltype(s)&amp; <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>不允许两个函数除了返回类型外其他都一样，这不是重载的函数</p>
<p><em><strong>顶层const不影响传入函数的对象，因此不能用顶层const来进行函数重载，而底层const则可以</strong></em></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>*)</span></span>;		<span class="hljs-comment">//形参为常量指针，是底层const，可以对函数重载</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span></span>;				<span class="hljs-comment">//函数重载为普通指针的形参</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>* <span class="hljs-type">const</span>)</span></span>;		<span class="hljs-comment">//形参为指针常量，是顶层const</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span></span>;				<span class="hljs-comment">//等价于上式，重复声明函数</span><br></code></pre></td></tr></table></figure>

<p>const形参重载可借助<code>const_cast</code></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const <span class="hljs-built_in">string</span> &amp;shorter<span class="hljs-constructor">String(<span class="hljs-params">const</span> <span class="hljs-params">string</span> &amp;<span class="hljs-params">s1</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s2</span>)</span><br>&#123;<br>	return s1.size<span class="hljs-literal">()</span> &lt;= s2.size<span class="hljs-literal">()</span> ? s1 : s2;<br>&#125;<br><br><span class="hljs-built_in">string</span> &amp;shorter<span class="hljs-constructor">String(<span class="hljs-params">string</span> &amp;<span class="hljs-params">s1</span>, <span class="hljs-params">string</span> &amp;<span class="hljs-params">s2</span>)</span><br>&#123;<br>	auto &amp;r = shorter<span class="hljs-constructor">String(<span class="hljs-params">const_cast</span>&lt;<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp;&gt;(<span class="hljs-params">s1</span>)</span>,const_cast&lt;const <span class="hljs-built_in">string</span>&amp;&gt;(s2));<br>	return const_cast&lt;<span class="hljs-built_in">string</span> &amp;&gt;(r);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当普通引用传入时，调用第二个版本函数，将普通引用强制转换成const引用，再调用第一个版本函数，返回得到const引用绑定为一个引用上，再将其转换回普通引用返回</p>
<p>若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名</p>
<h3 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h3><ul>
<li><p>默认实参</p>
<p><code>string screen(sz ht = 24, sz wid = 80, char backgrnd = &#39; &#39;);</code></p>
<p>一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值</p>
<p>局部变量不能作为默认实参</p>
</li>
<li><p>内联函数</p>
<p>可避免函数调用的开销</p>
<p><code>inline const string &amp;shorterString(const string &amp;s1,const string&amp; s2)</code></p>
</li>
<li><p>constexpr函数</p>
<p>函数的返回类型及所有形参的类型都得是字面值类型，不一定返回常量表达式</p>
</li>
<li><p>调试帮助</p>
<ul>
<li><p>assert预处理宏</p>
<p><code>assert(expr)</code>如果expr为真则忽略，为假则输出信息并终止程序</p>
<p>通常用于检查不能发生的条件</p>
</li>
<li><p>NDEBUG预处理变量</p>
<p><code>CC -D NDEBUG main.c</code>可以定义这个变量<code>NDEBUG</code>，等价于在main.c一开始写# define NDEBUG</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDEBUG</span><br>        cerr &lt;&lt; <span class="hljs-string">&quot;Error:&quot;</span> &lt;&lt; __FILE__<br>             &lt;&lt; <span class="hljs-string">&quot;: in funciton &quot;</span> &lt;&lt; __func__<br>             &lt;&lt; <span class="hljs-string">&quot;at line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot; Compiled on &quot;</span> &lt;&lt; __DATE__<br>             &lt;&lt; <span class="hljs-string">&quot;at &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>分别输出报错的文件名的字符串字面值、当前调试的函数名的字符串字面值、行号的整型字面值、编译日期和编译时间的字符串字面值</p>
</li>
</ul>
</li>
</ul>
<h3 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h3><ul>
<li>重载函数匹配的<strong>三个步骤</strong>：1.候选函数；2.可行函数；3.寻找最佳匹配。</li>
<li><strong>候选函数</strong>：选定本次调用对应的重载函数集，集合中的函数称为候选函数</li>
<li><strong>可行函数</strong>：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数</li>
<li><strong>寻找最佳匹配</strong>：实参转换等级：精确匹配-const转换的匹配-类型提升-算术类型转换-类类型转换</li>
</ul>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a><em><strong>函数指针</strong></em></h3><p>函数名作为一个值使用，该函数自动转换成指针</p>
<p>声明一个指向函数的指针，需包括返回类型和形参类型</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">lengthCompare</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;</span>)</span>;			<span class="hljs-comment">//函数声明</span><br><span class="hljs-built_in">bool</span> (*pf)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;);					<span class="hljs-comment">//函数指针，用指针替换函数名</span><br></code></pre></td></tr></table></figure>

<p>使用函数指针时，解引用与不解引用指针等价。<code>bool flag = pf(&quot;hh&quot;,&quot;kk&quot;);</code>等价于<code>bool flag = (*pf)(&quot;hh&quot;,&quot;kk&quot;);</code></p>
<p>把函数指针用作形参时，使用函数定义和使用函数指针定义等价</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void use<span class="hljs-constructor">Bigger(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s1</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp;<span class="hljs-params">s2</span>, <span class="hljs-params">bool</span> <span class="hljs-params">pf</span>(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp;,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp;)</span>);<br><span class="hljs-comment">//形参为函数类型，将自动转换成函数指针类型</span><br>void use<span class="hljs-constructor">Bigger(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s1</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp;<span class="hljs-params">s2</span>, <span class="hljs-params">bool</span> (<span class="hljs-operator">*</span><span class="hljs-params">pf</span>)</span>(const <span class="hljs-built_in">string</span>&amp;,const <span class="hljs-built_in">string</span>&amp;));<br><span class="hljs-comment">//形参为显式定义函数指针</span><br></code></pre></td></tr></table></figure>

<p>另外，可以用类型别名或者decltype简化需要用到函数指针的函数声明</p>
<h3 id="函数指针当返回值"><a href="#函数指针当返回值" class="headerlink" title="函数指针当返回值"></a><em><strong>函数指针当返回值</strong></em></h3><ol>
<li><p>普通版本</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> (*f(<span class="hljs-built_in">int</span>))(<span class="hljs-built_in">int</span>*,<span class="hljs-built_in">int</span>);<br></code></pre></td></tr></table></figure>

<p>首先，这是一个函数指针，且函数形参为int类型，指针本身也有形参列表，所以该指针指向函数，函数返回类型为int</p>
</li>
<li><p>类型别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> F = <span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>* ,<span class="hljs-type">int</span>);			<span class="hljs-comment">//F是函数类型</span><br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>* ,<span class="hljs-type">int</span>);		<span class="hljs-comment">//PF是函数指针类型</span><br><br><span class="hljs-function">PF <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">F* <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;							<span class="hljs-comment">//两种均等价于普通版本</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>尾置返回类型</p>
<p>与返回数组指针类型类似</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">auto <span class="hljs-built_in">f</span>(int) -&gt;<span class="hljs-built_in">int</span>(*)(int*,int);<br></code></pre></td></tr></table></figure>
</li>
<li><p>auto和decltype</p>
<p>如果明确知道返回函数，可以使用decltype简化</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">decltype</span>(f1)* <span class="hljs-built_in">f</span>(int* ,int);			<span class="hljs-comment">//f1即为需要返回的函数类型</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="第七章——类"><a href="#第七章——类" class="headerlink" title="第七章——类"></a>第七章——类</h2><p>类的基本思想是<em><strong>数据抽象</strong></em> 和<em><strong>封装</strong></em></p>
<p>数据抽象依赖于<em><strong>接口</strong></em> 和<em><strong>实现</strong></em> 技术</p>
<p>定义在类内部的函数都是隐式的inline函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span>&#123;<br>	<span class="hljs-comment">//成员函数</span><br>	<span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br>	<span class="hljs-comment">//返回书本的ISBN编号</span><br>	<span class="hljs-function">Sales_data &amp;<span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<br>	<span class="hljs-comment">//两个类对象属性相加，返回原对象</span><br>	<span class="hljs-function">doule <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>	<span class="hljs-comment">//返回平均价格</span><br>	<br>	std::string bookNo;<br>	<span class="hljs-comment">//ISBN编号</span><br>	<span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">//数量</span><br>	<span class="hljs-type">double</span> revenue = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">//总收入</span><br>&#125;;<br><span class="hljs-comment">//声明非成员函数，即接口</span><br><span class="hljs-function">Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data&amp;,<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function">std::ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream&amp; os,<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function">std::istream&amp; <span class="hljs-title">add</span><span class="hljs-params">(std::istream&amp; is,Sales_data&amp;)</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数通过this隐式参数来访问调用的对象，当调用成员函数时，隐式地先将类对象的地址初始化this</p>
<p><code>struct *const this</code>，this是一个指针常量，指针指向不变，即一直保存对象的地址</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>目的并非通用，属于类的实现部分</p>
<p>成员函数的声明需在类内，函数声明在其他成员之后，因此不用考虑函数体和其他成员的次序</p>
<p>默认情况下，this是指向非常量的指针常量，意味着不能将this绑定到常量对象上，则无法正常使用到该成员函数，因此应该在函数声明时，在函数形参列表后函数体前加上const，<code>std::string isbn() const&#123;return bookNo;&#125;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sales_data::avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(units_sold)<br>		<span class="hljs-keyword">return</span> revenue/units_sold;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="返回this对象的函数"><a href="#返回this对象的函数" class="headerlink" title="返回this对象的函数"></a>返回this对象的函数</h3><p><code>return *this</code>语句返回调用该函数的对象，令函数能够被连续调用</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Sales_data &amp;Sales_data::<span class="hljs-built_in">combine</span>(const Sales_data &amp;<span class="hljs-built_in">rhs</span>)<br>&#123;<br>	units_sold += <span class="hljs-built_in">rhs</span>.units_sold;<br>	revenue += <span class="hljs-built_in">rhs</span>.revenue;<br>	<span class="hljs-built_in">return</span> *this;<br>&#125;<br><br>//调用代码<br>Sales_data sd1,sd2,sd3;<br>sd1.<span class="hljs-built_in">combine</span>(sd2).<span class="hljs-built_in">combine</span>(sd3);<br></code></pre></td></tr></table></figure>

<h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><p>属于类的接口的组成部分，非成员函数声明与类声明在同一个文件，但不在类内</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery">//输入书本ISBN编号，数量以及单价<br>std::istream&amp; read(std::istream&amp; <span class="hljs-literal">is</span>,Sales_data&amp; <span class="hljs-type">item</span>)<br>&#123;<br>	double price = <span class="hljs-number">0</span>;<br>	<span class="hljs-literal">is</span> &gt;&gt; <span class="hljs-type">item</span>.bookNo &gt;&gt; <span class="hljs-type">item</span>.units_sold &gt;&gt; price;<br>	<span class="hljs-type">item</span>.revenue = price * <span class="hljs-type">item</span>.units_sold;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">is</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//打印输出书本ISBN编号、数量、总销售额及均价</span><br>std::<span class="hljs-variable constant_">ostream</span>&amp; <span class="hljs-keyword">print</span>(std::<span class="hljs-variable constant_">ostream</span>&amp; os, <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Sale_data</span>&amp; item)<br>&#123;<br>	os &lt;&lt; item.bookNo &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>    &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.<span class="hljs-title function_ invoke__">avg_price</span>();<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><span class="hljs-comment">//执行输出任务的函数尽量减少对格式控制，让用户代码决定是否换行</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//add函数，输入两个类类型，返回一个新类的副本</span><br><span class="hljs-title class_">Sales</span>_data <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> Sales_data&amp;item1,<span class="hljs-keyword">const</span> Sales_data&amp;item2</span>)<br>&#123;<br>	<span class="hljs-title class_">Sales</span>_data tmp = item1;<br>	item1.<span class="hljs-title function_">combine</span>(item2);<br>	<span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>构造函数是特殊的成员函数</li>
<li>无返回值</li>
<li>构造函数放在类的<code>public</code>部分</li>
<li>直到构造函数完成，对象才会有常量属性，因此构造函数可以向const对象写值</li>
<li><code>=default</code>要求编译器合成默认的构造函数</li>
<li>初始化列表：冒号和花括号之间的代码： <code>Sales_item(): units_sold(0), revenue(0.0) &#123; &#125;</code></li>
</ul>
<p>class和struct默认访问权限不同，struct则在第一个访问说明符之前的成员是public的，class则是private</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>允许特定的<strong>非成员函数</strong>访问一个类的<strong>私有成员</strong>，通常将友元声明成组地放在<strong>类定义的开始或者结尾</strong></p>
<p>必须在友元声明之外再对函数进行一次声明</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span></span>&#123;<br>friend Sales_data <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-keyword">const</span> Sales_data&amp;,<span class="hljs-keyword">const</span> Sales_data&amp;);<br>friend std::<span class="hljs-variable constant_">istream</span>&amp; <span class="hljs-title function_ invoke__">read</span>(std::<span class="hljs-variable constant_">istream</span>&amp; is, Sales_data&amp;);<br>friend std::<span class="hljs-variable constant_">ostream</span>&amp; <span class="hljs-keyword">print</span>(std::<span class="hljs-variable constant_">ostream</span>&amp; os,<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Sales_data</span>&amp;);<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-title function_ invoke__">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br>	<span class="hljs-title function_ invoke__">Sales_data</span>(<span class="hljs-keyword">const</span> std::<span class="hljs-variable constant_">string</span> &amp;s,unsigned n,douple p):<br>			<span class="hljs-title function_ invoke__">boodNo</span>(s),<span class="hljs-title function_ invoke__">revenue</span>(p),<span class="hljs-title function_ invoke__">units_sold</span>(n) &#123;&#125;<br>	<span class="hljs-title function_ invoke__">Sales_data</span>(<span class="hljs-keyword">const</span> std::<span class="hljs-variable constant_">string</span> &amp;s):<span class="hljs-title function_ invoke__">bookNo</span>(s) &#123;&#125;<br>	<span class="hljs-title function_ invoke__">Sales_data</span>(std::<span class="hljs-variable constant_">istream</span>&amp;);<span class="hljs-comment">//类外实现构造函数</span><br>	<span class="hljs-comment">//类内实现构造函数 Sales_data(std::istream&amp; is) &#123;return read(is,*this);&#125;</span><br>	<br>	std::<span class="hljs-variable constant_">string</span>&amp; <span class="hljs-title function_ invoke__">isbn</span>() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> bookNo&#125;;<br>	Sales_data&amp; <span class="hljs-title function_ invoke__">combine</span>(<span class="hljs-keyword">const</span> Sales_data&amp;);<br>	<span class="hljs-keyword">double</span>&amp; <span class="hljs-title function_ invoke__">avg_price</span>(<span class="hljs-keyword">const</span> Sales_data&amp;) <span class="hljs-keyword">const</span>;<br><span class="hljs-keyword">private</span>:<br>	std::<span class="hljs-variable constant_">string</span> bookNo;<br>	<span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>	unsigned units_sold = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//类外接口函数声明</span><br>Sales_data <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-keyword">const</span> Sales_data&amp;,<span class="hljs-keyword">const</span> Sales_data&amp;);<br>std::<span class="hljs-variable constant_">istream</span>&amp; <span class="hljs-title function_ invoke__">read</span>(std::<span class="hljs-variable constant_">istream</span>&amp; is, Sales_data&amp;);<br>std::<span class="hljs-variable constant_">ostream</span>&amp; <span class="hljs-keyword">print</span>(std::<span class="hljs-variable constant_">ostream</span>&amp; os,<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Sales_data</span>&amp;);<br></code></pre></td></tr></table></figure>

<p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员</p>
<p>也可以只对声明另一个类中的某个成员函数为友元，并说明该成员函数的作用域</p>
<p>若想要把一组重载函数声明为友元，则需要对每一个分别声明</p>
<h3 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h3><p><em><strong>用来定义类型的成员必须先定义后使用</strong></em></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">typedef</span> std::string::size_type pos;<br><span class="hljs-keyword">private</span>:<br>	pos cursor = <span class="hljs-number">0</span>;<br>	pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>	std::string contents;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>定义在类内部的成员函数都是自动inline的，可以在类内部显式inline声明，也能在类外部定义的时候说明inline</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>	<span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br>	<span class="hljs-built_in">Screen</span>(pos ht,pos wd,<span class="hljs-type">char</span> c):<span class="hljs-built_in">height</span>(ht),<span class="hljs-built_in">width</span>(wd),<span class="hljs-built_in">contents</span>(ht*wd,c) &#123;&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> contents[cursor];&#125;<br>	<span class="hljs-comment">//获取光标当前的内容,隐式内联</span><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//显式内联，在类外定义</span><br>	<span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r,pos c)</span></span>;<br><span class="hljs-keyword">private</span>:<br>	pos cursor = <span class="hljs-number">0</span>;<br>	pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>	std::string contents;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span> <span class="hljs-comment">//因为已经在类内声明过inline，此处可以省略</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> contents[ht*width+wd];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span><br><span class="hljs-function"></span>&#123;<br>	cursor = r * width + c;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>若希望能修改类的const成员函数中的某个成员变量，可以通过变量声明前加入mutable实现</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>	<span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br>	<span class="hljs-built_in">Screen</span>(pos ht,pos wd,<span class="hljs-type">char</span> c):<span class="hljs-built_in">height</span>(ht),<span class="hljs-built_in">width</span>(wd),<span class="hljs-built_in">contents</span>(ht*wd,c) &#123;&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> contents[cursor];&#125;<br>	<span class="hljs-comment">//获取光标当前的内容,隐式内联</span><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//显式内联，在类外定义</span><br>	<span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r,pos c)</span></span>;<br>	<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//修改mutable变量函数</span><br><span class="hljs-keyword">private</span>:<br>	pos cursor = <span class="hljs-number">0</span>;<br>	pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>	std::string contents;<br>	<br>	<span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;<span class="hljs-comment">//被修改mutable变量</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span> <span class="hljs-comment">//因为已经在类内声明过inline，此处可以省略</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> contents[ht*width+wd];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span><br><span class="hljs-function"></span>&#123;<br>	cursor = r * width + c;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>	++access_ctr;<span class="hljs-comment">//记录被调用次数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>返回*this的成员函数，返回对象本身，则可以连续调用</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>	<span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br>	<span class="hljs-built_in">Screen</span>(pos ht,pos wd,<span class="hljs-type">char</span> c):<span class="hljs-built_in">height</span>(ht),<span class="hljs-built_in">width</span>(wd),<span class="hljs-built_in">contents</span>(ht*wd,c) &#123;&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> contents[cursor];&#125;<br>	<span class="hljs-comment">//获取光标当前的内容,隐式内联</span><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//显式内联，在类外定义</span><br>	<span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r,pos c)</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//修改mutable变量函数</span><br>	<br>	<span class="hljs-function">Screen&amp; <span class="hljs-title">set</span><span class="hljs-params">(pos,pos,<span class="hljs-type">char</span>)</span></span>;<br>	<span class="hljs-function">Screan&amp; <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>	pos cursor = <span class="hljs-number">0</span>;<br>	pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>	std::string contents;<br>	<br>	<span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;<span class="hljs-comment">//被修改mutable变量</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span> <span class="hljs-comment">//因为已经在类内声明过inline，此处可以省略</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> contents[ht*width+wd];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span><br><span class="hljs-function"></span>&#123;<br>	cursor = r * width + c;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>	++access_ctr;<span class="hljs-comment">//记录被调用次数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">Screen::set</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>	contents[cursor] = c;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">screen::set</span><span class="hljs-params">(pos r,pos col, <span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>	contents[r * width + col] = c;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//调用set  myScreen.move(4,0).set(&#x27;#&#x27;);</span><br></code></pre></td></tr></table></figure>

<h3 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a><em><strong>基于const的重载</strong></em></h3><p>若有常量成员函数，即使返回对象本身，也不能与非常量成员函数一起连续调用，则应该对该常量成员函数进行非常量版本的重载</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>	<span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//有另一个构造函数时，若需要默认构造函数，必须显式声明</span><br>	<span class="hljs-built_in">Screen</span>(pos ht,pos wd,<span class="hljs-type">char</span> c):<span class="hljs-built_in">height</span>(ht),<span class="hljs-built_in">width</span>(wd),<span class="hljs-built_in">contents</span>(ht*wd,c) &#123;&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> contents[cursor];&#125;<br>	<span class="hljs-comment">//获取光标当前的内容,隐式内联</span><br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//显式内联，在类外定义</span><br>	<span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r,pos c)</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">//修改mutable变量函数</span><br>	<span class="hljs-function">Screen&amp; <span class="hljs-title">set</span><span class="hljs-params">(pos,pos,<span class="hljs-type">char</span>)</span></span>;<br>	<span class="hljs-function">Screen&amp; <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br>	<br>	<span class="hljs-comment">//display函数重载</span><br>	<span class="hljs-function">Screen&amp; <span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> </span>&#123;<span class="hljs-built_in">do_display</span>(os);<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<br>	<span class="hljs-function"><span class="hljs-type">const</span> Screen&amp; <span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-built_in">do_display</span>(os);<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<br>	<br><span class="hljs-keyword">private</span>:<br>	pos cursor = <span class="hljs-number">0</span>;<br>	pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>	std::string contents;<br>	<span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;<span class="hljs-comment">//被修改mutable变量</span><br>	<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream&amp; os)</span> <span class="hljs-type">const</span> </span>&#123;os &gt;&gt; contents;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span> <span class="hljs-comment">//因为已经在类内声明过inline，此处可以省略</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> contents[ht*width+wd];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span><br><span class="hljs-function"></span>&#123;<br>	cursor = r * width + c;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>	++access_ctr;<span class="hljs-comment">//记录被调用次数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">Screen::set</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>	contents[cursor] = c;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">screen::set</span><span class="hljs-params">(pos r,pos col, <span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>	contents[r * width + col] = c;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//此时可以调用 myScreen.display(cout).set(&#x27;*&#x27;);</span><br></code></pre></td></tr></table></figure>

<p>以上，display函数有常量和非常量版本，对于常量版本，调用do_display函数，常量对象再被调用成常量对象，即直接对常量对象操作，常量对象传递到函数内部并打印并返回常量对象；对于非常量版本，调用do_display函数，非常量对象被传递，此时传递的是对该非常量对象的常量调用，传递到函数内部并打印，返回该调用的常量对象，即原来的非常量对象。也就是说，将非常量对象通过多一次的函数调用统一成常量对象的调用，而对常量对象不影响。</p>
<p>每个类都是唯一的类型，类在声明后定义前，是一个不完全类型，可以定义指向给类的指针或引用，也可以声明以该类类型作为参数或返回类型的函数。</p>
<h3 id="Person类程序"><a href="#Person类程序" class="headerlink" title="Person类程序"></a>Person类程序</h3><p>编写一个Person类，表示人员的姓名和住址，string来存放，能够返回姓名和住址，能够读取和打印Person对象，构造函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>	friend std::<span class="hljs-variable constant_">istream</span>&amp; <span class="hljs-title function_ invoke__">read</span>(std::<span class="hljs-variable constant_">istream</span>&amp;, Person&amp;);<br>	friend std::<span class="hljs-variable constant_">ostream</span>&amp; <span class="hljs-title function_ invoke__">pritn</span>(std::<span class="hljs-variable constant_">ostream</span>&amp;,<span class="hljs-keyword">const</span> Person&amp;);<br><span class="hljs-keyword">public</span>:<br>	auto <span class="hljs-title function_ invoke__">get_name</span>() <span class="hljs-keyword">const</span> -&gt; std::<span class="hljs-variable constant_">string</span> <span class="hljs-keyword">const</span>&amp; &#123;<span class="hljs-keyword">return</span> name;&#125;<br>	auto <span class="hljs-title function_ invoke__">get_address</span>() <span class="hljs-keyword">const</span> -&gt; std::<span class="hljs-variable constant_">string</span> <span class="hljs-keyword">const</span>&amp; &#123;<span class="hljs-keyword">return</span> address;&#125;<br>	<span class="hljs-comment">//const位置不影响,也可以在std::string之前</span><br>	<span class="hljs-comment">//等价于</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">std</span>::<span class="hljs-variable constant_">string</span>&amp; <span class="hljs-title function_ invoke__">get_neme</span>() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> name;&#125;<br>	std::<span class="hljs-variable constant_">string</span> <span class="hljs-keyword">const</span>&amp; <span class="hljs-title function_ invoke__">get_address</span>() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> address;&#125;<br>	<br>	<span class="hljs-title function_ invoke__">Person</span>() = <span class="hljs-keyword">default</span>;<br>	<span class="hljs-title function_ invoke__">Person</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; s1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; s2): <span class="hljs-title function_ invoke__">name</span>(s1),<span class="hljs-title function_ invoke__">name</span>(s2) &#123;&#125;<br>	<span class="hljs-title function_ invoke__">Person</span>(std::<span class="hljs-variable constant_">istream</span>&amp;)&#123;&#125;;<span class="hljs-comment">//类外定义</span><br>	<span class="hljs-comment">//类内定义 Person(std::istream&amp; is) &#123;read(is,*this);&#125;</span><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">string</span> name,address;<br>&#125;;<br><br>std::<span class="hljs-variable constant_">istream</span>&amp; <span class="hljs-title function_ invoke__">read</span>(std::<span class="hljs-variable constant_">istream</span>&amp; is, Person&amp; p)<br>&#123;<br>	is &lt;&lt; p.name &lt;&lt; p.address;<br>	<span class="hljs-keyword">return</span> is;<br>&#125;<br>std::<span class="hljs-variable constant_">ostream</span>&amp; <span class="hljs-keyword">print</span>(std::<span class="hljs-variable constant_">ostream</span>&amp; os, <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Person</span>&amp; p)<br>&#123;<br>	os &gt;&gt; p.name &gt;&gt; p.address;<br>	<span class="hljs-keyword">return</span> os;<br>&#125;<br><span class="hljs-title class_">Person</span>::<span class="hljs-title function_ invoke__">person</span>(std::<span class="hljs-variable constant_">istream</span>&amp; is)<br>&#123;<br>	<span class="hljs-title function_ invoke__">read</span>(is,*this);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>函数的<strong>返回类型</strong>通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外</p>
<p>如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，则必须通过构造函数初始值列表为这些成员提供初值</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> NoDefault&#123;<br>	<span class="hljs-constructor">NoDefault(<span class="hljs-params">int</span>)</span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//NoDefault类没有提供默认构造函数，此时必须给C加上构造函数</span><br><span class="hljs-keyword">class</span> C&#123;<br>	<span class="hljs-constructor">C(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>: <span class="hljs-constructor">NoDefault(<span class="hljs-params">x</span>)</span> &#123;&#125;<br>	NoDefault nf;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>委托构造函数使用所属类中其他的构造函数来执行自己的初始化过程，受委托的构造函数的初始值列表和函数体被依次执行，最后再执行委托者的函数体</p>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则实际上定义了转换为此类类型的<strong>隐式转换机制</strong>，编译器只会自动地执行<strong>仅一步</strong>类型转换</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string null_book <span class="hljs-operator">=</span> <span class="hljs-string">&quot;9999-99&quot;</span><span class="hljs-comment">;</span><br>item.combine(null_book)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>string实参传入combine成员函数时，string会自动创建一个Sales_data对象</p>
<p>编译器只会执行一步类型转换</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">item.combine(<span class="hljs-string">&quot;9999-99&quot;</span>);<span class="hljs-regexp">//</span>此时会报错<br>item.combine(string(<span class="hljs-string">&quot;9999-99&quot;</span>));<br>item.combine(Sales_data(<span class="hljs-string">&quot;9999-99&quot;</span>));<span class="hljs-regexp">//</span>加上一步显式类型转换则不报错<br></code></pre></td></tr></table></figure>

<p>通过对成员函数声明explicit可以阻止隐式类型转换，explicit只能出现在类内函数的声明中。但可以使用构造函数进行显式的类型转换</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-type">item</span>.combine(Sales_data(null_book));<br><span class="hljs-type">item</span>.combine(static_cast<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Sales_data</span>&gt;</span>(cin));</span><br></code></pre></td></tr></table></figure>

<p><code>explicit</code>构造函数只能用于直接初始化，不能用于拷贝形式的初始化</p>
<h3 id="聚合类-（aggregate-class）"><a href="#聚合类-（aggregate-class）" class="headerlink" title="聚合类 （aggregate class）"></a>聚合类 （aggregate class）</h3><ul>
<li>满足以下所有条件：<ul>
<li>所有成员都是<code>public</code>的。</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值。</li>
<li>没有基类，也没有<code>virtual</code>函数。</li>
</ul>
</li>
<li>可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。</li>
</ul>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><ul>
<li><code>constexpr</code>函数的参数和返回值必须是字面值。</li>
<li><strong>字面值类型</strong>：除了算术类型、引用和指针外，某些类也是字面值类型。</li>
<li>数据成员都是字面值类型的聚合类是字面值常量类。</li>
<li>如果不是聚合类，则必须满足下面所有条件：<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个<code>constexpr</code>构造函数。</li>
<li>如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。</li>
</ul>
</li>
</ul>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ul>
<li>非<code>static</code>数据成员存在于类类型的每个对象中。</li>
<li>成员函数可以直接使用静态成员</li>
<li>每个<code>static</code>数据成员是与类关联的对象，并不与该类的对象相关联。</li>
<li>声明：<ul>
<li>声明之前加上关键词<code>static</code>。</li>
</ul>
</li>
<li>使用：<ul>
<li>成员算符**<code>::</code>直接访问静态成员:<code>r = Account::rate();</code></li>
<li>也可以使用对象访问：<code>r = ac.rate();</code></li>
</ul>
</li>
<li>定义：在类外部定义时不用加<code>static</code>。</li>
<li>初始化：<ul>
<li>通常不在类的内部初始化，而是在定义时进行初始化，如 <code>double Account::interestRate = initRate();</code></li>
<li>如果一定要在类内部定义，则要求必须是字面值常量类型的<code>constexpr</code>。</li>
</ul>
</li>
</ul>
<h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="第八章——IO库"><a href="#第八章——IO库" class="headerlink" title="第八章——IO库"></a>第八章——IO库</h2><h3 id="标准库定义的IO类型"><a href="#标准库定义的IO类型" class="headerlink" title="标准库定义的IO类型"></a>标准库定义的IO类型</h3><ul>
<li><code>iostream</code>头文件：从标准流中读写数据，<code>istream</code>、<code>ostream</code>等。</li>
<li><code>fstream</code>头文件：从文件中读写数据，<code>ifstream</code>、<code>ofstream</code>等。</li>
<li><code>sstream</code>头文件：从字符串中读写数据，<code>istringstream</code>、<code>ostringstream</code></li>
</ul>
<h3 id="IO对象不可复制或赋值"><a href="#IO对象不可复制或赋值" class="headerlink" title="IO对象不可复制或赋值"></a>IO对象不可复制或赋值</h3><ul>
<li>1.IO对象不能存在容器里.</li>
<li>2.形参和返回类型也不能是流类型</li>
<li>3.形参和返回类型一般是流的<strong>引用</strong></li>
<li>4.读写一个IO对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的</li>
</ul>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><p><code>strm</code>是一种IO类型，（如<code>istream</code>）， <code>s</code>是一个流对象</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>strm:iostate</code></td>
<td>是一种机器无关的<strong>类型</strong>，提供了表达条件状态的完整功能</td>
</tr>
<tr>
<td><code>strm:badbit</code></td>
<td>用来指出流已经崩溃</td>
</tr>
<tr>
<td><code>strm:failbit</code></td>
<td>用来指出一个IO操作失败了</td>
</tr>
<tr>
<td><code>strm:eofbit</code></td>
<td>用来指出流到达了文件结束</td>
</tr>
<tr>
<td><code>strm:goodbit</code></td>
<td>用来指出流未处于错误状态，此值保证为零</td>
</tr>
<tr>
<td><code>s.eof()</code></td>
<td>若流<code>s</code>的<code>eofbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.fail()</code></td>
<td>若流<code>s</code>的<code>failbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.bad()</code></td>
<td>若流<code>s</code>的<code>badbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.good()</code></td>
<td>若流<code>s</code>处于有效状态，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>将流<code>s</code>中所有条件状态位复位，将流的状态设置成有效，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.clear(flags)</code></td>
<td>将流<code>s</code>中指定的条件状态位复位，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.setstate(flags)</code></td>
<td>根据给定的标志位，将流<code>s</code>中对应的条件状态位置位，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.rdstate()</code></td>
<td>返回流<code>s</code>的当前条件状态，返回值类型为<code>strm::iostate</code></td>
</tr>
</tbody></table>
<p>从给定流中读取数据，直至遇到文件结束符时停止，然后对流进行按所需位复位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string buf;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; buf)<br>	std::cout &lt;&lt; buf &lt;&lt; std::endl;<br>cin.<span class="hljs-built_in">clear</span>(cin.<span class="hljs-built_in">rdstate</span>() &amp; ~cin.eobit);<br><span class="hljs-comment">//cin.clear();直接将failbit,badbit,eofbit复位</span><br></code></pre></td></tr></table></figure>

<h3 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h3><p>缓冲刷新的原因</p>
<ul>
<li><p>程序正常结束</p>
</li>
<li><p>缓冲区满</p>
</li>
<li><p>endl显式刷新缓冲区</p>
</li>
<li><p>操纵符unitbuf设置流的内部状态来清空缓冲区，对cerr默认设置unitbuf，即cerr是立即刷新的</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cout &lt;&lt; unitbuf; <span class="hljs-regexp">//</span>所有输出操作都会立即刷新缓冲区<br>cout &lt;&lt; nounitbuf; <span class="hljs-regexp">//</span>恢复正常缓冲方式<br></code></pre></td></tr></table></figure>
</li>
<li><p>当读写被关联的流时，关联到的流的缓冲区会被刷新。如cin和cerr关联到cout，读cin或写cerr都导致cout刷新缓冲区</p>
</li>
<li><p>flush刷新缓冲区，不附加任何额外字符</p>
</li>
<li><p>ends插入一个空字符，再刷新缓冲区</p>
</li>
</ul>
<p>交互式系统通常应该关联输入流和输出流，则所有输出包括用户提示，都会在读操作之前被打印出来</p>
<h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p><code>fstream</code>是头文件<code>fstream</code>中定义的一个类型，<code>fstrm</code>是一个文件流对象</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>fstream fstrm;</code></td>
<td>创建一个未绑定的文件流。</td>
</tr>
<tr>
<td><code>fstream fstrm(s);</code></td>
<td>创建一个文件流，并打开名为<code>s</code>的文件，<code>s</code>可以是<code>string</code>也可以是<code>char</code>指针</td>
</tr>
<tr>
<td><code>fstream fstrm(s, mode);</code></td>
<td>与前一个构造函数类似，但按指定<code>mode</code>打开文件</td>
</tr>
<tr>
<td><code>fstrm.open(s)</code></td>
<td>打开名为<code>s</code>的文件，并和<code>fstrm</code>绑定</td>
</tr>
<tr>
<td><code>fstrm.close()</code></td>
<td>关闭和<code>fstrm</code>绑定的文件</td>
</tr>
<tr>
<td><code>fstrm.is_open()</code></td>
<td>返回一个<code>bool</code>值，指出与<code>fstrm</code>关联的文件是否成功打开且尚未关闭</td>
</tr>
</tbody></table>
<p>在要求用到基类对象的地方，可以用继承类型对象来替代。则接受iostream引用参数的函数可以用一个fstream类型调用</p>
<p>当一个fstream对象被销毁时，close自动会被调用</p>
<table>
<thead>
<tr>
<th>文件模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>in</code></td>
<td>以读的方式打开</td>
</tr>
<tr>
<td><code>out</code></td>
<td>以写的方式打开</td>
</tr>
<tr>
<td><code>app</code></td>
<td>每次写操作前均定位到文件末尾</td>
</tr>
<tr>
<td><code>ate</code></td>
<td>打开文件后立即定位到文件末尾</td>
</tr>
<tr>
<td><code>trunc</code></td>
<td>截断文件</td>
</tr>
<tr>
<td><code>binary</code></td>
<td>以二进制方式进行IO操作。</td>
</tr>
</tbody></table>
<p>默认情况下，out模式打开会是trunc模式，out模式打开同时指定app模式或者in模式才不会被截断</p>
<h3 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h3><p><code>sstream</code>是头文件<code>sstream</code>中任意一个类型。<code>s</code>是一个<code>string</code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>sstream strm</code></td>
<td>定义一个未绑定的<code>stringstream</code>对象</td>
</tr>
<tr>
<td><code>sstream strm(s)</code></td>
<td>用<code>s</code>初始化对象</td>
</tr>
<tr>
<td><code>strm.str()</code></td>
<td>返回<code>strm</code>所保存的<code>string</code>的拷贝</td>
</tr>
<tr>
<td><code>strm.str(s)</code></td>
<td>将<code>s</code>拷贝到<code>strm</code>中，返回<code>void</code></td>
</tr>
</tbody></table>
<h3 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a>istringstream</h3><p>对整行文本进行读取，对其中行内的单词进行处理，则可以使用<code>istringstream</code></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PersonInfo</span>&#123;<br>	string name;<br>	vector&lt;string&gt; phones;<br>&#125;;<br>string line, <span class="hljs-type">word</span>;<br>vector&lt;PersonInfo&gt; people;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(cin,line))<br>&#123;<br>	PersonInfo info;<br>	<span class="hljs-function">istringstream <span class="hljs-title">record</span><span class="hljs-params">(line)</span></span>;<br>	record &gt;&gt; info.name;<br>	<span class="hljs-keyword">while</span>(record &gt;&gt; <span class="hljs-type">word</span>)<br>		info.phones.<span class="hljs-built_in">push_back</span>(<span class="hljs-type">word</span>);<br>	people.<span class="hljs-built_in">push_back</span>(info);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="第九章——顺序容器"><a href="#第九章——顺序容器" class="headerlink" title="第九章——顺序容器"></a>第九章——顺序容器</h2><p><code>value_type</code>  元素类型  </p>
<p><code>reference</code>  元素的左值类型，和<code>value_type &amp;</code>含义相同  </p>
<p><code>const_reference</code>  元素的<code>const</code>左值类型，即<code>const value_type &amp;</code></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><code>forward list</code>迭代器不支持递减运算符</p>
<p>将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同；而当使用迭代器来拷贝一个范围时，就不要求容器类型相同</p>
<h3 id="array容器"><a href="#array容器" class="headerlink" title="array容器"></a>array容器</h3><p>定义array时，不仅要指定元素类型，还要指定容器大小，<code>array&lt;int,42&gt; arr</code>，默认构造的array是非空的，包含了与其大小一样多的元素</p>
<p>不能对<strong>内置数组</strong>进行拷贝或对象赋值操作，但array可以</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">array</span>&lt;int, <span class="hljs-number">10</span>&gt; digits = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-attribute">array</span>&lt;int, <span class="hljs-number">10</span>&gt; copy = digits;<br></code></pre></td></tr></table></figure>

<h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和<code>swap</code></h3><p><code>c.assign(b, e)</code>  将<code>c</code>中的元素替换成迭代器<code>b</code>和<code>e</code>表示范围中的元素，<code>b</code>和<code>e</code>不能指向<code>c</code>中的元素  </p>
<p><code>c.assign(il)</code>  将<code>c</code>中的元素替换成初始化列表<code>il</code>中的元素  </p>
<p><code>c.assign(n, r)</code>  将<code>c</code>中的元素替换为<code>n</code>个值是<code>t</code>的元素</p>
<p>array容器不能使用assign；由于值列表对象的大小与原对象大小不一样，也不允许用花括号包围的值列表进行赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;string&gt; names;<br>vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; oldstyle;<br>names = oldstyle;<span class="hljs-comment">// 报错，容器类型不匹配</span><br>name.<span class="hljs-built_in">assign</span>(oldstyle.<span class="hljs-built_in">begin</span>(),oldstyle.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure>

<p>赋值运算会导致指向左边容器的迭代器、引用和指针都失效，swap则不会（array和string除外）这是因为swap不对元素进行交换，只交换两个容器内部的数据结构，时间复杂度为O(1)。而swap对string会导致失效；对array进行swap会真正交换它们的元素</p>
<h3 id="容器操作——insert"><a href="#容器操作——insert" class="headerlink" title="容器操作——insert"></a>容器操作——<code>insert</code></h3><p><code>c.insert(p, t)</code>  在迭代器<code>p</code>指向的元素之前创建一个值是<code>t</code>的元素，返回指向新元素的迭代器</p>
<p><code>c.insert(p, n, t)</code>  在迭代器<code>p</code>指向的元素之前插入<code>n</code>个值为<code>t</code>的元素，返回指向第一个新元素的迭代器；如果<code>n</code>是0，则返回<code>p</code>  </p>
<p><code>c.insert(p, b, e)</code>  将迭代器<code>b</code>和<code>e</code>范围内的元素，插入到<code>p</code>指向的元素之前；如果范围为空，则返回<code>p</code>  </p>
<p><code>c.insert(p, il)</code>  <code>il</code>是一个花括号包围中的元素值列表，将其插入到<code>p</code>指向的元素之前；如果<code>il</code>是空，则返回<code>p</code></p>
<p><code>insert</code>函数将元素插入到迭代器指定位置<strong>之前</strong>，时间复杂度为O(n)，对于list时间复杂度则为O(1)</p>
<p>向<code>vector</code>,<code>string</code>,<code>deque</code>容器中插入元素都会使所有迭代器、指针和引用失效，向deque首尾位置添加元素，迭代器失效，但指针和引用不失效</p>
<p>利用insert的返回值，可以在容器中一个特定位置反复插入元素</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">list&lt;string&gt; lst;<br><span class="hljs-keyword">auto</span> iter = lst.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span>(cin &gt;&gt; <span class="hljs-type">word</span>)<br>	iter = lst.<span class="hljs-built_in">insert</span>(iter,<span class="hljs-type">word</span>);<span class="hljs-comment">//不断在链表头插入元素</span><br></code></pre></td></tr></table></figure>

<h3 id="容器操作——emplace"><a href="#容器操作——emplace" class="headerlink" title="容器操作——emplace"></a>容器操作——<code>emplace</code></h3><p><code>emplace_back(args)</code>在尾部创建一个由args创建的元素</p>
<p><code>emplace_front(args)</code>在头部创建一个由args创建的元素</p>
<p><code>emplace(p,args)</code>在迭代器p指向的元素之前创建一个由args创建的元素，返回指向新添加元素的迭代器</p>
<p><code>emplace</code>开头的函数是新标准引入的，这些操作是构造而不是拷贝元素,传递给<code>emplace</code>的参数必须和元素类型的<strong>构造函数</strong>相匹配</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>c是一个Sales_data对象<br>c.emplace_back(<span class="hljs-string">&quot;989-32000&quot;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">15.99</span>);<br><span class="hljs-regexp">//</span>在c的末尾构造一个Sales_data对象<br>c.push_back(Sales_data(<span class="hljs-string">&quot;989-32000&quot;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">15.99</span>));<br><span class="hljs-regexp">//</span>相当于创建一个临时的Sales_data对象传递给push_back<br></code></pre></td></tr></table></figure>

<p>上述语句都会创建新的Sales_data对象，在调用emplace_back时，会在容器管理的内存空间中直接创建对象，而调用push_back则会创建一个局部临时对象，并将其压入容器中。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.back()</code></td>
<td>返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><code>c.front()</code></td>
<td>返回<code>c</code>中头元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><code>c[n]</code></td>
<td>返回<code>c</code>中下标是<code>n</code>的元素的引用，<code>n</code>时候一个无符号证书。若<code>n&gt;=c.size()</code>，则函数行为未定义</td>
</tr>
<tr>
<td><code>c.at(n)</code></td>
<td>返回下标为<code>n</code>的元素引用。如果下标越界，则抛出<code>out_of_range</code>异常</td>
</tr>
</tbody></table>
<p>访问成员函数返回的是引用</p>
<p>如果希望确保下标是合法的，可以使用at成员函数</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><code>c.erase(p)</code>  删除迭代器<code>p</code>指向的元素，返回一个指向被删除元素之后的元素的迭代器，若<code>p</code>本身是尾后迭代器，则函数行为未定义  </p>
<p><code>c.erase(b, e)</code>  删除迭代器<code>b</code>和<code>e</code>范围内的元素，返回指向最后一个被删元素<strong>之后</strong>元素的迭代器，若<code>e</code>本身就是尾后迭代器，则返回尾后迭代器</p>
<p>删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效，删除deque的尾元素会导致尾后迭代器失效。指向vector、string被删除元素位置之后的迭代器、引用和指针都会失效</p>
<h3 id="forward-list容器"><a href="#forward-list容器" class="headerlink" title="forward_list容器"></a><code>forward_list</code>容器</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>lst.before_begin()</code></td>
<td>返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。</td>
</tr>
<tr>
<td><code>lst.cbefore_begin()</code></td>
<td>同上，但是返回的是常量迭代器。</td>
</tr>
<tr>
<td><code>lst.insert_after(p, t)</code></td>
<td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象。返回<strong>最后一个</strong>插入元素的迭代器</td>
</tr>
<tr>
<td><code>lst.insert_after(p, n, t)</code></td>
<td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象，<code>n</code>是数量。若<code>n</code>是0则函数行为未定义</td>
</tr>
<tr>
<td><code>lst.insert_after(p, b, e)</code></td>
<td>在迭代器<code>p</code>之后插入元素。由迭代器<code>b</code>和<code>e</code>指定范围，不能指向lst内</td>
</tr>
<tr>
<td><code>lst.insert_after(p, il)</code></td>
<td>在迭代器<code>p</code>之后插入元素。由<code>il</code>指定初始化列表。</td>
</tr>
<tr>
<td><code>emplace_after(p, args)</code></td>
<td>使用<code>args</code>在<code>p</code>之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若<code>p</code>为尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td><code>lst.erase_after(p)</code></td>
<td>删除<code>p</code>指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若<code>p</code>指向<code>lst</code>的尾元素或者是一个尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td><code>lst.erase_after(b, e)</code></td>
<td>类似上面，删除对象换成从<code>b</code>到<code>e</code>指定的范围。</td>
</tr>
</tbody></table>
<p>当在<code>forward_list</code>中添加或删除元素时，需要关注两个迭代器，指向当前元素和指向其前驱</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//删除所有奇数元素</span><br>forward_list&lt;<span class="hljs-built_in">int</span>&gt; flst = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>auto prev = flst.<span class="hljs-keyword">begin</span><span class="hljs-constructor">_before()</span>;<br>auto curr = flst.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>;<br><span class="hljs-keyword">while</span>(curr!=flst.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>)<br>&#123;<br>	<span class="hljs-keyword">if</span>(*curr&amp;<span class="hljs-number">0x1</span>)<br>		curr = flst.erase<span class="hljs-constructor">_after(<span class="hljs-params">prev</span>)</span>;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		prev = curr;<br>		++curr;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="删除奇数元素程序"><a href="#删除奇数元素程序" class="headerlink" title="删除奇数元素程序"></a>删除奇数元素程序</h3><p>编写程序，查找并删除<code>forward_list&lt;int&gt;</code>中的奇数元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;forward_list&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::forward_list;<br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">remove_odds</span><span class="hljs-params">(forward_list&lt;<span class="hljs-type">int</span>&gt;&amp; flist)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> is_odd = [] (<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> i &amp; <span class="hljs-number">0x1</span>; &#125;;<br>    flist.<span class="hljs-built_in">remove_if</span>(is_odd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    forward_list&lt;<span class="hljs-type">int</span>&gt; data = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;;<br>    <span class="hljs-built_in">remove_odds</span>(data);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : data) <br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>remove_if</code>是list容器的特定算法，让谓词为真时删除该元素</p>
<h3 id="容器大小管理操作"><a href="#容器大小管理操作" class="headerlink" title="容器大小管理操作"></a>容器大小管理操作</h3><p>调用<code>reserve</code>不会减少容器所占用的内存空间，即<code>capacity</code>，将会大于或等于当前的容量大小传递给<code>reserve</code>的参数；<code>resize</code>只会改变容器中元素的数量，即<code>size</code>而不改变容器的容量；<code>shrink_to_fit</code>则会请求退回多余的内存空间，但不保证一定退回</p>
<h3 id="string的额外操作"><a href="#string的额外操作" class="headerlink" title="string的额外操作"></a>string的额外操作</h3><p>构造string</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>string s(cp, n)</code></td>
<td><code>s</code>是<code>cp</code>指向的数组中前<code>n</code>个字符的拷贝，此数组</td>
</tr>
<tr>
<td><code>string s(s2, pos2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符的拷贝。若<code>pos2 &gt; s2.size()</code>，则构造函数的行为未定义。</td>
</tr>
<tr>
<td><code>string s(s2, pos2, len2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的<code>len2</code>个字符的拷贝。</td>
</tr>
</tbody></table>
<p>从一个<code>const char*</code>创建string时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符串时停止；如果构造函数中还有计数值作为形参，数组则不必以空字符结尾</p>
<p>substr操作</p>
<p><code>s.substr(pos, n)</code>  返回一个<code>string</code>，包含<code>s</code>中<strong>从<code>pos</code>开始</strong>的<code>n</code>个字符的拷贝。<code>pos</code>的默认值是0，<code>n</code>的默认值是<code>s.size() - pos</code>，即拷贝从<code>pos</code>开始的所有字符</p>
<p>改变string的其他方法</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.insert(pos, args)</code></td>
<td>在<code>pos</code>之前插入<code>args</code>指定的字符。<code>pos</code>可以使是下标或者迭代器。接受下标的版本返回指向<code>s</code>的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td>
</tr>
<tr>
<td><code>s.erase(pos, len)</code></td>
<td>删除从<code>pos</code>开始的<code>len</code>个字符，如果<code>len</code>被省略，则删除后面所有字符，返回指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.assign(args)</code></td>
<td>将<code>s</code>中的字符替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.append(args)</code></td>
<td>将<code>args</code>指定的字符追加到<code>s</code>，返回一个指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.replace(range, args)</code></td>
<td>删除<code>s</code>中范围<code>range</code>中的字符，替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td>
</tr>
</tbody></table>
<p>编写一个函数，接受三个<code>string</code>参数是<code>s</code>、<code>oldVal</code> 和<code>newVal</code>。使用迭代器及<code>insert</code>和<code>erase</code>函数将<code>s</code>中所有<code>oldVal</code>替换为<code>newVal</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout; <br><span class="hljs-keyword">using</span> std::endl; <br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">replace_with</span><span class="hljs-params">(string &amp;s, string <span class="hljs-type">const</span>&amp; oldVal, string <span class="hljs-type">const</span>&amp; newVal)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur = s.<span class="hljs-built_in">begin</span>(); cur &lt;= s.<span class="hljs-built_in">end</span>() - oldVal.<span class="hljs-built_in">size</span>(); )<br>        <span class="hljs-keyword">if</span> (oldVal == string&#123; cur, cur + oldVal.<span class="hljs-built_in">size</span>() &#125;)<br>            cur = s.<span class="hljs-built_in">erase</span>(cur, cur + oldVal.<span class="hljs-built_in">size</span>()),<br>            cur = s.<span class="hljs-built_in">insert</span>(cur, newVal.<span class="hljs-built_in">begin</span>(), newVal.<span class="hljs-built_in">end</span>()),<br>            cur += newVal.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">else</span>  <br>            ++cur;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s&#123; <span class="hljs-string">&quot;To drive straight thru is a foolish, tho courageous act.&quot;</span> &#125;;<br>    <span class="hljs-built_in">replace_with</span>(s, <span class="hljs-string">&quot;tho&quot;</span>, <span class="hljs-string">&quot;though&quot;</span>);<br>    <span class="hljs-built_in">replace_with</span>(s, <span class="hljs-string">&quot;thru&quot;</span>, <span class="hljs-string">&quot;through&quot;</span>);<br>    cout &lt;&lt; s &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重写上一题的函数，这次使用一个下标和<code>replace</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout; <br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">replace_with</span><span class="hljs-params">(string &amp;s, string <span class="hljs-type">const</span>&amp; oldVal, string <span class="hljs-type">const</span>&amp; newVal)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>; pos &lt;= s.<span class="hljs-built_in">size</span>() - oldVal.<span class="hljs-built_in">size</span>();)<br>        <span class="hljs-keyword">if</span> (s[pos] == oldVal[<span class="hljs-number">0</span>] &amp;&amp; s.<span class="hljs-built_in">substr</span>(pos, oldVal.<span class="hljs-built_in">size</span>()) == oldVal)<br>            s.<span class="hljs-built_in">replace</span>(pos, oldVal.<span class="hljs-built_in">size</span>(), newVal),<br>            pos += newVal.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">else</span><br>            ++pos;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str&#123; <span class="hljs-string">&quot;To drive straight thru is a foolish, tho courageous act.&quot;</span> &#125;;<br>    <span class="hljs-built_in">replace_with</span>(str, <span class="hljs-string">&quot;tho&quot;</span>, <span class="hljs-string">&quot;though&quot;</span>);<br>    <span class="hljs-built_in">replace_with</span>(str, <span class="hljs-string">&quot;thru&quot;</span>, <span class="hljs-string">&quot;through&quot;</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="string的搜索操作"><a href="#string的搜索操作" class="headerlink" title="string的搜索操作"></a>string的搜索操作</h3><p>每个操作都接受一个可选的第二参数，表示从什么位置开始搜索</p>
<table>
<thead>
<tr>
<th>搜索操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.find(args)</code></td>
<td>查找<code>s</code>中<code>args</code>第一次出现的位置</td>
</tr>
<tr>
<td><code>s.rfind(args)</code></td>
<td>查找<code>s</code>中<code>args</code>最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_of(args)</code></td>
<td>在<code>s</code>中查找<code>args</code>中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_last_of(args)</code></td>
<td>在<code>s</code>中查找<code>args</code>中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>在<code>s</code>中查找第一个不在<code>args</code>中的字符</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>在<code>s</code>中查找最后一个不在<code>args</code>中的字符</td>
</tr>
</tbody></table>
<p>每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。如果搜索失败则返回一个名为<code>string::npos</code>的<code>static</code>成员（类型是<code>string::size_type</code>，初始化值是-1，npos是一个无符号类型，也就是<code>string</code>最大的可能大小）</p>
<h3 id="string的比较操作"><a href="#string的比较操作" class="headerlink" title="string的比较操作"></a>string的比较操作</h3><table>
<thead>
<tr>
<th>参数形式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>s2</code></td>
<td>比较<code>s</code>和<code>s2</code></td>
</tr>
<tr>
<td><code>pos1, n1, s2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td>
</tr>
<tr>
<td><code>pos1, n1, s2, pos2, n2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td>
</tr>
<tr>
<td><code>cp</code></td>
<td>比较<code>s</code>和<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td><code>pos1, n1, cp</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td><code>pos1, n1, cp, n2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的地址开始<code>n2</code>个字符</td>
</tr>
</tbody></table>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><code>to_string(val)</code>  一组重载函数，返回数值<code>val</code>的<code>string</code>表示。<code>val</code>可以使任何算术类型。对每个浮点类型和<code>int</code>或更大的整型，都有相应版本的<code>to_string()</code>。和往常一样，小整型会被提升。</p>
<p><code>stoi(s, p, b)</code>  返回<code>s</code>起始子串（表示整数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0，即函数不保存下标。<code>b</code>是转换所用的基数，默认是10。返回<code>int</code></p>
<p>要转换为数值的string中第一个非空表字符必须是数值中可能出现的字符</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string s2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pi = 3.14&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">d</span> <span class="hljs-operator">=</span> stod(s2.substr(s2.find_first_of(<span class="hljs-string">&quot;+-.0123456789&quot;</span>)))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>适配器是使一事物的行为类似于另一事物的行为的一种机制。函数、容器和迭代器都有适配器</p>
<p>三个顺序容器适配器：stack、queue和priority_queue</p>
<p>默认下，stack和queue是基于deque实现的，priority_queue是基于vector实现的，可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，实现对默认容器类型的重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>,&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; stk;<br></code></pre></td></tr></table></figure>

<p>stack需要实现后进先出，即<code>push_back</code>和<code>pop_back</code>的操作，则可以使用<code>vector</code>和<code>deque</code>实现，而不可以用<code>forward_list</code>构建</p>
<p>queue需要实现先进先出，即<code>push_back</code>和<code>pop_front</code>的操作，那么就不可以使用<code>vector</code>而可以使用<code>deque</code>和<code>list</code>构建</p>
<p>priority_queue需要有随机访问的能力，因此可使用<code>vector</code>和<code>deque</code>构建</p>
<p>对于每个容器适配器，只可以使用适配器操作，而不能使用底层容器类型的操作</p>
<h2 id="第十章——泛型算法"><a href="#第十章——泛型算法" class="headerlink" title="第十章——泛型算法"></a>第十章——泛型算法</h2><p>泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现</p>
<p>算法<strong>永远不会改变底层容器的大小</strong>。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素</p>
<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p> <code>accumulate</code>（在<code>numeric</code>中定义），接受三个参数，前两个指出需要求和的元素的范围，第三个是求和的初值。由于在string中定义了“+”运算符，则可以通过accumulate将string元素连接起来；如果传入一个字符串字面值给第三个参数，类型将是<code>const char *</code>，并没有“+”运算符，则会报错</p>
<p><code>find_first_of</code>，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的<code>end</code>迭代器。</p>
<p>对于只读取而不改变元素的算法，通常最好使用<code>cbegin</code>和<code>cend</code></p>
<p><code>equal</code>：确定两个序列是否保存相同的值，前两个表示第一个序列中的范围，第三个表示第二个序列的首元素。若在传入C风格字符串，则比较的是两个指针指向的地址</p>
<p>只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长</p>
<h3 id="写容器的算法"><a href="#写容器的算法" class="headerlink" title="写容器的算法"></a>写容器的算法</h3><p><code>fill</code>： <code>fill(vec.begin(), vec.end(), 0);</code> 将每个元素重置为0</p>
<p><code>fill_n</code>： <code>fill_n(vec.begin(), 10, 0);</code>将给定值赋予迭代器指向的元素开始的指定个元素，但要确保容器能容纳要写入的元素</p>
<p>插入迭代器<code>back_inserter</code>：</p>
<p>用来确保算法有足够的空间存储数据。<code>#include &lt;iterator&gt;</code></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vector&lt;<span class="hljs-built_in">int</span>&gt; vec;				<span class="hljs-comment">//空vector</span><br>auto it = back<span class="hljs-constructor">_inserter(<span class="hljs-params">vec</span>)</span>;	 <span class="hljs-comment">//创建插入迭代器</span><br>*it = <span class="hljs-number">42</span>;						<span class="hljs-comment">//添加一个元素</span><br>fill<span class="hljs-constructor">_n(<span class="hljs-params">back_inserter</span>(<span class="hljs-params">vec</span>)</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);  <span class="hljs-comment">//添加10个元素</span><br></code></pre></td></tr></table></figure>

<p>拷贝算法<code>copy</code>，前两个参数指定输入范围，第三个指向目标序列。传递给copy的目的序列至少要包含与输入序列一样多的元素，返回目的位置迭代器递增后的位置。可以用copy实现对内置数组的拷贝</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">int</span> <span class="hljs-built_in">a1</span>[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<span class="hljs-comment">;</span><br><span class="hljs-symbol">int</span> <span class="hljs-built_in">a2</span>[sizeof(<span class="hljs-built_in">a1</span>)/sizeof(*<span class="hljs-built_in">a1</span>)]<span class="hljs-comment">;</span><br><span class="hljs-symbol">auto</span> ret = copy(begin(<span class="hljs-built_in">a1</span>),<span class="hljs-meta">end</span>(<span class="hljs-built_in">a1</span>),<span class="hljs-built_in">a2</span>)<span class="hljs-comment">;</span><br><span class="hljs-comment">//ret指向拷贝到a2的尾元素之后的位置</span><br></code></pre></td></tr></table></figure>

<p>replace算法将输入序列中所有等于给定值的元素都改为另一个值</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">replace(<span class="hljs-name">ilst</span>.begin(),ilst.edn(),<span class="hljs-number">0</span>,<span class="hljs-number">42</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>上述语句将该序列中所有0替换成42，若希望原序列不变，则用replace_copy</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">replace<span class="hljs-constructor">_copy(<span class="hljs-params">ilst</span>.<span class="hljs-params">cbegin</span>()</span>,ilst.cend<span class="hljs-literal">()</span>,back<span class="hljs-constructor">_inserter(<span class="hljs-params">ivec</span>)</span>,<span class="hljs-number">0</span>,<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure>

<p>ivec包含ilst的一份拷贝，且将所有0换成42</p>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">sort</span>(<span class="hljs-keyword">words</span>.begin(),<span class="hljs-keyword">words</span>.<span class="hljs-keyword">end</span>())<span class="hljs-comment">;//只根据首字母排字典序</span><br>auto end_unique = unique(<span class="hljs-keyword">words</span>.begin(),<span class="hljs-keyword">words</span>.<span class="hljs-keyword">end</span>())<span class="hljs-comment">;//返回的是指向不重复区域之后第一个位置的迭代器</span><br><span class="hljs-keyword">words</span>.erase(end_unique,<span class="hljs-keyword">words</span>.<span class="hljs-keyword">end</span>())<span class="hljs-comment">;//要删除重复元素必须要用到容器操作</span><br></code></pre></td></tr></table></figure>

<h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>谓词是一个<strong>可调用的表达式</strong>，返回结果是一个能用作条件的值</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> is<span class="hljs-constructor">Shorter(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s1</span>,<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s2</span>)</span><br>&#123;<br>	return s1.size<span class="hljs-literal">()</span> &lt; s2.size<span class="hljs-literal">()</span>;<br>&#125;<br>sort(words.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>,words.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,isShorter);<span class="hljs-comment">//按照单词长短排序</span><br>stable<span class="hljs-constructor">_sort(<span class="hljs-params">words</span>.<span class="hljs-params">begin</span>()</span>,words.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,isShorter);<span class="hljs-comment">//单词长度相同的则会保持字典序</span><br></code></pre></td></tr></table></figure>

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>可以向一个算法传递任何类别的可调用对象，包括<strong>函数、函数指针、重载函数调用运算符的类和lambda表达式</strong></p>
<p><code>lambda</code>表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数</p>
<p><code>[capture list](parameter list) -&gt; return type &#123;function body&#125;</code></p>
<ul>
<li><p><code>capture list</code>捕获列表</p>
<p>不可忽略。为空时表明不使用它所在函数中的任何局部变量。捕获列表只用于局部非static变量，lambda可直接使用局部static变量和它所在函数之外声明的名字</p>
</li>
<li><p><code>return type</code>是返回类型。可忽略</p>
<p>如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void；当需要为一个lambda定义返回类型时，必须使用尾置返回类型</p>
</li>
<li><p><code>parameter</code>是参数列表。可忽略</p>
</li>
<li><p><code>function body</code>是函数体。不可忽略</p>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">stable<span class="hljs-constructor">_sort(<span class="hljs-params">words</span>.<span class="hljs-params">begin</span>()</span>,words.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,<span class="hljs-literal">[]</span>(const <span class="hljs-built_in">string</span>&amp;a, const <span class="hljs-built_in">string</span>&amp; b)&#123;return a.size<span class="hljs-literal">()</span>&lt;b.size<span class="hljs-literal">()</span>;&#125;);<br>auto wc = find<span class="hljs-constructor">_if(<span class="hljs-params">words</span>.<span class="hljs-params">begin</span>()</span>, words.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, <span class="hljs-literal">[<span class="hljs-identifier">sz</span>]</span>(const <span class="hljs-built_in">string</span> &amp;a)&#123;return a.size<span class="hljs-literal">()</span> &gt;= sz;&#125;);<br><span class="hljs-comment">//获取一个迭代器，指向第一个满足size&gt;=sz的元素</span><br><span class="hljs-keyword">for</span><span class="hljs-constructor">_each(<span class="hljs-params">wc</span>, <span class="hljs-params">words</span>.<span class="hljs-params">end</span>()</span>, <span class="hljs-literal">[]</span>(const <span class="hljs-built_in">string</span> &amp;s)&#123;cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;)<br></code></pre></td></tr></table></figure>

<p>使用partition算法</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lisp">auto pivot = partition(<span class="hljs-name">vs</span>.begin(), vs.end(), [sz](<span class="hljs-name">const</span> std:<span class="hljs-symbol">:string</span> <span class="hljs-symbol">&amp;s</span>)&#123;<br>        return s.size() &gt;= sz<span class="hljs-comment">;&#125;);//相当于排序好，符合谓词的元素排在前，返回最后一个符合谓词元素的后一个位置迭代器</span><br><br>for(<span class="hljs-name">auto</span> it = vs.cbegin()<span class="hljs-comment">; it != pivot; ++it)</span><br>    std:<span class="hljs-symbol">:cout</span> &lt;&lt; *it &lt;&lt; &quot; &quot;;<br></code></pre></td></tr></table></figure>

<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>定义<code>lambda</code>时会生成一个新的类类型和该类型的一个对象</p>
<p>当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的</p>
<p>隐式捕获：&amp;告诉编译器采用捕获引用方式，&#x3D;则表示值捕获方式</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">wc = find_if(<span class="hljs-built_in">words</span>.begin(), <span class="hljs-built_in">words</span>.<span class="hljs-keyword">end</span>(), [=](const <span class="hljs-built_in">string</span> &amp;a)&#123;<span class="hljs-literal">return</span> a.size() &gt;= sz;&#125;);<br></code></pre></td></tr></table></figure>

<p>混合使用隐式捕获和显式捕获时，捕获列表第一个元素必须是一个&amp;或&#x3D;，显式捕获的变量必须使用与隐式捕获不同的方式，即如果隐式捕获采用引用方式（&amp;），则显式捕获命名变量必须采用值方式。</p>
<h3 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变lambda</h3><p>如果希望能改变一个<strong>被捕获的变量</strong>的值（不改变原来的值），就必须在<strong>参数列表首</strong>加上<code>mutable</code></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">size_t <span class="hljs-built_in">v1</span> = <span class="hljs-number">42</span>;<br>auto f = [<span class="hljs-built_in">v1</span>] () mutable &#123;return ++<span class="hljs-built_in">v1</span><span class="hljs-comment">;&#125;;</span><br><span class="hljs-built_in">v1</span> = <span class="hljs-number">0</span>;<br>auto <span class="hljs-keyword">j </span>= f()<span class="hljs-comment">; //j为43</span><br></code></pre></td></tr></table></figure>

<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>标准库bind函数，定义在头文件<code>functional</code>中，可以看做为一个通用的函数适配器。接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表</p>
<p><code>auto newCallable = bind(callable, arg_list);</code></p>
<p><code>arg_list</code>中的参数可能包含形如<code>_n</code>的名字，其中n是一个整数，这些是占位符。<code>_n</code>代表第n个位置的参数。定义在<code>placeholders</code>的命名空间中。<code>using std::placeholder::_1;</code>或<code>using namespace std::placeholders;</code>使得由<code>placeholders</code>定义的所有名字都可用</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> check<span class="hljs-constructor">_size(<span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">s</span>, <span class="hljs-params">string</span>::<span class="hljs-params">size_type</span> <span class="hljs-params">sz</span>)</span><br>&#123;<br>	return s.size<span class="hljs-literal">()</span> &gt;= sz;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>想要将这个函数作为<code>find_if</code>（接受一个一元谓词）的参数，则可以绑定<code>check_size</code>的sz参数</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">auto</span> check6 = bind(check_size,_1,<span class="hljs-number">6</span>);<br><br><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">bool</span> b1 = check6(s);	<span class="hljs-comment">//相当于调用check_size(s,6);</span><br></code></pre></td></tr></table></figure>

<p><code>auto g = bind(f, a, b, _2, c, _1);</code>，调用<code>g(_1, _2)</code>实际上调用<code>f(a, b, _2, c, _1)</code></p>
<p>非占位符的参数要使用引用传参，必须使用标准库<code>ref</code>函数或者<code>cref</code>函数</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">ostream &amp;<span class="hljs-built_in">print</span>(ostream &amp;<span class="hljs-built_in">os</span>,const <span class="hljs-built_in">string</span> &amp;s,<span class="hljs-built_in">char</span> c)<br>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">os</span> &lt;&lt; s &lt;&lt; c; <br>&#125;<br>for_each(words.begin(),words.<span class="hljs-keyword">end</span>(),bind(<span class="hljs-built_in">print</span>,ref(<span class="hljs-built_in">os</span>),_1,<span class="hljs-string">&#x27; &#x27;</span>));<br></code></pre></td></tr></table></figure>

<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素</p>
<ul>
<li><code>back_inserter</code>：创建一个使用<code>push_back</code>的迭代器。</li>
<li><code>front_inserter</code>创建一个使用<code>push_front</code>的迭代器。元素总是插入到容器的第一个元素之前</li>
<li><code>inserter</code>创建一个使用<code>insert</code>的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被查到迭代器所指向的元素<strong>之前</strong></li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">list</span>&lt;int&gt; lst = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-attribute">list</span>&lt;int&gt; lst2,lst3;<br><span class="hljs-attribute">copy</span>(lst.begin(),lst.end(),front_inserter(lst2));		//生成&#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">copy</span>(lst.begin(),lst.end(),inserter(lst3,lst.begin()));	//生成&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure>

<p><code>front_inserter</code>生成的迭代器会将插入的元素序列的顺序颠倒过来，而<code>inserter</code>和<code>back_inserter</code>则不会</p>
<h3 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h3><p>迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl">istream_iterator &lt;<span class="hljs-keyword">int</span>&gt; in_iter(cin);	<span class="hljs-regexp">//</span>从cin读入<span class="hljs-keyword">int</span><br>istream_iteraator &lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">eof</span>;			<span class="hljs-regexp">//</span>尾后迭代器<br><span class="hljs-keyword">while</span>(in_iter!=<span class="hljs-keyword">eof</span>)<br>&#123;<br>	vec.push_back(*in_iter++);<br>&#125;<br>//另一种方式<br>vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">vec</span>(in_iter,<span class="hljs-keyword">eof</span>);<br></code></pre></td></tr></table></figure>

<p>ostream_iterator提供可选第二参数，是一个C风格字符串，每各元素输出后都打印此字符串</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">ostream_iterator&lt;int&gt; out_iter(cout,<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-keyword">for</span>(auto <span class="hljs-keyword">e</span>:<span class="hljs-keyword">vec</span>)<br><span class="hljs-comment">	*out_iter+= = e;</span><br>cout &lt;&lt; endl;<br><span class="hljs-comment">//另一种方式</span><br><span class="hljs-keyword">copy</span>(<span class="hljs-keyword">vec</span>.begin(),<span class="hljs-keyword">vec</span>.end(),out_iter);<br></code></pre></td></tr></table></figure>

<p>其中解引用和递增运算可以忽略，不产生作用。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>递增一个反向迭代器会移动到前一个元素</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">string line = <span class="hljs-string">&quot;first,second,third&quot;</span>;<br><span class="hljs-keyword">auto</span> comma = <span class="hljs-built_in">find</span>(line.<span class="hljs-built_in">cbegin</span>(),line.<span class="hljs-built_in">cend</span>(),<span class="hljs-string">&#x27;,&#x27;</span>);		<span class="hljs-comment">//comma指向第一个逗号</span><br><span class="hljs-keyword">auto</span> rcomma = <span class="hljs-built_in">find</span>(line.<span class="hljs-built_in">crbegin</span>(),line.<span class="hljs-built_in">crend</span>(),<span class="hljs-string">&#x27;,&#x27;</span>);	<span class="hljs-comment">//rcomma指向的是最后一个逗号</span><br></code></pre></td></tr></table></figure>

<p>当需要打印出第一个和最后一个单词时</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">cout &lt;&lt; <span class="hljs-built_in">string</span>(line.cbegin(),comma);<br>cout &lt;&lt; <span class="hljs-built_in">string</span>(line.rcbegin(),rcomma);<span class="hljs-comment">//这里打印出来的单词逆序打印</span><br>cout &lt;&lt; <span class="hljs-built_in">string</span>(rcomma.base(),line<span class="hljs-selector-class">.rcend</span>());<span class="hljs-comment">//正序打印最后一个单词</span><br></code></pre></td></tr></table></figure>

<h3 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h3><p>对于<code>list</code>和<code>forward_list</code>，优先使用成员函数版本的算法而不是通用算法</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>lst.merge(lst2)</code></td>
<td>将来自<code>lst2</code>的元素合并入<code>lst</code>，二者都必须是有序的，元素将从<code>lst2</code>中删除。</td>
</tr>
<tr>
<td><code>lst.merge(lst2, comp)</code></td>
<td>同上，给定比较操作。</td>
</tr>
<tr>
<td><code>lst.remove(val)</code></td>
<td>调用<code>erase</code>删除掉与给定值相等(&#x3D;&#x3D;)的每个元素</td>
</tr>
<tr>
<td><code>lst.remove_if(pred)</code></td>
<td>调用<code>erase</code>删除掉令一元谓词为真的每个元素</td>
</tr>
<tr>
<td><code>lst.reverse()</code></td>
<td>反转<code>lst</code>中元素的顺序</td>
</tr>
<tr>
<td><code>lst.sort()</code></td>
<td>使用<code>&lt;</code>排序元素</td>
</tr>
<tr>
<td><code>lst.sort(comp)</code></td>
<td>使用给定比较操作排序元素</td>
</tr>
<tr>
<td><code>lst.unique()</code></td>
<td>调用<code>erase</code>删除同一个值的连续拷贝。使用<code>==</code>。</td>
</tr>
<tr>
<td><code>lst.unique(pred)</code></td>
<td>调用<code>erase</code>删除同一个值的连续拷贝。使用给定的二元谓词。</td>
</tr>
</tbody></table>
<p><strong>list和forward_list的splice成员函数版本的参数</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>(p, lst2)</code></td>
<td><code>p</code>是一个指向<code>lst</code>中元素的迭代器，或者一个指向<code>flst</code>首前位置的迭代器。函数将<code>lst2</code>中的所有元素移动到<code>lst</code>中<code>p</code>之前的位置或是<code>flst</code>中<code>p</code>之后的位置。将元素从<code>lst2</code>中删除。<code>lst2</code>的类型必须和<code>lst</code>相同，而且不能是同一个链表。</td>
</tr>
<tr>
<td><code>(p, lst2, p2)</code></td>
<td>同上，<code>p2</code>是一个指向<code>lst2</code>中位置的有效的迭代器，将<code>p2</code>指向的元素移动到<code>lst</code>中，或将<code>p2</code>之后的元素移动到<code>flst</code>中。<code>lst2</code>可以是于<code>lst</code>或<code>flst</code>相同的链表。</td>
</tr>
<tr>
<td><code>(p, lst2, b, e)</code></td>
<td><code>b</code>和<code>e</code>表示<code>lst2</code>中的合法范围。将给定范围中的元素从<code>lst2</code>移动到<code>lst</code>或<code>first</code>中。<code>lst2</code>与<code>lst</code>可以使相同的链表，但<code>p</code>不能指向给定范围中的元素。</td>
</tr>
</tbody></table>
<ul>
<li>使用<code>lst.splice(args)</code>或<code>flst.splice_after(args)</code></li>
</ul>
<p>链表特有版本与通用版本的区别在于链表版本会改变底层的容器</p>
<h2 id="第十一章——关联容器"><a href="#第十一章——关联容器" class="headerlink" title="第十一章——关联容器"></a>第十一章——关联容器</h2><p>关联容器中的元素时按照<strong>关键字</strong>来保存和访问的，支持通过关键字来高效地查找和读取元素</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器，关键字类型必须定义元素比较的方法。默认是<code>&lt;</code></p>
<p>对于自定义类型，如果想传递一个比较的函数，所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>（小于等于），可以这样定义，提供关键字类型（Sales_data）以及比较操作类型（函数指针类型）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareIsbn</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;lhs, <span class="hljs-type">const</span> Sales_data &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() &lt; rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br><span class="hljs-comment">//1.</span><br><span class="hljs-function">multiset&lt;Sales_data, <span class="hljs-title">decltype</span><span class="hljs-params">(compareIsbn)</span>*&gt; <span class="hljs-title">bookstore</span><span class="hljs-params">(compareIsbn)</span></span>;<br><span class="hljs-comment">//2.</span><br><span class="hljs-built_in">bool</span> (*pf) (<span class="hljs-type">const</span> Sales_data &amp;,<span class="hljs-type">const</span> Sales_data &amp;) = &amp;compareIsbn;<span class="hljs-comment">//&amp;可忽略</span><br><span class="hljs-function">multiset&lt;Sales_data, pf&gt; <span class="hljs-title">bookstore</span><span class="hljs-params">(pf)</span></span>;<br><span class="hljs-comment">//3.</span><br><span class="hljs-keyword">using</span> pf = <span class="hljs-built_in">bool</span> (*) (<span class="hljs-type">const</span> Sales_data &amp;,<span class="hljs-type">const</span> Sales_data &amp;);<br><span class="hljs-function">multiset&lt;Sales_data, pf&gt; <span class="hljs-title">bookstore</span><span class="hljs-params">(pf)</span></span>;<br></code></pre></td></tr></table></figure>

<p>用<code>compareIsbn</code>来初始化<code>bookstore</code>对象，表明在向对象添加元素时，将调用<code>compareIsbn</code>函数来进行排序。且可以代替<code>&amp;compareIsbn</code>，当使用一个函数名字时，会自动转换成指针类型</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>在<code>utility</code>头文件中定义</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>pair&lt;T1, T2&gt; p;</code></td>
<td><code>p</code>是一个<code>pair</code>，两个类型分别是<code>T1</code>和<code>T2</code>的成员都进行了值初始化。</td>
</tr>
<tr>
<td><code>pair&lt;T1, T2&gt; p(v1, v2);</code></td>
<td><code>first</code>和<code>second</code>分别用<code>v1</code>和<code>v2</code>进行初始化。</td>
</tr>
<tr>
<td><code>pair&lt;T1, T2&gt;p = &#123;v1, v2&#125;;</code></td>
<td>等价于&#96;p(v1, v2)</td>
</tr>
<tr>
<td><code>make_pair(v1, v2);</code></td>
<td><code>pair</code>的类型从<code>v1</code>和<code>v2</code>的类型推断出来。</td>
</tr>
</tbody></table>
<p>当函数需要返回一个pair时，可以直接对返回值进行列表初始化</p>
<p><code>return &#123;v.back(),v.back().size()&#125;;</code></p>
<h3 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h3><table>
<thead>
<tr>
<th>类型别名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>key_type</code></td>
<td>此容器类型的关键字类型</td>
</tr>
<tr>
<td><code>mapped_type</code></td>
<td>每个关键字关联的类型，只适用于<code>map</code></td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>对于<code>map</code>，是<code>pair&lt;const key_type, mapped_type&gt;</code>; 对于<code>set</code>，和<code>key_type</code>相同。</td>
</tr>
</tbody></table>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>解引用一个关联容器迭代器时，<strong>会得到一个类型为容器的<code>value_type</code>的值的引用</strong></p>
<p>虽然set定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种类型都只允许只读访问</p>
<p>遍历<code>map</code>、<code>multimap</code>、<code>set</code>、<code>multiset</code>时，迭代器按<strong>关键字升序</strong>遍历元素</p>
<p>使用关联容器定义的专用算法会比泛型算法快很多</p>
<table>
<thead>
<tr>
<th><code>insert</code>操作</th>
<th>关联容器</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.insert(v)</code>  <code>c.emplace(args)</code></td>
<td><code>v</code>是<code>value_type</code>类型的对象；<code>args</code>用来构造一个元素。 对于<code>map</code>和<code>set</code>，只有元素的关键字不存在<code>c</code>中才插入或构造元素。函数返回一个<code>pair</code>，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的<code>bool</code>值。对于<code>multimap</code>和<code>multiset</code>则会插入范围中的每个元素。</td>
</tr>
<tr>
<td><code>c.insert(b, e)</code> <code>c.insert(il)</code></td>
<td><code>b</code>和<code>e</code>是迭代器，表示一个<code>c::value_type</code>类型值的范围；<code>il</code>是这种值的花括号列表。函数返回<code>void</code>。对于 <code>map</code>和<code>set</code>，只插入关键字不在<code>c</code>中的元素。</td>
</tr>
<tr>
<td><code>c.insert(p, v)</code>  <code>c.emplace(p, args)</code></td>
<td>类似<code>insert(v)</code>，但将迭代器<code>p</code>作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。</td>
</tr>
</tbody></table>
<p>向<code>map</code>添加元素：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">word_count.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-type">word</span>, <span class="hljs-number">1</span>&#125;);<br>word_count.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-type">word</span>, <span class="hljs-number">1</span>));<br>word_count.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">size_t</span>&gt;(<span class="hljs-type">word</span>, <span class="hljs-number">1</span>));<br>`word_count.<span class="hljs-built_in">insert</span>(map&lt;string, <span class="hljs-type">size_t</span>&gt;::<span class="hljs-built_in">value_type</span> (<span class="hljs-type">word</span>, <span class="hljs-number">1</span>));`<br></code></pre></td></tr></table></figure>

<p>以上四种添加方式等价</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">while</span> (cin &gt;&gt; word)<br>	++word_count.<span class="hljs-built_in">insert</span>(&#123;word, <span class="hljs-number">0</span>&#125;).<span class="hljs-built_in">first</span>-&gt;<span class="hljs-built_in">second</span>;<br></code></pre></td></tr></table></figure>

<p>这条语句等价于</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">while</span> (cin &gt;&gt; word)<br>&#123;<br>	auto result = word_count.<span class="hljs-built_in">insert</span>(&#123;word, <span class="hljs-number">0</span>&#125;);<br>	++(result.<span class="hljs-built_in">first</span>-&gt;<span class="hljs-built_in">second</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>insert</code>成功时，返回指向该元素位置的迭代器，并对其值加一操作，即<code>insert</code>一个<code>&#123;word，1&#125;;</code></p>
<p><code>insert</code>失败时，返回的是指向map容器中已有的该元素位置的迭代器，并对其值加一操作</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.erase(k)</code></td>
<td>从<code>c</code>中删除每个关键字为<code>k</code>的元素。返回一个<code>size_type</code>值，指出删除的元素的数量。</td>
</tr>
<tr>
<td><code>c.erase(p)</code></td>
<td>从<code>c</code>中删除迭代器<code>p</code>指定的元素。<code>p</code>必须指向<code>c</code>中一个真实元素，不能等于<code>c.end()</code>。返回一个指向<code>p</code>之后元素的迭代器，若<code>p</code>指向<code>c</code>中的尾元素，则返回<code>c.end()</code></td>
</tr>
<tr>
<td><code>c.erase(b, e)</code></td>
<td>删除迭代器对<code>b</code>和<code>e</code>所表示范围中的元素。返回<code>e</code>。</td>
</tr>
</tbody></table>
<h3 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h3><p>只有**<code>map</code>和<code>unordered_map（非const）</code>有下标运算符和对应的at函数**，set类型不支持下标，<code>multimap</code>或<code>unordered_multimap</code>可能有多个值与关键字相关联，也不支持下标操作</p>
<p>如果使用下标操作时，关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化</p>
<h3 id="访问查找元素"><a href="#访问查找元素" class="headerlink" title="访问查找元素"></a>访问查找元素</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>c.find(k)</code></td>
<td>返回一个迭代器，指向第一个关键字为<code>k</code>的元素，若<code>k</code>不在容器中，则返回尾后迭代器</td>
</tr>
<tr>
<td><code>c.count(k)</code></td>
<td>返回关键字等于<code>k</code>的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1。</td>
</tr>
<tr>
<td><code>c.lower_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>不小于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.upper_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>大于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.equal_range(k)</code></td>
<td>返回一个迭代器<code>pair</code>，表示关键字等于<code>k</code>的元素的范围。若<code>k</code>不存在，<code>pair</code>的两个成员均等于<code>c.end()</code>。</td>
</tr>
</tbody></table>
<p><code>lower_bound</code>和<code>upper_bound</code>不适用于无序容器</p>
<h3 id="打印作者的所有著作"><a href="#打印作者的所有著作" class="headerlink" title="打印作者的所有著作"></a>打印作者的所有著作</h3><p>使用find和count函数</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">string search_item(<span class="hljs-string">&quot;Kevin&quot;</span>);<span class="hljs-comment">//要查找的作者</span><br>auto entries = authors.<span class="hljs-built_in">count</span>(search_item);<br>auto iter = authors.<span class="hljs-built_in">find</span>(search_item);<br><span class="hljs-keyword">while</span>(entries)<br>&#123;<br>	cout &lt;&lt; iter-&gt;<span class="hljs-built_in">second</span> &lt;&lt; endl;<br>    ++iter;<br>    --entries;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用<code>lower_bound</code>和<code>upper_bound</code></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">for</span>(auto beg = authors.lower<span class="hljs-constructor">_bound(<span class="hljs-params">search_item</span>)</span>;beg!=authors.upper<span class="hljs-constructor">_bound(<span class="hljs-params">search_item</span>)</span>;beg++)<br>	cout &lt;&lt; beg-&gt;second &lt;&lt; endl;<br><span class="hljs-comment">//lower_bound 返回的是第一个等于查找值的迭代器，upper_bound 返回的是最后一个等于查找值的后一个元素的迭代器</span><br></code></pre></td></tr></table></figure>

<p>使用<code>equal_range</code></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span>(auto pos = authors.equal_range(search_item);pos.<span class="hljs-built_in">first</span>!=pos.<span class="hljs-built_in">second</span>;++pos.<span class="hljs-built_in">first</span>)<br>	cout &lt;&lt; pos.<span class="hljs-built_in">first</span>-&gt;<span class="hljs-built_in">second</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h3 id="单词转换程序？？？"><a href="#单词转换程序？？？" class="headerlink" title="单词转换程序？？？"></a>单词转换程序？？？</h3><p>here is the link to [istringistream](# istringstream)</p>
<p>通过读取map_file文件获得单词转换规则，在读入input文件过程中将根据映射返回转换后的内容，即打印出来</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript">map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; <span class="hljs-title function_">buildMap</span>(<span class="hljs-params">ifstream &amp;map_file</span>)<br>&#123;<br>	<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; <span class="hljs-title function_">transform</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">const</span> map&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; &amp;m</span>)<br>&#123;<br><br>&#125;<br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">word_transform</span>(<span class="hljs-params">ifstream &amp;map_file,ifstream &amp;input</span>)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h3><p>有序容器使用比较运算符来组织元素；无序容器使用哈希函数和关键字类型的<code>==</code>运算符</p>
<p>无序容器在存储上组织为一组桶(bucket)，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>桶接口</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.bucket_count()</code></td>
<td>正在使用的桶的数目</td>
</tr>
<tr>
<td><code>c.max_bucket_count()</code></td>
<td>容器能容纳的最多的桶的数目</td>
</tr>
<tr>
<td><code>c.bucket_size(n)</code></td>
<td>第<code>n</code>个桶中有多少个元素</td>
</tr>
<tr>
<td><code>c.bucket(k)</code></td>
<td>关键字为<code>k</code>的元素在哪个桶中</td>
</tr>
<tr>
<td><strong>桶迭代</strong></td>
<td></td>
</tr>
<tr>
<td><code>local_iterator</code></td>
<td>可以用来访问桶中元素的迭代器类型</td>
</tr>
<tr>
<td><code>const_local_iterator</code></td>
<td>桶迭代器的<code>const</code>版本</td>
</tr>
<tr>
<td><code>c.begin(n)</code>，<code>c.end(n)</code></td>
<td>桶<code>n</code>的首元素迭代器</td>
</tr>
<tr>
<td><code>c.cbegin(n)</code>，<code>c.cend(n)</code></td>
<td>与前两个函数类似，但返回<code>const_local_iterator</code>。</td>
</tr>
<tr>
<td><strong>哈希策略</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.load_factor()</code></td>
<td>每个桶的平均元素数量，返回<code>float</code>值。</td>
</tr>
<tr>
<td><code>c.max_load_factor()</code></td>
<td><code>c</code>试图维护的平均比桶大小，返回<code>float</code>值。<code>c</code>会在需要时添加新的桶，以使得<code>load_factor&lt;=max_load_factor</code></td>
</tr>
<tr>
<td><code>c.rehash(n)</code></td>
<td>重组存储，使得<code>bucket_count&gt;=n</code>，且<code>bucket_count&gt;size/max_load_factor</code></td>
</tr>
<tr>
<td><code>c.reverse(n)</code></td>
<td>重组存储，使得<code>c</code>可以保存<code>n</code>个元素且不必<code>rehash</code>。</td>
</tr>
</tbody></table>
<p>无序容器的性能依赖于哈希函数的质量和桶的数量和大小</p>
<h3 id="无序类型对关键字类型的要求"><a href="#无序类型对关键字类型的要求" class="headerlink" title="无序类型对关键字类型的要求"></a>无序类型对关键字类型的要求</h3><p>不能直接定义关键字类型为自定义类类型的无序容器，需要提供自定义的哈希值函数以及提供函数替代<code>==</code>运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">hasher</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;sd)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;string&gt;() (sd.<span class="hljs-built_in">isbn</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eqOp</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;lhs,<span class="hljs-type">const</span> Sales_data &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br><span class="hljs-comment">//使用重载的哈希值计算函数和比较函数来定义无序容器</span><br><span class="hljs-keyword">using</span> SD_multiset = unordered_multiset&lt;Sales_data,<span class="hljs-keyword">decltype</span>(hasher)*,<span class="hljs-keyword">decltype</span>(eqOp)*&gt;;<br><span class="hljs-function">SD_multiset <span class="hljs-title">bookstore</span><span class="hljs-params">(<span class="hljs-number">42</span>,hasher,eqOp)</span></span>;<br></code></pre></td></tr></table></figure>

<h2 id="第十二章——动态内存"><a href="#第十二章——动态内存" class="headerlink" title="第十二章——动态内存"></a>第十二章——动态内存</h2><ul>
<li><strong>静态内存</strong>用来保存局部<code>static</code>对象、类<code>static</code>对象、定义在任何函数之外的变量（全局）。</li>
<li><strong>栈内存</strong>用来保存定义在函数内的非<code>static</code>对象（局部）。</li>
<li><strong>堆内存</strong>，又称自由空间，用来存储<strong>动态分配</strong>的对象，即在程序运行时分配的对象，需要显式地销毁</li>
</ul>
<p>动态内存管理通过<code>new</code>为对象分配空间并返回一个指向该对象的指针，通过<code>delete</code>接收一个动态对象的指针，销毁对象并释放内存。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><strong>shared_ptr和unique_ptr都支持的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>shared_ptr&lt;T&gt; sp</code>  <code>unique_ptr&lt;T&gt; up</code></td>
<td>空智能指针，可以指向类型是<code>T</code>的对象</td>
</tr>
<tr>
<td><code>p</code></td>
<td>将<code>p</code>用作一个条件判断，若<code>p</code>指向一个对象，则为<code>true</code></td>
</tr>
<tr>
<td><code>*p</code></td>
<td>解引用<code>p</code>，获得它指向的对象。</td>
</tr>
<tr>
<td><code>p-&gt;mem</code></td>
<td>等价于<code>(*p).mem</code></td>
</tr>
<tr>
<td><code>p.get()</code></td>
<td>返回<code>p</code>中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。</td>
</tr>
<tr>
<td><code>swap(p, q)</code> <code>p.swap(q)</code></td>
<td>交换<code>p</code>和<code>q</code>中的指针</td>
</tr>
</tbody></table>
<p><strong>shared_ptr独有的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>make_shared&lt;T&gt;(args)</code></td>
<td>返回一个<code>shared_ptr</code>，指向一个动态分配的类型为<code>T</code>的对象。使用<code>args</code>初始化此对象。</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt;p(q)</code></td>
<td><code>p</code>是<code>shared_ptr q</code>的拷贝；此操作会<strong>递增</strong><code>q</code>中的计数器。<code>q</code>中的指针必须能转换为<code>T*</code></td>
</tr>
<tr>
<td><code>p = q</code></td>
<td><code>p</code>和<code>q</code>都是<code>shared_ptr</code>，所保存的指针必须能互相转换。此操作会<strong>递减</strong><code>p</code>的引用计数，<strong>递增</strong><code>q</code>的引用计数；若<code>p</code>的引用计数变为0，则将其管理的原内存释放。</td>
</tr>
<tr>
<td><code>p.unique()</code></td>
<td>若<code>p.use_count()</code>是1，返回<code>true</code>；否则返回<code>false</code></td>
</tr>
<tr>
<td><code>p.use_count()</code></td>
<td>返回与<code>p</code>共享对象的智能指针数量；可能很慢，主要用于调试。</td>
</tr>
</tbody></table>
<p><code>make_shared</code>用其参数来构造给定类型的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;5&#x27;</span>); <br></code></pre></td></tr></table></figure>

<p>每个<code>shared_ptr</code>都有一个关联的计数器，称为引用计数，记录有多少个<code>shared_ptr</code>指向相同的对象。当指向一个对象的最后一个<code>shared_ptr</code>被销毁时，会自动销毁此对象，即释放相关联的内存。</p>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>用new动态分配和初始化对象</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> *ps1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>;		<span class="hljs-comment">//默认初始化为空</span><br><span class="hljs-built_in">string</span> *ps2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>();		<span class="hljs-comment">//值初始化为空</span><br><span class="hljs-built_in">int</span> *pi1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>;				<span class="hljs-comment">//默认初始化，未定义</span><br><span class="hljs-built_in">int</span> *pi2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>();			<span class="hljs-comment">//值初始化为0，*pi2 为0</span><br></code></pre></td></tr></table></figure>

<p>对于内置类型来说，值初始化有定义的值，默认初始化的对象的值则是未定义；对于定义了构造函数的类类型，都会通过默认构造函数来初始化</p>
<p>由于要用初始化器的类型来推断要分配的类型，只有当括号中有单一初始化器才可以使用auto</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">auto</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">auto</span>(obj);<br></code></pre></td></tr></table></figure>

<p>默认下，new不能分配所要求的内存空间，会抛出<code>bad_alloc</code>的异常，可以将<code>nothrow</code>传递给new阻止其抛出异常</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">int</span> *p1 = <span class="hljs-keyword">new</span> (<span class="hljs-keyword">nothrow</span>) <span class="hljs-keyword">int</span>;<br></code></pre></td></tr></table></figure>

<p><code>delete</code>要求必须指向<strong>动态分配的内存</strong>或者是一个<strong>空指针</strong></p>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>接受指针参数的智能指针构造函数是<code>explicit</code>的，不能将一个内置指针隐式转换成智能指针，只能直接初始化，即用new返回的指针来初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;<span class="hljs-type">int</span>&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1024</span>);<br><span class="hljs-comment">//错误，不能隐式转换,类似于函数传参</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">1024</span>))</span></span>;<br><span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure>

<p><strong>定义和改变shared_ptr的其他方法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>shared_ptr&lt;T&gt; p(q)</code></td>
<td><code>p</code>管理内置指针<code>q</code>所指向的对象；<code>q</code>必须指向<code>new</code>分配的内存，且能够转换为<code>T*</code>类型</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(u)</code></td>
<td><code>p</code>从<code>unique_ptr u</code>那里接管了对象的所有权；将<code>u</code>置为空</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(q, d)</code></td>
<td><code>p</code>接管了内置指针<code>q</code>所指向的对象的所有权。<code>q</code>必须能转换为<code>T*</code>类型。<code>p</code>将使用可调用对象<code>d</code>来代替<code>delete</code>。</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(p2, d)</code></td>
<td><code>p</code>是<code>shared_ptr p2</code>的拷贝，唯一的区别是<code>p</code>将可调用对象<code>d</code>来代替<code>delete</code>。</td>
</tr>
<tr>
<td><code>p.reset()</code></td>
<td>若<code>p</code>是唯一指向其对象的<code>shared_ptr</code>，<code>reset</code>会释放此对象。若传递了可选的参数内置指针<code>q</code>，会令<code>p</code>指向<code>q</code>，否则会将<code>p</code>置空。若还传递了参数<code>d</code>，则会调用<code>d</code>而不是<code>delete</code>来释放<code>q</code>。</td>
</tr>
<tr>
<td><code>p.reset(q)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>p.reset(q, d)</code></td>
<td>同上</td>
</tr>
</tbody></table>
<p>get函数返回一个<strong>内置指针</strong>，指向智能指针管理的对象。只有在确定代码不会delete指针的情况下才使用。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span>(!p.<span class="hljs-built_in">unique</span>())<br>	<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reset</span>(new <span class="hljs-built_in">int</span>(*p));<br><span class="hljs-comment">//如果不是唯一用户，则将一份拷贝到新内存上并使其成为唯一用户</span><br></code></pre></td></tr></table></figure>

<p>不使用get()初始化或reset另一个智能指针</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">process(<span class="hljs-name">shared_ptr&lt;int&gt;</span>(<span class="hljs-name">p</span>.get()))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><code>p.get()</code>返回内置指针，然后创建了新的临时<code>shared_ptr</code>智能指针，也是指向p指向的对象，但这是新的<code>shared_ptr</code>，此时计数值为1，当执行完该语句后，临时智能指针被销毁，所指向的内存也被释放，则原有的p指针成为空悬指针，再对p进行操作会出现错误</p>
<p><strong>只有<code>shared_ptr&lt;int&gt; p2(p)</code>，此时p2与p共同指向同一个对象，计数值为2</strong></p>
<h3 id="使用自己的释放操作"><a href="#使用自己的释放操作" class="headerlink" title="使用自己的释放操作"></a>使用自己的释放操作</h3><p>如果你使用智能指针管理的资源不是<code>new</code>分配的内存，记住传递给它一个删除器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">connection</span><br>&#123;<br>	std::string ip;<br>	<span class="hljs-type">int</span> port;<br>	<span class="hljs-built_in">connection</span>(std::string i, <span class="hljs-type">int</span> p) : <span class="hljs-built_in">ip</span>(i), <span class="hljs-built_in">port</span>(p) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">destination</span><br>&#123;<br>	std::string ip;<br>	<span class="hljs-type">int</span> port;<br>	<span class="hljs-built_in">destination</span>(std::string i, <span class="hljs-type">int</span> p) : <span class="hljs-built_in">ip</span>(i), <span class="hljs-built_in">port</span>(p) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function">connection <span class="hljs-title">connect</span><span class="hljs-params">(destination* pDest)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">std::shared_ptr&lt;connection&gt; <span class="hljs-title">pConn</span><span class="hljs-params">(<span class="hljs-keyword">new</span> connection(pDest-&gt;ip, pDest-&gt;port))</span></span>;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;creating connection(&quot;</span> &lt;&lt; pConn.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-keyword">return</span> *pConn;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(connection pConn)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;connection close(&quot;</span> &lt;&lt; pConn.ip &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; pConn.port &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;	<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">end_connection</span><span class="hljs-params">(connection* pConn)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">disconnect</span>(*pConn);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(destination &amp;d)</span></span><br><span class="hljs-function"></span>&#123;<br>	connection conn = <span class="hljs-built_in">connect</span>(&amp;d);<br>	<span class="hljs-function">std::shared_ptr&lt;connection&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;conn, end_connection)</span></span>;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;connecting now(&quot;</span> &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">destination <span class="hljs-title">dest</span><span class="hljs-params">(<span class="hljs-string">&quot;220.181.111.111&quot;</span>, <span class="hljs-number">10086</span>)</span></span>;<br>	<span class="hljs-built_in">f</span>(dest);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当p被销毁时，会调用删除器函数<code>end_connection</code>，即使发生异常，p同样会被销毁从而关闭连接</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>某一个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象，不支持拷贝或者赋值操作</p>
<p><strong>unique_ptr操作</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>unique_ptr&lt;T&gt; u1</code></td>
<td>空<code>unique_ptr</code>，可以指向类型是<code>T</code>的对象。<code>u1</code>会使用<code>delete</code>来是释放它的指针。</td>
</tr>
<tr>
<td><code>unique_ptr&lt;T, D&gt; u2</code></td>
<td><code>u2</code>会使用一个类型为<code>D</code>的可调用对象来释放它的指针。</td>
</tr>
<tr>
<td><code>unique_ptr&lt;T, D&gt; u(d)</code></td>
<td>空<code>unique_ptr</code>，指向类型为<code>T</code>的对象，用类型为<code>D</code>的对象<code>d</code>代替<code>delete</code></td>
</tr>
<tr>
<td><code>u = nullptr</code></td>
<td>释放<code>u</code>指向的对象，将<code>u</code>置为空。</td>
</tr>
<tr>
<td><code>u.release()</code></td>
<td><code>u</code>放弃对指针的控制权，返回指针，并将<code>u</code>置空。</td>
</tr>
<tr>
<td><code>u.reset()</code></td>
<td>释放<code>u</code>指向的对象</td>
</tr>
<tr>
<td><code>u.reset(q)</code></td>
<td>令<code>u</code>指向<code>q</code>指向的对象</td>
</tr>
<tr>
<td><code>u.reset(nullptr)</code></td>
<td>将<code>u</code>置空</td>
</tr>
</tbody></table>
<p>可以通过调用<code>release</code>或<code>reset</code>将指针的所有权转移给另一个<code>unique_ptr</code></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> (<span class="hljs-number">42</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1.release())</span></span>;<span class="hljs-comment">//release返回悬空指针</span><br>p2.<span class="hljs-built_in">reset</span>(p1.<span class="hljs-built_in">release</span>());<span class="hljs-comment">//reset释放掉原来的对象，并指向给定的指针，即p1指针release之后的指针，指向p1原来的对象</span><br></code></pre></td></tr></table></figure>

<p>可以拷贝或赋值一个将要被销毁的<code>unique_ptr</code>，即通过函数的返回值返回</p>
<p>与<code>shared_ptr</code>不同，<code>unique_ptr</code>管理删除器的方式必须在指向类型之后提供删除器类型（可调用对象）</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">unique_ptr</span>&lt;connection,decl<span class="hljs-keyword">type</span>(end_connection)*&gt; p(&amp;c,end_connection);<br></code></pre></td></tr></table></figure>

<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>weak_ptr&lt;T&gt; w</code></td>
<td>空<code>weak_ptr</code>可以指向类型为<code>T</code>的对象</td>
</tr>
<tr>
<td><code>weak_ptr&lt;T&gt; w(sp)</code></td>
<td>与<code>shared_ptr</code>指向相同对象的<code>weak_ptr</code>。<code>T</code>必须能转换为<code>sp</code>指向的类型。</td>
</tr>
<tr>
<td><code>w = p</code></td>
<td><code>p</code>可以是<code>shared_ptr</code>或一个<code>weak_ptr</code>。赋值后<code>w</code>和<code>p</code>共享对象。</td>
</tr>
<tr>
<td><code>w.reset()</code></td>
<td>将<code>w</code>置为空。</td>
</tr>
<tr>
<td><code>w.use_count()</code></td>
<td>与<code>w</code>共享对象的<code>shared_ptr</code>的数量。</td>
</tr>
<tr>
<td><code>w.expired()</code></td>
<td>若<code>w.use_count()</code>为0，返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td><code>w.lock()</code></td>
<td>如果<code>expired</code>为<code>true</code>，则返回一个空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code>。</td>
</tr>
</tbody></table>
<p>创建一个<code>weak_ptr</code>时，需要用<code>shared_ptr</code>来初始化它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-function">weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wk</span><span class="hljs-params">(p)</span></span>;<br></code></pre></td></tr></table></figure>

<p>wk和p指向相同的对象，但wk不影响p的引用计数。wk指向的对象可能会被释放掉</p>
<h3 id="StrBlob和StrBlobPtr程序"><a href="#StrBlob和StrBlobPtr程序" class="headerlink" title="StrBlob和StrBlobPtr程序"></a><strong>StrBlob和StrBlobPtr程序</strong></h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs scss">class StrBlobPtr;<br>class StrBlob&#123;<br>friend class StrBlobPtr;<br>public:<br>	string&amp; <span class="hljs-built_in">begin</span>();<br>	string&amp; <span class="hljs-built_in">end</span>();<br>	<br>	<span class="hljs-built_in">StrBlob</span>() : <span class="hljs-built_in">data</span>(make_shared&lt;vector&lt;string&gt;())&#123;&#125;<br>	<span class="hljs-built_in">StrBlob</span>(initializer_list&lt;string&gt; il) : <span class="hljs-built_in">data</span>(make_shared&lt;vector&lt;string&gt;(il)) &#123;&#125;<br>	<br>	vector&lt;string&gt;::size_type <span class="hljs-built_in">size</span>() const &#123;return data-&gt;size;&#125;<br>	bool <span class="hljs-built_in">empty</span>() const &#123;return data-&gt;<span class="hljs-built_in">empty</span>(&#125;<br>	<br>	string&amp; front() &#123;<span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>,&quot;no front&quot;);return data-&gt;<span class="hljs-built_in">front</span>();&#125;<br>	string&amp; <span class="hljs-built_in">back</span>() &#123;<span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>,&quot;no back&quot;);return data-&gt;<span class="hljs-built_in">back</span>();&#125;<br>	const string&amp; <span class="hljs-built_in">front</span>() const &#123;<span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>,&quot;no front&quot;);return data-&gt;<span class="hljs-built_in">front</span>();&#125;<br>	const string&amp; <span class="hljs-built_in">back</span>() const &#123;<span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>,&quot;no back&quot;);return data-&gt;<span class="hljs-built_in">back</span>();&#125;<br>	<br>	void <span class="hljs-built_in">push_back</span>(const string&amp; s) &#123;data-&gt;<span class="hljs-built_in">push_back</span>(s);&#125;<br>	void <span class="hljs-built_in">pop_back</span>() &#123;<span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>,&quot;no back to pop&quot;); data-&gt;<span class="hljs-built_in">pop_back</span>();&#125;<br>private:<br>	void <span class="hljs-built_in">check</span>(vector&lt;string&gt;::size_type t, const string&amp; msg) const<br>	&#123;<br>		<span class="hljs-built_in">if</span>(t &gt;= data-&gt;size())<br>			throw <span class="hljs-built_in">out_of_range</span>(msg);<br>	&#125;<br>	shared_ptr&lt;vector&lt;string&gt;&gt; data;<br>&#125;;<br><br>StrBlobPtr StrBlob::<span class="hljs-built_in">begin</span>()<br>&#123;<br>	return <span class="hljs-built_in">StrBlobPtr</span>(*this);<br>&#125;<br><br>StrBlobPtr StrBlob::<span class="hljs-built_in">end</span>()<br>&#123;<br>	return <span class="hljs-built_in">StrBlobPtr</span>(*this, data-&gt;size());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义<code>StrBlob</code>类，用<code>shared_ptr</code>存储数组，提供访问元素和始末迭代器接口，声明<code>friend</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrBlobPtr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">StrBlobPtr</span>(): <span class="hljs-built_in">cur</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>	<span class="hljs-built_in">StrBlobPtr</span>(StrBlob&amp; sb, size_type t = <span class="hljs-number">0</span>): <span class="hljs-built_in">wkptr</span>(sb.data),<span class="hljs-built_in">cur</span>(t) &#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> StrBlobPtr&amp; p) &#123; <span class="hljs-keyword">return</span> p.curr != curr; &#125;<br>	<span class="hljs-function">string&amp; <span class="hljs-title">deref</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-comment">//检查指针是否存在以及是否超出范围</span><br>		<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">check</span>(cur, <span class="hljs-string">&quot;dereference past end&quot;</span>);<br>		<span class="hljs-keyword">return</span> (*p)[cur];<br>	&#125;<br>	<br>	<span class="hljs-function">StrBlobPtr&amp; <span class="hljs-title">incr</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-comment">//检查是否超出范围，如果已经指向尾后迭代器则不能递增</span><br>		<span class="hljs-built_in">check</span>(cur, <span class="hljs-string">&quot;increase past end&quot;</span>);<br>		cur++;<br>		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	shared_ptr&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">check</span>(size_type t, <span class="hljs-type">const</span> string&amp; msg) <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">auto</span> p = wkptr.<span class="hljs-built_in">lock</span>();<br>		<span class="hljs-keyword">if</span>(!p)				<span class="hljs-comment">//如果p为空指针</span><br>			<span class="hljs-keyword">throw</span> <span class="hljs-built_in">runningtime_error</span>(<span class="hljs-string">&quot;unbound&quot;</span>);<br>		<span class="hljs-keyword">if</span>(i &gt;= p-&gt;<span class="hljs-built_in">size</span>())<br>			<span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(msg);<br>		<span class="hljs-keyword">return</span> p;<br>	&#125;<br>	<br>	weak_ptr&lt;vector&lt;string&gt;&gt; wkptr;<br>	vector&lt;string&gt;::size_type cur;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>核查指针类，定义一个<code>weak_ptr</code>与<code>StrBlob</code>共享存储数组，要么指向为空，要么指向<code>vector</code>，但不增加引用数</p>
<p><code>bool operator!=(const StrBlobPtr&amp; p) &#123; return p.curr != curr; &#125;</code>重载运算符<code>!=</code>判断两个指针类是否相等</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">int main()<br>&#123;<br>	ifstream ifs(<span class="hljs-string">&quot;books.txt&quot;</span>);<br>	StrBlob <span class="hljs-keyword">sb;</span><br><span class="hljs-keyword"></span>	string s;<br>	while (getline(ifs, s))<br>	&#123;<br>		<span class="hljs-keyword">sb.push_back(s);</span><br><span class="hljs-keyword"></span>	&#125;<br>	for (StrBlobPtr <span class="hljs-keyword">sbp </span>= <span class="hljs-keyword">sb.begin(); </span><span class="hljs-keyword">sbp </span>!= <span class="hljs-keyword">sb.end(); </span><span class="hljs-keyword">sbp.incr())</span><br><span class="hljs-keyword"></span>	&#123;<br>		cout &lt;&lt; <span class="hljs-keyword">sbp.deref() </span>&lt;&lt; endl;<br>	&#125;<br><br>	return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对两个类的使用，类似于指针与指针指向对象的操作</p>
<h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p><code>new</code>一个动态数组：类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量），返回<strong>指向第一个元素类型的指针</strong>，而不是数组类型</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];	<span class="hljs-comment">//未初始化</span><br><span class="hljs-type">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]();<span class="hljs-comment">//值初始化为0</span><br></code></pre></td></tr></table></figure>

<p>因为在值初始化的括号中未能提供初始化器，因此不能用auto</p>
<p>当用new分配一个大小为0的数组时，返回一个合法的非空指针，但不能解引用，类似于尾后迭代器</p>
<p><code>delete</code>一个动态数组：</p>
<p><code>delete [] p;</code></p>
<h3 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">unique_ptr&lt;<span class="hljs-keyword">int</span> []&gt; up(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]);<span class="hljs-comment">//up指向一个包含10个元素的未初始化数组</span><br></code></pre></td></tr></table></figure>

<p>指向数组的<code>unique_ptr</code>不支持成员访问运算符（点和箭头），可以用下标访问数组中的元素</p>
<p><code>shared_ptr</code>不直接支持管理动态数组，需要提供自定义的删除器，且<code>shared_ptr</code>未定义下标运算符，则需要通过get函数获取一个内置指针来访问数组元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>],[](<span class="hljs-type">int</span>*p)&#123;<span class="hljs-keyword">delete</span>[] p;&#125;)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)<br>&#123;<br>	*(sp.<span class="hljs-built_in">get</span>() + i) = i;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>定义在头文件<code>memory</code>中，将内存分配和对象构造分离开</p>
<p><strong>标准库allocator类及其算法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>allocator&lt;T&gt; a</code></td>
<td>定义了一个名为<code>a</code>的<code>allocator</code>对象，它可以为类型为<code>T</code>的对象分配内存</td>
</tr>
<tr>
<td><code>a.allocate(n)</code></td>
<td>分配一段原始的、未构造的内存，保存<code>n</code>个类型为<code>T</code>的对象。</td>
</tr>
<tr>
<td><code>a.deallocate(p, n)</code></td>
<td>释放从<code>T*</code>指针<code>p</code>中地址开始的内存，这块内存保存了<code>n</code>个类型为<code>T</code>的对象；<code>p</code>必须是一个先前由<code>allocate</code>返回的指针。且<code>n</code>必须是<code>p</code>创建时所要求的大小。在调用<code>deallocate</code>之前，用户必须对每个在这块内存中创建的对象调用<code>destroy</code>。</td>
</tr>
<tr>
<td><code>a.construct(p, args)</code></td>
<td><code>p</code>必须是一个类型是<code>T*</code>的指针，指向一块原始内存；<code>args</code>被传递给类型为<code>T</code>的构造函数，用来在<code>p</code>指向的内存中构造一个对象。</td>
</tr>
<tr>
<td><code>a.destroy(p)</code></td>
<td><code>p</code>为<code>T*</code>类型的指针，此算法对<code>p</code>指向的对象执行析构函数。</td>
</tr>
</tbody></table>
<p><strong>allocator伴随算法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>uninitialized_copy(b, e, b2)</code></td>
<td>从迭代器<code>b</code>和<code>e</code>给定的输入范围中拷贝元素到迭代器<code>b2</code>指定的未构造的原始内存中。<code>b2</code>指向的内存必须足够大，能够容纳输入序列中元素的拷贝。返回目的位置迭代器，指向最后一个构造的元素之后的位置</td>
</tr>
<tr>
<td><code>uninitialized_copy_n(b, n, b2)</code></td>
<td>从迭代器<code>b</code>指向的元素开始，拷贝<code>n</code>个元素到<code>b2</code>开始的内存中。</td>
</tr>
<tr>
<td><code>uninitialized_fill(b, e, t)</code></td>
<td>在迭代器<code>b</code>和<code>e</code>执行的原始内存范围中创建对象，对象的值均为<code>t</code>的拷贝。</td>
</tr>
<tr>
<td><code>uninitialized_fill_n(b, n, t)</code></td>
<td>从迭代器<code>b</code>指向的内存地址开始创建<code>n</code>个对象。<code>b</code>必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br>	allocator&lt;string&gt; alloc;<br>	<span class="hljs-keyword">auto</span> p = alloc.<span class="hljs-built_in">allocate</span>(n);<br>	string s;<br>	<span class="hljs-keyword">auto</span> q = p;<br>	<span class="hljs-keyword">while</span> (cin &gt;&gt; s &amp;&amp; q != p + n)<br>	&#123;<br>		alloc.<span class="hljs-built_in">construct</span>(q++, s);<br>	&#125;<br>	<span class="hljs-keyword">while</span> (q != p)<br>	&#123;<br>		std::cout &lt;&lt; *--q &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>		alloc.<span class="hljs-built_in">destroy</span>(q);<br>	&#125;<br>	alloc.<span class="hljs-built_in">deallocate</span>(p, n);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="文本查询程序"><a href="#文本查询程序" class="headerlink" title="文本查询程序"></a>文本查询程序</h1><ul>
<li>当程序读取输入文件时，需记住单词出现的每一行</li>
<li>输出需提取每个单词所关联的行号，行号升序出现且只出现一次，还要打印给定行号的文本</li>
</ul>
<p>对应地，</p>
<ul>
<li>将使用<code>istringstream</code>读取文件中的每一行，并拆分成逐个单词，再用<code>vector&lt;string&gt;</code>进行保存</li>
<li>用<code>map</code>保存与行号的映射，<code>set</code>保存一个单词对应的所有行号</li>
</ul>
<p>将上述定义为一个抽象的解决方案，定义一个保存输入文件的类<code>TextQuery</code>，包含<code>vector</code>和<code>map</code>，还有读取给定输入文件的构造函数和查询函数，查询函数返回单词出现次数，行号以及每行的文本；又将返回的结果定义成另一个类<code>QueryResult</code>，用来保存输出结果，包含一个<code>print</code>函数，完成结果的打印</p>
<p>显然，需要在两个类之间共享数据，如果只是将数据拷贝传输，则会浪费；如果是返回迭代器或指针，则可能会导致空悬指针；因此将用到<code>shared_ptr</code></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">void run(ifstream &amp;infile)<br>&#123;<br>	TextQuery t<span class="hljs-string">q(infile)</span>;<br>	<span class="hljs-keyword">while</span>(true)<br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;enter word to look for, or q to quit:&quot;</span>;<br>		string s;<br>		<span class="hljs-keyword">if</span>(!(cin &gt;&gt; s) || s == <span class="hljs-string">&#x27;q&#x27;</span>)	<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">print</span>(cout, tq.query(s)) &lt;&lt; endl;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用<code>infile</code>初始化<code>TextQuery</code>对象，构造函数读取输入文件，保存在成员变量<code>vector</code>中，并建立单词行号映射的<code>map</code></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueryResult</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextQuery</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">using</span> line_no = vector&lt;string&gt;::size_type;<br>	<span class="hljs-built_in">TextQuery</span>() = <span class="hljs-keyword">default</span>;<br>	<span class="hljs-built_in">TextQuery</span>(ifstream&amp; infile);<br>	<span class="hljs-function">QueryResult <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>	shared_ptr&lt;vector&lt;string&gt;&gt; file;<br>	map&lt;string,shared_ptr&lt;set&lt;line_no&gt;&gt;&gt; wm;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>考虑与<code>QueryResult</code>类对象共享数据的需求，<code>QueryResult</code>需要共享保存输入文件的<code>vector</code>，用于输入同行的文本；<code>QueryResult</code>还需要共享保存单词关联的行号的<code>set</code></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino">TextQuery::<span class="hljs-built_in">TextQuery</span>(ifstream&amp; infile): <span class="hljs-built_in">file</span>(<span class="hljs-keyword">new</span> vector&lt;string&gt;)<span class="hljs-comment">//file(make_shared&lt;vector&lt;string&gt;&gt;())</span><br>&#123;<br>	string text;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(infile,text))<br>	&#123;<br>		file-&gt;<span class="hljs-built_in">push_back</span>(text);<br>		<span class="hljs-type">int</span> n = file-&gt;<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>		<span class="hljs-function">istringstream <span class="hljs-title">line</span><span class="hljs-params">(text)</span></span>;<br>		string <span class="hljs-type">word</span>;<br>		<span class="hljs-keyword">while</span>(line &gt;&gt; <span class="hljs-type">word</span>)<br>		&#123;<br>			<span class="hljs-keyword">auto</span>&amp; lines = wm[<span class="hljs-type">word</span>];		<span class="hljs-comment">//返回的是shared_ptr指针</span><br>			<span class="hljs-keyword">if</span>(!lines)				   <span class="hljs-comment">//指针为空即第一次出现该单词，则新建一个</span><br>				lines.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> set&lt;line_no&gt;);<br>			lines-&gt;<span class="hljs-built_in">insert</span>(n);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>构造函数分配一个<code>vector</code>保存输入文件的文本。<code>getline</code>逐行读取文件并存入<code>vector</code>中，再用一个<code>istringstream</code>处理刚读入的一行中的每个单词，内层<code>while</code>用<code>istringstream</code>的输入运算符从当前行读取每个单词存入<code>word</code>中。当<code>map</code>中不存在<code>word</code>，即第一次出现该单词，下标运算符创建了一个<code>word</code>，返回一个空的智能指针，则再将指针<code>reset</code>，分配新的<code>set</code>，令其指向该<code>set</code>，再向<code>set</code>中插入行号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueryResult</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-title">print</span> <span class="hljs-params">(ostream&amp; os, <span class="hljs-type">const</span> QueryResult&amp; qr)</span></span>;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">QueryResult</span>(string s, shared_prt&lt;set&lt;TextQuery::line_no&gt;&gt; l, shared_ptr&lt;vector&lt;string&gt;&gt; p): <span class="hljs-built_in">sought</span>(s), <span class="hljs-built_in">file</span>(p), <span class="hljs-built_in">lines</span>(l) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>	string sought;								<span class="hljs-comment">//搜索的单词</span><br>	shared_ptr&lt;vector&lt;string&gt;&gt; file;			 <span class="hljs-comment">//输入文件</span><br>	shared_ptr&lt;set&lt;TextQuery::line_no&gt;&gt; lines;	  <span class="hljs-comment">//记录的行号</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>声明友元函数<code>print</code>，定义构造函数，将参数保存在数据成员中</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">QueryResult TextQuery::query(const <span class="hljs-built_in">string</span>&amp; s) const<br>&#123;<br>	<span class="hljs-comment">// static shared_ptr&lt;set&lt;line_no&gt;&gt; nodata(new set&lt;line_no&gt;);</span><br>	auto pos = wm.find(s);<br>	<span class="hljs-keyword">if</span>(pos<span class="hljs-operator"> == </span>wm.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>)		  <span class="hljs-comment">//找不到单词</span><br>		return <span class="hljs-constructor">QueryResult(<span class="hljs-params">s</span>,<span class="hljs-params">make_shared</span>&lt;<span class="hljs-params">set</span>&lt;<span class="hljs-params">line_no</span>&gt;&gt;()</span>,file);<br>		<span class="hljs-comment">//return QuertResult(s,nodata,file);</span><br>	<span class="hljs-keyword">else</span>					<span class="hljs-comment">//找到单词</span><br>		return <span class="hljs-constructor">QueryResult(<span class="hljs-params">s</span>, <span class="hljs-params">pos</span>-&gt;<span class="hljs-params">second</span>, <span class="hljs-params">file</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>query</code>函数接受一个单词，在<code>map</code>中定位其对应的行号，并构造一个<code>QueryResult</code>对象返回，包括<code>string, file, set</code>的<code>TextQuery</code>成员，并且共享着相同的数据</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">string</span> make<span class="hljs-constructor">_plural(<span class="hljs-params">size_t</span> <span class="hljs-params">ctr</span>, <span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">word</span>, <span class="hljs-params">const</span> <span class="hljs-params">string</span>&amp; <span class="hljs-params">ending</span>)</span><br>&#123;<br>	return (ctr &gt; <span class="hljs-number">1</span>) ? word + ending : word;<br>&#125;<br><br>ostream&amp; print(ostream&amp; os, const QueryResult&amp; qr)<br>&#123;<br>	os &lt;&lt; qr.sought &lt;&lt; <span class="hljs-string">&quot;occurs &quot;</span> &lt;&lt; qr.lines-&gt;size<span class="hljs-literal">()</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>		&lt;&lt; make<span class="hljs-constructor">_plural(<span class="hljs-params">qr</span>.<span class="hljs-params">lines</span>-&gt;<span class="hljs-params">size</span>()</span>, <span class="hljs-string">&quot;times&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>) &lt;&lt; endl;<br>	<span class="hljs-keyword">for</span>(auto num : *qr.lines)<br>	&#123;<br>		os &lt;&lt; <span class="hljs-string">&quot;\t(line&quot;</span> &lt;&lt; num + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;)&quot;</span><br>		&lt;&lt; *(qr.file-&gt;<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span> + num) &lt;&lt; endl;<br>	&#125;<br>	return os;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>qr.lines</code>是指向记录的行号的智能指针，需要先解引用或者用<code>-&gt;</code>运算符，范围for循环中解引用得到的<code>num</code>是取出<code>set</code>的每一个行号，对应类型为<code>set&lt;TextQuery::line_no&gt;&gt;::size_type</code>，而<code>qr.file</code>指向记录文本的数组，用<code>qr.file-&gt;begin()+num</code>则指向对应<code>num</code>行号的文本，同样，解引用即可获得整行文本。另外，程序能正确处理未找到单词的情况，只打印第一条输出语句，次数为0不进入范围for循环</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/notes/" class="print-no-link">#notes</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C3P阅读笔记</div>
      <div>https://kevin346-sc.github.io/2022/10/18/C3P阅读笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Kevin Huang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/05/LeetCode%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/" title="LeetCode回溯算法章节">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode回溯算法章节</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/15/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AB%A0%E8%8A%82/" title="LeetCode贪心算法章节">
                        <span class="hidden-mobile">LeetCode贪心算法章节</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
