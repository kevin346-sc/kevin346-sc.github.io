<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kevin346-sc.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="c++">
<meta property="og:type" content="website">
<meta property="og:title" content="Serein’s Blog">
<meta property="og:url" content="https://kevin346-sc.github.io/index.html">
<meta property="og:site_name" content="Serein’s Blog">
<meta property="og:description" content="c++">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kevin Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kevin346-sc.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Serein’s Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Serein’s Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kevin Huang</p>
  <div class="site-description" itemprop="description">c++</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/24/create_blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/24/create_blog/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-24 11:31:13" itemprop="dateCreated datePublished" datetime="2023-04-24T11:31:13+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-29 19:58:38" itemprop="dateModified" datetime="2022-11-29T19:58:38+08:00">2022-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="hexo-github部署个人博客"><a href="#hexo-github部署个人博客" class="headerlink" title="hexo+github部署个人博客"></a>hexo+github部署个人博客</h1><h2 id="环境与软件需求"><a href="#环境与软件需求" class="headerlink" title="环境与软件需求"></a>环境与软件需求</h2><ul>
<li>win10</li>
<li>git<br><em><strong>本教程需要先安装好git</strong></em><br><em><strong>本教程需要先安装好git</strong></em><br><em><strong>本教程需要先安装好git</strong></em></li>
</ul>
<ol>
<li><p>在<a target="_blank" rel="noopener" href="http://nodejs.org/">node.js官网</a>下载对应版本</p>
<p><img src="/create_blog/node_js.png" alt="nodejs"></p>
</li>
<li><p>安装完成后打开Git Bash.exe，输入<code>node -v</code>可查看node.js安装版本，输入<code>npm -v</code>可查看npm安装版本</p>
<p><img src="/create_blog/-v.png" alt="查看版本"></p>
</li>
<li><p>利用npm安装cnpm，同时使用镜像源</p>
<p><code>npm install -g cnpm --registry=https://registry.nmp.taobao.org</code></p>
</li>
<li><p>同样地，可以输入<code>cnpm</code>查看cnpm版本</p>
</li>
<li><p>这时，就可利用cnpm安装hexo，输入<code>cnpm install -g hexo-cli</code></p>
<p><img src="/create_blog/hexo.png" alt="hexo"></p>
</li>
<li><p>至此，创建博客前序步骤全部完成，在bash中指定一个路径，输入<code>mkdir </code>+文件夹名称，如blog，作为博客的根目录，进入该目录路径（有关博客操作都要在博客的根目录下进行），输入<code>hexo init</code>即完成博客的初始化。此时，输入<code>hexo s</code>即可通过<a href="localhost:4000">localhost:4000</a>对博客进行访问</p>
</li>
<li><p>在github中新建一个仓库待用，仓库名字通常为github名.github.io</p>
</li>
<li><p>安装git部署插件，输入<code>npm install hexo-deployer-git --save</code>，每次新建一个blog都要安装一次插件</p>
</li>
<li><p>更改配置文件（很多时候都会用到配置文件），输入<code>vim _config.yml</code>，先输入<code>i</code>使改为<code>insert</code>模式，找到<code>Deployment</code>进行配置修改，修改成如下</p>
<p><img src="/create_blog/deployment.png" alt="deployment"></p>
<p>即修改<code>type</code>属性为<code>git</code>，在<code>repo</code>下输入在github新建仓库的地址，并加上<code>branch:master</code>指定分支为master，然后即可退出vim，按下esc再按两次大写Z</p>
</li>
<li><p>此时即可对博客进行在github上的部署，在输入<code>hexo d</code>之前需要先输入<code>git config --global user.email &quot;18khhuang2@stu.edu.cn&quot;</code>和<code>git config --global user.name &quot;kevin346-sc&quot;</code>进行认证，否则将会无法进行远端部署</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-24 10:49:36" itemprop="dateCreated datePublished" datetime="2023-04-24T10:49:36+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-29 19:48:16" itemprop="dateModified" datetime="2022-11-29T19:48:16+08:00">2022-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/19/collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/19/collection/" class="post-title-link" itemprop="url">collection</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-19 11:23:27 / 修改时间：16:16:30" itemprop="dateCreated datePublished" datetime="2023-04-19T11:23:27+08:00">2023-04-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/11/Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/Nginx/" class="post-title-link" itemprop="url">Nginx</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-11 16:41:59" itemprop="dateCreated datePublished" datetime="2023-04-11T16:41:59+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-13 15:34:00" itemprop="dateModified" datetime="2023-04-13T15:34:00+08:00">2023-04-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="在Ubuntu18中使用Nginx"><a href="#在Ubuntu18中使用Nginx" class="headerlink" title="在Ubuntu18中使用Nginx"></a>在Ubuntu18中使用Nginx</h1><p>准备Nginx所需的库</p>
<ol>
<li><p>GCC编译器</p>
<p>Nginx不直接提供二进制可执行程序</p>
</li>
<li><p>PCRE库</p>
<p><code>sudo apt-get install libpcre3-dev</code></p>
<p>安装完成后用 <code>pcre-config --version</code>查看是否安装成功</p>
<img src="C:\myblog\source\_posts\Nginx\pcre.png" style="zoom: 50%;" />
</li>
<li><p>zlib库</p>
<p><code>zlib</code>库主要用于对HTTP包的内容进行压缩，进而减少网络传输量</p>
<p><code>sudo apt install zlib1g</code></p>
<img src="C:\myblog\source\_posts\Nginx\zlib1g.png" style="zoom: 80%;" />

<p><code>zlib</code>是直接使用的库，<code>zlib-devel</code>是二次开发所需要的库</p>
<p><code>sudo apt install zlib1g-dev</code></p>
<img src="C:\myblog\source\_posts\Nginx\zlib1g-dev.png" style="zoom: 80%;" />
</li>
<li><p>OpenSSL开发库</p>
<p>通过OpenSSL库，可以使用SSL协议传输HTTP，另外，使用MD5、SHA1等散列函数也需要该库</p>
<p>在Ubuntu系统中，<code>openssl-devel</code>库需要分开来安装</p>
<p><code>sudo apt-get install openssl</code></p>
<p><code>sudo apt-get install libssl-dev</code></p>
<img src="C:\myblog\source\_posts\Nginx\openssl.png" style="zoom: 50%;" /></li>
</ol>
<h1 id="在centos-7-中使用Nginx"><a href="#在centos-7-中使用Nginx" class="headerlink" title="在centos 7 中使用Nginx"></a>在centos 7 中使用Nginx</h1><h2 id="安装所需要的库"><a href="#安装所需要的库" class="headerlink" title="安装所需要的库"></a>安装所需要的库</h2><ol>
<li><p>gcc 和 g++</p>
<p><code>yum installl -y gcc</code></p>
<p><img src="C:\myblog\source_posts\Nginx\gcc_c.png"></p>
<p><code>yum install -y gcc-c++</code></p>
<p><img src="C:\myblog\source_posts\Nginx\g++_c.png"></p>
</li>
<li><p>pcre</p>
<p><code>yum install -y pcre pcre-devel</code></p>
<img src="C:\myblog\source\_posts\Nginx\pcre.png" style="zoom: 50%;" />
</li>
<li><p>zlib</p>
<p><code>yum install -y zlib zlib-devel</code></p>
<img src="C:\myblog\source\_posts\Nginx\pcre.png" style="zoom: 50%;" />
</li>
<li><p>openssl</p>
<p><code>yum install -y openssl openssl-devel</code></p>
<p><img src="C:\myblog\source_posts\Nginx\openssl_c.png"></p>
</li>
</ol>
<h2 id="让centos7实现联网"><a href="#让centos7实现联网" class="headerlink" title="让centos7实现联网"></a>让centos7实现联网</h2><p>默认情况下是不联网，而我们通常需要赋予静态IP让虚拟机联网</p>
<p>centos 系统默认没有<code>ifconfig</code>命令，需要先下载<code>yum install -y  net-tools.x86_64</code>或者使用<code>ip addr</code>命令，关注<code>ens33</code></p>
<ol>
<li><p>修改ens33的配置文件</p>
<p><code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p><img src="C:\myblog\source_posts\Nginx\ens33.png"></p>
<p>将<code>BOOTPROTO</code>由原来的dhcp改为static，表明使用静态IP地址，将<code>ONBOOT</code>由原来的no改为yes，启动网络连接，再给出IP地址、子网掩码、网关和DNS服务器。以上DNS服务器是免费的</p>
</li>
<li><p>重启网络服务</p>
<p><code>systemctl restart network</code></p>
</li>
<li><p>输入<code>ip addr</code>命令可以看到网络配置完成，可以通过<code>ping www.baidu.com</code>进行测试，完成联网</p>
</li>
</ol>
<h2 id="编译Nginx源码"><a href="#编译Nginx源码" class="headerlink" title="编译Nginx源码"></a>编译Nginx源码</h2><p>上一步中联网的目的是获取虚拟机的IP地址，通过xshell以及xftp连接进行Nginx源码的传输</p>
<p>准备好以下的目录</p>
<ol>
<li>Nginx源码的存放目录，存放Nginx源码文件，非官方的模块源代码文件</li>
<li>编译阶段产生的中间文件存放目录，默认情况下编译过程中自动生成objs目录，存放在源码目录下</li>
<li>部署目录，存放实际Nginx运行所需要的二进制文件、配置文件，默认情况下为 <code>/usr/local/nginx</code></li>
<li>日志文件存放目录</li>
</ol>
<p>默认情况下，linux内核参数考虑最通用的场景，不符合用于高并发访问的web服务器的定义，所以通过修改内核参数，使得Nginx拥有更高性能</p>
<p>修改<code>/etc/sysctl.conf</code>来更改内核参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fs .file-max = 999999</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.ip_local_port_range = 1024		61000</span><br><span class="line">net.ipv4.tcp_rmem = 4096 32768 262142</span><br><span class="line">net.ipv4.tcp_wmem = 4096 32768 262142</span><br><span class="line">net.core.netdev_max_backlog = 8096</span><br><span class="line">net.core.rmem_default = 262144</span><br><span class="line">net.core.wmem_default = 262144</span><br><span class="line">net.core.rmem_max = 2097152</span><br><span class="line">net.core.wmem_max = 2097152</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_syn.backlog=1024</span><br></pre></td></tr></table></figure>

<p>然后执行<code>sysctl -p</code>命令，使上述修改生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">file-max: 这个参数表示进程 (比如一个 worker 进程) 可以同时打开的最大句柄数这个参数直接限制最大并发连接数，需根据实际情况配置。</span><br><span class="line">tcp_tw_reuse: 这个参数设置为 1，表示允许将 TIME-WAIT 状态的 socket 重新用于新的 TCP 连接，这对于服务器来说很有意义，因为服务器上总会有大量 TIME-WAIT 状态的连接</span><br><span class="line">tcp_keepalive_time: 这个参数表示当 keepalive 启用时，TCP 发送 keepalive 消息的频度。默认是 2 小时，若将其设置得小一些，可以更快地清理无效的连接。</span><br><span class="line">tcp_fin_timeout:这个参数表示当服务器主动关闭连接时，socket 保持在 FIN-WAIT-2状态的最大时间。</span><br><span class="line">tcp_max_tw_buckets: 这个参数表示操作系统允许 TIME WAIT 套接字数量的最大值如果超过这个数字，TIME WAIT 套接字将立刻被清除并打印警告信息。该参数默认为 180 000，过多的 TIME WAIT 套接字会使 Web 服务器变慢。</span><br><span class="line">tcp_max_syn_backlog: 这个参数表示 TCP 三次握手建立阶段接收 SYN 请求队列的最大长度，默认为 1024，将其设置得大一些可以使出现 Nginx 繁忙来不及 accept 新连接的情况时，Linux 不至于丢失客户端发起的连接请求。</span><br><span class="line">ip_local_port_range:这个参数定义了在 UDP 和TCP 连接中本地 (不括连接的远端)端口的取值范围。</span><br><span class="line">net.ipv4.tcp_rmem : 这个参数定义了 TCP 接收缓存 (用于 TCP 接收滑动窗口)的最小值、默认值、最大值。</span><br><span class="line">net.ipv4.tcp_wmem: 这个参数定义了 TCP 发送缓存 (用于 TCP 发送滑动窗口)的最小值、默认值、最大值。</span><br><span class="line">netdev_max_backlog: 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。这个参数表示该队列的最大值。</span><br><span class="line">rmem_default: 这个参数表示内核套接字接收缓存区默认的大小。</span><br><span class="line">wmem_default: 这个参数表示内核套接字发送缓存区默认的大小</span><br><span class="line">rmem_max: 这个参数表示内核套接字接收缓存区的最大大小。</span><br><span class="line">wmem_max: 这个参数表示内核套接字发送缓存区的最大大小。</span><br><span class="line">tcp_syncookies：该参数与性能无关，用于解决 TCP 的 SYN 攻击</span><br></pre></td></tr></table></figure>

<p>进入到Nginx源码目录，执行以下3行命令：</p>
<p><code>./configure</code>——检测操作系统内核和已经安装的软件，参数的解析，中间目录的生成以及根据各种参数生成一些 C 源码文件、Makefile 文件等</p>
<p><code>make</code>——根据 configure 命令生成的 Makefile 文件编译Nginx 工程，并生成目标文件最终的二进制文件</p>
<p><code>make install</code>——根据configure 执行时的参数将Nginx 部署到指定的安装目录，包括相关目录的建立和二进制文件、配置文件的复制</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/03/12/webserver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/12/webserver/" class="post-title-link" itemprop="url">webserver</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-12 08:45:41" itemprop="dateCreated datePublished" datetime="2023-03-12T08:45:41+08:00">2023-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-20 20:29:48" itemprop="dateModified" datetime="2023-04-20T20:29:48+08:00">2023-04-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="webserver高性能服务器"><a href="#webserver高性能服务器" class="headerlink" title="webserver高性能服务器"></a>webserver高性能服务器</h1><p>系统：Linux</p>
<p>发行版：Ubuntu18</p>
<p>涉及知识点：</p>
<p>软件：VMware Station、Visual Studio Code、Xshell、Xftp</p>
<p>linux发行版中，有两个主流，CentOs和Ubuntu，分别是基于红帽企业和Debian，Ubuntu需要经常更新，用到.deb和apt软件包；而CentOS不常更新，使用.rpm和flatpak软件包。这说明了CentOS会更稳定。在此项目中，因为Ubuntu有一个庞大的社区，有更多的文档和免费的问题信息支持，并且Ubuntu上手更为简单，因此选择的发行版为Ubuntu18</p>
<h1 id="0、搭建linux虚拟机开发环境"><a href="#0、搭建linux虚拟机开发环境" class="headerlink" title="0、搭建linux虚拟机开发环境"></a>0、搭建linux虚拟机开发环境</h1><h2 id="Ubuntu-18安装"><a href="#Ubuntu-18安装" class="headerlink" title="Ubuntu 18安装"></a>Ubuntu 18安装</h2><p>下载Ubuntu18光驱，在VMware Station中创建Ubuntu 64位虚拟机并导入光驱进行安装，推荐安装VMware Tools，能够自适应虚拟机屏幕大小和实现在主机拖拽文件到虚拟机中等功能。</p>
<p>终端安装ssh，输入<code>sudo apt install openssh-server</code></p>
<p>[报错]暂时不能解析域名“sercurity.ubuntu.com”——这是因为虚拟机没有连上网，可以打开虚拟机设置选择桥接模式，并勾上复制物理网络连接状态（复习桥接模式和NAT）<img src="C:\myblog\source\_posts\webserver\ubuntu_net.png" style="zoom:60%;" /></p>
<p>为连接虚拟机，需要获取虚拟机的IP地址，在终端输入<code>sudo apt install net-tools</code>安装<code>net-tools</code>后即可通过<code>ifconfig</code>命令获取IP地址</p>
<p>[报错]没有可安装的候选——执行<code>sudo apt install net-tools</code>之后再次安装即可</p>
<h2 id="用xshell连接虚拟机"><a href="#用xshell连接虚拟机" class="headerlink" title="用xshell连接虚拟机"></a>用xshell连接虚拟机</h2><p>复制虚拟机的IP地址，在xshell中新建会话，填写会话名称和主机号（虚拟机IP地址），协议选择ssh，其余默认即可</p>
<img src="C:\myblog\source\_posts\webserver\ssh_new.png" style="zoom:60%;" />

<p>输入用户名，密码就可以连接上</p>
<h2 id="在vscode中连接虚拟机"><a href="#在vscode中连接虚拟机" class="headerlink" title="在vscode中连接虚拟机"></a>在vscode中连接虚拟机</h2><p>在扩展中下载remote development，可以看到左侧栏多出的“远程资源管理器”图标，进入远程资源管理器，选择ssh并打开ssh配置文件，填写正确参数</p>
<img src="C:\myblog\source\_posts\webserver\vscode_config.png" style="zoom: 80%;" />

<p>之后，能看到左侧ssh栏下有对应的主机连接信息，选择再新窗口中打开，输入密码就能在vscode实现对虚拟机的操作</p>
<h1 id="linux-系统编程入门"><a href="#linux-系统编程入门" class="headerlink" title="linux 系统编程入门"></a>linux 系统编程入门</h1><h2 id="静态库创建和使用"><a href="#静态库创建和使用" class="headerlink" title="静态库创建和使用"></a>静态库创建和使用</h2><ol>
<li><code>gcc -c *.c</code>编译生成<code>.o</code>类型文件</li>
<li><code>ar rcs libxxx.a *.o</code>利用ar工具将<code>.o</code>文件生成名为xxx的静态库，其中，<code>lib</code>和<code>.a</code>为固定命名</li>
</ol>
<p>编译<code>main.c</code>文件时，需要包含函数声明的头文件，以及函数定义的静态库文件 </p>
<p>文件结构如下时，</p>
<p><img src="C:\myblog\source_posts\webserver\stat_tree.png"></p>
<p><code>gcc -o app main.c -I ./include -l calc -L ./lib</code>生成 可执行文件<code>app</code></p>
<h2 id="动态库创建和使用"><a href="#动态库创建和使用" class="headerlink" title="动态库创建和使用"></a>动态库创建和使用</h2><ol>
<li><code>gcc -fpic -c *.c </code>编译生成与位置无关的<code>.o</code>文件</li>
<li><code>gcc -shared *.o -o libxxx.so</code>生成名为xxx的动态库，其中，<code>lib</code>和<code>.so</code>为固定命名</li>
</ol>
<p>在dynamic文件夹下生成动态库文件如下：</p>
<p><img src="C:\myblog\source_posts\webserver\dyna_tree.png"></p>
<p>在使用动态库时，如果直接像静态库那样使用，则在运行生成的可执行文件<code>app</code>时会报错</p>
<p><img src="C:\myblog\source_posts\webserver\dyna_bug.png"></p>
<p>使用<code>ldd(list dynamic dependencies)</code>命令查看动态库的依赖关系</p>
<p><img src="C:\myblog\source_posts\webserver\dyna_ldd.png"></p>
<p>可以看到，最终生成的可执行文件不能运行的原因在于其对应的动态库<code>libcalc.so</code>缺失</p>
<p>而文件在定位共享库时，对应ELF格式的可执行程序，先后搜索 DT_RPATH段 -&gt; 环境变量LD_LIBRARY_PATH -&gt; &#x2F;etc&#x2F;ld.so.cache 文件列表 -&gt; &#x2F;lib&#x2F;, &#x2F;usr&#x2F;lib 目录找到库文件后将其载入内存</p>
<p>因此，第一种方法可以在环境变量中加入动态库路径</p>
<p><img src="C:\myblog\source_posts\webserver\dyna_PATH.png"></p>
<p><strong>但环境变量在每次关闭终端后都会恢复到打开终端之前</strong></p>
<p>第二种方法则可以在用户级别下配置文件 <code>~/.bashrc</code> 中保存该环境变量</p>
<p><code>vim .bashrc</code>敲入<code>shift+g</code>移动到最后一行，敲入<code>o</code>在下一行中插入编辑</p>
<p>输入相同的<code>export</code>语句，保存并退出，<code>. .bashrc</code>或<code>source .bashrc</code>重新运行配置文件使其生效</p>
<p>第三种方法在系统级别下配置文件 <code>/etc/profile</code> 中加入同样的<code>export</code>语句</p>
<p><img src="C:\myblog\source_posts\webserver\dyna_lddok.png"></p>
<p>以上是通过环境变量来找到路径</p>
<p>另外，还可以修改<code>/etc/ld.so.cache </code>文件，<code>sudo vim /etc/ld.so.conf</code>在文件中加入路径，间接修改<code>.cache</code>文件，保存退出，<code>sudo ldconfig</code>进行更新</p>
<p>最后，不推荐将动态库文件放到 <code>/lib/</code>,<code>/usr/lib/</code>目录中，因为这两个目录下有很多文件，可能会有重复命名问题</p>
<h2 id="静态库vs动态库"><a href="#静态库vs动态库" class="headerlink" title="静态库vs动态库"></a>静态库vs动态库</h2><p>静态库</p>
<ul>
<li>加载速度快</li>
<li>程序发布不需要提供静态库，移植方便</li>
<li>但浪费内存</li>
<li>不利于更新部署</li>
</ul>
<p>动态库</p>
<ul>
<li>实现进程间资源共享</li>
<li>更新部署简单</li>
<li>何时加载可控</li>
<li>但加载速度慢</li>
<li>程序发布需要提供动态库</li>
</ul>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>目标 ： 依赖</p>
<p>​		(tab)命令</p>
<p>其他规则通常为第一条规则服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app : sub.c add.c mult.c div.c main.c</span><br><span class="line">	gcc sub.c add.c mult.c div.c main.c -o app</span><br></pre></td></tr></table></figure>

<p>依赖存在，则执行命令；否则向下检查其他规则，寻找生成依赖的命令</p>
<p>依赖生成时间比目标晚，则需要执行命令对目标进行更新</p>
<p>变量定义：变量名&#x3D;变量值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AR : 归档维护程序的名称，默认值为 ar</span><br><span class="line">CC : C 编译器的名称，默认值为 cc</span><br><span class="line">CXX : C++ 编译器的名称，默认值为 g++</span><br><span class="line">$@ : 目标的完整名称</span><br><span class="line">$&lt; : 第一个依赖文件的名称</span><br><span class="line">$^ : 所有的依赖文件</span><br><span class="line"></span><br><span class="line">%.o : %.c 匹配同一个字符串</span><br><span class="line"></span><br><span class="line">$(wildcard ./*.c ./PATH/*.c)</span><br><span class="line">返回 a.c b.c c.c</span><br><span class="line">src=$(wildcard ./*.c)</span><br><span class="line"></span><br><span class="line">$(patsubst %.c %.o a.c b.c)</span><br><span class="line">返回替换a.c, b.c 后的字符串 a.o, b.o</span><br><span class="line">objs=$(patsubst %.c, %.o, $(src))</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">	rm $(objs) -f</span><br></pre></td></tr></table></figure>



<h2 id="GDB调试工具"><a href="#GDB调试工具" class="headerlink" title="GDB调试工具"></a>GDB调试工具</h2><p>gcc -g -Wall a.c -o test</p>
<p>-g作用是在可执行文件中加入源代码信息，-wall打开所有warning</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">list/l (行号)</span><br><span class="line">list/l (文件名:函数名)</span><br><span class="line">show list</span><br><span class="line">set list (要显示的行数大小)</span><br><span class="line">set args (给程序输入的参数1) (给程序输入的参数2)</span><br><span class="line">show args</span><br><span class="line">b (行号)</span><br><span class="line">b (文件名:函数名)</span><br><span class="line">b (行号) if (条件)</span><br><span class="line">i b</span><br><span class="line">d (断点编号)</span><br><span class="line">dis (断点编号)</span><br><span class="line">ena (断点编号)</span><br><span class="line">run  ——遇到断点才停</span><br><span class="line">start ——停在第一行</span><br><span class="line">c ——到下一个断点</span><br><span class="line">n ——下一行(不进入函数体)</span><br><span class="line">s ——下一步(进入函数体)</span><br><span class="line">finish ——调出函数体</span><br><span class="line">p (变量名) ——打印变量值</span><br><span class="line">ptype (变量名) ——打印变量类型</span><br><span class="line">display (变量名) ——自动打印变量名</span><br><span class="line">undisplay(变量名) ——取消自动打印</span><br><span class="line">i display ——显示自动打印信息</span><br><span class="line">set var (变量名)=(变量值)</span><br></pre></td></tr></table></figure>



<h2 id="I-x2F-O函数"><a href="#I-x2F-O函数" class="headerlink" title="I&#x2F;O函数"></a>I&#x2F;O函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/* open 函数</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">	- flags: O_RDONLY, O_WRONLY, O_RDWR, O_CREAT...</span><br><span class="line">	- mode: 八进制，最终文件权限值为 mode &amp; ~umask, umask 默认 0002， 也可以使用宏，如 S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*read 函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">	从fd指向的文件中读取 count字节，存到buf中</span><br><span class="line">	返回-1则读取失败，0则表示读取到文件末尾，否则返回读取到的字节数</span><br><span class="line">size_t and ssize_t are,  respectively,  unsigned  and  signed</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*write 函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">	将buf中的count字节写入到文件fd中</span><br><span class="line">	返回写入的字节数，有可能小于count，因为写入空间不够。-1或0则写入失败</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*lseek 函数</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">	改变文件 fd 中的读写指针位置</span><br><span class="line">	- whence 可选参数 </span><br><span class="line">		宏定义 SEEK_SET, 文件开始位置</span><br><span class="line">		SEEK_CUR, 文件指针当前位置</span><br><span class="line">		SEEK_END, 文件结束位置</span><br><span class="line">	返回从文件开头开始的指针位置，-1则报错，并将报错记录在perrno中</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*stat 函数</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int stat(const char *pathname, struct stat *statbuf);</span><br><span class="line">	获取文件信息，记录在statbuf当中</span><br><span class="line">- struct stat &#123;</span><br><span class="line">              dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">              ino_t     st_ino;         /* Inode number */</span><br><span class="line">              mode_t    st_mode;        /* File type and mode */</span><br><span class="line">              nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">              uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">              gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">              dev_t     st_rdev;        /* Device ID (if special file) */</span><br><span class="line">              off_t     st_size;        /* Total size, in bytes */</span><br><span class="line">              blksize_t st_blksize;     /* Block size for filesystem I/O */</span><br><span class="line">              blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line">              time_t	 st_atime;		/* Time of last access */</span><br><span class="line">              time_t	 st_mtime;		/* Time of last modification */</span><br><span class="line">              time_t	 st_ctime;		/* Time of last status change */</span><br><span class="line">          &#125;;</span><br><span class="line">- 返回0则成功，否则返回-1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>其中，st_mode 变量如下：</p>
<p>setGID - 设置组id，setUID - 设置用户id，Sticky - 粘住位</p>
<p><img src="C:\myblog\source_posts\webserver\st_mode.png" alt="st_mode"></p>
<p>根据文件类型位，与相应位的宏定义 相与 运算即可，</p>
<p><img src="C:\myblog\source_posts\webserver\fileytpe.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*lstat 函数</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/stat.h&gt;</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int lstat(const char *pathname, struct stat *statbuf);</span><br><span class="line">    	stat函数如果传入的是软连接，则返回链接文件信息而非链接指向的文件，而lstat函数返回链接指向文件的信息</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*access 函数</span><br><span class="line"> #include&lt;unistd.h&gt;</span><br><span class="line"> int access(const char * pathname, int mode)</span><br><span class="line"> 	判断文件的权限或是否存在</span><br><span class="line"> 	-mode, R_OK, W_OK, X_OK, F_OK</span><br><span class="line"> 	成功返回0，否则返回-1</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*chmod 函数</span><br><span class="line">	#include &lt;sys/stat.h&gt;</span><br><span class="line">	int chmod(const char *pathname, mode_t mode);</span><br><span class="line">	改变文件权限</span><br><span class="line">	-mode, 八进制数，使用不同用户宏定义</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*truncate 函数</span><br><span class="line">	#include &lt;unistd.h&gt;</span><br><span class="line">	#include &lt;sys/types.h&gt;</span><br><span class="line">int truncate(const char *path, off_t length);</span><br><span class="line">	截断或扩展文件长度</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/110710.htm">库CentOS与Ubuntu哪个更适合做服务器系统</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/03/10/lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/10/lab/" class="post-title-link" itemprop="url">lab</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-10 20:46:47" itemprop="dateCreated datePublished" datetime="2023-03-10T20:46:47+08:00">2023-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 10:49:20" itemprop="dateModified" datetime="2023-03-11T10:49:20+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="0、docker搭建linux环境（for-Windows）"><a href="#0、docker搭建linux环境（for-Windows）" class="headerlink" title="0、docker搭建linux环境（for Windows）"></a>0、docker搭建linux环境（for Windows）</h1><h2 id="docker官网下载-docker-desktop"><a href="#docker官网下载-docker-desktop" class="headerlink" title="docker官网下载 docker desktop"></a><a target="_blank" rel="noopener" href="https://www.docker.com/">docker官网</a>下载 docker desktop</h2><p>右上角点击Get Started，选择Download for Windows进行下载并安装</p>
<img src="C:\myblog\source\_posts\lab\docker_download.png" style="zoom:50%;" />

<p>打开cmd，通过<code>docker --version</code> 命令查看是否安装成功</p>
<h2 id="配置docker镜像"><a href="#配置docker镜像" class="headerlink" title="配置docker镜像"></a>配置docker镜像</h2><p>打开docker desktop，在设置中找到Docker Engine，将原有文本修改成如下并Apply &amp; restart</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;experimental&quot;: false,</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://docker.mirrors.ustc.edu.cn&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;features&quot;: &#123;</span><br><span class="line">    &quot;buildkit&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="C:\myblog\source\_posts\lab\docker_engine.png" style="zoom:50%;" />

<p>cmd中输入<code>docker info</code>并显示有如下信息即可</p>
<p><img src="C:\myblog\source_posts\lab\docker_info.png"></p>
<h2 id="拉取Linux镜像并新建容器"><a href="#拉取Linux镜像并新建容器" class="headerlink" title="拉取Linux镜像并新建容器"></a>拉取Linux镜像并新建容器</h2><p>这里选择CentOS系统，当然也可以使用其他系统，只需要修改命令参数</p>
<p>输入<code>docker pull centos</code>即可拉取最新的centos镜像，如果需要特定版本的镜像，则在系统名字后加上版本参数如<code>docker pull centos:7</code></p>
<p>还可以输入<code>docker images</code>查看本地主机上的镜像</p>
<p><img src="C:\myblog\source_posts\lab\docker_images.png"></p>
<p>其中，</p>
<p>RESPOSITORY 是镜像的仓库源，TAG 是镜像的标签，代表不同版本，IMAGE ID 是镜像ID，CREATED 是镜像的创建时间，SIZE是镜像的大小</p>
<p>docker中镜像相当于一个类，如果运行还需要将类进行实例化，也就是新建一个容器</p>
<p><code>docker run -it centos /bin/bash</code></p>
<p>其中，</p>
<p>选项-i 指交互式操作，-t 指终端，it通常一起使用，&#x2F;bin&#x2F;bash 表面希望有个交互式shell，centos不指定版本则默认使用最新版本即lastest</p>
<p><code>[root@9c2ab6d80ac1 /]#</code>即进入centos系统界面</p>
<h2 id="打开原有容器而非创建"><a href="#打开原有容器而非创建" class="headerlink" title="打开原有容器而非创建"></a>打开原有容器而非创建</h2><p>以刚新建的centost容器为例，</p>
<img src="C:\myblog\source\_posts\lab\docker_name.png" style="zoom:80%;" />

<ul>
<li>从docker desktop复制其name或者ID号</li>
<li><code>docker start 9c2ab6d80ac14f1edf1dec3f89c9b6f759018913f2e13a8086c3c30c24ba0dd9</code>或者<code>docker start csapp_env</code>让容器启动</li>
<li><code>docker exec -it 9c2ab6d80ac14f1edf1dec3f89c9b6f759018913f2e13a8086c3c30c24ba0dd9 /bin/bash</code>以交互式操作进入容器</li>
<li><code>[root@9c2ab6d80ac1 /]#</code>centos系统界面</li>
<li>退出容器则输入<code>exit</code></li>
</ul>
<p>这里，除了<code>exec</code>也可以使用<code>attach</code>命令进入容器，<code>attach</code>如果从这个容器退出，就会导致容器的停止</p>
<h1 id="1、datalab"><a href="#1、datalab" class="headerlink" title="1、datalab"></a>1、datalab</h1><h2 id="挂载目录实现Linux机与主机文件同步"><a href="#挂载目录实现Linux机与主机文件同步" class="headerlink" title="挂载目录实现Linux机与主机文件同步"></a>挂载目录实现Linux机与主机文件同步</h2><ul>
<li>首先在主机中建立要共享的文件夹，复制其绝对路径，如C:\Users\amour\csapp\lab</li>
<li>运行<code>docker container run -it -v &quot;C:\Users\amour\csapp\lab&quot;:/csapp --name=csapp_env contos /bin/bash</code>，实现挂载，其中，在容器中的目录名为<code>csapp</code>，容器名为<code>csapp_env</code></li>
<li>验证挂载情况，进入容器中的目录<code>cd csapp</code>，再用<code>ls</code>指令查看子文件是否与主机中的一致</li>
</ul>
<h2 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h2><ul>
<li><p>更新yum源，<code>yum -y update</code></p>
<p>[报错1] 由于本地语言环境不适配可能会出现<code>Failed to set locale, defaulting to C.UTF-8</code>报错，则需要先安装响应的语言包和语言环境</p>
<ul>
<li><p><code>locale -a</code>查看目前已安装的语言包</p>
</li>
<li><p><code>yum install glibc-langpack-zh</code>安装中文语言包</p>
<p>[报错2] 这一步可能又会出现<code>Failed to download metadata for repo &#39;appstream&#39;</code>,需要将软件包修改源，在<code>/etc/yum.repos</code>中更新<code>repos.d</code>使用<code>vault.centos.org</code>代替<code>mirror.centos.org</code></p>
<ul>
<li><p>cd &#x2F;etc&#x2F;yum.repos.d</p>
</li>
<li><p>vi CentOS-Linux-BaseOS.repo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[baseos]</span><br><span class="line">name=CentOS Linux $releasever - BaseOS</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/release=$releasever&amp;arch=$basearch&amp;repo=BaseOS&amp;infra=$infra</span><br><span class="line">#baseurl=http://mirror.centos.org/$contentdir/$releasever/BaseOS/$basearch/os/</span><br><span class="line">baseurl=https://vault.centos.org/centos/$releasever/BaseOS/$basearch/os/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br></pre></td></tr></table></figure>
</li>
<li><p>vi CentOS-Linux-AppStream.repo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[appstream]</span><br><span class="line">name=CentOS Linux $releasever - AppStream</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=AppStream&amp;infra=$infra</span><br><span class="line">#baseurl=http://mirror.centos.org/$contentdir/$releasever/AppStream/$basearch/os/</span><br><span class="line">baseurl=https://vault.centos.org/centos/$releasever/AppStream/$basearch/os/ </span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>dnf install glibc-langpack-en</p>
</li>
<li><p>此时再输入<code>locale -a</code>查看目前的语言包，发现除了原有的<code>C.utf8</code>之外，还有其他的<code>en_utf8</code>和<code>zh_utf8</code>，至此，已解决语言环境不适配导致无法使用yum更新下载的问题</p>
</li>
</ul>
</li>
<li><p><code>yum install sudo</code>安装sudo</p>
</li>
<li><p><code>yum install make automake gcc gcc-c++ kernel-devel</code>安装c&#x2F;c++编译环境</p>
</li>
<li><p><code>yum install gdb</code>安装gdb调试器</p>
</li>
<li><p><code>yum install glibc-debel.i686</code>安装32位嵌入式C库</p>
</li>
<li><p>完成配置</p>
</li>
</ul>
<p>至此，可以在主机的编译器中编写代码保存到共享目录中，在docker的虚拟centos容器中编译和运行代码</p>
<p>如：在共享目录中创建<code>hello.c</code>文件并编写好，进入容器中的共享文件夹<code>cd csapp/L0/</code>，使用<code>make hello</code>进行编译，<code>./hello</code>即可运行</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/03/05/%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/05/%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/" class="post-title-link" itemprop="url">改造计划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-05 14:15:33" itemprop="dateCreated datePublished" datetime="2023-03-05T14:15:33+08:00">2023-03-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-09 17:02:40" itemprop="dateModified" datetime="2023-03-09T17:02:40+08:00">2023-03-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向招聘要求和面经学习"><a href="#面向招聘要求和面经学习" class="headerlink" title="面向招聘要求和面经学习"></a>面向招聘要求和面经学习</h1><h2 id="基础语法-面经"><a href="#基础语法-面经" class="headerlink" title="基础语法 + 面经"></a>基础语法 + 面经</h2><p>利用宿舍时间10:00-11:00 C++ Primer</p>
<p>牛客网面经、习题</p>
<h2 id="操作系统（重点）"><a href="#操作系统（重点）" class="headerlink" title="操作系统（重点）"></a>操作系统（重点）</h2><p>网课：CMU15-413</p>
<p>书籍：CSAPP + 现代操作系统</p>
<p>项目相关：labs</p>
<p>牛客网习题</p>
<h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><p>网课：王道</p>
<p>小林coding</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>网课：CMU15-445</p>
<p>书籍：MySQL必知必会（REDIS？）</p>
<p>小林coding</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>蓝桥杯真题库 + 代码随想录LeetCode + CODETOP</p>
<p>每日两题</p>
<h2 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h2><p>Linux原子哥</p>
<h2 id="webserver项目"><a href="#webserver项目" class="headerlink" title="webserver项目"></a>webserver项目</h2><p>C++ set自定义排序问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class node &#123;</span><br><span class="line">public:</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    int stime;</span><br><span class="line">    int fintime;</span><br><span class="line"></span><br><span class="line">    node(int xx, int yy, int st ,int ot) : x(xx), y(yy), stime(st), fintime(st + ot) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool operator &lt; (node n) const</span><br><span class="line">    &#123;</span><br><span class="line">        if (n.fintime != fintime)</span><br><span class="line">            return fintime &lt; n.fintime;</span><br><span class="line">        else if (x != n.x)</span><br><span class="line">            return x &lt; n.x;</span><br><span class="line">        else</span><br><span class="line">            return y &lt; n.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator &lt; (const node* n) const</span><br><span class="line">    &#123;</span><br><span class="line">        if (n-&gt;fintime != fintime)</span><br><span class="line">            return fintime &lt; n-&gt;fintime;</span><br><span class="line">        else if (x != n-&gt;x)</span><br><span class="line">            return x &lt; n-&gt;x;</span><br><span class="line">        else</span><br><span class="line">            return y &lt; n-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>利用 <code>&lt;</code> 运算符重载，如果<code>set&lt;node*&gt; nodes</code>，此时排序会出现混乱</p>
<p>而定义<code>set&lt;node&gt; nodes</code>则不会，并且使用仿函数也正常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class comp&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()( const node&amp; l, const node&amp; r) const</span><br><span class="line">&#123;</span><br><span class="line">    if (l.fintime != r.fintime)</span><br><span class="line">        return l.fintime &lt; r.fintime;</span><br><span class="line">    else if (l.x != r.x)</span><br><span class="line">        return l.x &lt; r.x;</span><br><span class="line">    else</span><br><span class="line">        return l.y &lt; r.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>set&lt;node, comp&gt; nodes</code>或<code>set&lt;node*, comp&gt; nodes</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/12/02/DP%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/02/DP%E7%AB%A0%E8%8A%82/" class="post-title-link" itemprop="url">DP章节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-02 17:23:42" itemprop="dateCreated datePublished" datetime="2022-12-02T17:23:42+08:00">2022-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-27 13:44:18" itemprop="dateModified" datetime="2023-02-27T13:44:18+08:00">2023-02-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="DP模板"><a href="#DP模板" class="headerlink" title="DP模板"></a>DP模板</h1><ol>
<li>确定数组<code>dp[i]</code>的含义，以及下标<code>i</code>的含义</li>
<li>确定数组<code>dp[i]</code>的递推公式</li>
<li>确定数组<code>dp[i]</code>的初始值</li>
<li>确定遍历顺序</li>
<li>举例推导</li>
</ol>
<h1 id="基础DP"><a href="#基础DP" class="headerlink" title="基础DP"></a>基础DP</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>容易想到递归的方法来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if(n&lt;=1)</span><br><span class="line">            return n;</span><br><span class="line">        return fib(n-1) + fib(n-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n!)，空间复杂度为O(n)</p>
<h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>DP数组的含义是<code>i</code>位置的斐波那契数列值是<code>dp[i]</code></p>
<p>递推公式为<code>dp[i] = dp[i-1]+dp[i-2]</code></p>
<p>DP数组初始值<code>dp[0]=0,dp[1]=1</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if(n == 0)  return 0;</span><br><span class="line">        vector&lt;int&gt; vec(n+1);</span><br><span class="line">        vec[0] = 0;</span><br><span class="line">        vec[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec[i] = vec[i - 1] + vec[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return vec[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(n)</p>
<h3 id="DP优化"><a href="#DP优化" class="headerlink" title="DP优化"></a>DP优化</h3><p>因为<code>dp[i]</code>的值只与其前两个值，即<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，则可以不需要借助容器<code>vector</code>来记录，而是只用三个变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if(n == 0)  return 0;</span><br><span class="line">        int v0 = 0, v1 = 1;</span><br><span class="line">        int sum = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = v0 + v1;</span><br><span class="line">            v0 = v1;</span><br><span class="line">            v1 = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return v1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(1)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>由于<code> F(n)</code> 只和 <code>F(n-1)</code>与 <code>F(n-2)</code>有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <code>O(1)</code>，即只需要借助三个变量来完成</strong></p>
<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h2><p>该题允许向上攀爬一个或两个台阶，返回n级台阶总共有多少种不同的攀爬方法</p>
<h3 id="DP思路"><a href="#DP思路" class="headerlink" title="DP思路"></a>DP思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当n为1时，有1种方式</span><br><span class="line">当n为2时，有2种方式</span><br><span class="line">当n为3时，有3种方式</span><br><span class="line">当n为4时，有5种方式</span><br></pre></td></tr></table></figure>

<p>可以看出，当阶数为n时，是<code>n-1</code>和<code>n-2</code>级阶数方法的总和</p>
<ul>
<li><p>确定DP数组含义</p>
<p><code>DP[i]</code>表示在台阶<code>i</code>时的攀爬方法</p>
</li>
<li><p>确定递推公式</p>
<p><code>DP[i] = DP[i - 1] + DP[i - 2];</code></p>
</li>
<li><p>确定初始值</p>
<p><code>DP[1] = 1, DP[2] = 2</code></p>
</li>
<li><p>确定遍历顺序</p>
<p>遍历顺序为正序，从头到尾遍历数组</p>
</li>
</ul>
<h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if(n &lt;= 3)  return n;</span><br><span class="line">        int res = 0;</span><br><span class="line">        vector&lt;int&gt; dp(n+1);</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        dp[2] = 2;</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DP优化-1"><a href="#DP优化-1" class="headerlink" title="DP优化"></a>DP优化</h3><p>与[上一题](# DP优化)优化方式类似，<strong>因为<code>dp[i]</code>的值只与其前两个值，即<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，因此可以使用滚动数组实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if(n &lt;= 3)  return n;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int q = 1, w = 2, e = 3;</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            e = q + w;</span><br><span class="line">            q = w;</span><br><span class="line">            w = e;</span><br><span class="line">        &#125;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>由于<code> F(n)</code> 只和 <code>F(n-1)</code>与 <code>F(n-2)</code>有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <code>O(1)</code>，即只需要借助三个变量来完成</strong></p>
<h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></h2><p>该题给出爬每层楼梯的花费，允许每次爬一个或两个阶梯，要求使用最低花费爬到楼梯顶部</p>
<h3 id="DP思路-1"><a href="#DP思路-1" class="headerlink" title="DP思路"></a>DP思路</h3><p>可以看出，当爬到第n层楼梯时，当前总共的花费与<code>n-1</code>级楼梯的花费有关，也就是说当前状态可以由之前的状态推导出来</p>
<ul>
<li><p>确定DP数组含义</p>
<p><code>DP[i]</code>表示在台阶<code>i</code>时的总共花费</p>
</li>
<li><p>确定递推公式</p>
<p><code>DP[i] = min(DP[i - 1] + costs[i - 1], DP[i-  2] + costs[i - 2];</code></p>
</li>
<li><p>确定初始值</p>
<p><code>DP[1] = 0, DP[2] = 0</code>，初始值应由递推公式中的<code>cost[i]</code>来决定</p>
</li>
<li><p>确定遍历顺序</p>
<p>遍历顺序为正序，从头到尾遍历数组</p>
</li>
</ul>
<h3 id="DP-2"><a href="#DP-2" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(cost.size()+1);</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        dp[1] = 0;</span><br><span class="line">        for(int i = 2; i &lt;= cost.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = min(dp[i - 1] + cost[i-1], dp[i-2] + cost[i-2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[cost.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DP优化-2"><a href="#DP优化-2" class="headerlink" title="DP优化"></a>DP优化</h3><p>类似的，<strong>因为<code>dp[i]</code>的值只与其前两个值，即<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，因此可以使用滚动数组实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int q = 0, w = 0, e = 0;</span><br><span class="line">        for(int i = 2; i &lt;= cost.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            e = min(q + cost[i-2], w + cost[i-1]);</span><br><span class="line">            q = w;</span><br><span class="line">            w = e;</span><br><span class="line">        &#125;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>由于<code> F(n)</code> 只和 <code>F(n-1)</code>与 <code>F(n-2)</code>有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <code>O(1)</code>，即只需要借助三个变量来完成</strong></p>
<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h2><p>该题有一个<code>m*n</code>大小的网格图，要求只能一次向下或者向右移动一步，返回总共不同的路径数</p>
<h3 id="DP思路-2"><a href="#DP思路-2" class="headerlink" title="DP思路"></a>DP思路</h3><p>若为<code>1*1</code>的网格，则有1条路径</p>
<p><code>2*2</code>的网格，有2条路径</p>
<p><code>3*2</code>或者是<code>2*3</code>的网格，则有3条路径</p>
<p><code>3*3</code>的网格中，有6条路径</p>
<p>由上可知，<strong>在<code>m*n</code>的网格当中，其路径总数等于 <code>(m-1)*n</code>网格的路径总数加上<code>m*(n-1)</code>网格的路径总数</strong>，因此将使用DP算法</p>
<ul>
<li><p>确定数组<code>DP[i][j]</code>含义</p>
<p><code>DP[i][j]</code>表示的是在<code>i*j</code>的网格当中，总共有<code>DP[i][j]</code>条路径</p>
</li>
<li><p>确定初始值</p>
<p><strong>为了方便，数组<code>DP[i][j]</code>表示第<code>i</code>行第<code>j</code>列，且不影响结果</strong></p>
<p><code>DP[1][j]</code>均为1，即第一行中的数，代表着<code>1*n</code>的所有网格</p>
<p><code>DP[i][1]</code>均为1，同理</p>
</li>
<li><p>确定状态转移方程</p>
<p><code>DP[i][j] = DP[i - 1][j] + DP[i][j - 1]</code></p>
</li>
<li><p>确定遍历顺序</p>
<p>从<code>i=2</code>开始遍历到<code>n</code>，正向遍历</p>
</li>
</ul>
<h3 id="DP-3"><a href="#DP-3" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">pubulic:</span><br><span class="line">	int uniquePaths(int m, int n)</span><br><span class="line">	&#123;</span><br><span class="line">		if(m == 1 || n == 1)</span><br><span class="line">			return 1;</span><br><span class="line">		vector&lt;int&gt; row(n + 1,1);</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; dp(n + 1,row);</span><br><span class="line">		//dp数组全部元素初始化为1</span><br><span class="line">		for(int i = 2; i &lt;= m; i++)</span><br><span class="line">			for(int j = 2; j &lt;= n; j++)</span><br><span class="line">				dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">		return dp[m][n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n^2)，遍历网格中的所有元素，空间复杂度为O(n^2)，为网格中的每个元素独立创建一份空间</p>
<h3 id="DP优化-3"><a href="#DP优化-3" class="headerlink" title="DP优化"></a>DP优化</h3><p>由上可知，当遍历时，当前位置下的元素只与同行上一列元素和同列上一行元素有关，因此可以只使用一维数组来进行空间的优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        if(m==1||n==1)  return 1;</span><br><span class="line">        vector&lt;int&gt; dp(n+1,1);</span><br><span class="line">        for(int i = 2; i &lt;= m; i++)</span><br><span class="line">            for(int j = 2; j &lt;= n; j++)</span><br><span class="line">                dp[j] += dp[j-1];</span><br><span class="line">            </span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>初始化中只需要对首行和首列元素进行初始化为1的操作</p>
<h2 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title=" 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/"> 不同路径 II</a></h2><p>与<a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">I</a>比较，该题多了障碍的设置，要求所有需要经过障碍所在位置的路径都不能被通过</p>
<h3 id="DP思路-3"><a href="#DP思路-3" class="headerlink" title="DP思路"></a>DP思路</h3><p>如果在<code>dp[i-1][j]</code>位置上有障碍，那么需要通过该点通往任意位置都将无法通过，这样可以通过将<code>dp[i-1][j]=0</code>，而<code>dp[i][j] = dp[i-1][j] + dp[i][j-1] = dp[i][j-1]</code></p>
<ul>
<li><p>确定数组<code>DP[i][j]</code>含义</p>
<p><code>DP[i][j]</code>表示的是在<code>i*j</code>的网格当中，排除有障碍的，总共有<code>DP[i][j]</code>条路径</p>
</li>
<li><p>确定初始值</p>
<p><strong>该题中 数组<code>DP[i+1][j+1]</code>表示第<code>i</code>行第<code>j</code>列</strong>，并且只需要对首列和首行的元素进行初始化</p>
<p>数组所有元素初始化为0，<strong>遍历数组中第0行和第0列的元素，如果当前位置上的元素没有遇到障碍，则将当前元素初值设为1</strong>，同时，<strong>如果遇到有障碍，那么在障碍之后的所有元素值都应该初始化为0</strong></p>
<p>如数组<code>[[0,0],[1,1],[0,0]]</code>，这时，对应的<code>dp</code>数组最终应该被初始化为<code>[[1,1],[0,0],[0,0]]</code></p>
</li>
<li><p>确定状态转移方程</p>
<p><code>DP[i][j] = DP[i - 1][j] + DP[i][j - 1]</code>，与上题一致</p>
</li>
<li><p>确定遍历顺序</p>
<p>正向遍历，与上题遍历顺序一致，但该题因为下标代表的含义不同，所以应该从<code>i=1</code>开始遍历到<code>n-1</code></p>
</li>
</ul>
<h3 id="DP-4"><a href="#DP-4" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.size(), n = obstacleGrid[0].size();</span><br><span class="line">        if(obstacleGrid[0][0]==1||obstacleGrid[m-1][n-1]==1)   return 0;</span><br><span class="line">        vector&lt;int&gt; row(n,0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, row);</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[i][0]==0)</span><br><span class="line">                dp[i][0] = 1;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[0][j]==0)</span><br><span class="line">                dp[0][j] = 1;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; m; i++)</span><br><span class="line">            for(int j = 1; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(obstacleGrid[i][j]==1)</span><br><span class="line">                    dp[i][j] = 0;</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] = dp[i-1][j] + dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="DP优化-4"><a href="#DP优化-4" class="headerlink" title="DP优化"></a>DP优化</h3><p>同样地，该题也可以只使用一个一维滚动数组来减小空间开销</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.size(), n = obstacleGrid[0].size();</span><br><span class="line">        if(obstacleGrid[0][0]==1||obstacleGrid[m-1][n-1]==1)   return 0;</span><br><span class="line">        vector&lt;int&gt; dp(n,0);</span><br><span class="line">        bool flag = false;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; m; i++)</span><br><span class="line">            for(int j = 0; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(j==0 &amp;&amp; flag)</span><br><span class="line">                    continue;</span><br><span class="line">                if(obstacleGrid[i][j]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = 0;</span><br><span class="line">                    if(j==0)</span><br><span class="line">                        flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(j==0)</span><br><span class="line">                    dp[j] = 1;</span><br><span class="line">                else</span><br><span class="line">                    dp[j] += dp[j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为不能另外用一个循环来进行<strong>首列的初始化</strong>，因此借助flag变量来标记是否遇到障碍，如果遇到，之后的元素都将初始化为0；而首行元素则不需要，因为所有元素都被初始化为0，并且当前元素的值，<strong>即<code>dp[i]</code>只与自身大小与左边元素大小有关</strong>，如<code>[[0,0,0,1,0,0]]</code>数组中，在遇到障碍之前的<code>dp</code>数组为<code>[1,1,1]</code>，遇到障碍则<code>dp[3]=0</code>，之后的元素<code>dp[i] += dp[i-1]</code>均为0</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>与<a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">上一题</a>对比，该题处理方法的不同主要在于 初始化中不能将首行和首列所有元素都初始化为1，因为可能会在首行或首列元素中放置了障碍，并且，<strong>遇到障碍之后的首行或首列元素都应该初始化为0</strong>，意味着<strong>在首行或首列遇到障碍之后的元素都将没有路径能够到达。</strong></p>
<h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></strong></h2><p>该题中给定一个整数，需要由<code>1-n</code>不同结点值组成一颗二叉搜索树，返回最多能组成互不相同的种树</p>
<h3 id="DP思路-4"><a href="#DP思路-4" class="headerlink" title="DP思路"></a>DP思路</h3><p>当n为1，只有1种二叉搜索树</p>
<p>当n为2，有2种二叉搜索树</p>
<p>当n为3，有5种二叉搜索树。 再细分，当以1为根结点，有两个大于1的数在根结点右边，则此时右子树可以组成n为2情况下的2种二叉搜索树；当以2为结点，同理有1个小于2的数在左子树，有1个数在右子树；当以3为结点，有2个数在左子树。</p>
<p>综上，可得n&#x3D;3时，<code>二叉搜索树数量=(右子树n=2的数量 * 左子树n=0的数量) + (右子树n=1的数量 * 左子树n=1的数量) + (右子树n=0的数量 * 左子树n=2的数量)</code></p>
<ul>
<li><p>确定数组<code>dp[i]</code>含义</p>
<p><code>dp[i]</code>表示的是i个结点下能组成二叉搜索树的数量</p>
</li>
<li><p>确定初始值</p>
<p><code>dp[0]=1</code>，空结点时能组成1种二叉搜索树</p>
<p><code>dp[1]=1</code></p>
<p><code>dp[2]=2</code></p>
</li>
<li><p>确定状态转移方程</p>
<p><code>dp[i]=dp[j-1]*dp[i-j]</code>，需要嵌套一层循环</p>
</li>
<li><p>确定遍历顺序</p>
<p>正向遍历，从<code>i=3</code>开始遍历到<code>n</code>，从<code>j = 1</code>遍历到 <code>j = i</code></p>
</li>
</ul>
<h3 id="DP-5"><a href="#DP-5" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        if(n==1)    return 1;</span><br><span class="line">        if(n==2)    return 2;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        dp[2] = 2;</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)</span><br><span class="line">            for(int j = 1; j &lt;= i;j++)</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i-j];</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数学解法"><a href="#数学解法" class="headerlink" title="数学解法"></a>数学解法</h3><p>卡特兰数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//公式：C0 = 1 , Cn+1 = 2(2n+1)/(n+2)*Cn </span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        long long C = 1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            C = C * 2 * (2 * i + 1) / (i + 2);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int)C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>该题难以推出状态转移方程，不妨细分情况，尽可能将之前的状态套进当前状态来考虑</p>
<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">整数拆分</a></strong></h2><p>该题给定一个正整数n，将其拆分为n个正整数的和，并返回这些和的最大化乘积</p>
<h3 id="DP思路-5"><a href="#DP思路-5" class="headerlink" title="DP思路"></a>DP思路</h3><p>算出前8个正整数的最大乘积为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1	2	3	4	5	6	7	8</span><br><span class="line">1	1	2	4	6	9	12	18</span><br></pre></td></tr></table></figure>

<p>将8拆分成以下的情况，</p>
<p><code>8 = j + (i - j)</code>，此时，<code>j</code>和<code>i - j</code>不再拆分，那么 <code>n=8</code>的最大乘积 &#x3D; <code>i</code> * <code>(i - j)</code>；若继续拆分<code>i - j</code>，那么 <code>n=8</code>的最大乘积 &#x3D; <code>i</code> * (<code>n = (i - j)</code>的最大乘积)</p>
<p>综上，可以得到 <code>dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j))</code></p>
<ul>
<li><p>确定数组<code>dp[i]</code>含义</p>
<p><code>dp[i]</code>表示的是整数<code>i</code>拆分的正整数的最大乘积</p>
</li>
<li><p>确定初始值</p>
<p><code>dp[1]=1</code></p>
<p><code>dp[2]=1</code></p>
<p><code>dp[3]=2</code></p>
</li>
<li><p>确定状态转移方程</p>
<p><code>dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j))</code>，需要嵌套一层循环</p>
</li>
<li><p>确定遍历顺序</p>
<p>正向遍历，从<code>i=4</code>开始遍历到<code>n</code>，从<code>j = 1</code>遍历到<code>j = i</code></p>
</li>
</ul>
<h3 id="DP-6"><a href="#DP-6" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1);</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; i++)</span><br><span class="line">            for(int j = 1; j &lt;= i/2; j++)</span><br><span class="line">                dp[i] = max(dp[i], max(j*(i-j), dp[i-j]*j));</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>数学证明：</p>
<blockquote>
<p>$$ {函数极值证明法}<br>函数极值证明法</p>
<p>显然，如果将给定的正整数拆分成尽可能多的某个特定的正整数，则这些正整数的乘积最大。</p>
<p>定义函数 f(x)f(x) 表示将给定的正整数 nn 拆分成尽可能多的正数 xx 的情况下的最大乘积，则可以将 nn 分成 \dfrac{n}{x}<br>x<br>n<br>​<br>  项，此时 f(x)&#x3D;x^{\frac{n}{x}}f(x)&#x3D;x<br>x<br>n<br>​</p>
<p> ，目标是求 f(x)f(x) 的最大值，即</p>
<p>\mathop{\max}\limits_{x}(f(x))<br>x<br>max<br>​<br> (f(x))</p>
<p>可以将 f(x)f(x) 写成如下形式：</p>
<p>f(x)&#x3D;x^{\frac{n}{x}}&#x3D;e^{\frac{n \ln x}{x}}<br>f(x)&#x3D;x<br>x<br>n<br>​</p>
<p> &#x3D;e<br>x<br>nlnx<br>​</p>
<p>令 g(t)&#x3D;e^tg(t)&#x3D;e<br>t<br> ，h(x)&#x3D;\dfrac{\ln x}{x}h(x)&#x3D;<br>x<br>lnx<br>​<br> ，则有 f(x)&#x3D;g(n \cdot h(x))f(x)&#x3D;g(n⋅h(x))。由于 g(t)g(t) 是单调递增的，n&gt;0n&gt;0，因此 h(x)h(x) 与 f(x)f(x) 的单调性相同。</p>
<p>计算 h(x)h(x) 的驻点，即 h’(x)&#x3D;\dfrac{1- \ln x}{x^2}&#x3D;0h<br>′<br> (x)&#x3D;<br>x<br>2</p>
<p>1−lnx<br>​<br> &#x3D;0 的点，得到驻点为 x&#x3D;ex&#x3D;e。</p>
<p>由于当 0&lt;x&lt;e0&lt;x&lt;e 时 h’(x)&gt;0h<br>′<br> (x)&gt;0，当 x&gt;ex&gt;e 时 h’(x)&lt;0h<br>′<br> (x)&lt;0，因此 x&#x3D;ex&#x3D;e 是 h(x)h(x) 的极大值点，也是 f(x)f(x) 的极大值点。由于函数 f(x)f(x) 的定义域连续，因此极大值点唯一，也是最大值点。</p>
<p>因此，当 x&#x3D;ex&#x3D;e 时，f(x)f(x) 取到最大值，\max f(x)&#x3D;f(e)&#x3D;e^{\frac{n}{e}}maxf(x)&#x3D;f(e)&#x3D;e<br>e<br>n<br>​</p>
<p> 。</p>
<p>由于 ee 不是整数，因此使用与 ee 最接近的整数作为 xx 的值，xx 可以是 22 或 33，此时需要比较 f(2)f(2) 与 f(3)f(3) 的大小，可以通过计算 \dfrac{f(3)}{f(2)}<br>f(2)<br>f(3)<br>​<br>  进行比较。</p>
<h1 id="dfrac-f-3-f-2-x3D-dfrac-e-n-cdot-h-3-e-n-cdot-h-2-x3D-e-n-cdot-h-3-n-cdot-h-2-x3D-e-n-cdot-frac-ln-3-3-frac-ln-2-2-x3D-e-frac-n-6-cdot-2-ln-3-3-ln-2-x3D-e-frac-n-6-cdot-ln-9-ln-8-f-2-f-3-​"><a href="#dfrac-f-3-f-2-x3D-dfrac-e-n-cdot-h-3-e-n-cdot-h-2-x3D-e-n-cdot-h-3-n-cdot-h-2-x3D-e-n-cdot-frac-ln-3-3-frac-ln-2-2-x3D-e-frac-n-6-cdot-2-ln-3-3-ln-2-x3D-e-frac-n-6-cdot-ln-9-ln-8-f-2-f-3-​" class="headerlink" title="\dfrac{f(3)}{f(2)}&#x3D;\dfrac{e^{n \cdot h(3)}}{e^{n \cdot h(2)}}&#x3D;e^{n \cdot h(3)-n \cdot h(2)}&#x3D;e^{n \cdot (\frac{\ln 3}{3} - \frac{\ln 2}{2})}&#x3D;e^{\frac{n}{6} \cdot (2 \ln 3 - 3 \ln 2)}&#x3D;e^{\frac{n}{6} \cdot (\ln 9 - \ln 8)}f(2)f(3)​"></a>\dfrac{f(3)}{f(2)}&#x3D;\dfrac{e^{n \cdot h(3)}}{e^{n \cdot h(2)}}&#x3D;e^{n \cdot h(3)-n \cdot h(2)}&#x3D;e^{n \cdot (\frac{\ln 3}{3} - \frac{\ln 2}{2})}&#x3D;e^{\frac{n}{6} \cdot (2 \ln 3 - 3 \ln 2)}&#x3D;e^{\frac{n}{6} \cdot (\ln 9 - \ln 8)}<br>f(2)<br>f(3)<br>​</h1><p>e<br>n⋅h(2)</p>
<p>e<br>n⋅h(3)</p>
<p>​<br> &#x3D;e<br>n⋅h(3)−n⋅h(2)<br> &#x3D;e<br>n⋅(<br>3<br>ln3<br>​<br> −<br>2<br>ln2<br>​<br> )<br> &#x3D;e<br>6<br>n<br>​<br> ⋅(2ln3−3ln2)<br> &#x3D;e<br>6<br>n<br>​<br> ⋅(ln9−ln8)</p>
<p>由于 \ln 9 &gt; \ln 8ln9&gt;ln8，因此 \dfrac{f(3)}{f(2)}&gt;1<br>f(2)<br>f(3)<br>​</p>
<blockquote>
<p>1，即 f(3)&gt;f(2)f(3)&gt;f(2)。当 x&#x3D;3x&#x3D;3 时，可以得到最大乘积。因此，应该将给定的正整数拆分成尽可能多的 33。</p>
</blockquote>
<p>根据 nn 除以 33 的余数进行分类讨论：</p>
<p>如果余数为 00，即 n&#x3D;3m(m \ge 2)n&#x3D;3m(m≥2)，则将 nn 拆分成 mm 个 33；</p>
<p>如果余数为 11，即 n&#x3D;3m+1(m \ge 1)n&#x3D;3m+1(m≥1)，由于 2 \times 2 &gt; 3 \times 12×2&gt;3×1，因此将 nn 拆分成 m-1m−1 个 33 和 22 个 22；</p>
<p>如果余数为 22，即 n&#x3D;3m+2(m \ge 1)n&#x3D;3m+2(m≥1)，则将 nn 拆分成 mm 个 33 和 11 个 22。</p>
<p>上述拆分的适用条件是 n \ge 4n≥4。如果 n \le 3n≤3，则上述拆分不适用，需要单独处理。</p>
<p>如果 n&#x3D;2n&#x3D;2，则唯一的拆分方案是 2&#x3D;1+12&#x3D;1+1，最大乘积是 1 \times 1&#x3D;11×1&#x3D;1；</p>
<p>如果 n&#x3D;3n&#x3D;3，则拆分方案有 3&#x3D;1+2&#x3D;1+1+13&#x3D;1+2&#x3D;1+1+1，最大乘积对应方案 3&#x3D;1+23&#x3D;1+2，最大乘积是 1 \times 2&#x3D;21×2&#x3D;2。</p>
<p>这两种情形可以合并为：当 n \le 3n≤3 时，最大乘积是 n-1n−1。<br>$$</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        if (n &lt;= 3) &#123;</span><br><span class="line">            return n - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int quotient = n / 3;</span><br><span class="line">        int remainder = n % 3;</span><br><span class="line">        if (remainder == 0) &#123;</span><br><span class="line">            return (int)pow(3, quotient);</span><br><span class="line">        &#125; else if (remainder == 1) &#123;</span><br><span class="line">            return (int)pow(3, quotient - 1) * 4;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (int)pow(3, quotient) * 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>DP思路考虑状态转移方程时，把正整数n拆分成 <code>j</code>和<code>n-j</code>来考虑，自然得到拆分的一种乘积为<code>j * (n - j)</code>，考虑到上一个的状态，拆分为<code>n - j</code>还可以继续拆分，此时，另一种乘积则为<code>j * dp[n - j]</code></p>
<p>贪心思路需要用到复杂数学证明的结论——尽可能将数拆分成2或3时的乘积最大。</p>
<blockquote>
<p>If an optimal product contains a factor f &gt;&#x3D; 4, then you can replace it with factors 2 and f-2 without losing optimality, as 2*(f-2) &#x3D; 2f-4 &gt;&#x3D; f. So you never need a factor greater than or equal to 4, meaning you only need factors 1, 2 and 3 (and 1 is of course wasteful and you’d only use it for n&#x3D;2 and n&#x3D;3, where it’s needed).</p>
<p>For the rest I agree, 3<em>3 is simply better than 2</em>2*2, so you’d never use 2 more than twice.、</p>
</blockquote>
<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/11/15/LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/15/LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/" class="post-title-link" itemprop="url">LeetCode贪心算法章节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-15 16:13:21" itemprop="dateCreated datePublished" datetime="2022-11-15T16:13:21+08:00">2022-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-12 11:40:02" itemprop="dateModified" datetime="2022-12-12T11:40:02+08:00">2022-12-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LeetCode贪心算法章节"><a href="#LeetCode贪心算法章节" class="headerlink" title="LeetCode贪心算法章节"></a>LeetCode贪心算法章节</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>以每个人的胃口作为阈值，只有给够饼干才能满足，那么为了满足更多的人，则应根据胃口有小到大排序，在饼干数量一定情况下，先满足胃口小的可以让更多人得到满足</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">        if(s.size()==0) return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        sort(g.begin(),g.end());</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        int i=0, j=0;</span><br><span class="line">        while(i&lt;g.size() &amp;&amp; j&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(g[i]&lt;=s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(g[i]&gt;s[j])</span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目中用到的贪心算法思想，局部最优就是<strong>小饼干先喂饱小胃口</strong>，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**</p>
<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><strong>摆动序列</strong></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>根据数组前后差值关系，求出最长的摆动子序列，其中，子序列也可以删除原序列的某个元素。也就是说，不改变序列顺序，忽略非摆动的子序列，从中找到摆动子序列并拼接，求出最大的长度。</p>
<p>局部最优就是通过删除在单一坡度（单调序列）上的元素，使其出现两个峰值，如在<code>5,1,4,6,3</code>中，<code>1,4,6</code>为单一坡度，在删除元素4之后，就变成摆动序列，或者延长了摆动序列。实际操作中，可以忽略掉单调坡上的元素，只取两端，统计使出现峰值的转折点元素</p>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p><code>res</code>初始为1（默认最右面有一个峰值），此时<code>cursub</code>&gt; 0 &amp;&amp;<code>presub</code>&lt;&#x3D; 0，那么res++（计算了左面的峰值），最后得到的<code>res</code>就是2（峰值个数为2即摆动序列长度为2）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()&lt;=1)  return nums.size();</span><br><span class="line">        int res = 1;</span><br><span class="line">        int presub = 0;</span><br><span class="line">        int cursub = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size() - 1;i++)</span><br><span class="line">        &#123;  </span><br><span class="line">            cursub = nums[i + 1] - nums[i];</span><br><span class="line">            if((cursub &gt; 0 &amp;&amp; presub &lt;= 0)||(cursub &lt; 0 &amp;&amp; presub &gt;= 0))</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                presub = cursub;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述版本中，判断条件为<code>presub &lt;= 0</code>和<code>presub&gt; = 0</code>，让<code>presub</code>等于0也进入结果集收集，是因为在一开始<code>presub</code>为0。另外，考虑到出现相邻相同元素时，此时<code>cursub=0</code>，不会被统计到结果中，并且，<code>presub</code>也不会更新成0，就是为了阻止非严格单调序列也会被统计到，如<code>1,5,3,3,2</code>，如果每次都更新<code>presub</code>，令<code>presub=cursub</code>，当遇到相同元素时，所有相同元素不被统计成摆动序列（因为<code>cursub=0</code>)，但相同元素的下一个元素无论是否符合摆动，都会被统计成摆动序列里（因为此时<code>presub=0</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()&lt;=1)  return nums.size();</span><br><span class="line">        int res = 1;</span><br><span class="line">        int presub = 0;</span><br><span class="line">        int cursub = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size() - 1;i++)</span><br><span class="line">        &#123;  </span><br><span class="line">            cursub = nums[i + 1] - nums[i];</span><br><span class="line">            if(cursub==0)   continue;</span><br><span class="line">            if(cursub*presub &lt;= 0)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            presub = cursub;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上版本使用不同方法判断摆动，<code>cursub * presub &lt;= 0</code>，还要增加<code>if(cursub==0)   continue;</code>，当遇到相同元素时，<code>cursub=0</code>则直接跳过当次循环，也不会更新<code>presub</code>，直到遇到不同的元素。也就是相当于去重处理</p>
<h3 id="动规"><a href="#动规" class="headerlink" title="动规"></a>动规</h3><p>利用动态规划思想</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>保持区间波动，只需要把单调区间上的元素移除就可以了，通过局部最优达到全局最优</p>
<p>本题关键在于对摆动子序列的统计判断条件，即当遇到相同元素时如何处理</p>
<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><strong>最大子数组和</strong></h2><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>寻找相加和最大时的子数组，与上题不同，上题不允许排序但能删掉中间的元素，是一种拼凑的子序列，本题要求是连续的子数组，容易想到的是用两层for循环以及双指针解法，其中，双层for循环能够实现但会导致超时，时间复杂度为O(n^2)；双指针法其实并不能够在单次循环中实现，在有正负交错的情况下，不能找到最大子数组的边界点。</p>
<p>贪心算法的局部最优思路路是，在求和过程中，一旦求和值为负数，则应舍弃掉之前的子序列，再重新从下一个元素开始求和</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res = INT_MIN;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            if(sum&gt;res)</span><br><span class="line">                res = sum;</span><br><span class="line">            if(sum&lt;0)</span><br><span class="line">                sum = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>当遇到连续正数时，<code>sum</code>一直增长并更新<code>res</code></li>
<li>当遇到连续负数时，第一个负数与<code>INT_MIN</code>对比肯定会更新到<code>res</code>中，后面的负数再更新到保持为0的<code>sum</code>中，最后跟已存到<code>res</code>的第一个负数做大小比较，取较大值</li>
<li>当遇到正数+负数+正数时，访问到负数时，只要<code>sum</code>值还没变为负数，都会一直扩大子序列，因为可能后面还会有正数使得子序列和更大，而当后面一直是负数直到<code>sum&lt;0</code>，那么就会重新开始计算子序列的最大和，因为从下一个正数开始的子序列和必然比负数大，这也是为何是<code>if(sum&lt;0)</code>而不是<code>if(nums[i]&lt;0)</code></li>
<li>时间复杂度为O(n)，遍历数组所有元素一次，空间复杂度为O(1)，占用常数级空间存放变量</li>
</ul>
<h3 id="动规-1"><a href="#动规-1" class="headerlink" title="动规"></a>动规</h3><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治的思想与递归回溯有些类似，通过划分子区间，直到区间元素个数为1，再回升合并，更新维护相应的变量，直到回到原始数组区间。因此，关键在于1. 要维护的信息 2. 如何在合并区间时更新这些信息</p>
<ol>
<li><code>lsum</code>维护包含左端点在内的最大子序列和</li>
<li><code>rsum</code>维护包含右端点在内的最大子序列和</li>
<li><code>isum</code>维护区间数组的最大子序列和</li>
<li><code>sum</code>维护区间数组的总和</li>
</ol>
<p>在合并<code>s1</code>和<code>s2</code>区间时，为了维护<code>isum</code>即最终求取的结果，都会用到以上的信息，这也是需要维护以上信息的原因</p>
<ol>
<li><code>sum = s1.sum + s2.sum</code>数组总和直接相加</li>
<li><code>lsum = max(s1.sum, s1.sum + s2.lsum)</code>取原左区间<code>lsum</code>和合并区间<code>lsum</code>即<code>s1.sum+s2.lsum</code>的最大值</li>
<li><code>rsum</code>同上</li>
<li><code>isum</code>有三种可能，可以是左区间的<code>isum</code>，也可能是右区间的<code>isum</code>，还有一种可能是合并之后跨越两个区间，此时<code>isum = s1.rsum + s2.lsum</code></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    struct status&#123;</span><br><span class="line">        int lsum, rsum, isum, sum;</span><br><span class="line">    &#125;;</span><br><span class="line">    status pushup(status&amp;s1, status&amp;s2)</span><br><span class="line">    &#123;</span><br><span class="line">        int sum = s1.sum + s2.sum;</span><br><span class="line">        int lsum = max(s1.lsum, s1.sum+s2.lsum);</span><br><span class="line">        int rsum = max(s2.rsum, s2.sum+s1.rsum);</span><br><span class="line">        int isum = max(max(s1.isum,s2.isum), s1.rsum+s2.lsum);</span><br><span class="line">        return (status) &#123;lsum, rsum, isum, sum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    status get(vector&lt;int&gt;&amp; nums, int st, int en)</span><br><span class="line">    &#123;</span><br><span class="line">        if(st==en)</span><br><span class="line">        &#123;</span><br><span class="line">            return (status) &#123;nums[st],nums[st],nums[st],nums[st]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (st + en) &gt;&gt; 1;</span><br><span class="line">        status s1 = get(nums, st, mid);</span><br><span class="line">        status s2 = get(nums, mid+1, en);</span><br><span class="line">        return pushup(s1,s2);</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        return get(nums,0,nums.size()-1).isum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，遍历数组所有元素一次，空间复杂度O(log n)，递归占用了栈空间</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>贪心算法能够在遍历数组的时候遇到子数组和为负数时及时舍弃，再重新从零开始，也是其贪的局部最优思想。</p>
<p>分治算法</p>
<ul>
<li>在于不断切割子区间，利用递归回溯思想把问题转化求解子区间的问题，<strong>最关键的地方在于合并区间时对信息的更新维护</strong></li>
<li>如果在合并区间上要存取的信息较多，函数参数冗杂，<strong>可以通过结构体来实现信息的传递</strong></li>
<li>虽然分治算法时间复杂度与贪心相同，且空间复杂度上由于递归比贪心要差，但分治算法<strong>构建了线段树</strong>，<strong>能做到快速访问任何子区间上的最大子序列和</strong>，访问的时间复杂度为O(log n)，对于<strong>大规模查询</strong>的情况下，这种方法的优势便体现了出来</li>
</ul>
<h2 id="买卖股票最佳时机II"><a href="#买卖股票最佳时机II" class="headerlink" title="买卖股票最佳时机II"></a>买卖股票最佳时机II</h2><h3 id="贪心-2"><a href="#贪心-2" class="headerlink" title="贪心"></a>贪心</h3><p>用贪心思想较为简单，由于没有买入卖出次数限制，只考虑每天的盈亏情况，再把所有盈余的情况相加即可</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0;i &lt; prices.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i+1]-prices[i]&gt;0)</span><br><span class="line">                res += prices[i+1] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动规-2"><a href="#动规-2" class="headerlink" title="动规"></a>动规</h3><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>贪心算法中，局部最优是将最大利润划分成每天能获取的利润，贪在只获取盈余的部分，舍弃亏钱的部分</p>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><h3 id="贪心-3"><a href="#贪心-3" class="headerlink" title="贪心"></a>贪心</h3><p>通过for循环里从头开始遍历数组的所有元素，借助一个变量<code>tmp</code>记录当前元素下往前所能达到的最大范围，并且在遍历过程中不断更新这个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(tmp&lt;0)  return false;</span><br><span class="line">            tmp = max(tmp, nums[i]);</span><br><span class="line">            --tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>贪心算法思想中局部最优是 当前位置下能够到达的最远范围，即<code>tmp</code>变量，贪在了不断更新当前位置下的最远范围，通过这个来判断能否到达目的位置</p>
<h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a><strong>跳跃游戏II</strong></h2><h3 id="贪心-4"><a href="#贪心-4" class="headerlink" title="贪心"></a>贪心</h3><p>贪心算法局部最优在于<strong>寻找当前能覆盖的最大范围</strong>，在遍历数组时遇到这个最大范围的边界点，则更新在遍历时遇到的最大范围以及更新跳数，即遇到了上一个最大范围则需要进行下一跳</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        int en = 0;</span><br><span class="line">        for(int i =0;i&lt;nums.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = max(nums[i]+i,tmp);</span><br><span class="line">            if(i == en)</span><br><span class="line">            &#123;</span><br><span class="line">                en = tmp;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>与上一题解法相比，都是用一次的数组遍历，但上题中<strong>记录的是以当前位置作为基准，所能到达的最远距离</strong>，且在<strong>遍历每一个点时都会更新这个距离</strong>；而这一题中因为能确保到达数组的最后一个位置，<strong>记录的是能够覆盖的最大范围</strong>，且<strong>只在到达了上一个最大范围时才更新这个范围</strong></p>
<h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>不断通过排序，对最小的元素进行取反，直到剩余取反次数为0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        while(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[0] = -nums[0];</span><br><span class="line">            sort(nums.begin(),nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心1"><a href="#贪心1" class="headerlink" title="贪心1"></a>贪心1</h3><p>显然，有着很多的重复排序操作，考虑只进行一次遍历和排序</p>
<p>由于有正数和负数，可以通过由小到大排序数组并分类讨论</p>
<ul>
<li><strong>如果当前最小元素是正数，且剩余取反次数是偶数，则可以直接返回</strong></li>
<li><strong>如果当前最小元素是正数，且剩余取反次数是奇数，则重新排序对最小值进行取反再返回</strong></li>
<li>如果当前最小元素是负数，且剩余取反次数大于0，则直接取反并移动到下一个元素</li>
<li>如果移动到下一个元素超出数组范围，且剩余取反次数大于0，则移动到数组首元素，这种情况下，原数组全为负数而此时数组全为正数，则只需判断剩余取反次数的奇偶性。</li>
</ul>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int res = accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        int i = 0;</span><br><span class="line">        while( k &amp;&amp; i&lt;nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i] &gt;= 0 &amp;&amp; k % 2 == 0)</span><br><span class="line">                break;</span><br><span class="line">            else if(nums[i] &gt;= 0 &amp;&amp; k % 2 != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                sort(nums.begin(),nums.end());</span><br><span class="line">                nums[0] = -nums[0];</span><br><span class="line">                res += 2*nums[0];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = -nums[i];</span><br><span class="line">            res += nums[i]*2;</span><br><span class="line">            ++i;</span><br><span class="line">            --k;</span><br><span class="line">            if(k &amp;&amp; i == nums.size())       //全负数且k &gt;= num.size()</span><br><span class="line">                i = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="贪心2"><a href="#贪心2" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种解法，用不同的方式排序，按照<strong>绝对值大小</strong>进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        return abs(a) &gt; abs(b);</span><br><span class="line">    &#125;</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int res = accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">        sort(nums.begin(),nums.end(),cmp);</span><br><span class="line">        int i = 0;</span><br><span class="line">        while( k &amp;&amp; i &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]&lt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">                res += 2*nums[i];</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k &amp;&amp; k%2!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[nums.size()-1] *= -1;</span><br><span class="line">            res += 2*nums[nums.size()-1];</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>贪心算法局部最优是将最小的负数取反，最大化数组和。</p>
<p>取到最小的负数就需要对数组的排序，可以有两种不同的排序方式，按值从小到大排序和按绝对值从小到大排序。从小到大排序会导致在对所有负数取反 而剩余取反次数大于零时，额外需要排序来对最小的整数进行取反。按绝对值排序则可以解决这个问题，当数组全为正数时，可直接根据剩余取反次数是否对数组末尾元素或首元素进行取反</p>
<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><strong>加油站</strong></h2><p>容易想到的是暴力解法，判断能否循环一圈，只需要在循环中间油量不会变为负数即返回<code>true</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool ok(vector&lt;int&gt;&amp; gas,vector&lt;int&gt;&amp; cost, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        int times = 1;</span><br><span class="line">        int tank = gas[index];</span><br><span class="line">        while(times &lt;= gas.size())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tank -= cost[index];</span><br><span class="line">            if(tank&lt;0)</span><br><span class="line">                return false;</span><br><span class="line">            index++;</span><br><span class="line">            if(index&gt;gas.size()-1)</span><br><span class="line">                index = 0;</span><br><span class="line">            tank += gas[index];</span><br><span class="line">            times++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>遍历数组，判断以当前元素开始能否循环一圈，但时间复杂度会达到O(n^2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool ok(vector&lt;int&gt;&amp; gas,vector&lt;int&gt;&amp; cost, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        int times = 1;</span><br><span class="line">        int tank = gas[index];</span><br><span class="line">        while(times &lt;= gas.size())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tank -= cost[index];</span><br><span class="line">            if(tank&lt;0)</span><br><span class="line">                return false;</span><br><span class="line">            index++;</span><br><span class="line">            if(index&gt;gas.size()-1)</span><br><span class="line">                index = 0;</span><br><span class="line">            tank += gas[index];</span><br><span class="line">            times++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = -1;</span><br><span class="line">        int tank = 0;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(gas[i] &lt; cost[i])</span><br><span class="line">                continue;</span><br><span class="line">            if(ok(gas,cost,i))</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="暴力优化"><a href="#暴力优化" class="headerlink" title="暴力优化"></a>暴力优化</h3><p>在暴力法中，每次都会有重复的遍历，因此可以借助容器记录遍历过的元素，记录<strong>该元素能走到最远的地方</strong>以及<strong>剩余的油量</strong>，下一次当再次遍历到该元素时则直接跳到保存的最远地方同时加上剩余的油量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        vector&lt;int&gt; dist(gas.size(),-1);</span><br><span class="line">        vector&lt;int&gt; tmp(gas.size());</span><br><span class="line">        int res = -1;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            int cur = gas[i];</span><br><span class="line">            while(cur-cost[j]&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                cur -= cost[j];</span><br><span class="line">                j = (j+1) % gas.size();</span><br><span class="line">                if(dist[j]!=-1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur += tmp[j];</span><br><span class="line">                    j = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    cur += gas[j];</span><br><span class="line">                if(j==i &amp;&amp; cur&gt;= 0)</span><br><span class="line">                    return i;</span><br><span class="line">            &#125;</span><br><span class="line">            dist[i] = j;</span><br><span class="line">            tmp[i] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然减少了重复访问的时间，利用了空间换取时间的思想，但对时间提升并不明显，依然是超出时间限制。</p>
<h3 id="暴力再优化"><a href="#暴力再优化" class="headerlink" title="暴力再优化"></a>暴力再优化</h3><p>进一步考虑，<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，也就是说，在遍历过程中，遍历完<code>i</code>之后即可直接跳转到<code>j+1</code>位置上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = -1;</span><br><span class="line">        vector&lt;int&gt; dist(gas.size(),-1);</span><br><span class="line">        vector&lt;int&gt; tmp(gas.size());</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            int cur = gas[i];</span><br><span class="line">            while(cur-cost[j]&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                cur -= cost[j];</span><br><span class="line">                j = (j+1)%gas.size();</span><br><span class="line">                if(dist[j]!=-1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur += tmp[j];</span><br><span class="line">                    j = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    cur += gas[j];</span><br><span class="line">                if(i == j)</span><br><span class="line">                    return i;</span><br><span class="line">            &#125;</span><br><span class="line">            dist[i] = j;</span><br><span class="line">            tmp[i] = cur;</span><br><span class="line">            if(i&lt;j)</span><br><span class="line">                i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以不借助数组，只占用常数级空间，显得更为简洁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = -1;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            int cur = gas[i];</span><br><span class="line">            while(cur-cost[j]&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                cur -= cost[j];</span><br><span class="line">                j = (j+1)%gas.size();</span><br><span class="line">                cur += gas[j];</span><br><span class="line">                if(i == j)</span><br><span class="line">                    return i;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i &lt; j)</span><br><span class="line">                i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心-5"><a href="#贪心-5" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int cursum = 0, tosum = 0;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int tmp = gas[i] - cost[i];</span><br><span class="line">            cursum += tmp;</span><br><span class="line">            tosum += tmp;</span><br><span class="line">            if(cursum &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">            	cursum = 0;</span><br><span class="line">            	res = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tosum &lt; 0)</span><br><span class="line">        	return -1;</span><br><span class="line">        else</span><br><span class="line">        	return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>贪心算法<strong>局部最优在于找到符合当前油量足以到达下一站点的位置</strong>，借助<code>cursum</code>来记录，一旦<code>cursum</code>小于零，即在<code>i</code>站点出发不能够循环一圈，就马上从下一个站点重新出发，并把<code>cursum</code>置零</p>
<p>同样使用到上述的一个条件——<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，那么此时就应该从<code>j+1</code>继续遍历</p>
<p>同时记录总油量，来判断是否存在任何站点都无法循环一圈的情况</p>
<h3 id="贪心special"><a href="#贪心special" class="headerlink" title="贪心special"></a>贪心special</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int tosum = 0;</span><br><span class="line">        int tmpsum = 0;</span><br><span class="line">        int mintmp = INT_MAX;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpsum = gas[i] - cost[i];</span><br><span class="line">            tosum += tmpsum;</span><br><span class="line">            if(tosum &lt; mintmp)</span><br><span class="line">                mintmp = tosum;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tosum&lt;0)    return -1;</span><br><span class="line">        if(mintmp &gt;= 0)     return 0;</span><br><span class="line">        for(int i = gas.size()-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpsum = gas[i] - cost[i];</span><br><span class="line">            mintmp += tmpsum;</span><br><span class="line">            if(mintmp &gt;=0)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有如下几种情况：</p>
<ol>
<li>任何一个站点都无法循环一圈，遍历一遍数组后<code>tosum</code>小于0，则返回-1</li>
<li>从0开始遍历一遍数组后，<code>tosum</code>大于0且中途油箱最小值<code>mintmp</code>都大于0，则可以循环一圈，且从位置0开始，返回0</li>
<li>从0开始遍历一遍数组后，<code>tosum</code>大于0但中途油箱最小值<code>mintmp</code>小于0，则可以循环一圈，但不从位置0开始，逆向遍历数组，不断加上路径某个站点净获得油量，当<code>mintmp</code>大于等于0时，即从该位置开始可以循环一圈</li>
</ol>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>本题的关键点在于理解到<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，由暴力解法优化而来的方法，因为都是在遍历数组时要直接模拟一圈循环，因此时间复杂度上会比贪心算法只遍历一遍数组要慢，但却有很好的优化方向，<strong>通过减少重复过程优化</strong>以及<strong>通过空间换取时间优化</strong>。贪心算法贪在了<strong>从当前站点出发，累加<code>tmp</code>的和<code>curSum</code>一旦小于0就要舍弃，新的起始位置至少要是j+1</strong></p>
<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><strong>分发糖果</strong></h2><h3 id="贪心1-1"><a href="#贪心1-1" class="headerlink" title="贪心1"></a>贪心1</h3><p>尽可能少的分发糖果，则每个人初始化为1，<code>for</code>循环遍历一次数组，根据当前元素与其前后元素对比，有以下情况</p>
<ul>
<li><p>若一直递增或递减</p>
<ul>
<li><p>当前元素<code>i</code>大于<code>i-1</code>，那么<code>tmp++</code>表示当前分发的糖果数量要比<code>i-1</code>多一个</p>
</li>
<li><p>当前元素<code>i</code>小于<code>i-1</code>，则同样<code>tmp++</code>，只考虑总数量</p>
</li>
</ul>
</li>
<li><p>若遇到转折点，用<code>cur</code>记录当前的趋势，即<code>cur&gt;0</code>表示递增，<code>cur&lt;0</code>递减，<code>cur==0</code>表示第一个值或相等值</p>
<ul>
<li>从<code>cur&gt;=0</code>变成<code>cur&lt;0</code>，<code>tmp</code>重新置为1，<code>tmp++</code>后再加入到总数量中，即在转折点之后应该分发两个糖果</li>
<li>从<code>cur&lt;=0</code>变成<code>cur&gt;0</code>时，<code>tmp</code>就应该置为0，<code>tmp++</code>后再加入到总数量中，因为分数比前一个小，分发的糖果就应该重置为1，同时要区分<code>cur&lt;0</code>和<code>cur==0</code>的情况</li>
</ul>
</li>
</ul>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        int cur = 0;</span><br><span class="line">        for(int i = 0; i &lt; ratings.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i == 0 || ratings[i] == ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = 1;</span><br><span class="line">                res += tmp;</span><br><span class="line">                cur = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &gt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                if(cur &lt;= 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = 1;</span><br><span class="line">                    tmp = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                ++tmp;</span><br><span class="line">                res += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &lt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                if(cur &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = -1;</span><br><span class="line">                    tmp = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(cur == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = -1;</span><br><span class="line">                    tmp = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                ++tmp;</span><br><span class="line">                res += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述忽略了一种特殊情况——<strong>当递增序列转折成递减序列，且递减序列长度大于等于递增序列后，转折点分发的糖果要再随递增序列增加而增加</strong>，因为转折点既属于递增也属于递减序列，<strong>它的糖果数量由两条序列中较长的一条决定</strong></p>
<p>因此，只是记录序列的转折情况是不足够的，**需要同时记录下递增序列<code>inc</code>和递减序列的长度<code>dec</code>**，以及当前序列的长度<code>tmp</code>，也相当于当前应分发的糖果数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        int inc = 0, dec = 0;</span><br><span class="line">        for(int i = 0; i &lt; ratings.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i == 0 || ratings[i] == ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = 1;</span><br><span class="line">                res += tmp;</span><br><span class="line">                inc = 1;</span><br><span class="line">                dec = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &gt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                ++tmp;</span><br><span class="line">                res += tmp;</span><br><span class="line">                dec = 0;</span><br><span class="line">                inc = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &lt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                ++dec;</span><br><span class="line">                if(dec == inc)</span><br><span class="line">                    ++dec;</span><br><span class="line">                res += dec;               </span><br><span class="line">                tmp = 1; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心2-1"><a href="#贪心2-1" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种思路是，分开两次从头至尾和从尾至头遍历数组，分别完成两条规则，从头至尾遍历保证右边分数高的糖果多于左边分数低的，从尾至头遍历保证左边分数高的糖果多于右边分数低的。</p>
<p>贪心算法局部最优在于保证当前糖果数量与上一个的糖果数量满足规则要求，但每次遍历只能满足一条规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        vector&lt;int&gt; can(ratings.size(),1);</span><br><span class="line">        for(int i = 1; i&lt;ratings.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ratings[i]&gt;ratings[i-1])</span><br><span class="line">                can[i] = can[i-1] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = ratings.size()-2; i&gt;= 0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ratings[i] &gt; ratings[i+1])</span><br><span class="line">                can[i] = max(can[i], can[i+1]+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(can.begin(),can.end(),0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>贪心1中思路更直接，但需要考虑的情况会更复杂，需要注意到<strong>转折序列中，递增和递减序列长度对转折点的影响</strong></p>
<p>贪心2分别使用了两次贪心策略，让题目要求更简洁明了</p>
<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><strong>根据身高重建队列</strong></h2><p>本题中，数组<code>[h, k]</code>序号为<code>i</code>，这意味着 身高为<code>h</code>，并且在队列前面还有<code>k</code>个身高高于或等于<code>h</code>的人，要求在于对打乱的<code>i</code>重新排序成正确顺序，使得<code>h</code>和<code>k</code>排列符合规则</p>
<h3 id="贪心-6"><a href="#贪心-6" class="headerlink" title="贪心"></a>贪心</h3><p>在一次遍历中，并不能做到满足两条规则，需要分两步走，根据规则各自使用贪心策略。<strong>首先，对于数组的第0个元素，即身高，排列时的局部最优在于当前身高小于上一个身高，也就是按照降序排列身高</strong>。而对于第1个元素k，根据规则，应当按照升序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a[0] != b[0])</span><br><span class="line">		return a[0] &gt; b[0];</span><br><span class="line">	else</span><br><span class="line">		return a[1] &lt; b[1];</span><br><span class="line">&#125;</span><br><span class="line">sort(people.begin(), people.end(), cmp);</span><br></pre></td></tr></table></figure>

<p>排列过后，数组<code>people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</code>顺序变为<code>[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</code>，可知，根据规则，在空的结果集中插入数组，贪心策略局部最优在于优先插入身高较高（即遍历排列后的数组）且其k较低的，如下插入过程所示，这样可以满足插入后的数组满足要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[7,0]</span><br><span class="line">[7,0],[7,1]</span><br><span class="line">[7,0],[6,1],[7,1]</span><br><span class="line">[5,0],[7,0],[6,1],[7,1]</span><br><span class="line">[5,0],[7,0],[5,2],[6,1],[7,1]</span><br><span class="line">[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]</span><br></pre></td></tr></table></figure>

<p><strong>第二步中的贪心优先处理身高较高的，在较高的排列完成后，就算再插入次高的元素也不会影响排列，依旧符合规则，在插入次高元素时，由于规则要求在此元素之前要有k个身高大于等于其身高的元素，因此，可以直接在位置k插入，使得局部上最优。</strong></p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2)</span><br><span class="line">    &#123;</span><br><span class="line">        if (v1[0] != v2[0])</span><br><span class="line">            return v1[0] &gt; v2[0];</span><br><span class="line">        else</span><br><span class="line">            return v1[1] &lt; v2[1];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(), cmp);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (int i = 0; i &lt; people.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.insert(res.begin() + people[i][1],people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在定义<code>cmp</code>函数时，将其定义为<code>static</code>静态函数是因为在类内定义函数，如果定义成非静态函数，则函数属于类的对象，而非类共有的函数，也就是说会隐式传递了<code>this</code>指针，那么类的对象在调用该函数的时候，就会通过指针隐式传递到函数参数列表中，来区分是哪一个对象调用函数，非静态函数实际参数为<code>bool cmp(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2, Solution* this)</code></strong></p>
<h3 id="贪心优化"><a href="#贪心优化" class="headerlink" title="贪心优化"></a>贪心优化</h3><p>在上一版本中的代码中，借助数组来记录结果，而数组在进行<code>insert</code>操作时，时间复杂度为O(n)，显得并不高效，因此可以借助链表来完成多次的插入操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2)</span><br><span class="line">    &#123;</span><br><span class="line">        if (v1[0] != v2[0])</span><br><span class="line">            return v1[0] &gt; v2[0];</span><br><span class="line">        else</span><br><span class="line">            return v1[1] &lt; v2[1];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(), cmp);</span><br><span class="line">        list&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (int i = 0; i &lt; people.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            auto index = people[i][1];</span><br><span class="line">            auto iter = res.begin();</span><br><span class="line">            while(index--)</span><br><span class="line">            &#123;</span><br><span class="line">                iter++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.insert(iter,people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;vector&lt;int&gt;&gt; (res.begin(),res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在调整迭代器位置时，还可以使用<code>advance</code>标准库函数，<code>advance(it,n)</code>可以让迭代器<code>it</code>往前移动<code>n</code>个位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto index = people[i][1];</span><br><span class="line">auto iter = res.begin();</span><br><span class="line">advance(iter, index);</span><br><span class="line">res.insert(iter, people[i]);</span><br></pre></td></tr></table></figure>

<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>与[上一题](# 分发糖果)比较，都是需要分两步走，把规则拆分成两步再分别使用贪心策略，这一题中最关键点在于在第二步中的贪心策略，<strong>局部最优在于插入一个元素时，只考虑当前规则是要求只有k个值在其前面，因此可以直接插入到第k个位置上，并且插入之后也不会影响已经插入的元素，符合规则</strong></p>
<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><strong>用最少数量的箭引爆气球</strong></h2><p>这道题中，使用数量尽可能少的箭引爆更多的气球，首先，可以用过排序让带有重叠区间的数组分布在一起，而排序则又可以分为两种，分别是根据开始位置和结束位置，对应了不同方向的思路</p>
<h3 id="贪心1-2"><a href="#贪心1-2" class="headerlink" title="贪心1"></a>贪心1</h3><p>按照开始位置来进行排序，定义排序函数，开始位置小的会排在前面，如果开始位置相同，则结束位置更小的排在前面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a[0]==b[0])</span><br><span class="line">		return a[1] &lt; b[1];</span><br><span class="line">	return a[0] &lt; b[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，对于数组<code>[[10,16],[2,8],[1,6],[7,12]]</code>将会排序成<code>[[1,6],[2,8],[7,12],[10,16]]</code>，接着，为了追求最少数量的箭，在区间尽可能排序成重复的基础上，<strong>局部最优在于取重复数组区间的最小的结束位置</strong>，并在该位置上射出弓箭，这样就能尽可能覆盖到更多的不同区间，即引爆更多的气球</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[0]!=b[0])</span><br><span class="line">            return a[0] &lt; b[0];</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        if(points.size()==0)    return 0;</span><br><span class="line">        int res = points.size();</span><br><span class="line">        sort(points.begin(), points.end(),cmp);</span><br><span class="line">        int en = points[0][1];</span><br><span class="line">        for(int i = 1; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(en &gt;= points[i][0]) //有重叠 </span><br><span class="line">            &#123;</span><br><span class="line">                res--;</span><br><span class="line">                en = min(points[i][1], en); </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                en = points[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用一个变量<code>en</code>来记录重复区间结束位置，<code>if(en &gt;= points[i][0])	en = min(points[i][1], en)</code>当遇到有重叠区间时，应对<code>en</code>进行更新，令其等于 <strong>当前区间的结束位置</strong> 和 <strong>原结束位置</strong> 的最小值，而不是直接赋值等于当前区间的结束位置或上一个区间的结束位置。也因为不需要返回原数组，可以在原数组上直接修改结束位置，只需要判断上一个区间的结束位置，并不断对其进行维护<code>points[i][1] = min(points[i-1][1], points[i][1])</code></p>
<h3 id="贪心2-2"><a href="#贪心2-2" class="headerlink" title="贪心2"></a>贪心2</h3><p>另外一种方法是用不同的排序方法，按照区间的结束位置来进行排序，结束位置较小的则排在前面，如果结束位置相同则让开始位置较小的靠前（这一步不影响）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a[1]==b[1])</span><br><span class="line">		return a[0] &lt; b[0];</span><br><span class="line">	return a[1] &lt; b[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种排序下，只需要判断<strong>当前区间的开始位置与重复区间的结束位置是否有重叠</strong>，用<code>en</code>来对重复区间的结束位置进行记录，如果没有则需要增加弓箭的数量，而如果开始位置小于等于上一个区间的结束位置，则无论如何两个区间都会有重叠，并且<strong>有重叠时不用对<code>en</code>进行更新，保持原来的重复区间结束位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        if(points.size()==0)    return 0;</span><br><span class="line">        int res = 1;</span><br><span class="line">        sort(points.begin(), points.end(),cmp);</span><br><span class="line">        int en = points[0][1];</span><br><span class="line">        for(int i = 1; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(en &lt; points[i][0]) //无重叠 </span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                en = points[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>两种排序方法引出两种对重叠区间不同的判断方式，且都是用到了贪心策略，<strong>尽可能让当前区间的开始元素与记录区间的结束元素有重叠，即通过排序再加上尽量去重叠区间的最大值，则可以覆盖到更多区间</strong></p>
<p>第一种排序方式，<strong>按区间的开始位置升序排列</strong>，借助变量<code>en</code>记录有重复区间的结束位置，不论是否有重叠区间，都要对<code>en</code>进行维护，<strong>当有重叠时，<code>en</code>取当前区间的结束位置和原结束位置的最小值</strong>；当没有重叠时，<code>en</code>则取当前区间的结束位置</p>
<p>第二种排序方式，<strong>按区间的结束位置升序排列</strong>，同样借助变量<code>en</code>对重叠区间的结束位置进行记录，因为是根据结束位置进行了排序，<strong>当有重叠时，对<code>en</code>不需要进行维护，因为<code>en</code>的值已经是当前包括之前所有区间的结束位置的最小值</strong>；在没有重叠时，<code>en</code>也同样取当前区间的结束位置</p>
<p>时间复杂度为O(n log n + n)，为排序消耗的时间和遍历数组的时间，空间复杂度为O(log n)，排序所占用的栈空间，最坏情况下为O(n)，需要n次的递归调用</p>
<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>该题与[上一题](# 用最少数量的箭引爆气球)比较相像，都是有关于重叠的区间，而这题要求的是找出导致重叠的区间并将其删除，返回要删除的个数</p>
<h3 id="贪心-7"><a href="#贪心-7" class="headerlink" title="贪心"></a>贪心</h3><p>类似的，首先需要排序，让重叠的区间尽可能靠近，这里按照区间的结束位置升序排列，但对于相同的结束位置的区间，应该考虑到<strong>优先删除开始位置更小的区间</strong>，因为<strong>开始位置小，所覆盖的区间更大，出现与其他区间相互重叠的可能性也更大</strong>。因此遍历顺序应该是先确定区间结束位置更小，并且区间内所覆盖的范围也要更小，当遇到有重叠的区间则应该增加删除的数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[1]==b[1])</span><br><span class="line">            return a[0] &gt; b[0];</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(intervals.size()==1)</span><br><span class="line">            return res;</span><br><span class="line">        sort(intervals.begin(),intervals.end(),cmp);</span><br><span class="line">        int en = intervals[0][1];</span><br><span class="line">        for(int i = 1; i &lt; intervals.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(en &gt; intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                en = intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>该题中，<strong>局部优化在于按照区间的结束位置排序，并且要将范围更小的区间排列在先，是为了占用更小的空间，减少重叠的发生</strong></p>
<p>同样的，这题也可以<strong>按照区间的开始位置排序，这时要将范围更大的区间排列在先，并且是采用从右往左的遍历方式</strong>，也是出于相同的原因</p>
<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><strong>划分字母区间</strong></h2><p>首先看到划分字符串想到的是回溯法，但在这题中并不需要暴力搜索。题目要求的是同一个字母只出现在一个分段中，而且只有分段最多的分法正确</p>
<p>首先需要遍历一次，得到所有字母对应的下标，借助可变数组来保存每个字母最后一次出现的下标位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; hashmap(26);</span><br><span class="line">for(int i = 0; i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	hashmap[s[i]-&#x27;a&#x27;] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="贪心-8"><a href="#贪心-8" class="headerlink" title="贪心"></a>贪心</h3><p>在得到每个字母对应最远的下标后，使用贪心策略，局部最优在于<strong>一个分段尽可能小，但同时还要包含出现过的字母的所有范围</strong>，再对字符串进行遍历，对于一个片段，划分完成时，当前下标与哈希表中字母的最后一次出现的下标位置相同，并且，在遍历的过程中，对<code>tmp</code>更新为 <strong>当前字母的最远距离</strong> 和 <strong>原字母的最远距离</strong> 的较大值，也就是将<code>tmp</code>保持为该片段中含有的字母出现的最大位置或最远距离。也就是说，在一个片段中，划分只与该片段中有最长距离的字母有关，在遍历过程中，不断更新这个字母，当遍历到该字母的最长距离时，即一个片段的划分完成</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; partitionLabels(string s) &#123;</span><br><span class="line">        vector&lt;int&gt; hashmap(26);</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int tmp = 0, count = 1;</span><br><span class="line">        for(int i = 0; i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hashmap[s[i] - &#x27;a&#x27;] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = max(tmp, hashmap[s[i]-&#x27;a&#x27;]);</span><br><span class="line">            if(i==tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count);</span><br><span class="line">                count = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在该题中十分巧妙，贪在<strong>当前片段下，要让片段尽可能小的同时还要保证出现过的字母只在该片段中出现</strong>。这就需要借助哈希表来记录<strong>每个字母最后一次出现的位置</strong>，即它们各自的最大距离；在对字符串遍历过程中，还要维护<strong>保证每个出现过的字母的最远距离</strong>，这个距离就是这个片段长度的<strong>最小长度</strong></p>
<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>该题要求对有重叠的区间进行最大化合并，返回合并后的区间</p>
<p>类似于之前的有关重叠区间题目，该题也是将各区间进行排序后，再使用贪心策略，将尽可能多的区间进行合并</p>
<h3 id="贪心1-3"><a href="#贪心1-3" class="headerlink" title="贪心1"></a>贪心1</h3><p>先按照区间的结束位置升序排列，结束位置较小的排在前面。因为开始位置不影响结果，所以可不给出排序规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于区间数组<code>[[1,10],[2,5],[6,9]]</code>则会排序变为<code>[[2,5],[6,9],[1,10]]</code>，接着，为了能够合并更多的区间，借助变量<code>tmp</code>取值为重叠区间的结束位置，<strong>正向遍历数组</strong>，当遇到<code>tmp &lt; intervals[i][0]</code>时代表没有重叠区间，则直接把该区间加入到结果集中，但当遍历到<code>[1,10]</code>时，该区间已将前面全部区间所包含，导致不正确的原因是遍历方式选择不正确，在该题中，<strong>如果按照区间的结束位置来排列，则遍历顺序应该是从尾到头的逆向遍历</strong></p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 1) return intervals;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int st = intervals[intervals.size()-1][0], en = intervals[intervals.size()-1][1];</span><br><span class="line">        for (int i = intervals.size()-1; i &gt;= 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (st &lt;= intervals[i][1]) // 有重叠</span><br><span class="line">            &#123;</span><br><span class="line">                st = min(st, intervals[i][0]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(vector&lt;int&gt; &#123;st, en&#125;);</span><br><span class="line">                st = intervals[i][0];</span><br><span class="line">                en = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(vector&lt;int&gt; &#123;st,en&#125;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心2-3"><a href="#贪心2-3" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种方式则是<strong>按照开始位置升序排列，此时，应该正向遍历数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[0] &lt; b[0];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 1) return intervals;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int st = intervals[0][0], en = intervals[0][1];</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (en &gt;= intervals[i][0]) // 有重叠</span><br><span class="line">            &#123;</span><br><span class="line">                en = max(intervals[i][1], en);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(vector&lt;int&gt; &#123;st, en&#125;);</span><br><span class="line">                st = intervals[i][0];</span><br><span class="line">                en = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(vector&lt;int&gt; &#123;st,en&#125;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>该题与<a href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4">无重叠区间</a>相比有相反的感觉，都是要找到重叠区间的部分，但后者是优先寻找到范围更小的区间，是为了减少重叠的可能性；而这题是要优先找到范围更大的区间，就是为了要尽可能多的重叠区间。也因此，<strong>要根据不同的目的，针对不同排序方式下选用不同的遍历顺序</strong></p>
<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>该题要求返回小于等于给定输入的尽可能大的数，并且返回值按位非严格递增，如给定<code>98</code>则返回<code>89</code></p>
<h3 id="贪心-9"><a href="#贪心-9" class="headerlink" title="贪心"></a>贪心</h3><p>要求返回的数尽可能大，那么局部最优在于先从低位修改，这也确定了遍历顺序是从右往左，如果<code>num[i]</code>大于<code>num[i+1]</code>，不符合按位递增规则，则<code>num[i]--; num[i+1]=&#39;9&#39;;</code>。但是如果给定输入为<code>1000</code>，只修改为<code>900</code>，而原本应该为<code>999</code>，因此，需要另外借助变量记录开始修改为9的位置，即<code>i+1</code>处，在<code>i+1</code>往后的位置都应该赋值为9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int monotoneIncreasingDigits(int n) &#123;</span><br><span class="line">        string num = to_string(n);</span><br><span class="line">        int flag = num.size();</span><br><span class="line">        for (int i = num.size() - 1; i &gt; 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (num[i -1] &gt; num[i])</span><br><span class="line">            &#123;</span><br><span class="line">                num[i - 1]--;</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = flag; i &lt; num.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i] = &#x27;9&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return stoi(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(log n)，n为输入的数，log n对应其位数，空间复杂度为O(log n)，占用log n的空间来存放数的每一位</p>
<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在于 <strong>为了取到最大值，从数的低位开始修改</strong>，这就确定了从右往左的遍历顺序；还需要有标志位来记录需要变为9的所有位置</p>
<h2 id="买卖股票最佳时机I"><a href="#买卖股票最佳时机I" class="headerlink" title="买卖股票最佳时机I"></a><strong>买卖股票最佳时机I</strong></h2><p>与[同系列的上一题](# 买卖股票最佳时机II)相比，该题还增加了手续费，相当于限制了买卖次数，需要找到除去手续费后的最大利润，而不能像上一题那样无限制买入卖出</p>
<h3 id="贪心-10"><a href="#贪心-10" class="headerlink" title="贪心"></a>贪心</h3><p>思路依旧还是 希望能够在最低点买入，然后在最高点卖出，而因为有了手续费，还会有新的情况需要考虑到：<strong>如何知道当前点是最高点</strong></p>
<p>贪心策略就是用于解决这个问题，首先遍历寻找最低点进行买入，并维护<code>buy = prices[l]+fee</code>，此时<code>l</code>为最低点，如果遍历到该点利润大于零，可以虚拟地卖出了这只股票，利润值增加<code>profit += prices[sh] - buy = prices[sh] - prices[l] -fee</code>，此时<code>sh</code>为次高点，并且已经扣除了手续费，模拟在这个次高点虚拟卖出，同时还要更新买入价格为 <strong>当前股票价格</strong>，即<code>buy = prices[sh]</code>，如此一来，当遍历到下一个点发现股票价格还在上涨时<code>prices[h]&gt;prices[sh]</code>，则又虚拟的假设成在这个最高点上卖出了股票，由于买入价格的更新，利润值更新为<code>profit += prices[h] - buy = prices[h] -prices[sh] </code>，可以看出，根据这时候获得的利润，可以模拟出<strong>最低点买入而在最高点卖出</strong>的过程</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int buy = prices[0] + fee;</span><br><span class="line">        for(int i = 0; i &lt; prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i]+fee &lt; buy)</span><br><span class="line">                buy = prices[i] + fee;</span><br><span class="line">            else if(prices[i] &gt; buy)</span><br><span class="line">            &#123;</span><br><span class="line">                res += prices[i] - buy;</span><br><span class="line">                buy = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>相同思路，而不必将<code>buy</code>维护成最低买入点与手续费的和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int buy = prices[0];</span><br><span class="line">        for(int i = 0; i &lt; prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i] &lt; buy)</span><br><span class="line">                buy = prices[i] ;</span><br><span class="line">            else if(prices[i] &gt; buy + fee)</span><br><span class="line">            &#123;</span><br><span class="line">                res += prices[i] - buy - fee;</span><br><span class="line">                buy = prices[i]-fee;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在该题中体现在 <strong>遇到次高点时虚拟的卖出，更新利润的同时也更新买入价格，即虚拟地在该点买入</strong>，这也是局部最优的所在</p>
<p>遍历数组的时候，会有以下三种情况：</p>
<ul>
<li>该点比买入点更低，则更新买入的最低点</li>
<li>该点比买入点和手续费的和更高，即利润大于0，此时虚拟地卖出，更新利润以及更新买入点，也为后续更高点准备</li>
<li>该点在<code>[低买入点+手续费，高卖出点]</code>范围，即没有利润，则此时不会卖出，不进行任何操作</li>
</ul>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a><strong>监控二叉树</strong></h2><p>题目要求添加最少的监控，覆盖到所有的二叉树结点</p>
<p>一开始，想到根据父结点的值来判断当前结点是否需要添加监控，如果父结点值为0，则为当前结点添加监控；反之亦然。同时使用层序迭代遍历二叉树即可完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1;</span><br><span class="line">        int res = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;//还要存父结点</span><br><span class="line">        //层序遍历</span><br><span class="line">        TreeNode* pre, *cur;</span><br><span class="line">        que.push(nullptr);</span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i = 0; i &lt; que.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pre = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line"></span><br><span class="line">                if(pre &amp;&amp; pre-&gt;val == 0 &amp;&amp; (cur-&gt;left||cur-&gt;right))</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    cur-&gt;val = 1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(cur-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(cur);</span><br><span class="line">                    que.push(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(cur-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(cur);</span><br><span class="line">                    que.push(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然而，这种方法下，当遇到的二叉树<strong>添加监控的结点的孙子结点是叶子结点时，则无法做到监控的全覆盖</strong></p>
<h3 id="贪心-11"><a href="#贪心-11" class="headerlink" title="贪心"></a>贪心</h3><p>采用贪心策略，局部最优在于<strong>为了添加的监控数量最少，则只给叶子结点的父结点添加监控</strong></p>
<p>针对以上，结点值会有三种状态：<strong>0表示无覆盖，1表示有监控，2表示被覆盖</strong>。增加结点值为 2 是为了方便表示叶子结点等的状态，进而，二叉树的遍历顺序应为<strong>后序遍历</strong>，先遍历子结点再遍历中间结点，由下至上的遍历顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(TreeNode* node, int&amp; res)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node)		//遇到空结点应返回2</span><br><span class="line">			return 2;</span><br><span class="line">		int l = dfs(node-&gt;left, res);</span><br><span class="line">		int r = dfs(node-&gt;right, res);</span><br><span class="line">		</span><br><span class="line">		if(l == 2 &amp;&amp; r == 2)</span><br><span class="line">         	return 0;</span><br><span class="line">         if(l == 0 || r == 0)</span><br><span class="line">         &#123;</span><br><span class="line">         	res++;</span><br><span class="line">         	return 1;</span><br><span class="line">         &#125;</span><br><span class="line">         if(l == 1 || r == 1)</span><br><span class="line">         	return 2;</span><br><span class="line">         </span><br><span class="line">         return -1;</span><br><span class="line">	&#125;</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(dfs(root, res) == 0)</span><br><span class="line">        	res++;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(log n)，最坏情况下为O(n)</p>
<p>因为后序遍历中，中间结点的处理情况需要用到其左右子结点的值来判断，因此，<strong>将当前结点的值作为递归函数的返回值</strong>。</p>
<p>根据左右子结点的值来判断当前当前结点的值，有四种情况：</p>
<ul>
<li>左右子结点都是有覆盖，则当前结点返回0，表示无覆盖</li>
<li>左右子结点有任意一个无覆盖，则当前结点应添加监控，返回1</li>
<li>左右子结点有任意一个有监控，则当前结点返回2，表示有覆盖</li>
<li>在对除根结点外的所有结点遍历结束后，对于根结点，可能会出现根结点未覆盖的情况，因此还需要对根结点的返回值进行一次判断，若返回0则需要再添加一个监控</li>
</ul>
<h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>该题中局部最优在于 <strong>不让叶子结点添加监控，而让叶子结点的父结点添加监控</strong>，在此基础上，推导出3种不同结点值的状况，并进行分类讨论</p>
<h2 id="通过最少操作次数使数组的和相等"><a href="#通过最少操作次数使数组的和相等" class="headerlink" title="通过最少操作次数使数组的和相等"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/">通过最少操作次数使数组的和相等</a></strong></h2><p>该题给定两个数组，限定数组元素值均为1~6，任意修改数组元素，使得两个数组和相等，返回操作次数</p>
<h3 id="贪心-12"><a href="#贪心-12" class="headerlink" title="贪心"></a>贪心</h3><p>采用贪心策略，局部最优在于优先让数组和大的数组元素改为1，数组和小的数组元素改为6，最快速逼近两个数组的和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        int n1 = nums1.size();</span><br><span class="line">        int n2 = nums2.size();</span><br><span class="line">        if(n1*6 &lt; n2 || n2 * 6 &lt; n1 )</span><br><span class="line">            return -1;</span><br><span class="line">        int sub = accumulate(nums1.begin(), nums1.end(),0)-accumulate(nums2.begin(), nums2.end(),0);</span><br><span class="line">        if(sub &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums1, nums2);</span><br><span class="line">            sub = -sub;</span><br><span class="line">        &#125;</span><br><span class="line">        //要求nums1 减小， nums2 增大</span><br><span class="line">        vector&lt;int&gt; cnt(6);</span><br><span class="line">        for(auto n:nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[n-1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto n:nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[6-n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 5, res = 0;;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i*cnt[i] &gt;= sub)</span><br><span class="line">                return res + (sub+i-1)/i;</span><br><span class="line">            res += cnt[i];</span><br><span class="line">            sub -= i*cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>让<code>nums1</code>的和比<code>nums2</code>的和大，即让<code>nums1</code>减小，<code>让nums2</code>增大；</p>
<p>分别遍历两个数组，借助<code>vector</code>容器记录两个数组中能够减小或增大的最大范围，如<code>cnt[4]</code>含义是数组中原始值为5或者为2的元素有<code>cnt[4]</code>个；</p>
<p>最后遍历<code>vector</code>容器，若当前减小或增大的最大范围能够覆盖两个数组的和的差，即<code>i*cnt[i] &gt;= sub</code>，意味着仅需要对当前<code>cnt[i]</code>个元素减小或增大<code>i</code>就能够让两个数组的和相等，否则，因为遍历顺序优先遍历修改范围更大的元素，所以先让这些元素对数组差进行填补，再遍历更小范围的元素；</p>
<p>返回值中<code>return res + (sub+i-1)/i;</code>而不是直接返回<code>return res + sub / i;</code>，若<code>sub</code>不能整除<code>i</code>，直接返回会有余数导致结果偏小不正确，若返回<code>return res + sub / i + 1</code>，此时若<code>sub</code>能整除<code>i</code>，没有余数又导致结果偏大不正确。因此<code>sub + i - 1</code>向上取整解决了这个问题</p>
<h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>局部最优在于<strong>优先让数组中修改范围更大的元素进行修改，以最快速度填补数组和之差</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/11/09/C3P%E7%AC%AC%E4%B8%89%E3%80%81%E5%9B%9B%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/09/C3P%E7%AC%AC%E4%B8%89%E3%80%81%E5%9B%9B%E9%83%A8%E5%88%86/" class="post-title-link" itemprop="url">C3P第三部分</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-09 21:46:25" itemprop="dateCreated datePublished" datetime="2022-11-09T21:46:25+08:00">2022-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-09 17:15:48" itemprop="dateModified" datetime="2023-03-09T17:15:48+08:00">2023-03-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是<strong>自身类类型的引用</strong>，且任何额外参数都有默认值，则此构造函数是<strong>拷贝构造函数</strong></p>
<p>合成拷贝构造函数可以用来阻止拷贝该类类型的对象</p>
<p><code>class Foo&#123; public: Foo(const Foo&amp;); &#125;</code></p>
<p><strong>合成的拷贝构造函数</strong>：会将参数的成员逐个拷贝到正在创建的对象中，内置类型直接拷贝，虽然不能直接拷贝一个数组，但会逐个元素进行拷贝，类类型则使用元素的拷贝函数</p>
<p>拷贝初始化通常使用拷贝构造函数来完成</p>
<ul>
<li>用<code>=</code>定义变量时。</li>
<li>将一个对象作为实参传递给一个非引用类型的形参。</li>
<li>从一个返回类型为非引用类型的函数返回一个对象。</li>
<li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。</li>
</ul>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>赋值运算符通常返回一个指向其左侧运算对象的引用</p>
<p>合成拷贝赋值运算符可以用来禁止该类型对象的赋值</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数释放对象使用的资源，并销毁对象的非static数据成员，析构函数不接受参数，没有返回值</p>
<p>在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。析构函数体本身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的</p>
<p><strong>当指向一个对象的引用或指针离开作用域时，析构函数不会执行</strong></p>
<p>合成析构函数可以用来阻止该类型的对象被销毁</p>
<h3 id="三-x2F-五法则"><a href="#三-x2F-五法则" class="headerlink" title="三&#x2F;五法则"></a>三&#x2F;五法则</h3><ul>
<li>需要析构函数的类也需要拷贝和赋值操作</li>
<li>需要拷贝操作的类也需要赋值操作，反之亦然</li>
</ul>
<h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用<code>=default</code></h3><p>类内使用<code>=default</code>修饰成员的声明时，隐式声明了该成员为内联的</p>
<p>如果不希望合成的成员是内联函数，则应该对其类外定义使用<code>=default</code></p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><ul>
<li>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。</li>
<li>定义删除的函数：<code>=delete</code> ，虽然声明了它们，但是不能以任何方式使用它们。</li>
<li>析构函数不能是删除的成员。</li>
<li>如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的</li>
<li>对于具有引用或无法默认构造的<code>const</code>成员的类，编译器不会为其合成默认构造函数。如果具有引用成员的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍指向与赋值前一样的对象，因此对于有引用成员的类，合成拷贝赋值运算符也被定义为删除的</li>
</ul>
<h3 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h3><p>通常，管理类外资源的类必须定义拷贝控制成员</p>
<ul>
<li><p>类的行为像值：对象有自己的状态，副本和原对象是完全独立的</p>
<p>如果将一个对象赋予它自身，赋值运算符必须能正确工作；大多数赋值运算符组合了析构函数和拷贝构造函数的工作</p>
</li>
<li><p>行为像指针：共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据</p>
</li>
</ul>
<p>IO类型和<code>unique_ptr</code>不允许拷贝或赋值，因此它们的行为不像值也不像指针</p>
<h3 id="HasPtr程序"><a href="#HasPtr程序" class="headerlink" title="HasPtr程序"></a><strong><code>HasPtr</code>程序</strong></h3><p>定义行为像值的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr&#123;</span><br><span class="line">public:</span><br><span class="line">	HasPtr(const string&amp; s = string()): ps(new string(s)), i(0) &#123;&#125;</span><br><span class="line">	//拷贝构造</span><br><span class="line">	HasPtr(const HasPtr&amp; p): ps(new string(*p.ps)), i(p.i) &#123;&#125;</span><br><span class="line">	//拷贝赋值运算符</span><br><span class="line">	HasPtr&amp; operator=(const HasPtr&amp; hp)&#123;</span><br><span class="line">		auto tmp = new string(*hp.ps);</span><br><span class="line">		delete ps;</span><br><span class="line">		ps = tmp;</span><br><span class="line">		i = hp.i;</span><br><span class="line">		return *this;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	//析构函数</span><br><span class="line">	~HasPtr() &#123;</span><br><span class="line">		if(--*use==0)&#123;</span><br><span class="line">			delete ps;</span><br><span class="line">			delete use;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	string* ps;</span><br><span class="line">	int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>定义行为像指针的类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr&#123;</span><br><span class="line">public:</span><br><span class="line">	HasPtr(const string&amp; s = string()): ps(new string(s)), i(0), use(new size_t(1)) &#123;&#125;</span><br><span class="line">	//拷贝构造</span><br><span class="line">	HasPtr(const HasPtr&amp; p): ps(p.ps), i(p.i), use(p.use) &#123;++*use;&#125;</span><br><span class="line">	//拷贝赋值运算符</span><br><span class="line">	HasPtr&amp; operator=(const HasPtr&amp; hp)</span><br><span class="line">	&#123;</span><br><span class="line">		++*hp.use;</span><br><span class="line">		if(--*use==0)</span><br><span class="line">		&#123;</span><br><span class="line">			delete ps;</span><br><span class="line">			delete use;</span><br><span class="line">		&#125;</span><br><span class="line">		ps = hp.ps;</span><br><span class="line">		i = hp.i;</span><br><span class="line">		use = hp.use;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//析构函数</span><br><span class="line">	~HasPtr() &#123;delete ps;&#125;</span><br><span class="line">private:</span><br><span class="line">	string* ps;</span><br><span class="line">	int i;</span><br><span class="line">	//引用计数，记录有多少对象共享相同的string</span><br><span class="line">	size_t *use;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h3><p>除了定义拷贝控制成员，管理资源的类通常还定义一个名为<code>swap</code>的函数。拷贝一个类值的<code>HasPtr</code>会分配一个新<code>string</code>并将其拷贝到<code>HasPtr</code>指向的位置，理论上这些内存分配是不必要的，因为可以只交换指针</p>
<p>类值版本下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr&#123;</span><br><span class="line">friend void swap(HasPtr&amp;, HasPtr&amp;);</span><br><span class="line">public:</span><br><span class="line">	HasPtr(const string&amp; s = string()): ps(new string(s)), i(0) &#123;&#125;</span><br><span class="line">	//拷贝构造</span><br><span class="line">	HasPtr(const HasPtr&amp; p): ps(new string(*p.ps)), i(p.i) &#123;&#125;</span><br><span class="line">	//拷贝赋值运算符</span><br><span class="line">	HasPtr&amp; operator=(const HasPtr&amp; hp)&#123;</span><br><span class="line">		++*hp.use;</span><br><span class="line">		if(--*use==0)</span><br><span class="line">		&#123;</span><br><span class="line">			delete ps;</span><br><span class="line">			delete use;</span><br><span class="line">		&#125;</span><br><span class="line">		ps = hp.ps;</span><br><span class="line">		i = hp.i;</span><br><span class="line">		use = hp.use;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//析构函数</span><br><span class="line">	~HasPtr() &#123;</span><br><span class="line">		if(--*use==0)&#123;</span><br><span class="line">			delete ps;</span><br><span class="line">			delete use;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	string* ps;</span><br><span class="line">	int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline </span><br><span class="line">void swap(HasPtr&amp; lhs, HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	swap(lhs.ps,rhs.ps);</span><br><span class="line">	swap(lhs.i,rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于三个<code>swap</code>参数类型不同， 不会导致递归循环，<code>swap</code>函数应该调用特定版本的<code>swap</code>而不是<code>std::swap</code></p>
<h3 id="在赋值运算符中使用swap"><a href="#在赋值运算符中使用swap" class="headerlink" title="在赋值运算符中使用swap"></a>在赋值运算符中使用<code>swap</code></h3><p><strong>定义swap的类通常用swap来定义它们的赋值运算符</strong>，使用<strong>拷贝并交换</strong>的技术</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::operator=(HasPtr hp)</span><br><span class="line">&#123;</span><br><span class="line">	swap(*this, hp);</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数不是引用，传入的是右侧运算对象的一个副本，交换副本与<code>*this</code>中的数据成员，<code>*this</code>将指向新分配的<code>string</code>——右侧运算对象中<code>string</code>的一个副本，当赋值运算符结束时，<code>hp</code>将被销毁，析构函数<code>delete</code>掉<code>hp</code>指向的内存，即原来左侧运算对象的内存。并且，它自动处理了自赋值情况，通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确</p>
<h3 id="拷贝控制示例"><a href="#拷贝控制示例" class="headerlink" title="拷贝控制示例"></a>拷贝控制示例</h3><p>两个类通过拷贝控制进行簿记操作，<code>Message</code>和<code>Folder</code>分别表示电子邮件消息和消息目录，每个<code>Message</code>对象可以出现在多个<code>Folder</code>中，每个<code>Folder</code>中记录其中的所有<code>Message</code>对象</p>
<p>在<code>Message</code>中保存一个它所在<code>Folder</code>的指针的<code>set</code>，每个<code>Folder</code>中保存它包含的<code>Message</code>的指针的<code>set</code>。<code>Message</code>类提供<code>save</code>和<code>remove</code>操作，用于创建或删除一个对象时与<code>Folder</code>相关联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">class Folders;</span><br><span class="line">class Message&#123;</span><br><span class="line">	friend class Folder;</span><br><span class="line">	friend void swap(Message&amp;,Message&amp;);</span><br><span class="line">public:</span><br><span class="line">	//不允许隐式转换</span><br><span class="line">	explicit Message(const string&amp; s = &quot;&quot;): contents(s) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	//拷贝构造函数</span><br><span class="line">	Message(const Message&amp; me): contents(me.contents), folders(me.folders)</span><br><span class="line">	&#123;</span><br><span class="line">		//但是在每个folder上并没有更新刚拷贝的Message对象</span><br><span class="line">		for(auto f:folders)</span><br><span class="line">		&#123;</span><br><span class="line">			f-&gt;addMsg(this);//调用Folder类中的函数添加Message指针</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//拷贝赋值运算符</span><br><span class="line">	Message&amp; operator=(const Message&amp; me)</span><br><span class="line">	&#123;</span><br><span class="line">		//为了自赋值操作正常，先删除原有的指针，再进行添加</span><br><span class="line">		//如果非自赋值，this为空，则不删除；不为空，则需要删除原有的关联再拷贝赋值</span><br><span class="line">		for(auto f:folders)</span><br><span class="line">		&#123;</span><br><span class="line">			f-&gt;remMsg(this);//调用Folder类中的函数删除Message指针</span><br><span class="line">		&#125;</span><br><span class="line">		contents = me.contents;</span><br><span class="line">		folders = me.folders;</span><br><span class="line">		for(auto f:folders)</span><br><span class="line">		&#123;</span><br><span class="line">			f-&gt;addMsg(me);</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//析构函数</span><br><span class="line">	~Message()</span><br><span class="line">	&#123;</span><br><span class="line">		for(auto f:folders)</span><br><span class="line">		&#123;</span><br><span class="line">			f-&gt;remMsg(this);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void save(Folder &amp;f)</span><br><span class="line">	&#123;</span><br><span class="line">		folders.insert(&amp;f);</span><br><span class="line">		f-&gt;addMsg(this);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void remove(Folder &amp;f)</span><br><span class="line">	&#123;</span><br><span class="line">		folders.erase(&amp;f);</span><br><span class="line">		f-&gt;remMsg(this);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void addFldr(Folder *f) &#123; folders.insert(f); &#125;</span><br><span class="line">    void remFldr(Folder *f) &#123; folders.erase(f); &#125;</span><br><span class="line">private:</span><br><span class="line">	string contents;		//保存消息文本</span><br><span class="line">	set&lt;Folder*&gt; folders;	//保存包含该消息的Folder指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void swap(Message&amp; lme, Message&amp; rme)</span><br><span class="line">&#123;</span><br><span class="line">	for(auto f:lme.folders)</span><br><span class="line">	&#123;</span><br><span class="line">		f-&gt;remMsg(lme);</span><br><span class="line">	&#125;</span><br><span class="line">	for(auto f:rme.folders)</span><br><span class="line">	&#123;</span><br><span class="line">		f-&gt;remMsg(rme);</span><br><span class="line">	&#125;</span><br><span class="line">	swap(lme.contents,rme.contents);</span><br><span class="line">	swap(lme.folders,rme.folders);</span><br><span class="line">	for(auto f:lme.folders)</span><br><span class="line">	&#123;</span><br><span class="line">		f-&gt;addMsg(lme);</span><br><span class="line">	&#125;</span><br><span class="line">	for(auto f:rme.folders)</span><br><span class="line">	&#123;</span><br><span class="line">		f-&gt;addMsg(rme);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于拷贝构造函数和拷贝赋值运算符，都需要实现已关联的<code>folders</code>进行更新，因为是拷贝，所以要在每个与原<code>Message</code>对象有关联的<code>Folder</code>对象都增加与新拷贝得到的<code>Message</code>对象进行关联，同理删除也是。另外，拷贝赋值运算符需要额外删除关联，是为了自赋值情况能正常运行，非</p>
<p>[TOC]</p>
<p>自赋值情况下，也需要让原对象删除原有的关联，如果为空则不删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Folders&#123;</span><br><span class="line">	friend class Message;</span><br><span class="line">	friend void swap(Folders&amp;, Folders&amp;);</span><br><span class="line">public:</span><br><span class="line">	Folder() = default;</span><br><span class="line">	Folder(const Folder &amp;);</span><br><span class="line">	Folder&amp; operator=(const Folder &amp;);</span><br><span class="line">	~Folder();</span><br><span class="line">private:</span><br><span class="line">	set&lt;Message*&gt; msgs;</span><br><span class="line">	</span><br><span class="line">	void add_to_Message(const Folder&amp;);</span><br><span class="line">	void remove_from_Message();</span><br><span class="line"></span><br><span class="line">	void addMsg(Message *m) &#123; msgs.insert(m); &#125;</span><br><span class="line">	void remMsg(Message *m) &#123; msgs.erase(m); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void swap(Folders&amp; lf, Folders&amp; rf)</span><br><span class="line">&#123;</span><br><span class="line">	lf.remove_from_Message();	</span><br><span class="line">	rf.remove_from_Message();</span><br><span class="line">	</span><br><span class="line">	swap(lf.msgs,rf.msgs);</span><br><span class="line">	</span><br><span class="line">	lf.add_to_Message();</span><br><span class="line">	rf.add_to_Message();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Folders::add_to_Message(const Folder&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">	for(auto m: f.msgs)</span><br><span class="line">	&#123;</span><br><span class="line">		m-&gt;folders.insert(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Folders::remove_from_Message()</span><br><span class="line">&#123;</span><br><span class="line">	for(auto m: msgs)</span><br><span class="line">	&#123;</span><br><span class="line">		m-&gt;folders.erase(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Folder::Folder(const Folder&amp; f): msgs(f.msgs)</span><br><span class="line">&#123;</span><br><span class="line">	add_to_Message(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Folder::~Folder() </span><br><span class="line">&#123; </span><br><span class="line">    remove_from_Message(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Folder &amp;Folder::operator=(const Folder &amp;rhs) </span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Message();</span><br><span class="line">    msgs = rhs.msgs;</span><br><span class="line">    add_to_Message(rhs);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Folder</code>类封装了对<code>set</code>中每个<code>Message</code>对象添加和删除该<code>folder</code>对象的函数，减少代码冗余，其余与<code>Message</code>类一致</p>
<p>在以上两种类的拷贝赋值运算符中，都没有使用到拷贝并交换技术，是因为此技术适用在有动态内存分配情况下，如<code>HasPtr</code>的类值实现，否则会增加复杂度</p>
<h3 id="动态内存管理类程序"><a href="#动态内存管理类程序" class="headerlink" title="动态内存管理类程序"></a><strong>动态内存管理类程序</strong></h3><p>定义一个类似于<code>vector</code>的类，需要自己进行内存分配，就要定义拷贝控制成员来管理内存，这个类只用于<code>string</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class StrVec&#123;</span><br><span class="line">public:</span><br><span class="line">	StrVec(): elements(nullptr), first_free(nullptr), cap(nullptr) &#123;&#125;</span><br><span class="line">	StrVec(const StrVec&amp;);				 //拷贝构造函数</span><br><span class="line">	StrVec&amp; operator=(const StrVec&amp;);	  //拷贝赋值运算符</span><br><span class="line">	~StrVec();							//析构函数</span><br><span class="line">	</span><br><span class="line">	void push_back(const string&amp;);</span><br><span class="line">	size_t size() const &#123;return first_free - elements;&#125;</span><br><span class="line">	size_t capacity() const &#123;return cap - first_free;&#125;</span><br><span class="line">	string* begin() const &#123;return elements;&#125;</span><br><span class="line">	string* end() const &#123;return first_free;&#125;</span><br><span class="line">private:</span><br><span class="line">	static allocator&lt;string&gt; alloc;</span><br><span class="line">	pair&lt;string*, string*&gt; alloc_n_copy(const string*, const string*);</span><br><span class="line">	void free();</span><br><span class="line">	void chk_n_alloc() &#123;if(size==capacity()) reallocate();&#125;</span><br><span class="line">	void reallocate();</span><br><span class="line">	</span><br><span class="line">	string* elements;		//指向数组开头</span><br><span class="line">	string* first_free;		//指向数组最后一个元素的后一个位置</span><br><span class="line">	string* cap;			//指向分配的内存的后一个位置</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>alloc</code>是一个静态成员，类型是<code>allocator&lt;string&gt;</code>，能够分配<code>StrVec</code>的内存</li>
<li><code>alloc_n_copy</code>会分配内存，并拷贝一个给定范围中的元素</li>
<li><code>free</code>会销毁构造的元素并释放内存</li>
<li><code>chk_n_alloc_</code>保证<code>StrVec</code>至少有容纳一个新元素的空间，如果没有则调用<code>reallocate</code>分配更多内存</li>
<li><code>reallocate</code>在内存用完时为<code>StrVec</code>分配新内存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void StrVec::push_back(const string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	chk_n_alloc();</span><br><span class="line">	//确保有足够空间容纳新元素</span><br><span class="line">	alloc.construct(first_free++, s);</span><br><span class="line">	//a.construct(p,args)  p是一个指针指向原始内存，在p指向的内存中用args构造一个对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>allocator</code>分配内存时，内存是<strong>未构造</strong>的，需要用<code>construct</code>函数在此内存中构造一个对象，同时<code>first_free</code>指针往后递增一位，指向下一个未构造的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string*, string*&gt; StrVec::alloc_n_copy(const string&amp; ls, const string&amp; rs)</span><br><span class="line">&#123;</span><br><span class="line">	auto data = alloc.allocate(rs - ls);</span><br><span class="line">	return &#123;data, unitialized_copy(ls, rs, data)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rs - ls</code>尾后指针减去首元素指针得出元素空间大小，传给<code>allocate</code>函数返回所分配空间的首地址，<code>unitialzed_copy</code>由<code>ls</code>和<code>rs</code>之间的元素拷贝到<code>data</code>起始的内存中，返回最后一个构造元素之后的位置，即返回的<code>pair</code>由新构建的首元素指针和尾后指针组成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void StrVec::free()</span><br><span class="line">&#123;</span><br><span class="line">	if(elements)</span><br><span class="line">	&#123;</span><br><span class="line">		for(auto p = first_free;p!=elements;p--)</span><br><span class="line">			alloc.destory(elements);</span><br><span class="line">		alloc.deallocate(element, cap - elements);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用for_each实现的free()</span><br><span class="line">for_each(elements, first_free, [this](std::string &amp;rhs)&#123; alloc.destroy(&amp;rhs); &#125;);</span><br></pre></td></tr></table></figure>

<p><code>destroy</code>会执行<code>string</code>的析构函数，释放<code>string</code>自己分配的内存空间。当元素销毁后，要调用<code>deallocate</code>函数释放<code>StrVec</code>分配的内存空间，传递的必须是<strong>之前<code>allocate</code>调用所返回的指针</strong>，因此在调用前应<strong>先对指针判空</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(const StrVec&amp; sv)</span><br><span class="line">&#123;</span><br><span class="line">	auto data = alloc.allocate(sv.begin(), sv.end());</span><br><span class="line">	elements = data-&gt;first;</span><br><span class="line">	first_free = data-&gt;second;</span><br><span class="line">	cap = data-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在拷贝构造函数中直接调用<code>alloc_n_copy</code>，返回值是一个指针的<code>pair</code>，<code>first</code>指向的是第一个构造的元素，<code>second</code>指向的是最后一个元素之后的位置，由于<code>alloc_n_copy</code>分配的空间是刚好容纳给定的元素，所以<code>cap</code>也是在最后一个元素之后的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//析构函数直接调用free()</span><br><span class="line">StrVec::~StrVec()</span><br><span class="line">&#123;</span><br><span class="line">	free();</span><br><span class="line">&#125;</span><br><span class="line">//拷贝赋值运算符</span><br><span class="line">StrVec&amp; StrVec::operator=(const StrVec&amp; sv)</span><br><span class="line">&#123;</span><br><span class="line">	auto data = alloc_n_copy(sv.begin(),sv.end());</span><br><span class="line">	free();</span><br><span class="line">	elements = data.first;</span><br><span class="line">	cap = first_free = data.second;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样地，拷贝赋值运算符也调用<code>alloc_n_copy</code>函数来初始化指针，为了排除赋值左边对象初始值的影响，要先调用<code>free()</code>函数对原对象进行析构，为了正确处理<strong>自赋值</strong>的情况，**<code>free</code>要在调用<code>alloc_n_copy</code>之后调用**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void StrVec::reallocate()</span><br><span class="line">&#123;</span><br><span class="line">	auto newcapacity = size()? 2 * size() : 1;</span><br><span class="line">    auto data = alloc.allocate(newcapacity);</span><br><span class="line">    auto elem = data;</span><br><span class="line">    auto ori = elements;</span><br><span class="line">    for(size_t i = 0; i != size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	alloc.construct(elem++, std::move(*ori++));</span><br><span class="line">    &#125;</span><br><span class="line">    free();</span><br><span class="line">    elements = data;</span><br><span class="line">    first_free = elem;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先确定重新分配内存的大小，新分配的容量加倍，如果原对象为空，则分配容纳一个元素的空间。在for循环中，使用<code>construct</code>构建新的<code>string</code>对象，同时用<code>elem</code>表示初始内存的地址并将其不断递增，第二个参数调用<code>move</code>，返回值将会使得<code>construct</code>使用<code>string</code>的移动构造函数，那么这些<code>string</code>管理的内存<strong>将不会被拷贝</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(const initializer_list&lt;string&gt;&amp; il)</span><br><span class="line">&#123;</span><br><span class="line">	auto data = alloc_n_copy(il.begin(), il.end());</span><br><span class="line">	elements = data.first;</span><br><span class="line">	cap = first_free = data.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>StrVec</code> 类添加一个构造函数，它接受一个 <code>initializer_list&lt;string&gt;</code> 参数，可以直接调用<code>alloc_n_copy</code>函数</p>
<h3 id="手撕string实现代码"><a href="#手撕string实现代码" class="headerlink" title="手撕string实现代码"></a><a target="_blank" rel="noopener" href="https://github.com/chenshuo/recipes/blob/fcf9486f5155117fb8c36b6b0944c5486c71c421/string/StringTrivial.h">手撕string实现代码</a></h3><h3 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h3><p>[TOC]</p>
<p>很多拷贝操作后，原对象会被销毁，因此引入移动操作可以大幅度提升性能</p>
<p>标准库容器、<code>string</code>和<code>shared_ptr</code>类既可以支持移动也支持拷贝。<code>IO</code>类和<code>unique_ptr</code>类可以移动但不能拷贝。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>通过<code>&amp;&amp;</code>获得右值引用，只能绑定到一个将要销毁的对象，常规引用可以称之为左值引用。左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值</p>
<ul>
<li><strong>返回左值引用的函数</strong>，以及<strong>赋值、下标、解引用</strong>和<strong>前置递增递减运算符</strong>，可以将左值引用绑定这类返回左值表达式</li>
<li><strong>返回非引用的函数</strong>，以及<strong>算术、关系、位</strong>和<strong>后置递增递减运算符</strong>，不能用左值引用绑定，但可以用**<code>const</code>的左值引用或一个右值引用绑定**</li>
</ul>
<p>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象</p>
<p>不能将一个右值引用绑定到一个右值引用类型的变量上</p>
<p><code>int &amp;&amp; rr1 = 42;</code></p>
<p><code>int &amp;&amp; rr2 = rr1;	//错误，rr1是左值</code></p>
<p><strong>move函数</strong>：</p>
<ul>
<li><code>int &amp;&amp;rr3 = std::move(rr1);</code></li>
<li><code>move</code>告诉编译器，我们有一个左值，但我希望像右值一样处理它。</li>
<li>调用<code>move</code>意味着：除了对<code>rr1</code>赋值或者销毁它外，我们将不再使用它。</li>
</ul>
<h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>类似于拷贝构造函数，移动构造函数的第一个参数是该类类型的<strong>右值引用</strong>，其余额外的参数都必须有默认实参</p>
<p>一旦资源完成移动，源对象必须不再指向被移动的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec&amp;&amp; s) noexcept</span><br><span class="line">	: elements(s.elements), first_free(s.first_free), cap(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">	s.element = first_free = cap = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动构造函数<strong>接管给定的<code>StrVec</code>中的内存</strong>，将给定对象中的指针都置为<code>nullptr</code>，移后源对象会被销毁，将在其上运行析构函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::operator=(StrVec &amp;&amp;sv) noexcept</span><br><span class="line">&#123;</span><br><span class="line">	if(*this!=sv)</span><br><span class="line">	&#123;</span><br><span class="line">		free();</span><br><span class="line">		elements = sv.elements;</span><br><span class="line">		first_free = sv.elements;</span><br><span class="line">		cap = sv.cap;</span><br><span class="line">		sv.elements = sv.first_free = sv.cap = nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于自赋值情况，<strong>移动赋值运算符通常会先检查this指针与sv的地址是否相同</strong>，如果相同，右侧和左侧对象指向相同的对象，则不做任何事直接返回该<code>StrVec</code>对象；否则，释放左侧运算对象的内存，并接管右侧对象的内存，最后再将右侧对象的指针置为<code>nullptr</code></p>
<p>只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员（非static）都能移动时，编译器才会为它合成移动构造函数或移动赋值运算符</p>
<p>有类成员<strong>定义了自己的拷贝构造函数且未定义移动构造函数</strong>，或者类成员定义自己的拷贝构造函数且编译器不能为其合成移动构造函数，那么合成的移动操作定义为删除</p>
<p>定义了移动操作的类也必须定义自己的拷贝操作，否则，合成拷贝操作都被默认定义为删除的</p>
<p>对于既有移动构造函数，也有拷贝构造函数的类，将会<strong>移动右值，拷贝左值</strong>，但如果没有移动构造函数，<strong>右值也会被拷贝</strong></p>
<h3 id="拷贝并交换赋值运算符和移动操作"><a href="#拷贝并交换赋值运算符和移动操作" class="headerlink" title="拷贝并交换赋值运算符和移动操作"></a>拷贝并交换赋值运算符和移动操作</h3><p>[如前所示](# 在赋值运算符中使用<code>swap</code>)，非引用参数意味着参数要进行拷贝初始化，对于左值将被拷贝，而右值则会被移动，因此，<strong>单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符</strong></p>
<p><code>hp = hp2;</code></p>
<p><code>hp = std::move(hp2);</code></p>
<p>第一个赋值，右侧运算对象是一个左值，因此将使用拷贝构造函数来初始化；第二个赋值，调用<code>std::move</code>将一个右值引用绑定到<code>hp2</code>上，移动构造函数是精准匹配的，因此，将用移动构造函数拷贝指针，而不分配任何内存</p>
<p>但是，<code>haspt</code>会执行两次的拷贝，一次在调用<code>move</code>函数，另一次在移动赋值运算符拷贝给<code>this</code>指针；而对于普通的移动构造版本，则只会执行一次拷贝</p>
<h3 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h3><p>移动迭代器的解引用运算符生成一个右值引用</p>
<p><code>make_move_iterator</code>函数讲一个普通迭代器转换为一个移动迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void StrVec::reallocate()</span><br><span class="line">&#123;</span><br><span class="line">	auto newcapacity = size()? 2 * size() : 1;</span><br><span class="line">    auto data = alloc.allocate(newcapacity);</span><br><span class="line">    auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), data);</span><br><span class="line">    free();</span><br><span class="line">    elements = data;</span><br><span class="line">    first_free = last;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[原版本](# 动态内存管理类程序)中使用一个<code>for</code>循环来调用<code>construct</code>从旧内存将元素拷贝到新内存中。作为一种替换，将使用<code>uninitialized_copy</code>来构造新分配的内存，传入的是移动迭代器，解引用运算生成符生成的是一个右值引用，意味着<code>construct</code>将使用移动构造函数来构造元素</p>
<h3 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h3><p>区分移动和拷贝的重载函数通常有一个版本接受一个<code>cosnt T&amp;</code>，另一个版本接受<code>T &amp;&amp;</code></p>
<p>通过在参数列表后放置一个引用限定符，可以强制赋值运算符左侧运算对象是左值或者右值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo &amp;operator=(const Foo&amp;) const &amp;;</span><br><span class="line">Foo &amp;operator=(Foo &amp;&amp;) &amp;&amp;;</span><br></pre></td></tr></table></figure>

<p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> <span class="type">const</span> &amp; </span>&#123;</span><br><span class="line">	<span class="function">Foo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> ret.<span class="built_in">sorted</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会产生递归并且最终溢出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> <span class="type">const</span> &amp; </span>&#123; <span class="keyword">return</span> <span class="built_in">Foo</span>(*<span class="keyword">this</span>).<span class="built_in">sorted</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>与上一题不同，本题的写法可以正确利用右值引用版本来完成排序。原因在于，编译器认为Foo(*this)是一个[无主]的右值，对它调用sorted会匹配右值引用版本</p>
<h2 id="第十四章-重载运算与类型转换"><a href="#第十四章-重载运算与类型转换" class="headerlink" title="第十四章 重载运算与类型转换"></a>第十四章 重载运算与类型转换</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>如果一个运算符函数是<strong>成员函数</strong>，则它的第一个（左侧）运算对象绑定到<strong>隐式的this指针</strong>上，成员运算符函数的（显式）参数数量比运算符的运算对象少一个</p>
<p>对于一个运算符函数来说，它或者是<strong>类的成员</strong>，或者<strong>至少含有一个类类型的参数</strong></p>
<p><strong>赋值、下标、调用和成员访问运算符</strong>必须是成员函数</p>
<h3 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h3><p>必须是普通的非成员函数，需要读写非公有数据成员时，一般被声明为友元</p>
<p>输出运算符的第一个形参是一个非常量<code>ostream</code>对象的引用，因为向流写入内容会改变其状态，且无法拷贝一个<code>ostream</code>对象；第二个形参是一个常量的引用，是想要打印的类类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;operator&lt;&lt;(ostream&amp; os, const Sales_data&amp; sd)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; sd.isbn &lt;&lt; &quot; &quot; &lt;&lt; sd.units_sold &lt;&lt; &quot; &quot; &lt;&lt; sd.revenue</span><br><span class="line">	&lt;&lt; &quot; &quot; &lt;&lt; sd.avg_price();</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出运算符尽量减少格式化操作，不应该打印换行符</p>
<p>输入运算符的第一个形参是一个非常量<code>istream</code>对象的引用，第二个形参是将要读入的对象的引用，非常量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;operator&gt;&gt;(istream&amp; is, Sales_data &amp;sd)</span><br><span class="line">&#123;</span><br><span class="line">	double price;</span><br><span class="line">	is &gt;&gt; sd.bookNo &gt;&gt; sd.units_sold &gt;&gt; price;</span><br><span class="line">	if(is)</span><br><span class="line">		sd.revenue = sd.units_sold * price;</span><br><span class="line">	else</span><br><span class="line">		sd = Sales_data();</span><br><span class="line">	return is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code>语句检查读取操作是否成功，如果发生IO错误，则运算符将给定的对象重置为空<code>Sales_data</code></p>
<p>输入运算符必须处理输入可能失败的情况</p>
<h3 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h3><p>一般不需要改变运算对象的状态，所以形参都是常量的引用。计算两个运算对象并得到一个新值，通常位于一个局部变量之内，最终返回该局部变量的一个副本</p>
<p>如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符，可以避免使用临时对象</p>
<p>相等运算符和不等运算符的一个应该把工作委托给另一个</p>
<p>如果存在唯一一种逻辑可靠的<code>&lt;</code>定义，则应该考虑为这个类定义<code>&lt;</code>运算符。如果同时还包含<code>==</code>，则当且晋档<code>&lt;</code>的定义和<code>++</code>产生的结果一直时才定义<code>&lt;</code>运算符</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a><strong>赋值运算符</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::operator=(initializer_list&lt;string&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">	auto data = alloc_n_copy(il.begin(),il.end());</span><br><span class="line">	free();</span><br><span class="line">	elements = data.first;</span><br><span class="line">	cap = first_free = data.second;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB%E7%A8%8B%E5%BA%8F">拷贝赋值运算符不同</a>，这个运算符无需检查对象向自身的赋值，因为形参<code>initializer_list</code>确保<code>il</code>与<code>this</code>指向的不是同一个对象</p>
<h3 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h3><p>以所访问元素的引用作为返回值，一般同时定义下标运算符的常量版本和非常量版本</p>
<h3 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h3><p>定义递增和递减运算符的类应该同时定义前置版本和后置版本</p>
<p>前置运算符应该返回递增或递减后对象的引用；后置运算符应该返回递增或递减前对象的值，后置版本接受一个额外的，不被使用的<code>int</code>类型的形参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//前置版本</span><br><span class="line">inline StrBlobPtr&amp; StrBlobPtr::operator++()</span><br><span class="line">&#123;</span><br><span class="line">    check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">    ++curr;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline StrBlobPtr&amp; StrBlobPtr::operator--()</span><br><span class="line">&#123;</span><br><span class="line">	--curr;</span><br><span class="line">    check(curr, &quot;decrement past begin of StrBlobPtr&quot;);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后置版本</span><br><span class="line">inline StrBlobPtr StrBlobPtr::operator++(int)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *this;</span><br><span class="line">    ++*this;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline StrBlobPtr StrBlobPtr::operator--(int)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *this;</span><br><span class="line">    --*this;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意前置递增运算符先将当前值传递给<code>check</code>函数，而递减运算符是先递减<code>curr</code>，再调用<code>check</code>函数</p>
<p>后置版本无需检查有效性，因为返回的是递增或递减前的状态的副本</p>
<h3 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string&amp; operator*() const</span><br><span class="line">&#123;</span><br><span class="line">	auto p = check(curr,&quot;dereference past end&quot;);</span><br><span class="line">	return (*p)[curr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string&amp; operator-&gt;() const</span><br><span class="line">&#123;</span><br><span class="line">	return&amp; this-&gt;operator*();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解引用运算符检查<code>curr</code>是否在作用范围内，如果在则返回<code>curr</code>指针所指元素的引用；箭头运算符调用解引用运算符并返回解引用结果元素的地址</p>
<h3 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h3><p>如果累定义了调用运算符，则该类的对象称作<strong>函数对象</strong></p>
<p>一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别</p>
<p><code>lambda</code>捕获变量：<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，由<code>lambda</code>产生的类当中的函数调用运算符是一个<code>const</code> 成员函数</p>
<p><strong>标准库函数对象</strong>:</p>
<table>
<thead>
<tr>
<th>算术</th>
<th>关系</th>
<th>逻辑</th>
</tr>
</thead>
<tbody><tr>
<td><code>plus&lt;Type&gt;</code></td>
<td><code>equal_to&lt;Type&gt;</code></td>
<td><code>logical_and&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>minus&lt;Type&gt;</code></td>
<td><code>not_equal_to&lt;Type&gt;</code></td>
<td><code>logical_or&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>multiplies&lt;Type&gt;</code></td>
<td><code>greater&lt;Type&gt;</code></td>
<td><code>logical_not&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>divides&lt;Type&gt;</code></td>
<td><code>greater_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>modulus&lt;Type&gt;</code></td>
<td><code>less&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>negate&lt;Type&gt;</code></td>
<td><code>less_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
</tbody></table>
<p>比较两个指针将产生未定义的行为，但可以通过<strong>标准库函数对象</strong>比较指针内存地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string*&gt; vec;</span><br><span class="line">sort(vec.begin(),vec.end(),[](string* a, string* b) &#123;return a &lt; b;&#125;);//错误，不能直接比较两个指针</span><br><span class="line">sort(vec.begin(),vec.end(),greater&lt;string*&gt; ());//正确，按降序排列指针的地址</span><br></pre></td></tr></table></figure>

<p>统计大于1024的值有多少个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout_if(vec.begin(),vec.end(),bind(greater&lt;int&gt;(), _1, 1024));</span><br></pre></td></tr></table></figure>
<p>找到第一个不等于pooh的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_if(str.begin(),str.end(),bind(not_equal_to&lt;string&gt;(), _1, &quot;pooh&quot;));</span><br></pre></td></tr></table></figure>
<p>将所有的值乘以2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform(vec.begin(),vec.end(),bind(multiplies&lt;int&gt;(), _1 ,2));</span><br></pre></td></tr></table></figure>

<p>判断一个给定的<code>int</code>值是否能被 <code>int</code> 容器中的所有元素整除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int input = 30;</span><br><span class="line">modulus&lt;int&gt; mod;</span><br><span class="line">auto predicator = [&amp;](int i) &#123; return 0 == mod(input, i); &#125;;</span><br><span class="line">auto is_divisible = std::any_of(data.begin(), data.end(), predicator);//any_of返回true或false</span><br></pre></td></tr></table></figure>

<h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p>可调用对象：函数、函数指针、<code>lambda</code>表达式、重载调用运算符的类和<code>bind</code>创建的对象</p>
<p>每一个<code>lambda</code>都有自己唯一的未命名的类类型，函数和函数指针的类型则由返回值和实参类型决定，但两个不同类型的可调用对象可以有相同的调用形式，调用形式包含调用的返回类型和实参类型，<code>int (int, int)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//函数</span><br><span class="line">int add(int i, int j) &#123;</span><br><span class="line">	return i + j;</span><br><span class="line">&#125;</span><br><span class="line">//lambda</span><br><span class="line">auto mod = [](int i, int j)&#123;return i%j;&#125;;</span><br><span class="line">//函数对象类</span><br><span class="line">struct divide&#123;</span><br><span class="line">	int operator()(int i, int j)</span><br><span class="line">	&#123;</span><br><span class="line">		return i/j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个函数表，用于存储指向这些可调用对象的指针<code>map&lt;string, int(*)(int, int)&gt; calc</code></p>
<p><code>calc.insert(&quot;+&quot;, add);</code>可添加<code>add</code>的指针至函数表中，但不能直接存入<code>mod</code>和<code>divide</code>，因为它们并不是函数指针类型，与<code>map</code>中所要求的类型不匹配，但可以通过<code>function</code>类型来解决</p>
<p><strong>标准库function类型</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>function&lt;T&gt; f;</code></td>
<td><code>f</code>是一个用来存储可调用对象的空<code>function</code>，这些可调用对象的调用形式应该与类型<code>T</code>相同。</td>
</tr>
<tr>
<td><code>function&lt;T&gt; f(nullptr);</code></td>
<td>显式地构造一个空<code>function</code></td>
</tr>
<tr>
<td><code>function&lt;T&gt; f(obj)</code></td>
<td>在<code>f</code>中存储可调用对象<code>obj</code>的副本</td>
</tr>
<tr>
<td><code>f</code></td>
<td>将<code>f</code>作为条件：当<code>f</code>含有一个可调用对象时为真；否则为假。</td>
</tr>
<tr>
<td>定义为<code>function&lt;T&gt;</code>的成员的类型</td>
<td></td>
</tr>
<tr>
<td><code>result_type</code></td>
<td>该<code>function</code>类型的可调用对象返回的类型</td>
</tr>
<tr>
<td><code>argument_type</code></td>
<td>当<code>T</code>有一个或两个实参时定义的类型。如果<code>T</code>只有一个实参，则<code>argument_type</code></td>
</tr>
<tr>
<td><code>first_argument_type</code></td>
<td>第一个实参的类型</td>
</tr>
<tr>
<td><code>second_argument_type</code></td>
<td>第二个实参的类型</td>
</tr>
</tbody></table>
<p>声明一个<code>function</code>类型，它可以表示接受两个<code>int</code>，返回一个<code>int</code>的可调用对象。<code>function&lt;int(int, int)&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, function&lt;int(int,int)&gt;&gt; calc = &#123;</span><br><span class="line">	&#123;&quot;+&quot;, add&#125;,								 //函数指针</span><br><span class="line">	&#123;&quot;-&quot;, minus&lt;int&gt;()&#125;,					  //标准库函数对象</span><br><span class="line">	&#123;&quot;*&quot;, [](int i, int j)&#123;return i*j;&#125;&#125;,	   //lambda表达式</span><br><span class="line">	&#123;&quot;/&quot;, divide()&#125;,						 //重载调用运算符的类，函数对象</span><br><span class="line">	&#123;&quot;%&quot;, mod&#125;								//命名的lambda对象</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h3><p>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型</p>
<p><code>operator type() const;</code></p>
<p>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是<code>const</code></p>
<p><code>int i = 42;</code></p>
<p><code>cin &lt;&lt; i;</code></p>
<p>使用<code>istream</code>的<code>bool</code>类型转换运算符将<code>cin</code>转换成<code>bool</code>，而这个<code>bool</code>会被提升为<code>int</code>进而执行左移42位的操作</p>
<p>可以通过显式的类型转换运算符防止自动隐式转换，这样，在执行类型转换时，需通过显式的强制类型转换</p>
<p><code>static_cast&lt;int&gt; (si) + 3;</code></p>
<p>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Integral &#123;</span><br><span class="line">	operator const int();</span><br><span class="line">	operator int() const;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一条语句指明类型转换得到的值为<code>const int</code>，不能对其进行修改</p>
<p>第二条语句指明不能对类对象进行修改</p>
<p>两个类提供相同的类型转换，例如A定义一个接受B的构造函数，同时B类定义了一个转换目标是A的类型转换运算符，则产生二义性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">	A(const B&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">struct B&#123;</span><br><span class="line">	operator A() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A f(const A&amp;);</span><br><span class="line">B b;</span><br><span class="line">A a = f(b);			//二义性：f(B::operator A())与f(A::A(const B&amp;))</span><br><span class="line"></span><br><span class="line">//显式调用类型转换运算符或者构造函数</span><br><span class="line">A a1 = f(b.operator A());</span><br><span class="line">A a2 = f(A(b));</span><br></pre></td></tr></table></figure>



<p>同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct LongDouble&#123;</span><br><span class="line">	LongDouble(double = 0.0);</span><br><span class="line">	LongDouble operator+(const SmallInt&amp;);</span><br><span class="line">	oprerator double();</span><br><span class="line">	operator float();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SmallInt&#123;</span><br><span class="line">	SmallInt operator+(const SmallInt&amp;, const SmallInt&amp;);</span><br><span class="line">	SmallInt (int = 0);</span><br><span class="line">	operator int() const &#123;</span><br><span class="line">		return val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt s1, s2;</span><br><span class="line">SmallInt s3 = s1 + s2;		// 成员函数重载+</span><br><span class="line">int i = s3 + 0;				// 二义性: s3转换成int再使用内置+ 或 0转换成SmallInt再使用重载+</span><br><span class="line"></span><br><span class="line">LongDouble operator+(LongDouble&amp;, double);</span><br><span class="line">SmallInt si;</span><br><span class="line">LongDouble ld;</span><br><span class="line">ld = si + ld;	//错误</span><br><span class="line">ld = ld + si;	//正确</span><br></pre></td></tr></table></figure>

<p><code>ld = si + ld;</code> 中两个类都不能相互转换，因此不能使用重载+，2<code>si</code>转换成<code>int</code>，<code>ld</code>转换成<code>double</code>或<code>float</code>，将产生二义性</p>
<p><code>ld = ld + si;</code> 中可以使用<code>ld</code>的重载+，<code>ld</code>在左，接受<code>double</code>的右侧运算对象，精确匹配；还可以<code>ld</code>转换成<code>double</code>或<code>float</code>，<code>si</code>转换成<code>int</code>，再使用内置+，但优先级低于前者，故无二义性</p>
<h2 id="第十五章-面向对象程序设计"><a href="#第十五章-面向对象程序设计" class="headerlink" title="第十五章 面向对象程序设计"></a>第十五章 面向对象程序设计</h2><h3 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h3><p>层次关系的根部是一个<strong>基类</strong>，其他类可通过直接或间接继承基类，继承得到的类称为<strong>派生类</strong></p>
<p>派生类要通过派生类列表显式指出从哪个基类继承而来，如<code>class Bulk_quote : public Quote&#123;//类定义&#125;;</code>，且只在类定义时才指出派生类列表，声明中只包含类名但不包含派生类列表<code>class Bulk_quote;</code></p>
<p>对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成<strong>虚函数</strong>，<code>virtual</code></p>
<p>派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字</p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义</p>
<p>派生类对象中包含了：派生类自己定义的成员的子对象（非静态）以及所继承的基类的子对象，即派生类对象中也含有基类对应的组成部分，可以把派生类对象当成基类对象来使用，通过将基类的指针或引用绑定到派生类对象中的基类部分上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;</span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *p = &amp;item;     //p指向Quote对象item</span><br><span class="line">p = bulk;			 //p指向Bulk_quote对象bulk中的Quote部分</span><br><span class="line">Quote &amp;r = bulk;	  //r绑定到bulk中的Quote部分</span><br></pre></td></tr></table></figure>

<p>这种转换称为<strong>派生类到基类的转换</strong></p>
<p>派生类必须使用基类的构造函数去初始化它的基类部分</p>
<p>如果将某个类作为基类，则该类必须已定义而非只有声明</p>
<p>防止继承发生可以在类名或函数名后加上关键字<code>final</code></p>
<h3 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h3><p>静态类型在编译时已知，是根据变量声明或表达式生成的类型；动态类型则是变量或表达式表示的在内存中的类型，在运行时才可知</p>
<p>如上例子中<code>p</code>或者<code>r</code>在绑定<code>bulk</code>后动态类型与静态类型不一样了，静态类型为<code>Quote</code>而动态类型为<code>Bulk_quote</code></p>
<p>因为一个基类对象可能是派生类对象一部分也可能不是，所以不存在从基类向派生类的隐式类型转换</p>
<p>用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分则会被忽略掉</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>使用虚函数可以执行动态绑定，动态绑定只有通过指针或者引用调用虚函数时才会发生</p>
<p>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同</p>
<p>当派生类覆盖了某个虚函数时，该函数在某类中的形参必须与派生类中的形参严格匹配</p>
<p>如果我们想覆盖某个虚函数，但不小心把形参列表弄错了，这个时候就不会覆盖基类中的虚函数。加上<code>override</code>可以明确程序员的意图，让编译器帮忙确认参数列表是否出错</p>
<p>如果通过基类引用或指针调用函数，则使用基类中定义的默认实参，因此派生类中定义的默认实参最好与基类一致</p>
<h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>纯虚函数用于清晰地告诉用户当前的函数是没有实际意义的。只用在函数体的位置前书写<code>=0</code>就可以将一个虚函数说明为纯虚函数</p>
<p>含有纯虚函数的类是抽象基类，抽象基类不能被直接创建成对象</p>
<h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><ul>
<li><code>protected</code> ： 基类和和其派生类还有友元可以访问。</li>
<li><code>private</code> ： 只有基类本身和友元可以访问。</li>
</ul>
<p>派生类的成员或友元只能通过派生类对象来访问<strong>基类的受保护成员</strong>。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<p>只有当<strong>公有继承</strong>自基类时，用户代码才能将<strong>派生类转换成基类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base *p = &amp;d1;		//正确，d1是公有继承</span><br><span class="line">p = &amp;d2;			//报错，d2是私有继承</span><br></pre></td></tr></table></figure>

<p>派生访问说明符的目的是：控制派生类用户对于基类成员的访问权限。比如<code>struct Priv_Drev: private Base&#123;&#125;</code>意味着在派生类<code>Priv_Drev</code>中，从<code>Base</code>继承而来的部分都是<code>private</code>的</p>
<p><strong>供派生类访问 应声明为受保护的，则派生类及其友元不能访问私有成员</strong>；<strong>由基类及其基类的友元访问 应声明为私有的</strong></p>
<p>不能继承友元关系</p>
<p>使用<code>using</code>改变个别成员的可访问性，<code>using</code>声明语句中名字的访问权限由该<code>using</code>声明语句之前的访问说明符决定</p>
<h3 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h3><p>派生类的作用域嵌套在其基类的作用域之内</p>
<p>派生类的成员将隐藏同名的基类成员</p>
<h3 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h3><p>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针将产生未定义的行为。因此<strong>基类通常定义一个虚析构函数<code>virtual ~Quote() = default;</code></strong></p>
<p><strong>如果一个类定义了析构函数，即使是通过<code>=default</code>的形式使用合成的版本，编译器也不会合成移动操作</strong></p>
<p><strong>派生类构造函数在初始化阶段不仅要初始化派生类自己的成员，还负责初始化基类部分</strong>。拷贝、赋值和移动同理，而析构函数只负责销毁派生类自己分配的资源</p>
<p>当为派生类定义对应的拷贝或移动构造函数时，通常使用对应的基类构造函数来初始化派生类对象的基类部分</p>
<h3 id="容器与继承——Basket类程序"><a href="#容器与继承——Basket类程序" class="headerlink" title="容器与继承——Basket类程序"></a><strong>容器与继承——Basket类程序</strong></h3><p>如果希望使用容器存放具有继承关系的对象时，由于派生类赋值给基类对象时，其中的派生类对象会被忽略掉，因此实际上存放的应该是基类的（智能）指针</p>
<p>为了实现<code>basket</code>存放<code>shared_ptr</code>，定义一个表示购物篮的类，并提供添加和打印输出的接口，私有成员定义一个<code>multiset</code>存放指向不同<code>Quote</code>的<code>shared_ptr</code>即<code>multiset&lt;shared_ptr&lt;Quote&gt;&gt; </code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Basket&#123;</span><br><span class="line">public:</span><br><span class="line">	void add_item(const shared_ptr&lt;Quote&gt;&amp; q) &#123;items.insert(q);&#125;</span><br><span class="line">	double total_receipt(ostream&amp;) const;</span><br><span class="line">private:</span><br><span class="line">	bool compare(const shared_ptr&lt;Quote&gt; &amp;l, const shared_ptr&lt;Quote&gt; &amp;r)</span><br><span class="line">	&#123;</span><br><span class="line">		return l-&gt;isbn() &lt; r-&gt;isbn();</span><br><span class="line">	&#125;</span><br><span class="line">	multiset&lt;shared_ptr&lt;Quote&gt;, decltype(compare)*&gt; items(compare);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>multiset</code>中存放的是<code>shared_ptr</code>，因此需要自定义小于运算符，初始化<code>items</code>并令其使用<code>compare</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double total_receipt(ostream&amp; os) const</span><br><span class="line">&#123;</span><br><span class="line">	double sum = 0.0;</span><br><span class="line">	for(auto iter = items.begin();</span><br><span class="line">			iter != item.end();</span><br><span class="line">			iter = upper_bound(*iter))</span><br><span class="line">	&#123;</span><br><span class="line">		sum += print_total(os, **iter, items.count(*iter));</span><br><span class="line">	&#125;</span><br><span class="line">	os &lt;&lt; &quot;total sale:&quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code>循环中，<code>*iter</code>解引用得到指向<code>Quote</code>的智能指针，调用<code>upper_bound</code>函数可以返回<code>multiset</code>中第一个非<code>*iter</code>智能指针指向的元素，替代了递增操作，意味着不需要打印重复的书本，在相同的书中只取一本作为代表打印。<code>**iter</code>解引用则返回<code>Quote</code>元素</p>
<p>接下来要实现<code>add_item</code>函数，因为存放的是<code>Quote</code>类型的智能指针，而并不确定指针所指向的具体类型，即该指针的静态类型有可能与动态类型不一样，在<code>make_shared(*类型*)</code>或者<code>shared_ptr pt = new *类型*</code>时无法确定使用基类还是派生类，如果使用基类，则派生类中的非基类部分会被忽略。因此，<strong>给<code>Quote</code>类添加一个虚函数，返回一个新申请的当前对象的拷贝</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Quote&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual Quote* clone() const &amp; &#123;return new Quote (*this);&#125;</span><br><span class="line">	virtual Quote* clone() &amp;&amp; &#123;return new Quote (move(*this));&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Bulk_quote : public Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Bulk_quote* clone() const &amp; &#123;return new Bulk_quote (*this);&#125;</span><br><span class="line">	Bulk_quote* clone() &amp;&amp; &#123;return new Bulk_quote (move(*this));&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现<code>add_item</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//原版本</span><br><span class="line">//void add_item(const shared_ptr&lt;Quote&gt;&amp; q) &#123;items.insert(q);&#125;</span><br><span class="line">void Basket::add_item(const Quote&amp; sale)</span><br><span class="line">&#123;</span><br><span class="line">	items.insert(shared_ptr&lt;Quote&gt;(sale.clone()));</span><br><span class="line">&#125;</span><br><span class="line">void Basket::add_item(const Quote&amp;&amp; sale)</span><br><span class="line">&#123;</span><br><span class="line">	items.insert(shared_ptr&lt;Quote&gt;(move(sale).clone()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版本<code>add_item</code>可以直接传入<code>quote</code>对象，程序自动生成相应类型的智能指针。<code>clone</code>无论是拷贝或者是移动数据，都会返回<code>shared_ptr</code>，然后调用<code>insert</code>直接加入到<code>items</code>中</p>
<h2 id="第十六章——模板与泛型编程"><a href="#第十六章——模板与泛型编程" class="headerlink" title="第十六章——模板与泛型编程"></a>第十六章——模板与泛型编程</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p><code>template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2)&#123;&#125;</code></p>
<p>以关键字 <code>template</code>开始，后接<strong>模板形参表</strong>，模板形参表是用<strong>尖括号</strong><code>&lt;&gt;</code>括住的一个或多个<strong>模板形参</strong>的列表，用逗号分隔，<strong>不能为空</strong></p>
<p>类型模板参数——在关键字<code>typrename</code>或者<code>class</code>之后，可以用来指定返回类型或函数的参数类型</p>
<p>非类型模板参数——用来表示一个值而非一个类型，通过<strong>特定的类型名指定非类型参数</strong>，<strong>当一个模板实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;unsighned N, unsigned M&gt;</span><br><span class="line">int compare(const char (&amp;p1)[n], const char (&amp;p2)[M])</span><br><span class="line">&#123;</span><br><span class="line">	return strcmp(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compare(&quot;hi&quot;, &quot;mom&quot;);</span><br><span class="line">//当调用compare时，编译器使用字面常量的大小来代替M和N，即调用 int compare(const char (&amp;p1)[3],const char (&amp;p2)[4])</span><br></pre></td></tr></table></figure>

<p>一个非类型参数可以是一个整数，或者是一个指向对象或函数类型的指针或引用；绑定到非类型整型参数的实参必须是一个常量表达式，必须具有静态的生存期。</p>
<p><code>inline</code>或<code>constexpr</code>说明符放在模板参数列表之后，返回类型之前</p>
<p><code>template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);</code></p>
<h3 id="编写类型无关的代码"><a href="#编写类型无关的代码" class="headerlink" title="编写类型无关的代码"></a>编写类型无关的代码</h3><ul>
<li>模板中的函数参数是<code>const</code>的引用</li>
<li>函数体中的条件判断仅使用<code>&lt;</code>比较运算</li>
</ul>
<h3 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h3><p>只有当实例化出模板的一个特定版本时，编译器才会生成代码</p>
<ul>
<li>普通函数的声明和类定义放在头文件，普通函数的定义和类成员函数的定义放在源文件中</li>
<li>函数模板或类模板成员函数的声明和定义都要在头文件中</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
