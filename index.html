<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kevin346-sc.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="c++">
<meta property="og:type" content="website">
<meta property="og:title" content="Serein’s Blog">
<meta property="og:url" content="https://kevin346-sc.github.io/index.html">
<meta property="og:site_name" content="Serein’s Blog">
<meta property="og:description" content="c++">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kevin Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kevin346-sc.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Serein’s Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Serein’s Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kevin Huang</p>
  <div class="site-description" itemprop="description">c++</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/24/Leetcode%E6%95%B0%E7%BB%84%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/24/Leetcode%E6%95%B0%E7%BB%84%E7%AB%A0%E8%8A%82/" class="post-title-link" itemprop="url">Leetcode数组章节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-24 15:13:04" itemprop="dateCreated datePublished" datetime="2023-04-24T15:13:04+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-25 15:08:02" itemprop="dateModified" datetime="2023-04-25T15:08:02+08:00">2023-04-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数组章节"><a href="#数组章节" class="headerlink" title="数组章节"></a>数组章节</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找模板题"><a href="#二分查找模板题" class="headerlink" title="二分查找模板题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">二分查找模板题</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        while(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] &lt; target)</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            else if(nums[mid] &gt; target)</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            else</span><br><span class="line">                return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，变形题可根据不同的判断条件进行判断，如将三种情况重新分成两种等</p>
<h3 id="lower-bound和upper-bound的实现"><a href="#lower-bound和upper-bound的实现" class="headerlink" title="lower_bound和upper_bound的实现"></a><code>lower_bound</code>和<code>upper_bound</code>的实现</h3><p><code>lower_bound</code>—返回第一个 大于等于 的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                r = mid - 1; // 可能左边还有值等于target的元素</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>upper_bound</code>—返回第一个 大于 的元素</p>
<p>类似，第一个 大于 的元素则判断条件中 遇到 小于等于 的元素时执行<code>l = mid + 1</code>， 遇到大于的元素 记录<code>ans</code>的同时<code>r = mid - 1</code>，因为左边可能还有值 大于 的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if (nums[mid] &lt;= target)</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">            	r = mid - 1;</span><br><span class="line">            	ans =mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="找到值等于target的区间"><a href="#找到值等于target的区间" class="headerlink" title="找到值等于target的区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">找到值等于target的区间</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int binary_search(vector&lt;int&gt;&amp; nums, int target)</span><br><span class="line">    &#123;</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                r = mid - 1; // 可能左边还有值等于target的元素</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int n = nums.size() - 1;</span><br><span class="line">        if(n &lt; 0)   return &#123;-1, -1&#125;;</span><br><span class="line">        int st = -1, en = -1;</span><br><span class="line">        st = binary_search(nums, target);</span><br><span class="line">        en = binary_search(nums, target + 1);</span><br><span class="line">        if(st == en) // 数组中找不到相等的元素</span><br><span class="line">            return &#123;-1, -1&#125;;</span><br><span class="line">        else if(en == -1) // 找到相等的元素但没有比target更大的元素</span><br><span class="line">            return &#123;st, n&#125;;</span><br><span class="line">        else</span><br><span class="line">            return &#123;st, en - 1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>应用 <code>lower_bound</code>的实现（找到第一个 大于等于 的元素），通过寻找区间首元素和尾元素的位置判断，传入不同的target值， 即可实现；但不能用 <code>upper_bound</code>来实现，因为<code>st = binary_search(nums, target - 1), en = binary_search(nums, target)</code>中，想要得知数组中 是否存在与target值相等的元素 与 当en为尾后元素时 冲突，例如<code>[5,7,7], target = 6</code>和<code>[2,2], target = 2</code></p>
<h3 id="找到第一个-逆序排序-小于等于-的元素"><a href="#找到第一个-逆序排序-小于等于-的元素" class="headerlink" title="找到第一个(逆序排序) 小于等于 的元素"></a>找到第一个(逆序排序) 小于等于 的元素</h3><h3 id="x的平方根"><a href="#x的平方根" class="headerlink" title="x的平方根"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">x的平方根</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        int l = 0, r = x, ans = -1;</span><br><span class="line">        while (l &lt;= r) &#123;</span><br><span class="line">            int mid = l + (r - l) / 2;</span><br><span class="line">            if ((long long)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>(当从小到大排序时)与上述不同，这一题要求的是 小于等于 的元素，则判断条件中当遇到 小于等于 的元素时，记录该元素同时<code>l = mid + 1</code>，因为右边可能还有 小于等于 的元素；而当遇到大于的元素，则直接<code>r = mid - 1</code>不用记录</p>
<h2 id="双指针——滑动窗口"><a href="#双指针——滑动窗口" class="headerlink" title="双指针——滑动窗口"></a>双指针——滑动窗口</h2><h3 id="移动元素"><a href="#移动元素" class="headerlink" title="移动元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">移动元素</a></h3><p>使用双指针在O(n)时间复杂度和O(1)空间复杂度下实现</p>
<p>同向遍历，即快慢指针实现，r指针遍历数组，不断的将r遍历到的不需要删除的元素赋值到l中，同时l++，当r遇到需要删除的元素则跳过，再次遇到不需要删除元素时，覆盖到l上，并逐一将后续需要的元素按顺序覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        // 同向遍历</span><br><span class="line">        int l = 0, r = 0;</span><br><span class="line">        for(r; r &lt; nums.size(); r++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[r] != val) // 需要删除的元素</span><br><span class="line">            &#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对向遍历，当l指针遇到需要删除的元素时与r指针交换，同时r–，此时，有可能r指针也指向需要删除的元素，因此这一轮中l指针不动，只移动r指针，也就在下一轮中再次判断l指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        // 对向遍历</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        while(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[l] == val) // 需要删除的元素</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[l], nums[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                l++;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方</a></h3><p>首先利用有序性，找到负数与非负数的分界线，从分界线开始向左右两边使用双指针遍历，其中，寻找分界线时可以使用二分法进行加速查找；或者从数组两端开始遍历并比较，最后则需要将数组逆序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// 从分界线开始遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()==1)</span><br><span class="line">            return &#123;nums[0]*nums[0]&#125;;</span><br><span class="line">        // 先找零 或者最小的正数</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        int ind = nums.size() - 1;</span><br><span class="line">        while(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] &gt;= 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ind = mid;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        l = ind - 1, r = ind;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        while(l &gt;= 0 &amp;&amp; r &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[l]*nums[l] &lt; nums[r]*nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(nums[l]*nums[l]);</span><br><span class="line">                l--;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(nums[r]*nums[r]);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l &gt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(nums[l]*nums[l]);</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">        while(r &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(nums[r]*nums[r]);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 从两端开始遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int i = 0, j = n - 1;</span><br><span class="line">        while(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            if(abs(nums[i]) &gt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(nums[i] * nums[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(nums[j] * nums[j]);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(nums[i]*nums[i]);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h4><p>通常，在使用快慢指针时，用快指针遍历数组并判断是否符合条件，而不是用慢指针，因此是判断<code>if(nums[r] != val)</code>而不是<code>if(val == nums[l]</code>，否则会miss掉一些值</p>
<h3 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() == 1)    return 1;</span><br><span class="line">        int l = 1;</span><br><span class="line">        for(int r = 1; r &lt; nums.size(); r++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[r] &gt; nums[r - 1])</span><br><span class="line">                nums[l++] = nums[r];</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="删除有序数组中的重复项-II"><a href="#删除有序数组中的重复项-II" class="headerlink" title="删除有序数组中的重复项 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">删除有序数组中的重复项 II</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int l = 2;</span><br><span class="line">        if(nums.size() &lt; 3) return nums.size();</span><br><span class="line">        for(int r = 2; r &lt; nums.size(); r++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[r] != nums[l - 2])</span><br><span class="line">                nums[l++] = nums[r];</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="总结2"><a href="#总结2" class="headerlink" title="总结2"></a>总结2</h4><p>都使用快慢指针，但当允许有两个重复值时，应该比较的是 <strong>快指针和慢指针-2</strong>，<strong>而不是 快指针和快指针-2</strong>，因为快慢指针都被初始化为2，当相等时，则快指针（&#x3D;慢指针）当前值多余，快指针继续遍历；遍历至当快指针遇到与慢指针-2不相等时，则可以将快指针的值赋值到慢指针，此时慢指针 &#x3D; 慢指针 - 1 &#x3D; 慢指针 - 2，需要删除的是慢指针而不是快指针。</p>
<p>同理，I中也可以将判断条件改为<code>if(nums[r] != nums[l - 1])</code>，也可以延伸到重复项数量为k</p>
<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title=" 长度最小的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/"> 长度最小的子数组</a></h3><p>右指针遍历整个数组，并不断扩大窗口，直至满足条件后，while循环中不断缩小窗口并更新结果，维持动态窗口满足条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        long long sum = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int res = nums.size() + 1;</span><br><span class="line">        for(int j = 0; j &lt; nums.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            while(sum &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                res = min(res, j - i + 1);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res == nums.size() + 1? 0 : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title=" 最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/"> 最小覆盖子串</a></h3><p>同样地，右指针遍历整个数组，而左指针不断缩小窗口，同时更新结果。此外，需要用哈希表记录窗口的访问记录并判断是否符合条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;char, int&gt; store, vis;</span><br><span class="line"></span><br><span class="line">    bool check()</span><br><span class="line">    &#123;</span><br><span class="line">        for (const auto &amp; it : store)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((vis.find(it.first) == vis.end()) || (vis.find(it.first) != vis.end() &amp;&amp; vis[it.first] &lt; it.second))</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line"></span><br><span class="line">        for (auto c : t)</span><br><span class="line">        &#123;</span><br><span class="line">            store[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        int res = s.size() + 1;</span><br><span class="line">        int ind = i;</span><br><span class="line">        while (j &lt; s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            vis[s[j]]++;</span><br><span class="line">            while (check()) // 已覆盖t字符串，则尝试缩小左边范围</span><br><span class="line">            &#123;</span><br><span class="line">                if(res &gt; j - i + 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = j - i + 1;</span><br><span class="line">                    ind = i;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[s[i++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res == s.size() + 1 ? &quot;&quot; : s.substr(ind, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruit-into-baskets/">水果成篮</a></h3><p>同样，右指针遍历数组，并扩大窗口，在不满足条件后，左指针不断缩小窗口，直至满足条件后更新结果。另外，还需要用哈希表来判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int totalFruit(vector&lt;int&gt;&amp; fruits) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; vis;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(int j = 0; j &lt; fruits.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[fruits[j]]++;</span><br><span class="line">            while(vis.size() &gt; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[fruits[i]]--;</span><br><span class="line">                if(vis[fruits[i]] == 0)</span><br><span class="line">                    vis.erase(fruits[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, j - i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h3><p>同样地思路，右指针不断扩大窗口，为了在扩大的时候不重复包含已有的元素，在添加元素到窗口之前把窗口中已有的对应元素删除掉，即左指针缩小窗口的过程，然后再更新结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int j = 0 , i = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        unordered_set&lt;char&gt; store;</span><br><span class="line">        for(j; j &lt; s.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            while(store.find(s[j]) != store.end())// 如果出现重复则先删除</span><br><span class="line">            &#123;</span><br><span class="line">                store.erase(s[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(store.find(s[j]) == store.end()) // 没有重复则加入</span><br><span class="line">                store.insert(s[j]);</span><br><span class="line">            res = max(res, j - i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="总结3"><a href="#总结3" class="headerlink" title="总结3"></a>总结3</h4><p><u>水果成篮和无重复字符的最长子串所求的是<strong>最大窗口长度</strong></u>，<u>而长度最小的子数组和最小覆盖子串求的是<strong>最小窗口长度</strong></u>，因此同样的遍历循环下，要在不同位置对结果进行更新，即求最大窗口长度时要在<strong>左指针</strong>遍历结束后更新，求最小窗口长度则是在<strong>右指针</strong>遍历过程中更新</p>
<h2 id="双指针——固定窗口"><a href="#双指针——固定窗口" class="headerlink" title="双指针——固定窗口"></a>双指针——固定窗口</h2><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title=" 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/"> 螺旋矩阵</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">        int up = 0, down = m-1, left = 0, right = n-1;</span><br><span class="line">        while (up &lt;= down &amp;&amp; left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = left; j &lt;= right; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[up][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            up++;</span><br><span class="line">            for (int i = up; i &lt;= down; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            if(up &gt; down || left &gt; right)</span><br><span class="line">                break;</span><br><span class="line">            for (int j = right; j &gt;= left; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[down][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            down--;</span><br><span class="line">            for (int i = down; i &gt;= up; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵 II</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        int cnt = n * n;</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        int up = 0, down = n - 1, left = 0, right = n - 1;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n));</span><br><span class="line">        while (tmp &lt;= cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = left; j &lt;= right; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[up][j] = tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            up++;</span><br><span class="line">            for (int i = up; i &lt;= down; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i][right] = tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            if (tmp &gt; cnt)</span><br><span class="line">                break;</span><br><span class="line">            for (int j = right; j &gt;= left; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                res[down][j] = tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            down--;</span><br><span class="line">            for (int i = down; i &gt;= up; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i][left] = tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/24/create_blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/24/create_blog/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-24 11:31:13" itemprop="dateCreated datePublished" datetime="2023-04-24T11:31:13+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-29 19:58:38" itemprop="dateModified" datetime="2022-11-29T19:58:38+08:00">2022-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="hexo-github部署个人博客"><a href="#hexo-github部署个人博客" class="headerlink" title="hexo+github部署个人博客"></a>hexo+github部署个人博客</h1><h2 id="环境与软件需求"><a href="#环境与软件需求" class="headerlink" title="环境与软件需求"></a>环境与软件需求</h2><ul>
<li>win10</li>
<li>git<br><em><strong>本教程需要先安装好git</strong></em><br><em><strong>本教程需要先安装好git</strong></em><br><em><strong>本教程需要先安装好git</strong></em></li>
</ul>
<ol>
<li><p>在<a target="_blank" rel="noopener" href="http://nodejs.org/">node.js官网</a>下载对应版本</p>
<p><img src="/create_blog/node_js.png" alt="nodejs"></p>
</li>
<li><p>安装完成后打开Git Bash.exe，输入<code>node -v</code>可查看node.js安装版本，输入<code>npm -v</code>可查看npm安装版本</p>
<p><img src="/create_blog/-v.png" alt="查看版本"></p>
</li>
<li><p>利用npm安装cnpm，同时使用镜像源</p>
<p><code>npm install -g cnpm --registry=https://registry.nmp.taobao.org</code></p>
</li>
<li><p>同样地，可以输入<code>cnpm</code>查看cnpm版本</p>
</li>
<li><p>这时，就可利用cnpm安装hexo，输入<code>cnpm install -g hexo-cli</code></p>
<p><img src="/create_blog/hexo.png" alt="hexo"></p>
</li>
<li><p>至此，创建博客前序步骤全部完成，在bash中指定一个路径，输入<code>mkdir </code>+文件夹名称，如blog，作为博客的根目录，进入该目录路径（有关博客操作都要在博客的根目录下进行），输入<code>hexo init</code>即完成博客的初始化。此时，输入<code>hexo s</code>即可通过<a href="localhost:4000">localhost:4000</a>对博客进行访问</p>
</li>
<li><p>在github中新建一个仓库待用，仓库名字通常为github名.github.io</p>
</li>
<li><p>安装git部署插件，输入<code>npm install hexo-deployer-git --save</code>，每次新建一个blog都要安装一次插件</p>
</li>
<li><p>更改配置文件（很多时候都会用到配置文件），输入<code>vim _config.yml</code>，先输入<code>i</code>使改为<code>insert</code>模式，找到<code>Deployment</code>进行配置修改，修改成如下</p>
<p><img src="/create_blog/deployment.png" alt="deployment"></p>
<p>即修改<code>type</code>属性为<code>git</code>，在<code>repo</code>下输入在github新建仓库的地址，并加上<code>branch:master</code>指定分支为master，然后即可退出vim，按下esc再按两次大写Z</p>
</li>
<li><p>此时即可对博客进行在github上的部署，在输入<code>hexo d</code>之前需要先输入<code>git config --global user.email &quot;18khhuang2@stu.edu.cn&quot;</code>和<code>git config --global user.name &quot;kevin346-sc&quot;</code>进行认证，否则将会无法进行远端部署</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-24 10:49:36" itemprop="dateCreated datePublished" datetime="2023-04-24T10:49:36+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-29 19:48:16" itemprop="dateModified" datetime="2022-11-29T19:48:16+08:00">2022-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/19/collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/19/collection/" class="post-title-link" itemprop="url">collection</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-19 11:23:27" itemprop="dateCreated datePublished" datetime="2023-04-19T11:23:27+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-03 09:25:18" itemprop="dateModified" datetime="2023-05-03T09:25:18+08:00">2023-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1. </p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"> </span><br><span class="line">struct PriceInfo &#123; double price; &#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const std::vector&lt;int&gt; data &#123;1, 2, 4, 5, 5, 6&#125;;</span><br><span class="line"> </span><br><span class="line">    for (int i = 0; i &lt; 7; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        // Search first element that is greater than i</span><br><span class="line">        auto upper = std::upper_bound(data.begin(), data.end(), i);</span><br><span class="line"> </span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; &quot; &lt; &quot;;</span><br><span class="line">        upper != data.end()</span><br><span class="line">            ? std::cout &lt;&lt; *upper &lt;&lt; &quot; at index &quot; &lt;&lt; std::distance(data.begin(), upper)</span><br><span class="line">            : std::cout &lt;&lt; &quot;not found&quot;;</span><br><span class="line">        std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;PriceInfo&gt; prices &#123;&#123;100.0&#125;, &#123;101.5&#125;, &#123;102.5&#125;, &#123;102.5&#125;, &#123;107.3&#125;&#125;;</span><br><span class="line"> </span><br><span class="line">    for (double to_find : &#123;102.5, 110.2&#125;)</span><br><span class="line">    &#123;</span><br><span class="line">        auto prc_info = std::lower_bound(prices.begin(), prices.end(), to_find,</span><br><span class="line">            [](double va,const PriceInfo&amp; info)</span><br><span class="line">            // no known conversion for argument 1 from &#x27;PriceInfo&#x27; to &#x27;double&#x27;</span><br><span class="line">            &#123;</span><br><span class="line">                return va &gt; info.price;</span><br><span class="line">            &#125;);</span><br><span class="line"> </span><br><span class="line">        prc_info != prices.end()</span><br><span class="line">            ? std::cout &lt;&lt; prc_info-&gt;price &lt;&lt; &quot; at index &quot; &lt;&lt; prc_info - prices.begin()</span><br><span class="line">            : std::cout &lt;&lt; to_find &lt;&lt; &quot; not found&quot;;</span><br><span class="line">        std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>需要将lambda函数 捕获列表中参数位置互换
</code></pre>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto prc_info = std::lower_bound(prices.begin(), prices.end(), to_find,</span><br><span class="line">            [](const PriceInfo&amp; info, double va)</span><br><span class="line">            &#123;</span><br><span class="line">                return va &gt; info.price;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>2. </p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 修改时间</span><br><span class="line">   char* t = ctime(&amp;st.st_mtime); // 这个字符串包含最后的换行符</span><br><span class="line">   // printf(&quot;%s\n&quot;, t);</span><br><span class="line">   </span><br><span class="line">   char* tt;</span><br><span class="line">   strncpy(tt, t, strlen(t) - 1); // 发生段错误</span><br><span class="line">   </span><br><span class="line">   char tt[1024];</span><br><span class="line">   // strncpy(tt, t, sizeof(t) - 1); // Tue May</span><br><span class="line">   strncpy(tt, t, strlen(t) - 1); // Tue May  2 10:15:54 2023</span><br><span class="line">   printf(&quot;%s\n&quot;, tt);</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<pre><code>`dest`不能用`char*`的`tt`，只能用`char tt[1024]`；
</code></pre>
<p>   <code>sizeof</code>只有前半段字符串，<code>strlen</code>才能全部复制</p>
<p>   并且<code>char tt[1024]</code>会改变前面变量<code>quanxian</code>的值，在后面加上了<code>tt</code>，而修改成更大的值则正常</p>
<p>3. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/11/Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/Nginx/" class="post-title-link" itemprop="url">Nginx</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-11 16:41:59" itemprop="dateCreated datePublished" datetime="2023-04-11T16:41:59+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-01 09:36:42" itemprop="dateModified" datetime="2023-05-01T09:36:42+08:00">2023-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="在Ubuntu18中使用Nginx"><a href="#在Ubuntu18中使用Nginx" class="headerlink" title="在Ubuntu18中使用Nginx"></a>在Ubuntu18中使用Nginx</h1><p>准备Nginx所需的库</p>
<ol>
<li><p>GCC编译器</p>
<p>Nginx不直接提供二进制可执行程序</p>
</li>
<li><p>PCRE库</p>
<p><code>sudo apt-get install libpcre3-dev</code></p>
<p>安装完成后用 <code>pcre-config --version</code>查看是否安装成功</p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927013.png" style="zoom: 50%;" />
</li>
<li><p>zlib库</p>
<p><code>zlib</code>库主要用于对HTTP包的内容进行压缩，进而减少网络传输量</p>
<p><code>sudo apt install zlib1g</code></p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927790.png" style="zoom: 80%;" />

<p><code>zlib</code>是直接使用的库，<code>zlib-devel</code>是二次开发所需要的库</p>
<p><code>sudo apt install zlib1g-dev</code></p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927372.png" style="zoom: 80%;" />
</li>
<li><p>OpenSSL开发库</p>
<p>通过OpenSSL库，可以使用SSL协议传输HTTP，另外，使用MD5、SHA1等散列函数也需要该库</p>
<p>在Ubuntu系统中，<code>openssl-devel</code>库需要分开来安装</p>
<p><code>sudo apt-get install openssl</code></p>
<p><code>sudo apt-get install libssl-dev</code></p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927704.png" style="zoom: 50%;" /></li>
</ol>
<h1 id="在centos-7-中使用Nginx"><a href="#在centos-7-中使用Nginx" class="headerlink" title="在centos 7 中使用Nginx"></a>在centos 7 中使用Nginx</h1><h2 id="安装所需要的库"><a href="#安装所需要的库" class="headerlink" title="安装所需要的库"></a>安装所需要的库</h2><ol>
<li><p>gcc 和 g++</p>
<p><code>yum installl -y gcc</code></p>
<p><img src="D:\hexo_blog\source_posts\Nginx\gcc_c.png"></p>
<p><code>yum install -y gcc-c++</code></p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010926366.png"></p>
</li>
<li><p>pcre</p>
<p><code>yum install -y pcre pcre-devel</code></p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927886.png" style="zoom: 50%;" />
</li>
<li><p>zlib</p>
<p><code>yum install -y zlib zlib-devel</code></p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927713.png" style="zoom: 50%;" />
</li>
<li><p>openssl</p>
<p><code>yum install -y openssl openssl-devel</code></p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010925548.png"></p>
</li>
</ol>
<h2 id="让centos7实现联网"><a href="#让centos7实现联网" class="headerlink" title="让centos7实现联网"></a>让centos7实现联网</h2><p>默认情况下是不联网，而我们通常需要赋予静态IP让虚拟机联网</p>
<p>centos 系统默认没有<code>ifconfig</code>命令，需要先下载<code>yum install -y  net-tools.x86_64</code>或者使用<code>ip addr</code>命令，关注<code>ens33</code></p>
<ol>
<li><p>修改ens33的配置文件</p>
<p><code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010925247.png"></p>
<p>将<code>BOOTPROTO</code>由原来的dhcp改为static，表明使用静态IP地址，将<code>ONBOOT</code>由原来的no改为yes，启动网络连接，再给出IP地址、子网掩码、网关和DNS服务器。以上DNS服务器是免费的</p>
</li>
<li><p>重启网络服务</p>
<p><code>systemctl restart network</code></p>
</li>
<li><p>输入<code>ip addr</code>命令可以看到网络配置完成，可以通过<code>ping www.baidu.com</code>进行测试，完成联网</p>
</li>
</ol>
<h2 id="编译Nginx源码"><a href="#编译Nginx源码" class="headerlink" title="编译Nginx源码"></a>编译Nginx源码</h2><p>上一步中联网的目的是获取虚拟机的IP地址，通过xshell以及xftp连接进行Nginx源码的传输</p>
<p>准备好以下的目录</p>
<ol>
<li>Nginx源码的存放目录，存放Nginx源码文件，非官方的模块源代码文件</li>
<li>编译阶段产生的中间文件存放目录，默认情况下编译过程中自动生成objs目录，存放在源码目录下</li>
<li>部署目录，存放实际Nginx运行所需要的二进制文件、配置文件，默认情况下为 <code>/usr/local/nginx</code></li>
<li>日志文件存放目录</li>
</ol>
<p>默认情况下，linux内核参数考虑最通用的场景，不符合用于高并发访问的web服务器的定义，所以通过修改内核参数，使得Nginx拥有更高性能</p>
<p>修改<code>/etc/sysctl.conf</code>来更改内核参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fs .file-max = 999999</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.ip_local_port_range = 1024		61000</span><br><span class="line">net.ipv4.tcp_rmem = 4096 32768 262142</span><br><span class="line">net.ipv4.tcp_wmem = 4096 32768 262142</span><br><span class="line">net.core.netdev_max_backlog = 8096</span><br><span class="line">net.core.rmem_default = 262144</span><br><span class="line">net.core.wmem_default = 262144</span><br><span class="line">net.core.rmem_max = 2097152</span><br><span class="line">net.core.wmem_max = 2097152</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_syn.backlog=1024</span><br></pre></td></tr></table></figure>

<p>然后执行<code>sysctl -p</code>命令，使上述修改生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">file-max: 这个参数表示进程 (比如一个 worker 进程) 可以同时打开的最大句柄数这个参数直接限制最大并发连接数，需根据实际情况配置。</span><br><span class="line">tcp_tw_reuse: 这个参数设置为 1，表示允许将 TIME-WAIT 状态的 socket 重新用于新的 TCP 连接，这对于服务器来说很有意义，因为服务器上总会有大量 TIME-WAIT 状态的连接</span><br><span class="line">tcp_keepalive_time: 这个参数表示当 keepalive 启用时，TCP 发送 keepalive 消息的频度。默认是 2 小时，若将其设置得小一些，可以更快地清理无效的连接。</span><br><span class="line">tcp_fin_timeout:这个参数表示当服务器主动关闭连接时，socket 保持在 FIN-WAIT-2状态的最大时间。</span><br><span class="line">tcp_max_tw_buckets: 这个参数表示操作系统允许 TIME WAIT 套接字数量的最大值如果超过这个数字，TIME WAIT 套接字将立刻被清除并打印警告信息。该参数默认为 180 000，过多的 TIME WAIT 套接字会使 Web 服务器变慢。</span><br><span class="line">tcp_max_syn_backlog: 这个参数表示 TCP 三次握手建立阶段接收 SYN 请求队列的最大长度，默认为 1024，将其设置得大一些可以使出现 Nginx 繁忙来不及 accept 新连接的情况时，Linux 不至于丢失客户端发起的连接请求。</span><br><span class="line">ip_local_port_range:这个参数定义了在 UDP 和TCP 连接中本地 (不括连接的远端)端口的取值范围。</span><br><span class="line">net.ipv4.tcp_rmem : 这个参数定义了 TCP 接收缓存 (用于 TCP 接收滑动窗口)的最小值、默认值、最大值。</span><br><span class="line">net.ipv4.tcp_wmem: 这个参数定义了 TCP 发送缓存 (用于 TCP 发送滑动窗口)的最小值、默认值、最大值。</span><br><span class="line">netdev_max_backlog: 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。这个参数表示该队列的最大值。</span><br><span class="line">rmem_default: 这个参数表示内核套接字接收缓存区默认的大小。</span><br><span class="line">wmem_default: 这个参数表示内核套接字发送缓存区默认的大小</span><br><span class="line">rmem_max: 这个参数表示内核套接字接收缓存区的最大大小。</span><br><span class="line">wmem_max: 这个参数表示内核套接字发送缓存区的最大大小。</span><br><span class="line">tcp_syncookies：该参数与性能无关，用于解决 TCP 的 SYN 攻击</span><br></pre></td></tr></table></figure>

<p>进入到Nginx源码目录，执行以下3行命令：</p>
<p><code>./configure</code>——检测操作系统内核和已经安装的软件，参数的解析，中间目录的生成以及根据各种参数生成一些 C 源码文件、Makefile 文件等</p>
<p><code>make</code>——根据 configure 命令生成的 Makefile 文件编译Nginx 工程，并生成目标文件最终的二进制文件</p>
<p><code>make install</code>——根据configure 执行时的参数将Nginx 部署到指定的安装目录，包括相关目录的建立和二进制文件、配置文件的复制</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/03/12/webserver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/12/webserver/" class="post-title-link" itemprop="url">webserver</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-12 08:45:41" itemprop="dateCreated datePublished" datetime="2023-03-12T08:45:41+08:00">2023-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-15 15:29:27" itemprop="dateModified" datetime="2023-05-15T15:29:27+08:00">2023-05-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="webserver高性能服务器"><a href="#webserver高性能服务器" class="headerlink" title="webserver高性能服务器"></a>webserver高性能服务器</h1><p>系统：Linux</p>
<p>发行版：Ubuntu18</p>
<p>涉及知识点：</p>
<p>软件：VMware Station、Visual Studio Code、Xshell、Xftp</p>
<p>linux发行版中，有两个主流，CentOs和Ubuntu，分别是基于红帽企业和Debian，Ubuntu需要经常更新，用到.deb和apt软件包；而CentOS不常更新，使用.rpm和flatpak软件包。这说明了CentOS会更稳定。在此项目中，因为Ubuntu有一个庞大的社区，有更多的文档和免费的问题信息支持，并且Ubuntu上手更为简单，因此选择的发行版为Ubuntu18</p>
<h1 id="0、搭建linux虚拟机开发环境"><a href="#0、搭建linux虚拟机开发环境" class="headerlink" title="0、搭建linux虚拟机开发环境"></a>0、搭建linux虚拟机开发环境</h1><h2 id="Ubuntu-18安装"><a href="#Ubuntu-18安装" class="headerlink" title="Ubuntu 18安装"></a>Ubuntu 18安装</h2><p>下载Ubuntu18光驱，在VMware Station中创建Ubuntu 64位虚拟机并导入光驱进行安装，推荐安装VMware Tools，能够自适应虚拟机屏幕大小和实现在主机拖拽文件到虚拟机中等功能。</p>
<p>终端安装ssh，输入<code>sudo apt install openssh-server</code></p>
<p>[报错]暂时不能解析域名“sercurity.ubuntu.com”——这是因为虚拟机没有连上网，可以打开虚拟机设置选择桥接模式，并勾上复制物理网络连接状态（复习桥接模式和NAT）<img src="C:\myblog\source\_posts\webserver\ubuntu_net.png" style="zoom:60%;" /></p>
<p>为连接虚拟机，需要获取虚拟机的IP地址，在终端输入<code>sudo apt install net-tools</code>安装<code>net-tools</code>后即可通过<code>ifconfig</code>命令获取IP地址</p>
<p>[报错]没有可安装的候选——执行<code>sudo apt install net-tools</code>之后再次安装即可</p>
<h2 id="用xshell连接虚拟机"><a href="#用xshell连接虚拟机" class="headerlink" title="用xshell连接虚拟机"></a>用xshell连接虚拟机</h2><p>复制虚拟机的IP地址，在xshell中新建会话，填写会话名称和主机号（虚拟机IP地址），协议选择ssh，其余默认即可</p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003845.png" style="zoom:60%;" />

<p>输入用户名，密码就可以连接上</p>
<h2 id="在vscode中连接虚拟机"><a href="#在vscode中连接虚拟机" class="headerlink" title="在vscode中连接虚拟机"></a>在vscode中连接虚拟机</h2><p>在扩展中下载remote development，可以看到左侧栏多出的“远程资源管理器”图标，进入远程资源管理器，选择ssh并打开ssh配置文件，填写正确参数</p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302001098.png" style="zoom: 80%;" />

<p>之后，能看到左侧ssh栏下有对应的主机连接信息，选择再新窗口中打开，输入密码就能在vscode实现对虚拟机的操作</p>
<h1 id="1、linux-系统编程入门"><a href="#1、linux-系统编程入门" class="headerlink" title="1、linux 系统编程入门"></a>1、linux 系统编程入门</h1><h2 id="静态库创建和使用"><a href="#静态库创建和使用" class="headerlink" title="静态库创建和使用"></a>静态库创建和使用</h2><ol>
<li><code>gcc -c *.c</code>编译生成<code>.o</code>类型文件</li>
<li><code>ar rcs libxxx.a *.o</code>利用ar工具将<code>.o</code>文件生成名为xxx的静态库，其中，<code>lib</code>和<code>.a</code>为固定命名</li>
</ol>
<p>编译<code>main.c</code>文件时，需要包含函数声明的头文件，以及函数定义的静态库文件 </p>
<p>文件结构如下时，</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003238.png"></p>
<p><code>gcc -o app main.c -I ./include -l calc -L ./lib</code>生成 可执行文件<code>app</code></p>
<h2 id="动态库创建和使用"><a href="#动态库创建和使用" class="headerlink" title="动态库创建和使用"></a>动态库创建和使用</h2><ol>
<li><code>gcc -fpic -c *.c </code>编译生成与位置无关的<code>.o</code>文件</li>
<li><code>gcc -shared *.o -o libxxx.so</code>生成名为xxx的动态库，其中，<code>lib</code>和<code>.so</code>为固定命名</li>
</ol>
<p>在dynamic文件夹下生成动态库文件如下：</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003732.png"></p>
<p>在使用动态库时，如果直接像静态库那样使用，则在运行生成的可执行文件<code>app</code>时会报错</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003380.png"></p>
<p>使用<code>ldd(list dynamic dependencies)</code>命令查看动态库的依赖关系</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003737.png"></p>
<p>可以看到，最终生成的可执行文件不能运行的原因在于其对应的动态库<code>libcalc.so</code>缺失</p>
<p>而文件在定位共享库时，对应ELF格式的可执行程序，先后搜索 DT_RPATH段 -&gt; 环境变量LD_LIBRARY_PATH -&gt; &#x2F;etc&#x2F;ld.so.cache 文件列表 -&gt; &#x2F;lib&#x2F;, &#x2F;usr&#x2F;lib 目录找到库文件后将其载入内存</p>
<p>因此，第一种方法可以在环境变量LD_LIBRARY_PATH中加入动态库路径</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004567.png"></p>
<p><strong>但环境变量在每次关闭终端后都会恢复到打开终端之前</strong></p>
<p>第二种方法则可以在用户级别下配置文件 <code>~/.bashrc</code> 中保存该环境变量</p>
<p><code>vim .bashrc</code>敲入<code>shift+g</code>移动到最后一行，敲入<code>o</code>在下一行中插入编辑</p>
<p>输入相同的<code>export</code>语句，保存并退出，<code>. .bashrc</code>或<code>source .bashrc</code>重新运行配置文件使其生效</p>
<p>第三种方法在系统级别下配置文件 <code>/etc/profile</code> 中加入同样的<code>export</code>语句</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004159.png"></p>
<p>以上是通过环境变量来找到路径</p>
<p>另外，还可以修改<code>/etc/ld.so.cache </code>文件，<code>sudo vim /etc/ld.so.conf</code>在文件中加入路径，间接修改<code>.cache</code>文件，保存退出，<code>sudo ldconfig</code>进行更新</p>
<p>最后，不推荐将动态库文件放到 <code>/lib/</code>,<code>/usr/lib/</code>目录中，因为这两个目录下有很多文件，可能会有重复命名问题</p>
<h2 id="静态库vs动态库"><a href="#静态库vs动态库" class="headerlink" title="静态库vs动态库"></a>静态库vs动态库</h2><p>静态库</p>
<ul>
<li>加载速度快</li>
<li>程序发布不需要提供静态库，移植方便</li>
<li>但浪费内存</li>
<li>不利于更新部署</li>
</ul>
<p>动态库</p>
<ul>
<li>实现进程间资源共享</li>
<li>更新部署简单</li>
<li>何时加载可控</li>
<li>但加载速度慢</li>
<li>程序发布需要提供动态库</li>
</ul>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>目标 ： 依赖</p>
<p>​		(tab)命令</p>
<p>其他规则通常为第一条规则服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app : sub.c add.c mult.c div.c main.c</span><br><span class="line">	gcc sub.c add.c mult.c div.c main.c -o app</span><br></pre></td></tr></table></figure>

<p>依赖存在，则执行命令；否则向下检查其他规则，寻找生成依赖的命令</p>
<p>依赖生成时间比目标晚，则需要执行命令对目标进行更新</p>
<p>变量定义：变量名&#x3D;变量值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AR : 归档维护程序的名称，默认值为 ar</span><br><span class="line">CC : C 编译器的名称，默认值为 cc</span><br><span class="line">CXX : C++ 编译器的名称，默认值为 g++</span><br><span class="line">$@ : 目标的完整名称</span><br><span class="line">$&lt; : 第一个依赖文件的名称</span><br><span class="line">$^ : 所有的依赖文件</span><br><span class="line"></span><br><span class="line">%.o : %.c 匹配同一个字符串</span><br><span class="line"></span><br><span class="line">$(wildcard ./*.c ./PATH/*.c)</span><br><span class="line">返回 a.c b.c c.c</span><br><span class="line">src=$(wildcard ./*.c)</span><br><span class="line"></span><br><span class="line">$(patsubst %.c %.o a.c b.c)</span><br><span class="line">返回替换a.c, b.c 后的字符串 a.o, b.o</span><br><span class="line">objs=$(patsubst %.c, %.o, $(src))</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">	rm $(objs) -f</span><br></pre></td></tr></table></figure>



<h2 id="GDB调试工具"><a href="#GDB调试工具" class="headerlink" title="GDB调试工具"></a>GDB调试工具</h2><p>gcc -g -Wall a.c -o test</p>
<p>-g作用是在可执行文件中加入源代码信息，-wall打开所有warning</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">list/l (行号)</span><br><span class="line">list/l (文件名:函数名)</span><br><span class="line">show list</span><br><span class="line">set list (要显示的行数大小)</span><br><span class="line">set args (给程序输入的参数1) (给程序输入的参数2)</span><br><span class="line">show args</span><br><span class="line">b (行号)</span><br><span class="line">b (文件名:函数名)</span><br><span class="line">b (行号) if (条件)</span><br><span class="line">i b</span><br><span class="line">d (断点编号)</span><br><span class="line">dis (断点编号)</span><br><span class="line">ena (断点编号)</span><br><span class="line">run  ——遇到断点才停</span><br><span class="line">start ——停在第一行</span><br><span class="line">c ——到下一个断点</span><br><span class="line">n ——下一行(不进入函数体)</span><br><span class="line">s ——下一步(进入函数体)</span><br><span class="line">finish ——调出函数体</span><br><span class="line">p (变量名) ——打印变量值</span><br><span class="line">ptype (变量名) ——打印变量类型</span><br><span class="line">display (变量名) ——自动打印变量名</span><br><span class="line">undisplay(变量名) ——取消自动打印</span><br><span class="line">i display ——显示自动打印信息</span><br><span class="line">set var (变量名)=(变量值)</span><br></pre></td></tr></table></figure>

<h2 id="文件I-x2F-O函数"><a href="#文件I-x2F-O函数" class="headerlink" title="文件I&#x2F;O函数"></a>文件I&#x2F;O函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* open 函数</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">	- flags: O_RDONLY, O_WRONLY, O_RDWR, O_CREAT...</span><br><span class="line">	- mode: 八进制，最终文件权限值为 mode &amp; ~umask, umask 默认 0002， 也可以使用宏，如 S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*read 函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">	从fd指向的文件中读取 count字节，存到buf中</span><br><span class="line">	返回-1则读取失败，0则表示读取到文件末尾，否则返回读取到的字节数</span><br><span class="line">size_t and ssize_t are,  respectively,  unsigned  and  signed</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*write 函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">	将buf中的count字节写入到文件fd中</span><br><span class="line">	返回写入的字节数，有可能小于count，因为写入空间不够。-1或0则写入失败</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*lseek 函数</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">	改变文件 fd 中的读写指针位置</span><br><span class="line">	- whence 可选参数 </span><br><span class="line">		宏定义 SEEK_SET, 文件开始位置</span><br><span class="line">		SEEK_CUR, 文件指针当前位置</span><br><span class="line">		SEEK_END, 文件结束位置</span><br><span class="line">	返回从文件开头开始的指针位置，-1则报错，并将报错记录在perrno中</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*stat 函数</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int stat(const char *pathname, struct stat *statbuf);</span><br><span class="line">	获取文件信息，记录在statbuf当中</span><br><span class="line">- struct stat &#123;</span><br><span class="line">              dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">              ino_t     st_ino;         /* Inode number */</span><br><span class="line">              mode_t    st_mode;        /* File type and mode */</span><br><span class="line">              nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">              uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">              gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">              dev_t     st_rdev;        /* Device ID (if special file) */</span><br><span class="line">              off_t     st_size;        /* Total size, in bytes */</span><br><span class="line">              blksize_t st_blksize;     /* Block size for filesystem I/O */</span><br><span class="line">              blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line">              time_t	 st_atime;		/* Time of last access */</span><br><span class="line">              time_t	 st_mtime;		/* Time of last modification */</span><br><span class="line">              time_t	 st_ctime;		/* Time of last status change */</span><br><span class="line">          &#125;;</span><br><span class="line">- 返回0则成功，否则返回-1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>其中，st_mode 变量如下：</p>
<p>setGID - 设置组id，setUID - 设置用户id，Sticky - 粘住位</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004423.png" alt="st_mode"></p>
<p>根据文件类型位，与相应位的宏定义 相与 运算即可，</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004953.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*lstat 函数</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/stat.h&gt;</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int lstat(const char *pathname, struct stat *statbuf);</span><br><span class="line">    	stat函数如果传入的是软连接，则返回链接文件信息而非链接指向的文件，而lstat函数返回链接指向文件的信息</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>利用上述函数实现<code>ls -l</code> 命令</p>
<p>接受一个文件名当做函数参数，输出该文件的信息</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305011616507.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">//ls-l.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;grp.h&gt;</span><br><span class="line">#include &lt;pwd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">// 类型权限 硬链接数 用户名 组名 文件大小 修改时间 文件名</span><br><span class="line">//-rw-rw-r-- 1 kevin kevin 0 5月   1 16:07 ls-l.c</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;too few arguments&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    struct stat st;</span><br><span class="line">    int flag = stat(argv[1], &amp;st);</span><br><span class="line">    if(flag == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;stat&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char filetype;</span><br><span class="line">    switch(st.st_mode &amp; __S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">        case __S_IFLNK:</span><br><span class="line">            filetype = &#x27;l&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFSOCK:</span><br><span class="line">            filetype = &#x27;s&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFREG:</span><br><span class="line">            filetype = &#x27;-&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFDIR:</span><br><span class="line">            filetype = &#x27;d&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFBLK:</span><br><span class="line">            filetype = &#x27;b&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFCHR:</span><br><span class="line">            filetype = &#x27;c&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFIFO:</span><br><span class="line">            filetype = &#x27;f&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            filetype = &#x27;?&#x27;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    char quanxian[10];</span><br><span class="line">    memset(quanxian, &#x27;-&#x27;, sizeof(quanxian));</span><br><span class="line">    // user</span><br><span class="line">    if(st.st_mode &amp; S_IRUSR)</span><br><span class="line">        quanxian[1] = &#x27;R&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IWUSR)</span><br><span class="line">        quanxian[2] = &#x27;W&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IXUSR)</span><br><span class="line">        quanxian[3] = &#x27;X&#x27;;</span><br><span class="line">    </span><br><span class="line">    // group</span><br><span class="line">    if(st.st_mode &amp; S_IRGRP)</span><br><span class="line">        quanxian[4] = &#x27;R&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IWGRP)</span><br><span class="line">        quanxian[5] = &#x27;W&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IXGRP)</span><br><span class="line">        quanxian[6] = &#x27;X&#x27;;</span><br><span class="line">    </span><br><span class="line">    // other</span><br><span class="line">    if(st.st_mode &amp; S_IROTH)</span><br><span class="line">        quanxian[7] = &#x27;R&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IWOTH)</span><br><span class="line">        quanxian[8] = &#x27;W&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IXOTH)</span><br><span class="line">        quanxian[9] = &#x27;X&#x27;;</span><br><span class="line">    // printf(&quot;%c%s\n&quot;, filetype,quanxian);</span><br><span class="line"></span><br><span class="line">    // 硬链接数</span><br><span class="line">    int linknum = st.st_nlink;</span><br><span class="line"></span><br><span class="line">    // 组名 用户名</span><br><span class="line">    char* u = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line">    char* g = getgrgid(st.st_gid)-&gt;gr_name;</span><br><span class="line">    </span><br><span class="line">    // 文件大小</span><br><span class="line">    long int fsize = st.st_size;</span><br><span class="line"></span><br><span class="line">    // 文件名</span><br><span class="line">    char* file_name = argv[1];</span><br><span class="line"></span><br><span class="line">    // 修改时间</span><br><span class="line">    char* t = ctime(&amp;st.st_mtime); // 这个字符串包含最后的换行符</span><br><span class="line">    // printf(&quot;%s\n&quot;, t);</span><br><span class="line">    char tt[100];</span><br><span class="line">    // strncpy(tt, t, sizeof(t) - 1); // Tue May</span><br><span class="line">    strncpy(tt, t, strlen(t) - 1); // Tue May  2 10:15:54 2023</span><br><span class="line">    // printf(&quot;%s\n&quot;, tt);</span><br><span class="line"></span><br><span class="line">    // 最终输出结果</span><br><span class="line">    char disp[1024] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    sprintf(disp, &quot;%c%s %d %s %s %ld %s %s\n&quot;, filetype, quanxian, linknum, u, g, fsize, tt, file_name);</span><br><span class="line">    // --RW-RW-R--Tue May  2 10:23:42 2023 1 kevin kevin 2590 Tue May  2 10:23:42 2023 ls-l.c</span><br><span class="line">    // -rw-rw-r-- 1 kevin kevin  2668 5月   2 10:26 ls-l.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;%s&quot;, disp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件属性操作函数"><a href="#文件属性操作函数" class="headerlink" title="文件属性操作函数"></a>文件属性操作函数</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*access 函数</span><br><span class="line"> #include&lt;unistd.h&gt;</span><br><span class="line"> int access(const char * pathname, int mode)</span><br><span class="line"> 	判断文件的权限或是否存在</span><br><span class="line"> 	-mode, R_OK, W_OK, X_OK, F_OK</span><br><span class="line"> 	成功返回0，否则返回-1</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*chmod 函数</span><br><span class="line">	#include &lt;sys/stat.h&gt;</span><br><span class="line">	int chmod(const char *pathname, mode_t mode);</span><br><span class="line">	改变文件权限</span><br><span class="line">	-mode, 八进制数，使用不同用户宏定义</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*truncate 函数</span><br><span class="line">	#include &lt;unistd.h&gt;</span><br><span class="line">	#include &lt;sys/types.h&gt;</span><br><span class="line">int truncate(const char *path, off_t length);</span><br><span class="line">	截断或扩展文件长度</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*mkdir 函数</span><br><span class="line">	#include &lt;sys/stat.h&gt;</span><br><span class="line">	#include &lt;sys/types.h&gt;</span><br><span class="line">	int mkdir(const char *pathname, mode_t mode);</span><br><span class="line">		- 创建目录，赋予mode权限，mode是八进制数，最终权限 = mode &amp; ~umask &amp; 0777</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*rmdir 函数</span><br><span class="line">     #include &lt;unistd.h&gt;</span><br><span class="line">     int rmdir(const char *pathname);</span><br><span class="line">         - 删除目录，目录要求是空目录</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*raname 函数</span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    int rename(const char *oldpath, const char *newpath);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*chdir 函数</span><br><span class="line">	#include &lt;unistd.h&gt;</span><br><span class="line">	int chdir(const char *path);</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*getcwd 函数</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    char *getcwd(char *buf, size_t size);</span><br><span class="line">    	- 获得当前工作目录</span><br><span class="line">    	- buf 用于存储路径的数组，size 是数组的大小</span><br><span class="line">    	- 返回值就是buf</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*opendir 函数</span><br><span class="line">	#include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;dirent.h&gt;</span><br><span class="line">    DIR *opendir(const char *name);</span><br><span class="line">    	- name 目录的名称</span><br><span class="line">    	- 返回 DIR* 类型，目录流，失败返回null</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*readdir 函数</span><br><span class="line">    #include &lt;dirent.h&gt;</span><br><span class="line">    struct dirent *readdir(DIR *dirp);</span><br><span class="line">        - dirp是opendir返回值</span><br><span class="line">        - 返回struct dirent，代表读取到的文件的信息</span><br><span class="line">          读取到了末尾或者失败则返回NULL</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*closedir 函数</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;dirent.h&gt;</span><br><span class="line">    int closedir(DIR *dirp);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>利用上述函数实现对目录的遍历和对该目录下普通文件数量的统计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#define _DEFAULT_SOURCE</span><br><span class="line">// #define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int tongji(const char * path)</span><br><span class="line">&#123;</span><br><span class="line">    DIR* dir = opendir(path);</span><br><span class="line">    if(dir == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;opendir&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    struct dirent* dent;</span><br><span class="line">    while((dent = readdir(dir)) != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        char* dirname = dent-&gt;d_name;</span><br><span class="line">        if(strcmp(dirname, &quot;.&quot;) == 0|| strcmp(dirname, &quot;..&quot;) == 0)</span><br><span class="line">            continue;</span><br><span class="line">        if(dent-&gt;d_type == DT_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            char newpath[1024];</span><br><span class="line">            sprintf(newpath, &quot;%s/%s&quot;, path, dirname);</span><br><span class="line">            cnt += tongji(newpath);</span><br><span class="line">        &#125;</span><br><span class="line">        if(dent-&gt;d_type == DT_REG)</span><br><span class="line">            cnt += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;too few args.&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = tongji(argv[1]);</span><br><span class="line">    printf(&quot;普通文件个数为：%d\n&quot;, res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件描述符复制函数"><a href="#文件描述符复制函数" class="headerlink" title="文件描述符复制函数"></a>文件描述符复制函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*dup 函数</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int dup(int oldfd);</span><br><span class="line">    	复制旧的文件描述符，返回一个新的最小空闲描述符</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*dup2 函数</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int dup2(int oldfd, int newfd);</span><br><span class="line">    	重定向文件描述符，将原本指向文件a的描述符oldfd 转向成指向文件b的描述符 newfd</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*fcntl 函数</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    #include &lt;fcntl.h&gt;</span><br><span class="line">    int fcntl(int fd, int cmd, ...);</span><br><span class="line">    	对需要操作的文件fd进行cmd操作</span><br><span class="line">    	- F_DUPFD : 复制文件描述符,复制fd，返回一个新的文件描述符</span><br><span class="line">    	- F_GETFL : 获取指定的文件描述符文件状态flag，类似open函数传递的flag</span><br><span class="line">    	- F_SETFL : 设置文件描述符文件状态flag</span><br><span class="line">              必选：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span><br><span class="line">              可选：O_APPEND, O_NONBLOCK非阻塞</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h1 id="2、Linux多进程开发"><a href="#2、Linux多进程开发" class="headerlink" title="2、Linux多进程开发"></a>2、Linux多进程开发</h1><h2 id="进程创建与查看"><a href="#进程创建与查看" class="headerlink" title="进程创建与查看"></a>进程创建与查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br><span class="line">	成功：子进程返回0，父进程返回子进程ID</span><br><span class="line">	失败则返回-1</span><br><span class="line">		- 当前系统的进程数达到系统规定上限，errno置为EAGAIN</span><br><span class="line">		- 系统内存不足，errno置为ENOMEM</span><br></pre></td></tr></table></figure>

<p><code>ps aux</code>、<code>ps ajx</code>列出与作业控制相关的信息、<code>ps -ef</code></p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305041430373.png"></p>
<p><code>top</code>命令实时显示进程动态 <code>-d</code>指定更新时间间隔</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305041434410.png"></p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305041437661.png"></p>
<h2 id="多进程GDB调试"><a href="#多进程GDB调试" class="headerlink" title="多进程GDB调试"></a>多进程GDB调试</h2><p>GDB默认只跟踪一个进程，调试当前进程时，其他进程继续运行</p>
<p><code>set follow-fork-mode [parent | child]</code>设置当前调试父进程或子进程</p>
<p><code>set detach-on-fork [on | off]</code> off表示调试当前进程时，其他进程被挂起，否则继续运行</p>
<p><code>info inferiors</code>查看调试的进程</p>
<p><code>inferior id</code>切换当前调试的进程</p>
<p><code>detach inferiors id</code>使进程脱离GDB调试</p>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><p>exec函数族的作用是根据指定的文件名找到可执行文件，调用后直接取代当前进程的内容，调用进程覆盖原来的内存</p>
<p>调用成功不返回，调用失败则返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line"></span><br><span class="line">int execlp(const char *file, const char *arg, ... /* (char *) NULL */);</span><br><span class="line"></span><br><span class="line">int execle(const char *path, const char *arg, .../*, (char *) NULL, char *const envp[] */);</span><br><span class="line"></span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line"></span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line"></span><br><span class="line">int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line"></span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure>

<p>l(list)——参数地址列表，以空指针结尾<br>v(vector)——存有各参数地址的指针数组的地址<br>p(path)——按 PATH 环境变量指定的目录搜索可执行文件<br>e(environment)——存有环境变量字符串地址的指针数组的地址</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>标准C库<code>exit</code>与Linux标准库<code>_exit</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);</span><br><span class="line">	在终止进程之前会刷新I/O缓冲区，而_exit则不会</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure>

<p>孤儿进程：父进程在子进程之前退出，子进程就被称为孤儿进程，将成为init进程的子进程，孤儿进程没有危害</p>
<p>僵尸进程：子进程在父进程之前退出，内核会在子进程退出后会保留一定的信息，而父进程没有进行处理，则产生僵尸进程，大量僵尸进程占用进程号，导致无法创建新的进程</p>
<p>僵尸进程的解决</p>
<ol>
<li><p>干掉父进程，让子进程变为孤儿进程，由init进程负责释放</p>
</li>
<li><p>父进程调用<code>wait()</code>或<code>waitpid()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t wait(int *wstatus);</span><br><span class="line">	- wstatus 储存子进程退出状态，使用相关宏函数可以获取退出状态信息</span><br><span class="line">	- 返回值 &gt; 0 返回的是子进程ID号, &lt; 0 失败，所有子进程结束</span><br><span class="line">pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">	- pid = -1, options = WNOHANG时等同于wait()</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305061511601.png" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305061513010.png" style="zoom:50%;" />
</li>
<li><p><code>fork</code>两次</p>
<p>父进程fork子进程，子进程fork孙进程后退出，则孙进程被init接管，但需要父进程回收子进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t  pid;</span><br><span class="line">    //创建第一个子进程</span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fork error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //第一个子进程</span><br><span class="line">    else if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //子进程再创建子进程</span><br><span class="line">        printf(&quot;I am the first child process.pid:%d\tppid:%d\n&quot;,getpid(),getppid());</span><br><span class="line">        pid = fork();</span><br><span class="line">        if (pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fork error:&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        //第一个子进程退出</span><br><span class="line">        else if (pid &gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;first procee is exited.\n&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        //第二个子进程</span><br><span class="line">        //睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里</span><br><span class="line">        sleep(3);</span><br><span class="line">        printf(&quot;I am the second child process.pid: %d\tppid:%d\n&quot;,getpid(),getppid());</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //父进程处理第一个子进程退出</span><br><span class="line">    if (waitpid(pid, NULL, 0) != pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;waitepid error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>signal</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">static void sig_child(int signo);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    //创建捕捉子进程退出信号</span><br><span class="line">    signal(SIGCHLD,sig_child);</span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fork error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;I am child process,pid id %d.I am exiting.\n&quot;,getpid());</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;I am father process.I will sleep two seconds\n&quot;);</span><br><span class="line">    //等待子进程先退出</span><br><span class="line">    sleep(2);</span><br><span class="line">    //输出进程信息</span><br><span class="line">    system(&quot;ps -o pid,ppid,state,tty,command&quot;);</span><br><span class="line">    printf(&quot;father process is exiting.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sig_child(int signo)</span><br><span class="line">&#123;</span><br><span class="line">     pid_t        pid;</span><br><span class="line">     int        stat;</span><br><span class="line">     //处理僵尸进程</span><br><span class="line">     while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt;0)</span><br><span class="line">            printf(&quot;child %d terminated.\n&quot;, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间通讯的目的：</p>
<ol>
<li>数据传输</li>
<li>通知事件</li>
<li>资源共享</li>
<li>进程控制</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305061537759.png"></p>
<h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>管道即匿名管道，没有文件实体，但有名管道有文件实体</p>
<p>管道是字节流，能够读取任意大小的数据块</p>
<p>匿名管道只能在<strong>具有公共祖先</strong>的进程中使用</p>
<p>使用命令<code>ulimit -a</code>可以查看管道缓冲大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int pipefd[2])</span><br><span class="line">	- 创建管道</span><br><span class="line">	- pipefd数组中，pipefd[0]表示管道读端， pipefd[1]表示写端，相当于管道两端的文件描述符</span><br><span class="line"></span><br><span class="line">int pipe2(int pipefd[2], int flags)</span><br><span class="line">	- flags参数O_NONBLOCK可以将管道设为非阻塞</span><br><span class="line"></span><br><span class="line">long fpathconf(int fd, int name)</span><br><span class="line">	- 查看管道缓冲大小函数</span><br><span class="line">	- fd是管道的读端或者写端，根据name所对应的宏定义可以获取管道的相关信息，_PC_PIPE_BUF最大缓冲区大小</span><br></pre></td></tr></table></figure>

<h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><p>有名管道克服了匿名管道只能在有亲缘关系的进程间通信的缺点，以FIFO文件形式存在于文件系统中，只要能够访问该文件，就能彼此进行通信</p>
<p>作为一个特殊文件存在，但FIFO中的内容存放在内存中</p>
<p>与匿名管道一样，都不支持<code>lseek()</code>文件定位操作</p>
<p>可以通过<code>mkfifo</code>命令创建有名管道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int mkfifo(const char* pathname, mode_t mode);</span><br><span class="line">	- mode 与 open中一样，八进制数</span><br></pre></td></tr></table></figure>

<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.</span><br><span class="line">void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">	- addr = NULL, 由内核指定</span><br><span class="line">	- length是要映射的数据长度，可以用lseek、stat获取文件的长度</span><br><span class="line">	- prot是映射内存的操作权限，</span><br><span class="line">	  PROT_EXEC,PROT_WRITE,PROT_READ,PROT_NONE，通常要小于等于磁盘文件open的权限</span><br><span class="line">	- flags， MAP_SHARED：映射区数据自动与磁盘文件同步	MAP_PRIVATE：不同步</span><br><span class="line">	- fd 映射的文件描述符</span><br><span class="line">	- offset 偏移量，要求是4k的整数倍，通常是0</span><br><span class="line">	- 返回创建的内存的首地址，失败则返回MAP_FAILD，即-1</span><br><span class="line">int munmap(void *addr, size_t length);</span><br><span class="line">	- 释放内存映射，参数需要与mmap对应</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>flags=MAP_ANONYMOUS</code>不依赖磁盘文件，使用匿名内存映射</p>
<p><code>void* ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</code></p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是在软件层次上对中断机制的一种模拟，属于异步通信</p>
<p>命令<code>kill -l</code>查看系统定义的信号列表，前31个为常规信号，其余为实时信号</p>
<p><code>SIGINT</code>——用户按下<code>&lt;Ctrl+C&gt;</code>组合键引发——终止进程</p>
<p><code>SIGQUIT</code>——用户按下<code>&lt;Ctrl+C&gt;</code>组合键引发——终止进程</p>
<p><code>SIGKILL</code>——无条件终止进程，不能被忽略，处理和阻塞——终止除了僵尸以外的所有进程</p>
<p><code>SIGPIPE</code>——管道破裂，向一个没有读端的管道写数据——终止进程</p>
<p><code>SIGSEGV</code>——段错误，无效内存访问——终止进程并产生core文件</p>
<p><code>SIGCHLD</code>——子进程结束时，父进程收到该信号——忽略</p>
<p><code>SIGCONT</code>——进程停止则继续运行——忽略</p>
<p><code>SIGSTOP</code>——停止进程的执行，不能被忽略，处理和阻塞——暂停进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int kill(pid_t pid, int sig);// 产生任意信号sig给进程pid</span><br><span class="line">	- pid = 0, 当前组；pid &gt; 0, 进程号为pid的进程；pid = -1, 所有能接受sig信号的进程，除了init进程；pid &lt; 0，组号为pid绝对值的进程</span><br><span class="line"></span><br><span class="line">int raise(int sig);// 相当于kill(getpid(), sig)</span><br><span class="line">void abort(void);// 相当于kill(getpid(), SIGABRT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">	- 传入0取消闹钟，传入任何值都会取消之前的闹钟</span><br><span class="line">	- 返回上一个闹钟剩余时间， 0 则没有闹钟</span><br><span class="line">	- 非阻塞，产生SIGALARM信号，默认终止当前进程</span><br><span class="line"></span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">int setitimer(int which, const struct itimerval *new_val,struct itimerval *old_value);</span><br><span class="line">	- which参数：ITIMER_REAL指真实时间，同alarm()，产生SIGALRM信号；ITIMER_VIRTUAL指内核态CPU执行时间，包括所有线程消耗的时间，产生SIGVTALRM信号；ITIMER_PROF指该进程在用户态和内核态CPU消耗的时间，产生SIGPROF信号</span><br><span class="line">	- struct itimerval &#123;</span><br><span class="line">               struct timeval it_interval; /* Interval for periodic timer */</span><br><span class="line">               struct timeval it_value;    /* Time until next expiration */</span><br><span class="line">           &#125;;</span><br><span class="line">           struct timeval &#123;</span><br><span class="line">               time_t      tv_sec;         /* seconds */</span><br><span class="line">               suseconds_t tv_usec;        /* microseconds */</span><br><span class="line">           &#125;;</span><br><span class="line">	- old_value 即getitimer()返回的指针，用于返回先前设定的值，为NULL则不需要返回先前值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*ANSI C 标准*/</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">	- signum 捕捉的信号，整型数或宏定义</span><br><span class="line">	- handler 设为SIG_IGN则忽略信号；SIG_DFL则默认动作；也可以传入函数指针自定义动作</span><br><span class="line">	- 返回先前的信号处理函数指针，SIG_ERR则捕捉不成功</span><br><span class="line">	- SIGKILL和SIGSTOP不能被捕捉和忽略</span><br><span class="line">	</span><br><span class="line">/*POSIX标准*/</span><br><span class="line">int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);</span><br><span class="line">	- signum 捕捉的信号</span><br><span class="line">	-  struct sigaction &#123;</span><br><span class="line">               void     (*sa_handler)(int);// 自定义的操作函数指针，也可以是SIG_IGN或SIG_DFL</span><br><span class="line">               void     (*sa_sigaction)(int, siginfo_t *, void *);// 只有在sa_flags指定时才定义，与sa_handler只定义一个</span><br><span class="line">               sigset_t   sa_mask;//自定义临时阻塞信号集</span><br><span class="line">               int        sa_flags;// 设为0时使用sa_handler；设为SA_SIGINFO时使用sa_sigaction</span><br><span class="line">               void     (*sa_restorer)(void);// 已废弃</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h2><p>未决信号集：未决是一种状态，指从信号产生到信号被处理前的时间</p>
<p>阻塞信号集：阻塞是一种动作，阻止信号被处理，但不阻止信号产生</p>
<p>信号集在内核使用位图实现，数据类型为<code>sigset_t</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*对自定义的信号集进行操作*/</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigemptyset(sigset_t *set);</span><br><span class="line">	- 初始化信号集set所有信号为0</span><br><span class="line">int sigfillset(sigset_t *set);</span><br><span class="line">	- 初始化信号集set所有信号为1</span><br><span class="line">int sigaddset(sigset_t *set, int signum);</span><br><span class="line">	- 置单个信号为1</span><br><span class="line">int sigdelset(sigset_t *set, int signum);</span><br><span class="line">	- 置单个信号为0</span><br><span class="line">int sigismember(const sigset_t *set, int signum);</span><br><span class="line">	- 查询单个信号是否为1</span><br><span class="line">	- 返回1则是，0则不是，-1查询失败</span><br><span class="line"></span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="line">	- 用于获取或者改变信号掩码，即阻塞信号集</span><br><span class="line">	- how 设为SIG_BLOCK，阻塞信号集则是与set相或的结果，即并集；设为SIG_UNBLOCK，阻塞信号集则是与~set相与的结果；设为SIG_SETMASK，阻塞信号集则是set</span><br><span class="line">	- oldset如果非NULL，则用来存储修改之前的阻塞信号集</span><br><span class="line">	- 返回0成功，-1失败</span><br><span class="line">int sigpending(sigset_t *set);</span><br><span class="line">	- 获取当前线程的未决信号集，存储在set中</span><br></pre></td></tr></table></figure>

<h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h2><p><code>SIGCHLD</code>信号产生的条件：子进程终止；子进程收到<code>SIGSTOP</code>信号停止；子进程停止后收到<code>SIGCONT</code>信号被唤醒。父进程接收到信号后默认忽略该信号</p>
<p>因为信号是异步通信，使用<code>waitpid(-1, NULL, WNOHANG)</code>实现不阻塞父进程情况下完成对子进程的回收，以及获取到子进程的状态信息</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是在物理内存中创建一块可以由多个进程共享的区域，需要其他机制实现同步对共享内存的访问，共享内存无需内核介入，因此速度更快</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">	- key表示一个共享内存的标志，十六进制，设为IPC_PRIVATE 或者 不为IPC_PRIVATE，同时没有key对应的共享内存段，并且shmflg中指定IPC_CREAT，则创建新的共享内存段</span><br><span class="line">	- size共享内存的大小，向上取整到PAGE_SIZE的整数倍</span><br><span class="line">	- shmflg设为IPC_CREAT新建共享内存段；设为IPC_EXCL|IPC_CREAT如果已经存在，则返回错误号EEXIST</span><br><span class="line">	- 成功则返回共享内存id号，失败返回01</span><br><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line">	- 将共享内存与当前进程关联</span><br><span class="line">	- shmaddr设为NULL，系统安排段地址</span><br><span class="line">	- shmflg设为SHM_EXEC，共享内存可以被执行；设为SHM_RDONLY,共享内存只读；不指定（0）则为读写</span><br><span class="line">	- 成功则返回共享内存的首地址，失败返回-1</span><br><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line">	- 将共享内存与当前进程取消关联，更新共享内存的shmid_ds结构体</span><br><span class="line">	- 成功则返回0，失败返回-1</span><br><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br><span class="line">	- 对共享内存进行cmd操作，设为IPC_STAT，获取当前共享内存状态；设为IPC_SET,设置共享内存状态；设为IPC_RMID,标记共享内存为销毁</span><br><span class="line">	- buf需要设置或者获取的共享内存的属性信息，当cmd为IPC_STAT时指定在buf中存储信息；IPC_SET根据buf指定的信息修改共享内存属性；IPC_RMID为NULL</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">key_t ftok(const char *pathname， int proj_id);</span><br><span class="line">	- 根据存在的路径名pathname和八位的整型数proj_id，生成一个共享内存的key值，相同路径名和proj_id相同时返回相同的key值</span><br></pre></td></tr></table></figure>

<p>共享内存操作命令</p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305121456792.png" style="zoom:67%;" />

<p>内存映射与共享内存的区别</p>
<ol>
<li>共享内存直接创建，内存映射需要磁盘文件</li>
<li>共享内存速度更快</li>
<li>进程操作的是同一块共享内存，内存映射在每个进程虚拟空间中有独立内存</li>
<li>进程突然退出共享内存依然存在，内存映射区消失；电脑死机共享内存消失，内存映射磁盘文件存在</li>
<li>进程退出共享内存区标记为删除，内存映射区销毁</li>
</ol>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><ul>
<li><p>守护进程运行在后台，独立于控制终端，内核不为守护进程自动生成任何控制信号以及终端相关的信号</p>
</li>
<li><p>会周期性执行某种任务，一般采用以d结尾的名字</p>
</li>
<li><p>守护进程的父进程是init进程，是孤儿进程</p>
</li>
</ul>
<p>创建守护进程步骤</p>
<ol>
<li>在父进程中fork并退出父进程，使子进程成为孤儿进程，此时子进程继承父进程的会话、进程组、控制终端、文件描述符等</li>
<li>在子进程中调用setsid创建新会话，脱离原来的进程组，会话以及终止终端。但此时可能会申请一个控制终端，因此可以再fork出子进程2，这样子进程2就不是会话组长，就不能申请控制终端了</li>
<li>更改当前工作目录，因为守护进程运行到系统关机，这就要求其所在目录不能被卸载</li>
<li>设置掩码，不受父进程的umask影响，可以设为0</li>
<li>关闭文件描述符，将0,1,2三个文件描述符重定向到”&#x2F;dev&#x2F;null”</li>
</ol>
<p>另外，也可以利用库函数daemon()创建守护进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int daemon(int nochdir, int noclose);</span><br><span class="line">	- nochdir 设为0时将当前目录更改为&quot;/&quot;</span><br><span class="line">	- noclose 设为0时将标准输入、标准输出、标准错误重定向至&quot;/dev/null&quot;</span><br><span class="line">	- 成功返回0，失败返回-1</span><br></pre></td></tr></table></figure>



<h1 id="3、Linux多线程开发"><a href="#3、Linux多线程开发" class="headerlink" title="3、Linux多线程开发"></a>3、Linux多线程开发</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/110710.htm">库CentOS与Ubuntu哪个更适合做服务器系统</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/03/10/lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/10/lab/" class="post-title-link" itemprop="url">lab</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-10 20:46:47" itemprop="dateCreated datePublished" datetime="2023-03-10T20:46:47+08:00">2023-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 10:49:20" itemprop="dateModified" datetime="2023-03-11T10:49:20+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="0、docker搭建linux环境（for-Windows）"><a href="#0、docker搭建linux环境（for-Windows）" class="headerlink" title="0、docker搭建linux环境（for Windows）"></a>0、docker搭建linux环境（for Windows）</h1><h2 id="docker官网下载-docker-desktop"><a href="#docker官网下载-docker-desktop" class="headerlink" title="docker官网下载 docker desktop"></a><a target="_blank" rel="noopener" href="https://www.docker.com/">docker官网</a>下载 docker desktop</h2><p>右上角点击Get Started，选择Download for Windows进行下载并安装</p>
<img src="C:\myblog\source\_posts\lab\docker_download.png" style="zoom:50%;" />

<p>打开cmd，通过<code>docker --version</code> 命令查看是否安装成功</p>
<h2 id="配置docker镜像"><a href="#配置docker镜像" class="headerlink" title="配置docker镜像"></a>配置docker镜像</h2><p>打开docker desktop，在设置中找到Docker Engine，将原有文本修改成如下并Apply &amp; restart</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;experimental&quot;: false,</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://docker.mirrors.ustc.edu.cn&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;features&quot;: &#123;</span><br><span class="line">    &quot;buildkit&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="C:\myblog\source\_posts\lab\docker_engine.png" style="zoom:50%;" />

<p>cmd中输入<code>docker info</code>并显示有如下信息即可</p>
<p><img src="C:\myblog\source_posts\lab\docker_info.png"></p>
<h2 id="拉取Linux镜像并新建容器"><a href="#拉取Linux镜像并新建容器" class="headerlink" title="拉取Linux镜像并新建容器"></a>拉取Linux镜像并新建容器</h2><p>这里选择CentOS系统，当然也可以使用其他系统，只需要修改命令参数</p>
<p>输入<code>docker pull centos</code>即可拉取最新的centos镜像，如果需要特定版本的镜像，则在系统名字后加上版本参数如<code>docker pull centos:7</code></p>
<p>还可以输入<code>docker images</code>查看本地主机上的镜像</p>
<p><img src="C:\myblog\source_posts\lab\docker_images.png"></p>
<p>其中，</p>
<p>RESPOSITORY 是镜像的仓库源，TAG 是镜像的标签，代表不同版本，IMAGE ID 是镜像ID，CREATED 是镜像的创建时间，SIZE是镜像的大小</p>
<p>docker中镜像相当于一个类，如果运行还需要将类进行实例化，也就是新建一个容器</p>
<p><code>docker run -it centos /bin/bash</code></p>
<p>其中，</p>
<p>选项-i 指交互式操作，-t 指终端，it通常一起使用，&#x2F;bin&#x2F;bash 表面希望有个交互式shell，centos不指定版本则默认使用最新版本即lastest</p>
<p><code>[root@9c2ab6d80ac1 /]#</code>即进入centos系统界面</p>
<h2 id="打开原有容器而非创建"><a href="#打开原有容器而非创建" class="headerlink" title="打开原有容器而非创建"></a>打开原有容器而非创建</h2><p>以刚新建的centost容器为例，</p>
<img src="C:\myblog\source\_posts\lab\docker_name.png" style="zoom:80%;" />

<ul>
<li>从docker desktop复制其name或者ID号</li>
<li><code>docker start 9c2ab6d80ac14f1edf1dec3f89c9b6f759018913f2e13a8086c3c30c24ba0dd9</code>或者<code>docker start csapp_env</code>让容器启动</li>
<li><code>docker exec -it 9c2ab6d80ac14f1edf1dec3f89c9b6f759018913f2e13a8086c3c30c24ba0dd9 /bin/bash</code>以交互式操作进入容器</li>
<li><code>[root@9c2ab6d80ac1 /]#</code>centos系统界面</li>
<li>退出容器则输入<code>exit</code></li>
</ul>
<p>这里，除了<code>exec</code>也可以使用<code>attach</code>命令进入容器，<code>attach</code>如果从这个容器退出，就会导致容器的停止</p>
<h1 id="1、datalab"><a href="#1、datalab" class="headerlink" title="1、datalab"></a>1、datalab</h1><h2 id="挂载目录实现Linux机与主机文件同步"><a href="#挂载目录实现Linux机与主机文件同步" class="headerlink" title="挂载目录实现Linux机与主机文件同步"></a>挂载目录实现Linux机与主机文件同步</h2><ul>
<li>首先在主机中建立要共享的文件夹，复制其绝对路径，如C:\Users\amour\csapp\lab</li>
<li>运行<code>docker container run -it -v &quot;C:\Users\amour\csapp\lab&quot;:/csapp --name=csapp_env contos /bin/bash</code>，实现挂载，其中，在容器中的目录名为<code>csapp</code>，容器名为<code>csapp_env</code></li>
<li>验证挂载情况，进入容器中的目录<code>cd csapp</code>，再用<code>ls</code>指令查看子文件是否与主机中的一致</li>
</ul>
<h2 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h2><ul>
<li><p>更新yum源，<code>yum -y update</code></p>
<p>[报错1] 由于本地语言环境不适配可能会出现<code>Failed to set locale, defaulting to C.UTF-8</code>报错，则需要先安装响应的语言包和语言环境</p>
<ul>
<li><p><code>locale -a</code>查看目前已安装的语言包</p>
</li>
<li><p><code>yum install glibc-langpack-zh</code>安装中文语言包</p>
<p>[报错2] 这一步可能又会出现<code>Failed to download metadata for repo &#39;appstream&#39;</code>,需要将软件包修改源，在<code>/etc/yum.repos</code>中更新<code>repos.d</code>使用<code>vault.centos.org</code>代替<code>mirror.centos.org</code></p>
<ul>
<li><p>cd &#x2F;etc&#x2F;yum.repos.d</p>
</li>
<li><p>vi CentOS-Linux-BaseOS.repo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[baseos]</span><br><span class="line">name=CentOS Linux $releasever - BaseOS</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/release=$releasever&amp;arch=$basearch&amp;repo=BaseOS&amp;infra=$infra</span><br><span class="line">#baseurl=http://mirror.centos.org/$contentdir/$releasever/BaseOS/$basearch/os/</span><br><span class="line">baseurl=https://vault.centos.org/centos/$releasever/BaseOS/$basearch/os/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br></pre></td></tr></table></figure>
</li>
<li><p>vi CentOS-Linux-AppStream.repo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[appstream]</span><br><span class="line">name=CentOS Linux $releasever - AppStream</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=AppStream&amp;infra=$infra</span><br><span class="line">#baseurl=http://mirror.centos.org/$contentdir/$releasever/AppStream/$basearch/os/</span><br><span class="line">baseurl=https://vault.centos.org/centos/$releasever/AppStream/$basearch/os/ </span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>dnf install glibc-langpack-en</p>
</li>
<li><p>此时再输入<code>locale -a</code>查看目前的语言包，发现除了原有的<code>C.utf8</code>之外，还有其他的<code>en_utf8</code>和<code>zh_utf8</code>，至此，已解决语言环境不适配导致无法使用yum更新下载的问题</p>
</li>
</ul>
</li>
<li><p><code>yum install sudo</code>安装sudo</p>
</li>
<li><p><code>yum install make automake gcc gcc-c++ kernel-devel</code>安装c&#x2F;c++编译环境</p>
</li>
<li><p><code>yum install gdb</code>安装gdb调试器</p>
</li>
<li><p><code>yum install glibc-debel.i686</code>安装32位嵌入式C库</p>
</li>
<li><p>完成配置</p>
</li>
</ul>
<p>至此，可以在主机的编译器中编写代码保存到共享目录中，在docker的虚拟centos容器中编译和运行代码</p>
<p>如：在共享目录中创建<code>hello.c</code>文件并编写好，进入容器中的共享文件夹<code>cd csapp/L0/</code>，使用<code>make hello</code>进行编译，<code>./hello</code>即可运行</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/03/05/%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/05/%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/" class="post-title-link" itemprop="url">改造计划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-05 14:15:33" itemprop="dateCreated datePublished" datetime="2023-03-05T14:15:33+08:00">2023-03-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-09 17:02:40" itemprop="dateModified" datetime="2023-03-09T17:02:40+08:00">2023-03-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向招聘要求和面经学习"><a href="#面向招聘要求和面经学习" class="headerlink" title="面向招聘要求和面经学习"></a>面向招聘要求和面经学习</h1><h2 id="基础语法-面经"><a href="#基础语法-面经" class="headerlink" title="基础语法 + 面经"></a>基础语法 + 面经</h2><p>利用宿舍时间10:00-11:00 C++ Primer</p>
<p>牛客网面经、习题</p>
<h2 id="操作系统（重点）"><a href="#操作系统（重点）" class="headerlink" title="操作系统（重点）"></a>操作系统（重点）</h2><p>网课：CMU15-413</p>
<p>书籍：CSAPP + 现代操作系统</p>
<p>项目相关：labs</p>
<p>牛客网习题</p>
<h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><p>网课：王道</p>
<p>小林coding</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>网课：CMU15-445</p>
<p>书籍：MySQL必知必会（REDIS？）</p>
<p>小林coding</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>蓝桥杯真题库 + 代码随想录LeetCode + CODETOP</p>
<p>每日两题</p>
<h2 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h2><p>Linux原子哥</p>
<h2 id="webserver项目"><a href="#webserver项目" class="headerlink" title="webserver项目"></a>webserver项目</h2><p>C++ set自定义排序问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class node &#123;</span><br><span class="line">public:</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    int stime;</span><br><span class="line">    int fintime;</span><br><span class="line"></span><br><span class="line">    node(int xx, int yy, int st ,int ot) : x(xx), y(yy), stime(st), fintime(st + ot) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool operator &lt; (node n) const</span><br><span class="line">    &#123;</span><br><span class="line">        if (n.fintime != fintime)</span><br><span class="line">            return fintime &lt; n.fintime;</span><br><span class="line">        else if (x != n.x)</span><br><span class="line">            return x &lt; n.x;</span><br><span class="line">        else</span><br><span class="line">            return y &lt; n.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator &lt; (const node* n) const</span><br><span class="line">    &#123;</span><br><span class="line">        if (n-&gt;fintime != fintime)</span><br><span class="line">            return fintime &lt; n-&gt;fintime;</span><br><span class="line">        else if (x != n-&gt;x)</span><br><span class="line">            return x &lt; n-&gt;x;</span><br><span class="line">        else</span><br><span class="line">            return y &lt; n-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>利用 <code>&lt;</code> 运算符重载，如果<code>set&lt;node*&gt; nodes</code>，此时排序会出现混乱</p>
<p>而定义<code>set&lt;node&gt; nodes</code>则不会，并且使用仿函数也正常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class comp&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()( const node&amp; l, const node&amp; r) const</span><br><span class="line">&#123;</span><br><span class="line">    if (l.fintime != r.fintime)</span><br><span class="line">        return l.fintime &lt; r.fintime;</span><br><span class="line">    else if (l.x != r.x)</span><br><span class="line">        return l.x &lt; r.x;</span><br><span class="line">    else</span><br><span class="line">        return l.y &lt; r.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>set&lt;node, comp&gt; nodes</code>或<code>set&lt;node*, comp&gt; nodes</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/12/02/DP%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/02/DP%E7%AB%A0%E8%8A%82/" class="post-title-link" itemprop="url">DP章节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-02 17:23:42" itemprop="dateCreated datePublished" datetime="2022-12-02T17:23:42+08:00">2022-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-27 13:44:18" itemprop="dateModified" datetime="2023-02-27T13:44:18+08:00">2023-02-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="DP模板"><a href="#DP模板" class="headerlink" title="DP模板"></a>DP模板</h1><ol>
<li>确定数组<code>dp[i]</code>的含义，以及下标<code>i</code>的含义</li>
<li>确定数组<code>dp[i]</code>的递推公式</li>
<li>确定数组<code>dp[i]</code>的初始值</li>
<li>确定遍历顺序</li>
<li>举例推导</li>
</ol>
<h1 id="基础DP"><a href="#基础DP" class="headerlink" title="基础DP"></a>基础DP</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>容易想到递归的方法来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if(n&lt;=1)</span><br><span class="line">            return n;</span><br><span class="line">        return fib(n-1) + fib(n-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n!)，空间复杂度为O(n)</p>
<h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>DP数组的含义是<code>i</code>位置的斐波那契数列值是<code>dp[i]</code></p>
<p>递推公式为<code>dp[i] = dp[i-1]+dp[i-2]</code></p>
<p>DP数组初始值<code>dp[0]=0,dp[1]=1</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if(n == 0)  return 0;</span><br><span class="line">        vector&lt;int&gt; vec(n+1);</span><br><span class="line">        vec[0] = 0;</span><br><span class="line">        vec[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec[i] = vec[i - 1] + vec[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return vec[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(n)</p>
<h3 id="DP优化"><a href="#DP优化" class="headerlink" title="DP优化"></a>DP优化</h3><p>因为<code>dp[i]</code>的值只与其前两个值，即<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，则可以不需要借助容器<code>vector</code>来记录，而是只用三个变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if(n == 0)  return 0;</span><br><span class="line">        int v0 = 0, v1 = 1;</span><br><span class="line">        int sum = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = v0 + v1;</span><br><span class="line">            v0 = v1;</span><br><span class="line">            v1 = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return v1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(1)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>由于<code> F(n)</code> 只和 <code>F(n-1)</code>与 <code>F(n-2)</code>有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <code>O(1)</code>，即只需要借助三个变量来完成</strong></p>
<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h2><p>该题允许向上攀爬一个或两个台阶，返回n级台阶总共有多少种不同的攀爬方法</p>
<h3 id="DP思路"><a href="#DP思路" class="headerlink" title="DP思路"></a>DP思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当n为1时，有1种方式</span><br><span class="line">当n为2时，有2种方式</span><br><span class="line">当n为3时，有3种方式</span><br><span class="line">当n为4时，有5种方式</span><br></pre></td></tr></table></figure>

<p>可以看出，当阶数为n时，是<code>n-1</code>和<code>n-2</code>级阶数方法的总和</p>
<ul>
<li><p>确定DP数组含义</p>
<p><code>DP[i]</code>表示在台阶<code>i</code>时的攀爬方法</p>
</li>
<li><p>确定递推公式</p>
<p><code>DP[i] = DP[i - 1] + DP[i - 2];</code></p>
</li>
<li><p>确定初始值</p>
<p><code>DP[1] = 1, DP[2] = 2</code></p>
</li>
<li><p>确定遍历顺序</p>
<p>遍历顺序为正序，从头到尾遍历数组</p>
</li>
</ul>
<h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if(n &lt;= 3)  return n;</span><br><span class="line">        int res = 0;</span><br><span class="line">        vector&lt;int&gt; dp(n+1);</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        dp[2] = 2;</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DP优化-1"><a href="#DP优化-1" class="headerlink" title="DP优化"></a>DP优化</h3><p>与[上一题](# DP优化)优化方式类似，<strong>因为<code>dp[i]</code>的值只与其前两个值，即<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，因此可以使用滚动数组实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if(n &lt;= 3)  return n;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int q = 1, w = 2, e = 3;</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            e = q + w;</span><br><span class="line">            q = w;</span><br><span class="line">            w = e;</span><br><span class="line">        &#125;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>由于<code> F(n)</code> 只和 <code>F(n-1)</code>与 <code>F(n-2)</code>有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <code>O(1)</code>，即只需要借助三个变量来完成</strong></p>
<h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></h2><p>该题给出爬每层楼梯的花费，允许每次爬一个或两个阶梯，要求使用最低花费爬到楼梯顶部</p>
<h3 id="DP思路-1"><a href="#DP思路-1" class="headerlink" title="DP思路"></a>DP思路</h3><p>可以看出，当爬到第n层楼梯时，当前总共的花费与<code>n-1</code>级楼梯的花费有关，也就是说当前状态可以由之前的状态推导出来</p>
<ul>
<li><p>确定DP数组含义</p>
<p><code>DP[i]</code>表示在台阶<code>i</code>时的总共花费</p>
</li>
<li><p>确定递推公式</p>
<p><code>DP[i] = min(DP[i - 1] + costs[i - 1], DP[i-  2] + costs[i - 2];</code></p>
</li>
<li><p>确定初始值</p>
<p><code>DP[1] = 0, DP[2] = 0</code>，初始值应由递推公式中的<code>cost[i]</code>来决定</p>
</li>
<li><p>确定遍历顺序</p>
<p>遍历顺序为正序，从头到尾遍历数组</p>
</li>
</ul>
<h3 id="DP-2"><a href="#DP-2" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(cost.size()+1);</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        dp[1] = 0;</span><br><span class="line">        for(int i = 2; i &lt;= cost.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = min(dp[i - 1] + cost[i-1], dp[i-2] + cost[i-2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[cost.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DP优化-2"><a href="#DP优化-2" class="headerlink" title="DP优化"></a>DP优化</h3><p>类似的，<strong>因为<code>dp[i]</code>的值只与其前两个值，即<code>dp[i-1]</code>和<code>dp[i-2]</code>有关，因此可以使用滚动数组实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int q = 0, w = 0, e = 0;</span><br><span class="line">        for(int i = 2; i &lt;= cost.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            e = min(q + cost[i-2], w + cost[i-1]);</span><br><span class="line">            q = w;</span><br><span class="line">            w = e;</span><br><span class="line">        &#125;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>由于<code> F(n)</code> 只和 <code>F(n-1)</code>与 <code>F(n-2)</code>有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <code>O(1)</code>，即只需要借助三个变量来完成</strong></p>
<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h2><p>该题有一个<code>m*n</code>大小的网格图，要求只能一次向下或者向右移动一步，返回总共不同的路径数</p>
<h3 id="DP思路-2"><a href="#DP思路-2" class="headerlink" title="DP思路"></a>DP思路</h3><p>若为<code>1*1</code>的网格，则有1条路径</p>
<p><code>2*2</code>的网格，有2条路径</p>
<p><code>3*2</code>或者是<code>2*3</code>的网格，则有3条路径</p>
<p><code>3*3</code>的网格中，有6条路径</p>
<p>由上可知，<strong>在<code>m*n</code>的网格当中，其路径总数等于 <code>(m-1)*n</code>网格的路径总数加上<code>m*(n-1)</code>网格的路径总数</strong>，因此将使用DP算法</p>
<ul>
<li><p>确定数组<code>DP[i][j]</code>含义</p>
<p><code>DP[i][j]</code>表示的是在<code>i*j</code>的网格当中，总共有<code>DP[i][j]</code>条路径</p>
</li>
<li><p>确定初始值</p>
<p><strong>为了方便，数组<code>DP[i][j]</code>表示第<code>i</code>行第<code>j</code>列，且不影响结果</strong></p>
<p><code>DP[1][j]</code>均为1，即第一行中的数，代表着<code>1*n</code>的所有网格</p>
<p><code>DP[i][1]</code>均为1，同理</p>
</li>
<li><p>确定状态转移方程</p>
<p><code>DP[i][j] = DP[i - 1][j] + DP[i][j - 1]</code></p>
</li>
<li><p>确定遍历顺序</p>
<p>从<code>i=2</code>开始遍历到<code>n</code>，正向遍历</p>
</li>
</ul>
<h3 id="DP-3"><a href="#DP-3" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">pubulic:</span><br><span class="line">	int uniquePaths(int m, int n)</span><br><span class="line">	&#123;</span><br><span class="line">		if(m == 1 || n == 1)</span><br><span class="line">			return 1;</span><br><span class="line">		vector&lt;int&gt; row(n + 1,1);</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; dp(n + 1,row);</span><br><span class="line">		//dp数组全部元素初始化为1</span><br><span class="line">		for(int i = 2; i &lt;= m; i++)</span><br><span class="line">			for(int j = 2; j &lt;= n; j++)</span><br><span class="line">				dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">		return dp[m][n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n^2)，遍历网格中的所有元素，空间复杂度为O(n^2)，为网格中的每个元素独立创建一份空间</p>
<h3 id="DP优化-3"><a href="#DP优化-3" class="headerlink" title="DP优化"></a>DP优化</h3><p>由上可知，当遍历时，当前位置下的元素只与同行上一列元素和同列上一行元素有关，因此可以只使用一维数组来进行空间的优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        if(m==1||n==1)  return 1;</span><br><span class="line">        vector&lt;int&gt; dp(n+1,1);</span><br><span class="line">        for(int i = 2; i &lt;= m; i++)</span><br><span class="line">            for(int j = 2; j &lt;= n; j++)</span><br><span class="line">                dp[j] += dp[j-1];</span><br><span class="line">            </span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>初始化中只需要对首行和首列元素进行初始化为1的操作</p>
<h2 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title=" 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/"> 不同路径 II</a></h2><p>与<a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">I</a>比较，该题多了障碍的设置，要求所有需要经过障碍所在位置的路径都不能被通过</p>
<h3 id="DP思路-3"><a href="#DP思路-3" class="headerlink" title="DP思路"></a>DP思路</h3><p>如果在<code>dp[i-1][j]</code>位置上有障碍，那么需要通过该点通往任意位置都将无法通过，这样可以通过将<code>dp[i-1][j]=0</code>，而<code>dp[i][j] = dp[i-1][j] + dp[i][j-1] = dp[i][j-1]</code></p>
<ul>
<li><p>确定数组<code>DP[i][j]</code>含义</p>
<p><code>DP[i][j]</code>表示的是在<code>i*j</code>的网格当中，排除有障碍的，总共有<code>DP[i][j]</code>条路径</p>
</li>
<li><p>确定初始值</p>
<p><strong>该题中 数组<code>DP[i+1][j+1]</code>表示第<code>i</code>行第<code>j</code>列</strong>，并且只需要对首列和首行的元素进行初始化</p>
<p>数组所有元素初始化为0，<strong>遍历数组中第0行和第0列的元素，如果当前位置上的元素没有遇到障碍，则将当前元素初值设为1</strong>，同时，<strong>如果遇到有障碍，那么在障碍之后的所有元素值都应该初始化为0</strong></p>
<p>如数组<code>[[0,0],[1,1],[0,0]]</code>，这时，对应的<code>dp</code>数组最终应该被初始化为<code>[[1,1],[0,0],[0,0]]</code></p>
</li>
<li><p>确定状态转移方程</p>
<p><code>DP[i][j] = DP[i - 1][j] + DP[i][j - 1]</code>，与上题一致</p>
</li>
<li><p>确定遍历顺序</p>
<p>正向遍历，与上题遍历顺序一致，但该题因为下标代表的含义不同，所以应该从<code>i=1</code>开始遍历到<code>n-1</code></p>
</li>
</ul>
<h3 id="DP-4"><a href="#DP-4" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.size(), n = obstacleGrid[0].size();</span><br><span class="line">        if(obstacleGrid[0][0]==1||obstacleGrid[m-1][n-1]==1)   return 0;</span><br><span class="line">        vector&lt;int&gt; row(n,0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, row);</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[i][0]==0)</span><br><span class="line">                dp[i][0] = 1;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[0][j]==0)</span><br><span class="line">                dp[0][j] = 1;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; m; i++)</span><br><span class="line">            for(int j = 1; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(obstacleGrid[i][j]==1)</span><br><span class="line">                    dp[i][j] = 0;</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] = dp[i-1][j] + dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="DP优化-4"><a href="#DP优化-4" class="headerlink" title="DP优化"></a>DP优化</h3><p>同样地，该题也可以只使用一个一维滚动数组来减小空间开销</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.size(), n = obstacleGrid[0].size();</span><br><span class="line">        if(obstacleGrid[0][0]==1||obstacleGrid[m-1][n-1]==1)   return 0;</span><br><span class="line">        vector&lt;int&gt; dp(n,0);</span><br><span class="line">        bool flag = false;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; m; i++)</span><br><span class="line">            for(int j = 0; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(j==0 &amp;&amp; flag)</span><br><span class="line">                    continue;</span><br><span class="line">                if(obstacleGrid[i][j]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = 0;</span><br><span class="line">                    if(j==0)</span><br><span class="line">                        flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(j==0)</span><br><span class="line">                    dp[j] = 1;</span><br><span class="line">                else</span><br><span class="line">                    dp[j] += dp[j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为不能另外用一个循环来进行<strong>首列的初始化</strong>，因此借助flag变量来标记是否遇到障碍，如果遇到，之后的元素都将初始化为0；而首行元素则不需要，因为所有元素都被初始化为0，并且当前元素的值，<strong>即<code>dp[i]</code>只与自身大小与左边元素大小有关</strong>，如<code>[[0,0,0,1,0,0]]</code>数组中，在遇到障碍之前的<code>dp</code>数组为<code>[1,1,1]</code>，遇到障碍则<code>dp[3]=0</code>，之后的元素<code>dp[i] += dp[i-1]</code>均为0</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>与<a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">上一题</a>对比，该题处理方法的不同主要在于 初始化中不能将首行和首列所有元素都初始化为1，因为可能会在首行或首列元素中放置了障碍，并且，<strong>遇到障碍之后的首行或首列元素都应该初始化为0</strong>，意味着<strong>在首行或首列遇到障碍之后的元素都将没有路径能够到达。</strong></p>
<h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></strong></h2><p>该题中给定一个整数，需要由<code>1-n</code>不同结点值组成一颗二叉搜索树，返回最多能组成互不相同的种树</p>
<h3 id="DP思路-4"><a href="#DP思路-4" class="headerlink" title="DP思路"></a>DP思路</h3><p>当n为1，只有1种二叉搜索树</p>
<p>当n为2，有2种二叉搜索树</p>
<p>当n为3，有5种二叉搜索树。 再细分，当以1为根结点，有两个大于1的数在根结点右边，则此时右子树可以组成n为2情况下的2种二叉搜索树；当以2为结点，同理有1个小于2的数在左子树，有1个数在右子树；当以3为结点，有2个数在左子树。</p>
<p>综上，可得n&#x3D;3时，<code>二叉搜索树数量=(右子树n=2的数量 * 左子树n=0的数量) + (右子树n=1的数量 * 左子树n=1的数量) + (右子树n=0的数量 * 左子树n=2的数量)</code></p>
<ul>
<li><p>确定数组<code>dp[i]</code>含义</p>
<p><code>dp[i]</code>表示的是i个结点下能组成二叉搜索树的数量</p>
</li>
<li><p>确定初始值</p>
<p><code>dp[0]=1</code>，空结点时能组成1种二叉搜索树</p>
<p><code>dp[1]=1</code></p>
<p><code>dp[2]=2</code></p>
</li>
<li><p>确定状态转移方程</p>
<p><code>dp[i]=dp[j-1]*dp[i-j]</code>，需要嵌套一层循环</p>
</li>
<li><p>确定遍历顺序</p>
<p>正向遍历，从<code>i=3</code>开始遍历到<code>n</code>，从<code>j = 1</code>遍历到 <code>j = i</code></p>
</li>
</ul>
<h3 id="DP-5"><a href="#DP-5" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        if(n==1)    return 1;</span><br><span class="line">        if(n==2)    return 2;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        dp[2] = 2;</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)</span><br><span class="line">            for(int j = 1; j &lt;= i;j++)</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i-j];</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数学解法"><a href="#数学解法" class="headerlink" title="数学解法"></a>数学解法</h3><p>卡特兰数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//公式：C0 = 1 , Cn+1 = 2(2n+1)/(n+2)*Cn </span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        long long C = 1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            C = C * 2 * (2 * i + 1) / (i + 2);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int)C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>该题难以推出状态转移方程，不妨细分情况，尽可能将之前的状态套进当前状态来考虑</p>
<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">整数拆分</a></strong></h2><p>该题给定一个正整数n，将其拆分为n个正整数的和，并返回这些和的最大化乘积</p>
<h3 id="DP思路-5"><a href="#DP思路-5" class="headerlink" title="DP思路"></a>DP思路</h3><p>算出前8个正整数的最大乘积为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1	2	3	4	5	6	7	8</span><br><span class="line">1	1	2	4	6	9	12	18</span><br></pre></td></tr></table></figure>

<p>将8拆分成以下的情况，</p>
<p><code>8 = j + (i - j)</code>，此时，<code>j</code>和<code>i - j</code>不再拆分，那么 <code>n=8</code>的最大乘积 &#x3D; <code>i</code> * <code>(i - j)</code>；若继续拆分<code>i - j</code>，那么 <code>n=8</code>的最大乘积 &#x3D; <code>i</code> * (<code>n = (i - j)</code>的最大乘积)</p>
<p>综上，可以得到 <code>dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j))</code></p>
<ul>
<li><p>确定数组<code>dp[i]</code>含义</p>
<p><code>dp[i]</code>表示的是整数<code>i</code>拆分的正整数的最大乘积</p>
</li>
<li><p>确定初始值</p>
<p><code>dp[1]=1</code></p>
<p><code>dp[2]=1</code></p>
<p><code>dp[3]=2</code></p>
</li>
<li><p>确定状态转移方程</p>
<p><code>dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j))</code>，需要嵌套一层循环</p>
</li>
<li><p>确定遍历顺序</p>
<p>正向遍历，从<code>i=4</code>开始遍历到<code>n</code>，从<code>j = 1</code>遍历到<code>j = i</code></p>
</li>
</ul>
<h3 id="DP-6"><a href="#DP-6" class="headerlink" title="DP"></a>DP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1);</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; i++)</span><br><span class="line">            for(int j = 1; j &lt;= i/2; j++)</span><br><span class="line">                dp[i] = max(dp[i], max(j*(i-j), dp[i-j]*j));</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>数学证明：</p>
<blockquote>
<p>$$ {函数极值证明法}<br>函数极值证明法</p>
<p>显然，如果将给定的正整数拆分成尽可能多的某个特定的正整数，则这些正整数的乘积最大。</p>
<p>定义函数 f(x)f(x) 表示将给定的正整数 nn 拆分成尽可能多的正数 xx 的情况下的最大乘积，则可以将 nn 分成 \dfrac{n}{x}<br>x<br>n<br>​<br>  项，此时 f(x)&#x3D;x^{\frac{n}{x}}f(x)&#x3D;x<br>x<br>n<br>​</p>
<p> ，目标是求 f(x)f(x) 的最大值，即</p>
<p>\mathop{\max}\limits_{x}(f(x))<br>x<br>max<br>​<br> (f(x))</p>
<p>可以将 f(x)f(x) 写成如下形式：</p>
<p>f(x)&#x3D;x^{\frac{n}{x}}&#x3D;e^{\frac{n \ln x}{x}}<br>f(x)&#x3D;x<br>x<br>n<br>​</p>
<p> &#x3D;e<br>x<br>nlnx<br>​</p>
<p>令 g(t)&#x3D;e^tg(t)&#x3D;e<br>t<br> ，h(x)&#x3D;\dfrac{\ln x}{x}h(x)&#x3D;<br>x<br>lnx<br>​<br> ，则有 f(x)&#x3D;g(n \cdot h(x))f(x)&#x3D;g(n⋅h(x))。由于 g(t)g(t) 是单调递增的，n&gt;0n&gt;0，因此 h(x)h(x) 与 f(x)f(x) 的单调性相同。</p>
<p>计算 h(x)h(x) 的驻点，即 h’(x)&#x3D;\dfrac{1- \ln x}{x^2}&#x3D;0h<br>′<br> (x)&#x3D;<br>x<br>2</p>
<p>1−lnx<br>​<br> &#x3D;0 的点，得到驻点为 x&#x3D;ex&#x3D;e。</p>
<p>由于当 0&lt;x&lt;e0&lt;x&lt;e 时 h’(x)&gt;0h<br>′<br> (x)&gt;0，当 x&gt;ex&gt;e 时 h’(x)&lt;0h<br>′<br> (x)&lt;0，因此 x&#x3D;ex&#x3D;e 是 h(x)h(x) 的极大值点，也是 f(x)f(x) 的极大值点。由于函数 f(x)f(x) 的定义域连续，因此极大值点唯一，也是最大值点。</p>
<p>因此，当 x&#x3D;ex&#x3D;e 时，f(x)f(x) 取到最大值，\max f(x)&#x3D;f(e)&#x3D;e^{\frac{n}{e}}maxf(x)&#x3D;f(e)&#x3D;e<br>e<br>n<br>​</p>
<p> 。</p>
<p>由于 ee 不是整数，因此使用与 ee 最接近的整数作为 xx 的值，xx 可以是 22 或 33，此时需要比较 f(2)f(2) 与 f(3)f(3) 的大小，可以通过计算 \dfrac{f(3)}{f(2)}<br>f(2)<br>f(3)<br>​<br>  进行比较。</p>
<h1 id="dfrac-f-3-f-2-x3D-dfrac-e-n-cdot-h-3-e-n-cdot-h-2-x3D-e-n-cdot-h-3-n-cdot-h-2-x3D-e-n-cdot-frac-ln-3-3-frac-ln-2-2-x3D-e-frac-n-6-cdot-2-ln-3-3-ln-2-x3D-e-frac-n-6-cdot-ln-9-ln-8-f-2-f-3-​"><a href="#dfrac-f-3-f-2-x3D-dfrac-e-n-cdot-h-3-e-n-cdot-h-2-x3D-e-n-cdot-h-3-n-cdot-h-2-x3D-e-n-cdot-frac-ln-3-3-frac-ln-2-2-x3D-e-frac-n-6-cdot-2-ln-3-3-ln-2-x3D-e-frac-n-6-cdot-ln-9-ln-8-f-2-f-3-​" class="headerlink" title="\dfrac{f(3)}{f(2)}&#x3D;\dfrac{e^{n \cdot h(3)}}{e^{n \cdot h(2)}}&#x3D;e^{n \cdot h(3)-n \cdot h(2)}&#x3D;e^{n \cdot (\frac{\ln 3}{3} - \frac{\ln 2}{2})}&#x3D;e^{\frac{n}{6} \cdot (2 \ln 3 - 3 \ln 2)}&#x3D;e^{\frac{n}{6} \cdot (\ln 9 - \ln 8)}f(2)f(3)​"></a>\dfrac{f(3)}{f(2)}&#x3D;\dfrac{e^{n \cdot h(3)}}{e^{n \cdot h(2)}}&#x3D;e^{n \cdot h(3)-n \cdot h(2)}&#x3D;e^{n \cdot (\frac{\ln 3}{3} - \frac{\ln 2}{2})}&#x3D;e^{\frac{n}{6} \cdot (2 \ln 3 - 3 \ln 2)}&#x3D;e^{\frac{n}{6} \cdot (\ln 9 - \ln 8)}<br>f(2)<br>f(3)<br>​</h1><p>e<br>n⋅h(2)</p>
<p>e<br>n⋅h(3)</p>
<p>​<br> &#x3D;e<br>n⋅h(3)−n⋅h(2)<br> &#x3D;e<br>n⋅(<br>3<br>ln3<br>​<br> −<br>2<br>ln2<br>​<br> )<br> &#x3D;e<br>6<br>n<br>​<br> ⋅(2ln3−3ln2)<br> &#x3D;e<br>6<br>n<br>​<br> ⋅(ln9−ln8)</p>
<p>由于 \ln 9 &gt; \ln 8ln9&gt;ln8，因此 \dfrac{f(3)}{f(2)}&gt;1<br>f(2)<br>f(3)<br>​</p>
<blockquote>
<p>1，即 f(3)&gt;f(2)f(3)&gt;f(2)。当 x&#x3D;3x&#x3D;3 时，可以得到最大乘积。因此，应该将给定的正整数拆分成尽可能多的 33。</p>
</blockquote>
<p>根据 nn 除以 33 的余数进行分类讨论：</p>
<p>如果余数为 00，即 n&#x3D;3m(m \ge 2)n&#x3D;3m(m≥2)，则将 nn 拆分成 mm 个 33；</p>
<p>如果余数为 11，即 n&#x3D;3m+1(m \ge 1)n&#x3D;3m+1(m≥1)，由于 2 \times 2 &gt; 3 \times 12×2&gt;3×1，因此将 nn 拆分成 m-1m−1 个 33 和 22 个 22；</p>
<p>如果余数为 22，即 n&#x3D;3m+2(m \ge 1)n&#x3D;3m+2(m≥1)，则将 nn 拆分成 mm 个 33 和 11 个 22。</p>
<p>上述拆分的适用条件是 n \ge 4n≥4。如果 n \le 3n≤3，则上述拆分不适用，需要单独处理。</p>
<p>如果 n&#x3D;2n&#x3D;2，则唯一的拆分方案是 2&#x3D;1+12&#x3D;1+1，最大乘积是 1 \times 1&#x3D;11×1&#x3D;1；</p>
<p>如果 n&#x3D;3n&#x3D;3，则拆分方案有 3&#x3D;1+2&#x3D;1+1+13&#x3D;1+2&#x3D;1+1+1，最大乘积对应方案 3&#x3D;1+23&#x3D;1+2，最大乘积是 1 \times 2&#x3D;21×2&#x3D;2。</p>
<p>这两种情形可以合并为：当 n \le 3n≤3 时，最大乘积是 n-1n−1。<br>$$</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        if (n &lt;= 3) &#123;</span><br><span class="line">            return n - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int quotient = n / 3;</span><br><span class="line">        int remainder = n % 3;</span><br><span class="line">        if (remainder == 0) &#123;</span><br><span class="line">            return (int)pow(3, quotient);</span><br><span class="line">        &#125; else if (remainder == 1) &#123;</span><br><span class="line">            return (int)pow(3, quotient - 1) * 4;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (int)pow(3, quotient) * 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>DP思路考虑状态转移方程时，把正整数n拆分成 <code>j</code>和<code>n-j</code>来考虑，自然得到拆分的一种乘积为<code>j * (n - j)</code>，考虑到上一个的状态，拆分为<code>n - j</code>还可以继续拆分，此时，另一种乘积则为<code>j * dp[n - j]</code></p>
<p>贪心思路需要用到复杂数学证明的结论——尽可能将数拆分成2或3时的乘积最大。</p>
<blockquote>
<p>If an optimal product contains a factor f &gt;&#x3D; 4, then you can replace it with factors 2 and f-2 without losing optimality, as 2*(f-2) &#x3D; 2f-4 &gt;&#x3D; f. So you never need a factor greater than or equal to 4, meaning you only need factors 1, 2 and 3 (and 1 is of course wasteful and you’d only use it for n&#x3D;2 and n&#x3D;3, where it’s needed).</p>
<p>For the rest I agree, 3<em>3 is simply better than 2</em>2*2, so you’d never use 2 more than twice.、</p>
</blockquote>
<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2022/11/15/LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/15/LeetCode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82/" class="post-title-link" itemprop="url">LeetCode贪心算法章节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-15 16:13:21" itemprop="dateCreated datePublished" datetime="2022-11-15T16:13:21+08:00">2022-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-12 11:40:02" itemprop="dateModified" datetime="2022-12-12T11:40:02+08:00">2022-12-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LeetCode贪心算法章节"><a href="#LeetCode贪心算法章节" class="headerlink" title="LeetCode贪心算法章节"></a>LeetCode贪心算法章节</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>以每个人的胃口作为阈值，只有给够饼干才能满足，那么为了满足更多的人，则应根据胃口有小到大排序，在饼干数量一定情况下，先满足胃口小的可以让更多人得到满足</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">        if(s.size()==0) return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        sort(g.begin(),g.end());</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        int i=0, j=0;</span><br><span class="line">        while(i&lt;g.size() &amp;&amp; j&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(g[i]&lt;=s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(g[i]&gt;s[j])</span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目中用到的贪心算法思想，局部最优就是<strong>小饼干先喂饱小胃口</strong>，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**</p>
<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><strong>摆动序列</strong></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>根据数组前后差值关系，求出最长的摆动子序列，其中，子序列也可以删除原序列的某个元素。也就是说，不改变序列顺序，忽略非摆动的子序列，从中找到摆动子序列并拼接，求出最大的长度。</p>
<p>局部最优就是通过删除在单一坡度（单调序列）上的元素，使其出现两个峰值，如在<code>5,1,4,6,3</code>中，<code>1,4,6</code>为单一坡度，在删除元素4之后，就变成摆动序列，或者延长了摆动序列。实际操作中，可以忽略掉单调坡上的元素，只取两端，统计使出现峰值的转折点元素</p>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p><code>res</code>初始为1（默认最右面有一个峰值），此时<code>cursub</code>&gt; 0 &amp;&amp;<code>presub</code>&lt;&#x3D; 0，那么res++（计算了左面的峰值），最后得到的<code>res</code>就是2（峰值个数为2即摆动序列长度为2）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()&lt;=1)  return nums.size();</span><br><span class="line">        int res = 1;</span><br><span class="line">        int presub = 0;</span><br><span class="line">        int cursub = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size() - 1;i++)</span><br><span class="line">        &#123;  </span><br><span class="line">            cursub = nums[i + 1] - nums[i];</span><br><span class="line">            if((cursub &gt; 0 &amp;&amp; presub &lt;= 0)||(cursub &lt; 0 &amp;&amp; presub &gt;= 0))</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                presub = cursub;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述版本中，判断条件为<code>presub &lt;= 0</code>和<code>presub&gt; = 0</code>，让<code>presub</code>等于0也进入结果集收集，是因为在一开始<code>presub</code>为0。另外，考虑到出现相邻相同元素时，此时<code>cursub=0</code>，不会被统计到结果中，并且，<code>presub</code>也不会更新成0，就是为了阻止非严格单调序列也会被统计到，如<code>1,5,3,3,2</code>，如果每次都更新<code>presub</code>，令<code>presub=cursub</code>，当遇到相同元素时，所有相同元素不被统计成摆动序列（因为<code>cursub=0</code>)，但相同元素的下一个元素无论是否符合摆动，都会被统计成摆动序列里（因为此时<code>presub=0</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()&lt;=1)  return nums.size();</span><br><span class="line">        int res = 1;</span><br><span class="line">        int presub = 0;</span><br><span class="line">        int cursub = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size() - 1;i++)</span><br><span class="line">        &#123;  </span><br><span class="line">            cursub = nums[i + 1] - nums[i];</span><br><span class="line">            if(cursub==0)   continue;</span><br><span class="line">            if(cursub*presub &lt;= 0)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            presub = cursub;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上版本使用不同方法判断摆动，<code>cursub * presub &lt;= 0</code>，还要增加<code>if(cursub==0)   continue;</code>，当遇到相同元素时，<code>cursub=0</code>则直接跳过当次循环，也不会更新<code>presub</code>，直到遇到不同的元素。也就是相当于去重处理</p>
<h3 id="动规"><a href="#动规" class="headerlink" title="动规"></a>动规</h3><p>利用动态规划思想</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>保持区间波动，只需要把单调区间上的元素移除就可以了，通过局部最优达到全局最优</p>
<p>本题关键在于对摆动子序列的统计判断条件，即当遇到相同元素时如何处理</p>
<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><strong>最大子数组和</strong></h2><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>寻找相加和最大时的子数组，与上题不同，上题不允许排序但能删掉中间的元素，是一种拼凑的子序列，本题要求是连续的子数组，容易想到的是用两层for循环以及双指针解法，其中，双层for循环能够实现但会导致超时，时间复杂度为O(n^2)；双指针法其实并不能够在单次循环中实现，在有正负交错的情况下，不能找到最大子数组的边界点。</p>
<p>贪心算法的局部最优思路路是，在求和过程中，一旦求和值为负数，则应舍弃掉之前的子序列，再重新从下一个元素开始求和</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res = INT_MIN;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            if(sum&gt;res)</span><br><span class="line">                res = sum;</span><br><span class="line">            if(sum&lt;0)</span><br><span class="line">                sum = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>当遇到连续正数时，<code>sum</code>一直增长并更新<code>res</code></li>
<li>当遇到连续负数时，第一个负数与<code>INT_MIN</code>对比肯定会更新到<code>res</code>中，后面的负数再更新到保持为0的<code>sum</code>中，最后跟已存到<code>res</code>的第一个负数做大小比较，取较大值</li>
<li>当遇到正数+负数+正数时，访问到负数时，只要<code>sum</code>值还没变为负数，都会一直扩大子序列，因为可能后面还会有正数使得子序列和更大，而当后面一直是负数直到<code>sum&lt;0</code>，那么就会重新开始计算子序列的最大和，因为从下一个正数开始的子序列和必然比负数大，这也是为何是<code>if(sum&lt;0)</code>而不是<code>if(nums[i]&lt;0)</code></li>
<li>时间复杂度为O(n)，遍历数组所有元素一次，空间复杂度为O(1)，占用常数级空间存放变量</li>
</ul>
<h3 id="动规-1"><a href="#动规-1" class="headerlink" title="动规"></a>动规</h3><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治的思想与递归回溯有些类似，通过划分子区间，直到区间元素个数为1，再回升合并，更新维护相应的变量，直到回到原始数组区间。因此，关键在于1. 要维护的信息 2. 如何在合并区间时更新这些信息</p>
<ol>
<li><code>lsum</code>维护包含左端点在内的最大子序列和</li>
<li><code>rsum</code>维护包含右端点在内的最大子序列和</li>
<li><code>isum</code>维护区间数组的最大子序列和</li>
<li><code>sum</code>维护区间数组的总和</li>
</ol>
<p>在合并<code>s1</code>和<code>s2</code>区间时，为了维护<code>isum</code>即最终求取的结果，都会用到以上的信息，这也是需要维护以上信息的原因</p>
<ol>
<li><code>sum = s1.sum + s2.sum</code>数组总和直接相加</li>
<li><code>lsum = max(s1.sum, s1.sum + s2.lsum)</code>取原左区间<code>lsum</code>和合并区间<code>lsum</code>即<code>s1.sum+s2.lsum</code>的最大值</li>
<li><code>rsum</code>同上</li>
<li><code>isum</code>有三种可能，可以是左区间的<code>isum</code>，也可能是右区间的<code>isum</code>，还有一种可能是合并之后跨越两个区间，此时<code>isum = s1.rsum + s2.lsum</code></li>
</ol>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    struct status&#123;</span><br><span class="line">        int lsum, rsum, isum, sum;</span><br><span class="line">    &#125;;</span><br><span class="line">    status pushup(status&amp;s1, status&amp;s2)</span><br><span class="line">    &#123;</span><br><span class="line">        int sum = s1.sum + s2.sum;</span><br><span class="line">        int lsum = max(s1.lsum, s1.sum+s2.lsum);</span><br><span class="line">        int rsum = max(s2.rsum, s2.sum+s1.rsum);</span><br><span class="line">        int isum = max(max(s1.isum,s2.isum), s1.rsum+s2.lsum);</span><br><span class="line">        return (status) &#123;lsum, rsum, isum, sum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    status get(vector&lt;int&gt;&amp; nums, int st, int en)</span><br><span class="line">    &#123;</span><br><span class="line">        if(st==en)</span><br><span class="line">        &#123;</span><br><span class="line">            return (status) &#123;nums[st],nums[st],nums[st],nums[st]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (st + en) &gt;&gt; 1;</span><br><span class="line">        status s1 = get(nums, st, mid);</span><br><span class="line">        status s2 = get(nums, mid+1, en);</span><br><span class="line">        return pushup(s1,s2);</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        return get(nums,0,nums.size()-1).isum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，遍历数组所有元素一次，空间复杂度O(log n)，递归占用了栈空间</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>贪心算法能够在遍历数组的时候遇到子数组和为负数时及时舍弃，再重新从零开始，也是其贪的局部最优思想。</p>
<p>分治算法</p>
<ul>
<li>在于不断切割子区间，利用递归回溯思想把问题转化求解子区间的问题，<strong>最关键的地方在于合并区间时对信息的更新维护</strong></li>
<li>如果在合并区间上要存取的信息较多，函数参数冗杂，<strong>可以通过结构体来实现信息的传递</strong></li>
<li>虽然分治算法时间复杂度与贪心相同，且空间复杂度上由于递归比贪心要差，但分治算法<strong>构建了线段树</strong>，<strong>能做到快速访问任何子区间上的最大子序列和</strong>，访问的时间复杂度为O(log n)，对于<strong>大规模查询</strong>的情况下，这种方法的优势便体现了出来</li>
</ul>
<h2 id="买卖股票最佳时机II"><a href="#买卖股票最佳时机II" class="headerlink" title="买卖股票最佳时机II"></a>买卖股票最佳时机II</h2><h3 id="贪心-2"><a href="#贪心-2" class="headerlink" title="贪心"></a>贪心</h3><p>用贪心思想较为简单，由于没有买入卖出次数限制，只考虑每天的盈亏情况，再把所有盈余的情况相加即可</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0;i &lt; prices.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i+1]-prices[i]&gt;0)</span><br><span class="line">                res += prices[i+1] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动规-2"><a href="#动规-2" class="headerlink" title="动规"></a>动规</h3><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>贪心算法中，局部最优是将最大利润划分成每天能获取的利润，贪在只获取盈余的部分，舍弃亏钱的部分</p>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><h3 id="贪心-3"><a href="#贪心-3" class="headerlink" title="贪心"></a>贪心</h3><p>通过for循环里从头开始遍历数组的所有元素，借助一个变量<code>tmp</code>记录当前元素下往前所能达到的最大范围，并且在遍历过程中不断更新这个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(tmp&lt;0)  return false;</span><br><span class="line">            tmp = max(tmp, nums[i]);</span><br><span class="line">            --tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>贪心算法思想中局部最优是 当前位置下能够到达的最远范围，即<code>tmp</code>变量，贪在了不断更新当前位置下的最远范围，通过这个来判断能否到达目的位置</p>
<h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a><strong>跳跃游戏II</strong></h2><h3 id="贪心-4"><a href="#贪心-4" class="headerlink" title="贪心"></a>贪心</h3><p>贪心算法局部最优在于<strong>寻找当前能覆盖的最大范围</strong>，在遍历数组时遇到这个最大范围的边界点，则更新在遍历时遇到的最大范围以及更新跳数，即遇到了上一个最大范围则需要进行下一跳</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        int en = 0;</span><br><span class="line">        for(int i =0;i&lt;nums.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = max(nums[i]+i,tmp);</span><br><span class="line">            if(i == en)</span><br><span class="line">            &#123;</span><br><span class="line">                en = tmp;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>与上一题解法相比，都是用一次的数组遍历，但上题中<strong>记录的是以当前位置作为基准，所能到达的最远距离</strong>，且在<strong>遍历每一个点时都会更新这个距离</strong>；而这一题中因为能确保到达数组的最后一个位置，<strong>记录的是能够覆盖的最大范围</strong>，且<strong>只在到达了上一个最大范围时才更新这个范围</strong></p>
<h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>不断通过排序，对最小的元素进行取反，直到剩余取反次数为0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        while(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[0] = -nums[0];</span><br><span class="line">            sort(nums.begin(),nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心1"><a href="#贪心1" class="headerlink" title="贪心1"></a>贪心1</h3><p>显然，有着很多的重复排序操作，考虑只进行一次遍历和排序</p>
<p>由于有正数和负数，可以通过由小到大排序数组并分类讨论</p>
<ul>
<li><strong>如果当前最小元素是正数，且剩余取反次数是偶数，则可以直接返回</strong></li>
<li><strong>如果当前最小元素是正数，且剩余取反次数是奇数，则重新排序对最小值进行取反再返回</strong></li>
<li>如果当前最小元素是负数，且剩余取反次数大于0，则直接取反并移动到下一个元素</li>
<li>如果移动到下一个元素超出数组范围，且剩余取反次数大于0，则移动到数组首元素，这种情况下，原数组全为负数而此时数组全为正数，则只需判断剩余取反次数的奇偶性。</li>
</ul>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int res = accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        int i = 0;</span><br><span class="line">        while( k &amp;&amp; i&lt;nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i] &gt;= 0 &amp;&amp; k % 2 == 0)</span><br><span class="line">                break;</span><br><span class="line">            else if(nums[i] &gt;= 0 &amp;&amp; k % 2 != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                sort(nums.begin(),nums.end());</span><br><span class="line">                nums[0] = -nums[0];</span><br><span class="line">                res += 2*nums[0];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = -nums[i];</span><br><span class="line">            res += nums[i]*2;</span><br><span class="line">            ++i;</span><br><span class="line">            --k;</span><br><span class="line">            if(k &amp;&amp; i == nums.size())       //全负数且k &gt;= num.size()</span><br><span class="line">                i = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="贪心2"><a href="#贪心2" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种解法，用不同的方式排序，按照<strong>绝对值大小</strong>进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        return abs(a) &gt; abs(b);</span><br><span class="line">    &#125;</span><br><span class="line">    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int res = accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">        sort(nums.begin(),nums.end(),cmp);</span><br><span class="line">        int i = 0;</span><br><span class="line">        while( k &amp;&amp; i &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]&lt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">                res += 2*nums[i];</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k &amp;&amp; k%2!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[nums.size()-1] *= -1;</span><br><span class="line">            res += 2*nums[nums.size()-1];</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>贪心算法局部最优是将最小的负数取反，最大化数组和。</p>
<p>取到最小的负数就需要对数组的排序，可以有两种不同的排序方式，按值从小到大排序和按绝对值从小到大排序。从小到大排序会导致在对所有负数取反 而剩余取反次数大于零时，额外需要排序来对最小的整数进行取反。按绝对值排序则可以解决这个问题，当数组全为正数时，可直接根据剩余取反次数是否对数组末尾元素或首元素进行取反</p>
<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><strong>加油站</strong></h2><p>容易想到的是暴力解法，判断能否循环一圈，只需要在循环中间油量不会变为负数即返回<code>true</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool ok(vector&lt;int&gt;&amp; gas,vector&lt;int&gt;&amp; cost, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        int times = 1;</span><br><span class="line">        int tank = gas[index];</span><br><span class="line">        while(times &lt;= gas.size())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tank -= cost[index];</span><br><span class="line">            if(tank&lt;0)</span><br><span class="line">                return false;</span><br><span class="line">            index++;</span><br><span class="line">            if(index&gt;gas.size()-1)</span><br><span class="line">                index = 0;</span><br><span class="line">            tank += gas[index];</span><br><span class="line">            times++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>遍历数组，判断以当前元素开始能否循环一圈，但时间复杂度会达到O(n^2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool ok(vector&lt;int&gt;&amp; gas,vector&lt;int&gt;&amp; cost, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        int times = 1;</span><br><span class="line">        int tank = gas[index];</span><br><span class="line">        while(times &lt;= gas.size())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tank -= cost[index];</span><br><span class="line">            if(tank&lt;0)</span><br><span class="line">                return false;</span><br><span class="line">            index++;</span><br><span class="line">            if(index&gt;gas.size()-1)</span><br><span class="line">                index = 0;</span><br><span class="line">            tank += gas[index];</span><br><span class="line">            times++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = -1;</span><br><span class="line">        int tank = 0;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(gas[i] &lt; cost[i])</span><br><span class="line">                continue;</span><br><span class="line">            if(ok(gas,cost,i))</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="暴力优化"><a href="#暴力优化" class="headerlink" title="暴力优化"></a>暴力优化</h3><p>在暴力法中，每次都会有重复的遍历，因此可以借助容器记录遍历过的元素，记录<strong>该元素能走到最远的地方</strong>以及<strong>剩余的油量</strong>，下一次当再次遍历到该元素时则直接跳到保存的最远地方同时加上剩余的油量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        vector&lt;int&gt; dist(gas.size(),-1);</span><br><span class="line">        vector&lt;int&gt; tmp(gas.size());</span><br><span class="line">        int res = -1;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            int cur = gas[i];</span><br><span class="line">            while(cur-cost[j]&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                cur -= cost[j];</span><br><span class="line">                j = (j+1) % gas.size();</span><br><span class="line">                if(dist[j]!=-1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur += tmp[j];</span><br><span class="line">                    j = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    cur += gas[j];</span><br><span class="line">                if(j==i &amp;&amp; cur&gt;= 0)</span><br><span class="line">                    return i;</span><br><span class="line">            &#125;</span><br><span class="line">            dist[i] = j;</span><br><span class="line">            tmp[i] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然减少了重复访问的时间，利用了空间换取时间的思想，但对时间提升并不明显，依然是超出时间限制。</p>
<h3 id="暴力再优化"><a href="#暴力再优化" class="headerlink" title="暴力再优化"></a>暴力再优化</h3><p>进一步考虑，<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，也就是说，在遍历过程中，遍历完<code>i</code>之后即可直接跳转到<code>j+1</code>位置上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = -1;</span><br><span class="line">        vector&lt;int&gt; dist(gas.size(),-1);</span><br><span class="line">        vector&lt;int&gt; tmp(gas.size());</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            int cur = gas[i];</span><br><span class="line">            while(cur-cost[j]&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                cur -= cost[j];</span><br><span class="line">                j = (j+1)%gas.size();</span><br><span class="line">                if(dist[j]!=-1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur += tmp[j];</span><br><span class="line">                    j = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    cur += gas[j];</span><br><span class="line">                if(i == j)</span><br><span class="line">                    return i;</span><br><span class="line">            &#125;</span><br><span class="line">            dist[i] = j;</span><br><span class="line">            tmp[i] = cur;</span><br><span class="line">            if(i&lt;j)</span><br><span class="line">                i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以不借助数组，只占用常数级空间，显得更为简洁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = -1;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            int cur = gas[i];</span><br><span class="line">            while(cur-cost[j]&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                cur -= cost[j];</span><br><span class="line">                j = (j+1)%gas.size();</span><br><span class="line">                cur += gas[j];</span><br><span class="line">                if(i == j)</span><br><span class="line">                    return i;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i &lt; j)</span><br><span class="line">                i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心-5"><a href="#贪心-5" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int cursum = 0, tosum = 0;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int tmp = gas[i] - cost[i];</span><br><span class="line">            cursum += tmp;</span><br><span class="line">            tosum += tmp;</span><br><span class="line">            if(cursum &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">            	cursum = 0;</span><br><span class="line">            	res = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tosum &lt; 0)</span><br><span class="line">        	return -1;</span><br><span class="line">        else</span><br><span class="line">        	return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>贪心算法<strong>局部最优在于找到符合当前油量足以到达下一站点的位置</strong>，借助<code>cursum</code>来记录，一旦<code>cursum</code>小于零，即在<code>i</code>站点出发不能够循环一圈，就马上从下一个站点重新出发，并把<code>cursum</code>置零</p>
<p>同样使用到上述的一个条件——<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，那么此时就应该从<code>j+1</code>继续遍历</p>
<p>同时记录总油量，来判断是否存在任何站点都无法循环一圈的情况</p>
<h3 id="贪心special"><a href="#贪心special" class="headerlink" title="贪心special"></a>贪心special</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int tosum = 0;</span><br><span class="line">        int tmpsum = 0;</span><br><span class="line">        int mintmp = INT_MAX;</span><br><span class="line">        for(int i = 0; i&lt;gas.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpsum = gas[i] - cost[i];</span><br><span class="line">            tosum += tmpsum;</span><br><span class="line">            if(tosum &lt; mintmp)</span><br><span class="line">                mintmp = tosum;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tosum&lt;0)    return -1;</span><br><span class="line">        if(mintmp &gt;= 0)     return 0;</span><br><span class="line">        for(int i = gas.size()-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpsum = gas[i] - cost[i];</span><br><span class="line">            mintmp += tmpsum;</span><br><span class="line">            if(mintmp &gt;=0)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有如下几种情况：</p>
<ol>
<li>任何一个站点都无法循环一圈，遍历一遍数组后<code>tosum</code>小于0，则返回-1</li>
<li>从0开始遍历一遍数组后，<code>tosum</code>大于0且中途油箱最小值<code>mintmp</code>都大于0，则可以循环一圈，且从位置0开始，返回0</li>
<li>从0开始遍历一遍数组后，<code>tosum</code>大于0但中途油箱最小值<code>mintmp</code>小于0，则可以循环一圈，但不从位置0开始，逆向遍历数组，不断加上路径某个站点净获得油量，当<code>mintmp</code>大于等于0时，即从该位置开始可以循环一圈</li>
</ol>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>本题的关键点在于理解到<strong>假设<code>i</code>能够到达最远的地方为<code>j</code>，且不能绕一圈，那么可以知道，在<code>i+1</code>到<code>j</code>区间上任一点都不能绕一圈</strong>，由暴力解法优化而来的方法，因为都是在遍历数组时要直接模拟一圈循环，因此时间复杂度上会比贪心算法只遍历一遍数组要慢，但却有很好的优化方向，<strong>通过减少重复过程优化</strong>以及<strong>通过空间换取时间优化</strong>。贪心算法贪在了<strong>从当前站点出发，累加<code>tmp</code>的和<code>curSum</code>一旦小于0就要舍弃，新的起始位置至少要是j+1</strong></p>
<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><strong>分发糖果</strong></h2><h3 id="贪心1-1"><a href="#贪心1-1" class="headerlink" title="贪心1"></a>贪心1</h3><p>尽可能少的分发糖果，则每个人初始化为1，<code>for</code>循环遍历一次数组，根据当前元素与其前后元素对比，有以下情况</p>
<ul>
<li><p>若一直递增或递减</p>
<ul>
<li><p>当前元素<code>i</code>大于<code>i-1</code>，那么<code>tmp++</code>表示当前分发的糖果数量要比<code>i-1</code>多一个</p>
</li>
<li><p>当前元素<code>i</code>小于<code>i-1</code>，则同样<code>tmp++</code>，只考虑总数量</p>
</li>
</ul>
</li>
<li><p>若遇到转折点，用<code>cur</code>记录当前的趋势，即<code>cur&gt;0</code>表示递增，<code>cur&lt;0</code>递减，<code>cur==0</code>表示第一个值或相等值</p>
<ul>
<li>从<code>cur&gt;=0</code>变成<code>cur&lt;0</code>，<code>tmp</code>重新置为1，<code>tmp++</code>后再加入到总数量中，即在转折点之后应该分发两个糖果</li>
<li>从<code>cur&lt;=0</code>变成<code>cur&gt;0</code>时，<code>tmp</code>就应该置为0，<code>tmp++</code>后再加入到总数量中，因为分数比前一个小，分发的糖果就应该重置为1，同时要区分<code>cur&lt;0</code>和<code>cur==0</code>的情况</li>
</ul>
</li>
</ul>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        int cur = 0;</span><br><span class="line">        for(int i = 0; i &lt; ratings.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i == 0 || ratings[i] == ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = 1;</span><br><span class="line">                res += tmp;</span><br><span class="line">                cur = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &gt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                if(cur &lt;= 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = 1;</span><br><span class="line">                    tmp = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                ++tmp;</span><br><span class="line">                res += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &lt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                if(cur &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = -1;</span><br><span class="line">                    tmp = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(cur == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = -1;</span><br><span class="line">                    tmp = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                ++tmp;</span><br><span class="line">                res += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述忽略了一种特殊情况——<strong>当递增序列转折成递减序列，且递减序列长度大于等于递增序列后，转折点分发的糖果要再随递增序列增加而增加</strong>，因为转折点既属于递增也属于递减序列，<strong>它的糖果数量由两条序列中较长的一条决定</strong></p>
<p>因此，只是记录序列的转折情况是不足够的，**需要同时记录下递增序列<code>inc</code>和递减序列的长度<code>dec</code>**，以及当前序列的长度<code>tmp</code>，也相当于当前应分发的糖果数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        int inc = 0, dec = 0;</span><br><span class="line">        for(int i = 0; i &lt; ratings.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i == 0 || ratings[i] == ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = 1;</span><br><span class="line">                res += tmp;</span><br><span class="line">                inc = 1;</span><br><span class="line">                dec = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &gt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                ++tmp;</span><br><span class="line">                res += tmp;</span><br><span class="line">                dec = 0;</span><br><span class="line">                inc = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ratings[i] &lt; ratings[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                ++dec;</span><br><span class="line">                if(dec == inc)</span><br><span class="line">                    ++dec;</span><br><span class="line">                res += dec;               </span><br><span class="line">                tmp = 1; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心2-1"><a href="#贪心2-1" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种思路是，分开两次从头至尾和从尾至头遍历数组，分别完成两条规则，从头至尾遍历保证右边分数高的糖果多于左边分数低的，从尾至头遍历保证左边分数高的糖果多于右边分数低的。</p>
<p>贪心算法局部最优在于保证当前糖果数量与上一个的糖果数量满足规则要求，但每次遍历只能满足一条规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        vector&lt;int&gt; can(ratings.size(),1);</span><br><span class="line">        for(int i = 1; i&lt;ratings.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ratings[i]&gt;ratings[i-1])</span><br><span class="line">                can[i] = can[i-1] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = ratings.size()-2; i&gt;= 0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ratings[i] &gt; ratings[i+1])</span><br><span class="line">                can[i] = max(can[i], can[i+1]+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(can.begin(),can.end(),0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>贪心1中思路更直接，但需要考虑的情况会更复杂，需要注意到<strong>转折序列中，递增和递减序列长度对转折点的影响</strong></p>
<p>贪心2分别使用了两次贪心策略，让题目要求更简洁明了</p>
<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><strong>根据身高重建队列</strong></h2><p>本题中，数组<code>[h, k]</code>序号为<code>i</code>，这意味着 身高为<code>h</code>，并且在队列前面还有<code>k</code>个身高高于或等于<code>h</code>的人，要求在于对打乱的<code>i</code>重新排序成正确顺序，使得<code>h</code>和<code>k</code>排列符合规则</p>
<h3 id="贪心-6"><a href="#贪心-6" class="headerlink" title="贪心"></a>贪心</h3><p>在一次遍历中，并不能做到满足两条规则，需要分两步走，根据规则各自使用贪心策略。<strong>首先，对于数组的第0个元素，即身高，排列时的局部最优在于当前身高小于上一个身高，也就是按照降序排列身高</strong>。而对于第1个元素k，根据规则，应当按照升序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a[0] != b[0])</span><br><span class="line">		return a[0] &gt; b[0];</span><br><span class="line">	else</span><br><span class="line">		return a[1] &lt; b[1];</span><br><span class="line">&#125;</span><br><span class="line">sort(people.begin(), people.end(), cmp);</span><br></pre></td></tr></table></figure>

<p>排列过后，数组<code>people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</code>顺序变为<code>[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</code>，可知，根据规则，在空的结果集中插入数组，贪心策略局部最优在于优先插入身高较高（即遍历排列后的数组）且其k较低的，如下插入过程所示，这样可以满足插入后的数组满足要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[7,0]</span><br><span class="line">[7,0],[7,1]</span><br><span class="line">[7,0],[6,1],[7,1]</span><br><span class="line">[5,0],[7,0],[6,1],[7,1]</span><br><span class="line">[5,0],[7,0],[5,2],[6,1],[7,1]</span><br><span class="line">[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]</span><br></pre></td></tr></table></figure>

<p><strong>第二步中的贪心优先处理身高较高的，在较高的排列完成后，就算再插入次高的元素也不会影响排列，依旧符合规则，在插入次高元素时，由于规则要求在此元素之前要有k个身高大于等于其身高的元素，因此，可以直接在位置k插入，使得局部上最优。</strong></p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2)</span><br><span class="line">    &#123;</span><br><span class="line">        if (v1[0] != v2[0])</span><br><span class="line">            return v1[0] &gt; v2[0];</span><br><span class="line">        else</span><br><span class="line">            return v1[1] &lt; v2[1];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(), cmp);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (int i = 0; i &lt; people.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.insert(res.begin() + people[i][1],people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在定义<code>cmp</code>函数时，将其定义为<code>static</code>静态函数是因为在类内定义函数，如果定义成非静态函数，则函数属于类的对象，而非类共有的函数，也就是说会隐式传递了<code>this</code>指针，那么类的对象在调用该函数的时候，就会通过指针隐式传递到函数参数列表中，来区分是哪一个对象调用函数，非静态函数实际参数为<code>bool cmp(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2, Solution* this)</code></strong></p>
<h3 id="贪心优化"><a href="#贪心优化" class="headerlink" title="贪心优化"></a>贪心优化</h3><p>在上一版本中的代码中，借助数组来记录结果，而数组在进行<code>insert</code>操作时，时间复杂度为O(n)，显得并不高效，因此可以借助链表来完成多次的插入操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2)</span><br><span class="line">    &#123;</span><br><span class="line">        if (v1[0] != v2[0])</span><br><span class="line">            return v1[0] &gt; v2[0];</span><br><span class="line">        else</span><br><span class="line">            return v1[1] &lt; v2[1];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(), cmp);</span><br><span class="line">        list&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (int i = 0; i &lt; people.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            auto index = people[i][1];</span><br><span class="line">            auto iter = res.begin();</span><br><span class="line">            while(index--)</span><br><span class="line">            &#123;</span><br><span class="line">                iter++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.insert(iter,people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;vector&lt;int&gt;&gt; (res.begin(),res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在调整迭代器位置时，还可以使用<code>advance</code>标准库函数，<code>advance(it,n)</code>可以让迭代器<code>it</code>往前移动<code>n</code>个位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto index = people[i][1];</span><br><span class="line">auto iter = res.begin();</span><br><span class="line">advance(iter, index);</span><br><span class="line">res.insert(iter, people[i]);</span><br></pre></td></tr></table></figure>

<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>与[上一题](# 分发糖果)比较，都是需要分两步走，把规则拆分成两步再分别使用贪心策略，这一题中最关键点在于在第二步中的贪心策略，<strong>局部最优在于插入一个元素时，只考虑当前规则是要求只有k个值在其前面，因此可以直接插入到第k个位置上，并且插入之后也不会影响已经插入的元素，符合规则</strong></p>
<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><strong>用最少数量的箭引爆气球</strong></h2><p>这道题中，使用数量尽可能少的箭引爆更多的气球，首先，可以用过排序让带有重叠区间的数组分布在一起，而排序则又可以分为两种，分别是根据开始位置和结束位置，对应了不同方向的思路</p>
<h3 id="贪心1-2"><a href="#贪心1-2" class="headerlink" title="贪心1"></a>贪心1</h3><p>按照开始位置来进行排序，定义排序函数，开始位置小的会排在前面，如果开始位置相同，则结束位置更小的排在前面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a[0]==b[0])</span><br><span class="line">		return a[1] &lt; b[1];</span><br><span class="line">	return a[0] &lt; b[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，对于数组<code>[[10,16],[2,8],[1,6],[7,12]]</code>将会排序成<code>[[1,6],[2,8],[7,12],[10,16]]</code>，接着，为了追求最少数量的箭，在区间尽可能排序成重复的基础上，<strong>局部最优在于取重复数组区间的最小的结束位置</strong>，并在该位置上射出弓箭，这样就能尽可能覆盖到更多的不同区间，即引爆更多的气球</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[0]!=b[0])</span><br><span class="line">            return a[0] &lt; b[0];</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        if(points.size()==0)    return 0;</span><br><span class="line">        int res = points.size();</span><br><span class="line">        sort(points.begin(), points.end(),cmp);</span><br><span class="line">        int en = points[0][1];</span><br><span class="line">        for(int i = 1; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(en &gt;= points[i][0]) //有重叠 </span><br><span class="line">            &#123;</span><br><span class="line">                res--;</span><br><span class="line">                en = min(points[i][1], en); </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                en = points[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用一个变量<code>en</code>来记录重复区间结束位置，<code>if(en &gt;= points[i][0])	en = min(points[i][1], en)</code>当遇到有重叠区间时，应对<code>en</code>进行更新，令其等于 <strong>当前区间的结束位置</strong> 和 <strong>原结束位置</strong> 的最小值，而不是直接赋值等于当前区间的结束位置或上一个区间的结束位置。也因为不需要返回原数组，可以在原数组上直接修改结束位置，只需要判断上一个区间的结束位置，并不断对其进行维护<code>points[i][1] = min(points[i-1][1], points[i][1])</code></p>
<h3 id="贪心2-2"><a href="#贪心2-2" class="headerlink" title="贪心2"></a>贪心2</h3><p>另外一种方法是用不同的排序方法，按照区间的结束位置来进行排序，结束位置较小的则排在前面，如果结束位置相同则让开始位置较小的靠前（这一步不影响）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a[1]==b[1])</span><br><span class="line">		return a[0] &lt; b[0];</span><br><span class="line">	return a[1] &lt; b[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种排序下，只需要判断<strong>当前区间的开始位置与重复区间的结束位置是否有重叠</strong>，用<code>en</code>来对重复区间的结束位置进行记录，如果没有则需要增加弓箭的数量，而如果开始位置小于等于上一个区间的结束位置，则无论如何两个区间都会有重叠，并且<strong>有重叠时不用对<code>en</code>进行更新，保持原来的重复区间结束位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        if(points.size()==0)    return 0;</span><br><span class="line">        int res = 1;</span><br><span class="line">        sort(points.begin(), points.end(),cmp);</span><br><span class="line">        int en = points[0][1];</span><br><span class="line">        for(int i = 1; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(en &lt; points[i][0]) //无重叠 </span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                en = points[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>两种排序方法引出两种对重叠区间不同的判断方式，且都是用到了贪心策略，<strong>尽可能让当前区间的开始元素与记录区间的结束元素有重叠，即通过排序再加上尽量去重叠区间的最大值，则可以覆盖到更多区间</strong></p>
<p>第一种排序方式，<strong>按区间的开始位置升序排列</strong>，借助变量<code>en</code>记录有重复区间的结束位置，不论是否有重叠区间，都要对<code>en</code>进行维护，<strong>当有重叠时，<code>en</code>取当前区间的结束位置和原结束位置的最小值</strong>；当没有重叠时，<code>en</code>则取当前区间的结束位置</p>
<p>第二种排序方式，<strong>按区间的结束位置升序排列</strong>，同样借助变量<code>en</code>对重叠区间的结束位置进行记录，因为是根据结束位置进行了排序，<strong>当有重叠时，对<code>en</code>不需要进行维护，因为<code>en</code>的值已经是当前包括之前所有区间的结束位置的最小值</strong>；在没有重叠时，<code>en</code>也同样取当前区间的结束位置</p>
<p>时间复杂度为O(n log n + n)，为排序消耗的时间和遍历数组的时间，空间复杂度为O(log n)，排序所占用的栈空间，最坏情况下为O(n)，需要n次的递归调用</p>
<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>该题与[上一题](# 用最少数量的箭引爆气球)比较相像，都是有关于重叠的区间，而这题要求的是找出导致重叠的区间并将其删除，返回要删除的个数</p>
<h3 id="贪心-7"><a href="#贪心-7" class="headerlink" title="贪心"></a>贪心</h3><p>类似的，首先需要排序，让重叠的区间尽可能靠近，这里按照区间的结束位置升序排列，但对于相同的结束位置的区间，应该考虑到<strong>优先删除开始位置更小的区间</strong>，因为<strong>开始位置小，所覆盖的区间更大，出现与其他区间相互重叠的可能性也更大</strong>。因此遍历顺序应该是先确定区间结束位置更小，并且区间内所覆盖的范围也要更小，当遇到有重叠的区间则应该增加删除的数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[1]==b[1])</span><br><span class="line">            return a[0] &gt; b[0];</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(intervals.size()==1)</span><br><span class="line">            return res;</span><br><span class="line">        sort(intervals.begin(),intervals.end(),cmp);</span><br><span class="line">        int en = intervals[0][1];</span><br><span class="line">        for(int i = 1; i &lt; intervals.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(en &gt; intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                en = intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>该题中，<strong>局部优化在于按照区间的结束位置排序，并且要将范围更小的区间排列在先，是为了占用更小的空间，减少重叠的发生</strong></p>
<p>同样的，这题也可以<strong>按照区间的开始位置排序，这时要将范围更大的区间排列在先，并且是采用从右往左的遍历方式</strong>，也是出于相同的原因</p>
<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><strong>划分字母区间</strong></h2><p>首先看到划分字符串想到的是回溯法，但在这题中并不需要暴力搜索。题目要求的是同一个字母只出现在一个分段中，而且只有分段最多的分法正确</p>
<p>首先需要遍历一次，得到所有字母对应的下标，借助可变数组来保存每个字母最后一次出现的下标位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; hashmap(26);</span><br><span class="line">for(int i = 0; i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	hashmap[s[i]-&#x27;a&#x27;] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="贪心-8"><a href="#贪心-8" class="headerlink" title="贪心"></a>贪心</h3><p>在得到每个字母对应最远的下标后，使用贪心策略，局部最优在于<strong>一个分段尽可能小，但同时还要包含出现过的字母的所有范围</strong>，再对字符串进行遍历，对于一个片段，划分完成时，当前下标与哈希表中字母的最后一次出现的下标位置相同，并且，在遍历的过程中，对<code>tmp</code>更新为 <strong>当前字母的最远距离</strong> 和 <strong>原字母的最远距离</strong> 的较大值，也就是将<code>tmp</code>保持为该片段中含有的字母出现的最大位置或最远距离。也就是说，在一个片段中，划分只与该片段中有最长距离的字母有关，在遍历过程中，不断更新这个字母，当遍历到该字母的最长距离时，即一个片段的划分完成</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; partitionLabels(string s) &#123;</span><br><span class="line">        vector&lt;int&gt; hashmap(26);</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int tmp = 0, count = 1;</span><br><span class="line">        for(int i = 0; i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hashmap[s[i] - &#x27;a&#x27;] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = max(tmp, hashmap[s[i]-&#x27;a&#x27;]);</span><br><span class="line">            if(i==tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count);</span><br><span class="line">                count = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在该题中十分巧妙，贪在<strong>当前片段下，要让片段尽可能小的同时还要保证出现过的字母只在该片段中出现</strong>。这就需要借助哈希表来记录<strong>每个字母最后一次出现的位置</strong>，即它们各自的最大距离；在对字符串遍历过程中，还要维护<strong>保证每个出现过的字母的最远距离</strong>，这个距离就是这个片段长度的<strong>最小长度</strong></p>
<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>该题要求对有重叠的区间进行最大化合并，返回合并后的区间</p>
<p>类似于之前的有关重叠区间题目，该题也是将各区间进行排序后，再使用贪心策略，将尽可能多的区间进行合并</p>
<h3 id="贪心1-3"><a href="#贪心1-3" class="headerlink" title="贪心1"></a>贪心1</h3><p>先按照区间的结束位置升序排列，结束位置较小的排在前面。因为开始位置不影响结果，所以可不给出排序规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于区间数组<code>[[1,10],[2,5],[6,9]]</code>则会排序变为<code>[[2,5],[6,9],[1,10]]</code>，接着，为了能够合并更多的区间，借助变量<code>tmp</code>取值为重叠区间的结束位置，<strong>正向遍历数组</strong>，当遇到<code>tmp &lt; intervals[i][0]</code>时代表没有重叠区间，则直接把该区间加入到结果集中，但当遍历到<code>[1,10]</code>时，该区间已将前面全部区间所包含，导致不正确的原因是遍历方式选择不正确，在该题中，<strong>如果按照区间的结束位置来排列，则遍历顺序应该是从尾到头的逆向遍历</strong></p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 1) return intervals;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int st = intervals[intervals.size()-1][0], en = intervals[intervals.size()-1][1];</span><br><span class="line">        for (int i = intervals.size()-1; i &gt;= 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (st &lt;= intervals[i][1]) // 有重叠</span><br><span class="line">            &#123;</span><br><span class="line">                st = min(st, intervals[i][0]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(vector&lt;int&gt; &#123;st, en&#125;);</span><br><span class="line">                st = intervals[i][0];</span><br><span class="line">                en = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(vector&lt;int&gt; &#123;st,en&#125;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心2-3"><a href="#贪心2-3" class="headerlink" title="贪心2"></a>贪心2</h3><p>另一种方式则是<strong>按照开始位置升序排列，此时，应该正向遍历数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[0] &lt; b[0];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 1) return intervals;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int st = intervals[0][0], en = intervals[0][1];</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (en &gt;= intervals[i][0]) // 有重叠</span><br><span class="line">            &#123;</span><br><span class="line">                en = max(intervals[i][1], en);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(vector&lt;int&gt; &#123;st, en&#125;);</span><br><span class="line">                st = intervals[i][0];</span><br><span class="line">                en = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(vector&lt;int&gt; &#123;st,en&#125;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>该题与<a href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4">无重叠区间</a>相比有相反的感觉，都是要找到重叠区间的部分，但后者是优先寻找到范围更小的区间，是为了减少重叠的可能性；而这题是要优先找到范围更大的区间，就是为了要尽可能多的重叠区间。也因此，<strong>要根据不同的目的，针对不同排序方式下选用不同的遍历顺序</strong></p>
<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>该题要求返回小于等于给定输入的尽可能大的数，并且返回值按位非严格递增，如给定<code>98</code>则返回<code>89</code></p>
<h3 id="贪心-9"><a href="#贪心-9" class="headerlink" title="贪心"></a>贪心</h3><p>要求返回的数尽可能大，那么局部最优在于先从低位修改，这也确定了遍历顺序是从右往左，如果<code>num[i]</code>大于<code>num[i+1]</code>，不符合按位递增规则，则<code>num[i]--; num[i+1]=&#39;9&#39;;</code>。但是如果给定输入为<code>1000</code>，只修改为<code>900</code>，而原本应该为<code>999</code>，因此，需要另外借助变量记录开始修改为9的位置，即<code>i+1</code>处，在<code>i+1</code>往后的位置都应该赋值为9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int monotoneIncreasingDigits(int n) &#123;</span><br><span class="line">        string num = to_string(n);</span><br><span class="line">        int flag = num.size();</span><br><span class="line">        for (int i = num.size() - 1; i &gt; 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (num[i -1] &gt; num[i])</span><br><span class="line">            &#123;</span><br><span class="line">                num[i - 1]--;</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = flag; i &lt; num.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i] = &#x27;9&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return stoi(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(log n)，n为输入的数，log n对应其位数，空间复杂度为O(log n)，占用log n的空间来存放数的每一位</p>
<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在于 <strong>为了取到最大值，从数的低位开始修改</strong>，这就确定了从右往左的遍历顺序；还需要有标志位来记录需要变为9的所有位置</p>
<h2 id="买卖股票最佳时机I"><a href="#买卖股票最佳时机I" class="headerlink" title="买卖股票最佳时机I"></a><strong>买卖股票最佳时机I</strong></h2><p>与[同系列的上一题](# 买卖股票最佳时机II)相比，该题还增加了手续费，相当于限制了买卖次数，需要找到除去手续费后的最大利润，而不能像上一题那样无限制买入卖出</p>
<h3 id="贪心-10"><a href="#贪心-10" class="headerlink" title="贪心"></a>贪心</h3><p>思路依旧还是 希望能够在最低点买入，然后在最高点卖出，而因为有了手续费，还会有新的情况需要考虑到：<strong>如何知道当前点是最高点</strong></p>
<p>贪心策略就是用于解决这个问题，首先遍历寻找最低点进行买入，并维护<code>buy = prices[l]+fee</code>，此时<code>l</code>为最低点，如果遍历到该点利润大于零，可以虚拟地卖出了这只股票，利润值增加<code>profit += prices[sh] - buy = prices[sh] - prices[l] -fee</code>，此时<code>sh</code>为次高点，并且已经扣除了手续费，模拟在这个次高点虚拟卖出，同时还要更新买入价格为 <strong>当前股票价格</strong>，即<code>buy = prices[sh]</code>，如此一来，当遍历到下一个点发现股票价格还在上涨时<code>prices[h]&gt;prices[sh]</code>，则又虚拟的假设成在这个最高点上卖出了股票，由于买入价格的更新，利润值更新为<code>profit += prices[h] - buy = prices[h] -prices[sh] </code>，可以看出，根据这时候获得的利润，可以模拟出<strong>最低点买入而在最高点卖出</strong>的过程</p>
<p>整体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int buy = prices[0] + fee;</span><br><span class="line">        for(int i = 0; i &lt; prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i]+fee &lt; buy)</span><br><span class="line">                buy = prices[i] + fee;</span><br><span class="line">            else if(prices[i] &gt; buy)</span><br><span class="line">            &#123;</span><br><span class="line">                res += prices[i] - buy;</span><br><span class="line">                buy = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>相同思路，而不必将<code>buy</code>维护成最低买入点与手续费的和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int buy = prices[0];</span><br><span class="line">        for(int i = 0; i &lt; prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[i] &lt; buy)</span><br><span class="line">                buy = prices[i] ;</span><br><span class="line">            else if(prices[i] &gt; buy + fee)</span><br><span class="line">            &#123;</span><br><span class="line">                res += prices[i] - buy - fee;</span><br><span class="line">                buy = prices[i]-fee;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>贪心策略在该题中体现在 <strong>遇到次高点时虚拟的卖出，更新利润的同时也更新买入价格，即虚拟地在该点买入</strong>，这也是局部最优的所在</p>
<p>遍历数组的时候，会有以下三种情况：</p>
<ul>
<li>该点比买入点更低，则更新买入的最低点</li>
<li>该点比买入点和手续费的和更高，即利润大于0，此时虚拟地卖出，更新利润以及更新买入点，也为后续更高点准备</li>
<li>该点在<code>[低买入点+手续费，高卖出点]</code>范围，即没有利润，则此时不会卖出，不进行任何操作</li>
</ul>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a><strong>监控二叉树</strong></h2><p>题目要求添加最少的监控，覆盖到所有的二叉树结点</p>
<p>一开始，想到根据父结点的值来判断当前结点是否需要添加监控，如果父结点值为0，则为当前结点添加监控；反之亦然。同时使用层序迭代遍历二叉树即可完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1;</span><br><span class="line">        int res = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;//还要存父结点</span><br><span class="line">        //层序遍历</span><br><span class="line">        TreeNode* pre, *cur;</span><br><span class="line">        que.push(nullptr);</span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i = 0; i &lt; que.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pre = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line"></span><br><span class="line">                if(pre &amp;&amp; pre-&gt;val == 0 &amp;&amp; (cur-&gt;left||cur-&gt;right))</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    cur-&gt;val = 1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(cur-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(cur);</span><br><span class="line">                    que.push(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(cur-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(cur);</span><br><span class="line">                    que.push(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然而，这种方法下，当遇到的二叉树<strong>添加监控的结点的孙子结点是叶子结点时，则无法做到监控的全覆盖</strong></p>
<h3 id="贪心-11"><a href="#贪心-11" class="headerlink" title="贪心"></a>贪心</h3><p>采用贪心策略，局部最优在于<strong>为了添加的监控数量最少，则只给叶子结点的父结点添加监控</strong></p>
<p>针对以上，结点值会有三种状态：<strong>0表示无覆盖，1表示有监控，2表示被覆盖</strong>。增加结点值为 2 是为了方便表示叶子结点等的状态，进而，二叉树的遍历顺序应为<strong>后序遍历</strong>，先遍历子结点再遍历中间结点，由下至上的遍历顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int dfs(TreeNode* node, int&amp; res)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!node)		//遇到空结点应返回2</span><br><span class="line">			return 2;</span><br><span class="line">		int l = dfs(node-&gt;left, res);</span><br><span class="line">		int r = dfs(node-&gt;right, res);</span><br><span class="line">		</span><br><span class="line">		if(l == 2 &amp;&amp; r == 2)</span><br><span class="line">         	return 0;</span><br><span class="line">         if(l == 0 || r == 0)</span><br><span class="line">         &#123;</span><br><span class="line">         	res++;</span><br><span class="line">         	return 1;</span><br><span class="line">         &#125;</span><br><span class="line">         if(l == 1 || r == 1)</span><br><span class="line">         	return 2;</span><br><span class="line">         </span><br><span class="line">         return -1;</span><br><span class="line">	&#125;</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(dfs(root, res) == 0)</span><br><span class="line">        	res++;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(log n)，最坏情况下为O(n)</p>
<p>因为后序遍历中，中间结点的处理情况需要用到其左右子结点的值来判断，因此，<strong>将当前结点的值作为递归函数的返回值</strong>。</p>
<p>根据左右子结点的值来判断当前当前结点的值，有四种情况：</p>
<ul>
<li>左右子结点都是有覆盖，则当前结点返回0，表示无覆盖</li>
<li>左右子结点有任意一个无覆盖，则当前结点应添加监控，返回1</li>
<li>左右子结点有任意一个有监控，则当前结点返回2，表示有覆盖</li>
<li>在对除根结点外的所有结点遍历结束后，对于根结点，可能会出现根结点未覆盖的情况，因此还需要对根结点的返回值进行一次判断，若返回0则需要再添加一个监控</li>
</ul>
<h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>该题中局部最优在于 <strong>不让叶子结点添加监控，而让叶子结点的父结点添加监控</strong>，在此基础上，推导出3种不同结点值的状况，并进行分类讨论</p>
<h2 id="通过最少操作次数使数组的和相等"><a href="#通过最少操作次数使数组的和相等" class="headerlink" title="通过最少操作次数使数组的和相等"></a><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/">通过最少操作次数使数组的和相等</a></strong></h2><p>该题给定两个数组，限定数组元素值均为1~6，任意修改数组元素，使得两个数组和相等，返回操作次数</p>
<h3 id="贪心-12"><a href="#贪心-12" class="headerlink" title="贪心"></a>贪心</h3><p>采用贪心策略，局部最优在于优先让数组和大的数组元素改为1，数组和小的数组元素改为6，最快速逼近两个数组的和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        int n1 = nums1.size();</span><br><span class="line">        int n2 = nums2.size();</span><br><span class="line">        if(n1*6 &lt; n2 || n2 * 6 &lt; n1 )</span><br><span class="line">            return -1;</span><br><span class="line">        int sub = accumulate(nums1.begin(), nums1.end(),0)-accumulate(nums2.begin(), nums2.end(),0);</span><br><span class="line">        if(sub &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums1, nums2);</span><br><span class="line">            sub = -sub;</span><br><span class="line">        &#125;</span><br><span class="line">        //要求nums1 减小， nums2 增大</span><br><span class="line">        vector&lt;int&gt; cnt(6);</span><br><span class="line">        for(auto n:nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[n-1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto n:nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[6-n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 5, res = 0;;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i*cnt[i] &gt;= sub)</span><br><span class="line">                return res + (sub+i-1)/i;</span><br><span class="line">            res += cnt[i];</span><br><span class="line">            sub -= i*cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>让<code>nums1</code>的和比<code>nums2</code>的和大，即让<code>nums1</code>减小，<code>让nums2</code>增大；</p>
<p>分别遍历两个数组，借助<code>vector</code>容器记录两个数组中能够减小或增大的最大范围，如<code>cnt[4]</code>含义是数组中原始值为5或者为2的元素有<code>cnt[4]</code>个；</p>
<p>最后遍历<code>vector</code>容器，若当前减小或增大的最大范围能够覆盖两个数组的和的差，即<code>i*cnt[i] &gt;= sub</code>，意味着仅需要对当前<code>cnt[i]</code>个元素减小或增大<code>i</code>就能够让两个数组的和相等，否则，因为遍历顺序优先遍历修改范围更大的元素，所以先让这些元素对数组差进行填补，再遍历更小范围的元素；</p>
<p>返回值中<code>return res + (sub+i-1)/i;</code>而不是直接返回<code>return res + sub / i;</code>，若<code>sub</code>不能整除<code>i</code>，直接返回会有余数导致结果偏小不正确，若返回<code>return res + sub / i + 1</code>，此时若<code>sub</code>能整除<code>i</code>，没有余数又导致结果偏大不正确。因此<code>sub + i - 1</code>向上取整解决了这个问题</p>
<h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>局部最优在于<strong>优先让数组中修改范围更大的元素进行修改，以最快速度填补数组和之差</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
