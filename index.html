<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kevin346-sc.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="c++">
<meta property="og:type" content="website">
<meta property="og:title" content="Serein’s Blog">
<meta property="og:url" content="https://kevin346-sc.github.io/index.html">
<meta property="og:site_name" content="Serein’s Blog">
<meta property="og:description" content="c++">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kevin Huang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kevin346-sc.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Serein’s Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Serein’s Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kevin Huang</p>
  <div class="site-description" itemprop="description">c++</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2024/08/17/git%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/17/git%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">git操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-08-17 20:44:01 / 修改时间：23:48:25" itemprop="dateCreated datePublished" datetime="2024-08-17T20:44:01+08:00">2024-08-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>假设远程仓库中有main分支，其中有Init的commit</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817191625062.png" alt="image-20240817191625062"></p>
<p>首先克隆同步到本地仓库，<code>git clone https://github.com/xx/xx.git</code></p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817191750339.png" alt="image-20240817191750339"></p>
<p>为了不扰乱main分支，应该在本地仓库中创建新的分支<code>git checkout -b my-feature</code></p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817191914518.png" alt="image-20240817191914518"></p>
<p>后续在此分支上进行自己的代码修改，修改完成后，使用<code>git diff</code>查看修改的代码，然后可<code>git add .</code> 添加修改到暂存区（staging）并告知本地git，<code>git commit -m &quot;f-commit&quot;</code>提交commit给local git</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817192347300.png" alt="image-20240817192347300"></p>
<p><code>git push -u origin my-feature</code>同步到远程仓库，此时远程仓库中也会新增<code>my-feature</code>分支</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817192627062.png" alt="image-20240817192627062"></p>
<p>如果此时远程仓库的代码有更新，则需要先拉取远程仓库main到本地的main，先切换到main分支<code>git checkout main</code>，<u>值得注意的是，这时候disk中的代码是Init状态的代码，并非在<code>f-commit</code>下的代码</u></p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817193511042.png" alt="image-20240817193511042"></p>
<p>这时候使用pull拉取<code>git pull origin main</code>，这时本地仓库与远程仓库状态一样，都有两个分支，切换回my-feature分支，为了在此分支上同步main分支代码更新，使用<code>git rebase main</code>，先让main的最新修改与当前分支同步，在这个基础上尝试添加该分支之前的commit(即<code>f-commit</code>)，如果有<code>rebase conflict</code>，需要手动选择保留哪个修改，这时候my-feature分支上会在f-commit前插入与远程分支一样的update commit</p>
<p> <img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817193714442.png" alt="image-20240817193714442"></p>
<p>再将本地同步到远程，<code>git push -f origin my-feature</code>，push需要加-f表示强制push，因为此时远程仓库的my-feature分支同样也有Init，update和f-commit三个commit</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817193839660.png" alt="image-20240817193839660"></p>
<p>将my-feature分支合并到main分支中<code>pull request</code></p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817194108191.png" alt="image-20240817194108191"></p>
<p>使用<code>squash and merge</code>，将一个分支上的所有改变合并成一个commit，合并完成后删除远程的my-feature分支，同样在本地仓库上<code>git checkout main</code> 切换到main分支再<code>git branch -D my-feature</code>删除my-feature，最后在main分支上<code>git pull origin main</code>同步远程仓库的更新，如此反复</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817194340700.png" alt="image-20240817194340700"></p>
<p>以上内容来源于<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=uj8hjLyEBmU">https://www.youtube.com/watch?v=uj8hjLyEBmU</a></p>
<p>关于撤销</p>
<p>假设初始状态下四个区域一致，disk是硬盘，staging暂存区，local本地仓库以及远端仓库remote</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817194658402.png" alt="image-20240817194658402"></p>
<p>如果发生修改change，但并未进行<code>git add</code>等操作，也就是说只在硬盘上修改，如果想要撤销，可以使用<code>git checkout &lt;changed_file&gt;</code> 或者<code>git restore &lt;changed_file&gt;</code>直接回退到Init状态，也就是上一次commit这个文件的状态，新版本的git更推荐使用restore</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817195333798.png" alt="image-20240817195333798"></p>
<p>在git add 后，也就是修改被同步到暂存区”git status -&gt; Changes to be commited”，如果想要撤销在暂存区的修改而保留硬盘上的修改，也就是取消git add的效果，就可以使用<code>git reset &lt;changed_file&gt;</code>或者<code>git restore --staged &lt;changed_file&gt;</code></p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817195619809.png" alt="image-20240817195619809"></p>
<p>如果想要连同硬盘上的修改也撤销，可以使用<code>git checkout HEAD &lt;changed_file&gt;</code>表示将文件撤销到最近一次commit的状态（HEAD）</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817195653564.png" alt="image-20240817195653564"></p>
<p>在git commit后，修改被提交到了本地git中，如果仅撤销本地git的修改，即取消git commit的效果，则可以使用<code>git reset --soft HEAD~1</code>，因为HEAD表示最近的一次commit，所以这里使用<code>HEAD~1</code>来表示想要回退到的Init状态</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817195853788.png" alt="image-20240817195853788"></p>
<p>进一步，如果想要取消连同取消git commit 和 git add 的效果，只保留在硬盘上的修改，那么可以使用<code>git reset HEAD~1</code>进行实现，也可以使用<code>git reset --mixed HEAD~1</code></p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817195922651.png" alt="image-20240817195922651"></p>
<p>要是连硬盘上的修改也撤销，就可以使用<code>git reset --hard HEAD~1</code></p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817200437211.png" alt="image-20240817200437211"></p>
<p>另一种撤销git revert，本质上是通过添加一个新的commit，使得看起来将change删除了，<code>git revert HEAD</code>这里的HEAD就是指commit过的change</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817200933821.png" alt="image-20240817200933821"></p>
<p>使用revert的好处有1. 可以撤销中间提交的任意一个commit </p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817201119527.png" alt="image-20240817201119527"></p>
<p>2.当修改push到远端remote仓库后，想要撤销公有分支上的修改，那么就只能使用revert，然后再push到远端仓库，从结果上撤销这个修改，否则会令使用这个公有分支的开发者混乱；也有可能这个分支是私有分支，就可以使用<code>git reset --hard HEAD~1</code>并推送到远端<code>git push -f</code>，-f 就是让remote强行接受这个分支变化，但不能用在共有分支上</p>
<p><img src="C:\Users\kevin\AppData\Roaming\Typora\typora-user-images\image-20240817201336433.png" alt="image-20240817201336433"></p>
<p>以上内容来源于<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ol7CMoJuAvI&t=17s">https://www.youtube.com/watch?v=ol7CMoJuAvI&amp;t=17s</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/11/19/template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/19/template/" class="post-title-link" itemprop="url">template</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-19 13:25:02" itemprop="dateCreated datePublished" datetime="2023-11-19T13:25:02+08:00">2023-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-27 14:57:33" itemprop="dateModified" datetime="2023-11-27T14:57:33+08:00">2023-11-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="并查集DisjointSet"><a href="#并查集DisjointSet" class="headerlink" title="并查集DisjointSet"></a>并查集DisjointSet</h2><p>并查集中每个强连通分量视为一个集合，强连通分量中任意两点均可达</p>
<p>并查集的两个基本操作</p>
<ul>
<li>Find：查找元素所属集合</li>
<li>Union：合并两个子集为一个新的集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Disjointset&#123;</span><br><span class="line">	private: </span><br><span class="line">		vector&lt;int&gt; fa;</span><br><span class="line">    	Disjointset(int max_size): fa(vector&lt;int&gt;(max_size))</span><br><span class="line">        &#123;</span><br><span class="line">            // 初始化fa数组</span><br><span class="line">            iota(fa.begin(), fa.end(), 0);</span><br><span class="line">        &#125;</span><br><span class="line">	public:</span><br><span class="line">        int Find(int x)</span><br><span class="line">        &#123;</span><br><span class="line">            if(fa[x] == x) // 自己就是根结点</span><br><span class="line">                return x;</span><br><span class="line">            else //继续查找父结点，直到根结点</span><br><span class="line">            &#123;</span><br><span class="line">                int parent = Find(fa[x]);</span><br><span class="line">                return parent;</span><br><span class="line">            &#125;</span><br><span class="line">            // 三目运算符写法</span><br><span class="line">            // return fa[x] == x ? x : Find(fa[x]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void Union(int a, int b)</span><br><span class="line">        &#123;</span><br><span class="line">            int pa_a = Find(a);</span><br><span class="line">            int pa_b = Find(b);</span><br><span class="line">            if(pa_a == pa_b) // 同属一个集合中，无需合并</span><br><span class="line">                return;</span><br><span class="line">            fa[pa_a] = pa_b;</span><br><span class="line">            // 也可以无需判断，直接写成 fa[pa_a] = pa_b;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样子，在树高较高的情况下（链表），find的复杂度可以达到O(n)，可以通过秩或者路径压缩的方法来减小复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 秩，代表树的高度</span><br><span class="line">// 当秩为a 与 秩为b 的两个子集合并时，将秩较小的合并到秩较大的集合上；若相等，则任意合并，秩+1</span><br><span class="line">class Disjointset&#123;</span><br><span class="line">	private: </span><br><span class="line">		vector&lt;int&gt; fa;</span><br><span class="line">		vector&lt;int&gt; rank; // 秩</span><br><span class="line">    	Disjointset(int max_size): fa(vector&lt;int&gt;(max_size), rank(vector&lt;int&gt;(max_size, 0)))</span><br><span class="line">        &#123;</span><br><span class="line">            // 初始化fa数组</span><br><span class="line">            iota(fa.begin(), fa.end(), 0);</span><br><span class="line">        &#125;</span><br><span class="line">	public:</span><br><span class="line">        int Find(int x)</span><br><span class="line">        &#123;</span><br><span class="line">            if(fa[x] == x) // 自己就是根结点</span><br><span class="line">                return x;</span><br><span class="line">            else //继续查找父结点，直到根结点</span><br><span class="line">            &#123;</span><br><span class="line">                int parent = Find(fa[x]);</span><br><span class="line">                return parent;</span><br><span class="line">            &#125;</span><br><span class="line">            // 三目运算符写法</span><br><span class="line">            // return fa[x] == x ? x : Find(fa[x]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void Union(int a, int b)</span><br><span class="line">        &#123;</span><br><span class="line">            int pa_a = Find(a);</span><br><span class="line">            int pa_b = Find(b);</span><br><span class="line">            if(rank[pa_a] &gt; rank[pa_b])</span><br><span class="line">            &#123;</span><br><span class="line">            	fa[pa_b] = pa_a;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">            	fa[pa_a] = pa_b;</span><br><span class="line">            	if(rank[pa_a] == rank[pa_b])</span><br><span class="line">            		rank[pa_b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 路径压缩</span><br><span class="line">class Disjointset&#123;</span><br><span class="line">	private: </span><br><span class="line">		vector&lt;int&gt; fa;</span><br><span class="line">    	Disjointset(int max_size): fa(vector&lt;int&gt;(max_size))</span><br><span class="line">        &#123;</span><br><span class="line">            // 初始化fa数组</span><br><span class="line">            iota(fa.begin(), fa.end(), 0);</span><br><span class="line">        &#125;</span><br><span class="line">	public:</span><br><span class="line">        int Find(int x)</span><br><span class="line">        &#123;</span><br><span class="line">            // 三目运算符写法</span><br><span class="line">            // return fa[x] == x ? x : Find(fa[x]);</span><br><span class="line">            // 在向上查找根结点时，每个孙子结点都变为子结点，减小树高</span><br><span class="line">            return fa[x] == x ? x : fa[x] = Find(fa[x]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void Union(int a, int b)</span><br><span class="line">        &#123;</span><br><span class="line">            int pa_a = Find(a);</span><br><span class="line">            int pa_b = Find(b);</span><br><span class="line">            if(pa_a == pa_b) // 同属一个集合中，无需合并</span><br><span class="line">                return;</span><br><span class="line">            fa[pa_a] = pa_b;</span><br><span class="line">            // 也可以无需判断，直接写成 fa[pa_a] = pa_b;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n+m×α(m))</code>，其中 n 是图中的顶点数，m 是图中边的数目，α 是反阿克曼函数，在n非常大的时候，α(n) &lt; 5。并查集的初始化需要 O(n)的时间，然后遍历 m 条边并执行 m 次合并操作，最后对 source 和 destination 执行一次查询操作，查询与合并的单次操作时间复杂度是 <code>O(α(m))</code>，因此合并与查询的时间复杂度是 <code>O(m×α(m))</code>，总时间复杂度是 <code>O(n+m×α(m))</code></p>
<h3 id="2316-统计无向图中无法互相到达点对数"><a href="#2316-统计无向图中无法互相到达点对数" class="headerlink" title="2316. 统计无向图中无法互相到达点对数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">2316. 统计无向图中无法互相到达点对数</a></h3><p>附加数组信息，保存节点数信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Disjointset&#123;</span><br><span class="line">    private:</span><br><span class="line">        vector&lt;int&gt; fa;</span><br><span class="line">        vector&lt;int&gt; rank;</span><br><span class="line">    public:</span><br><span class="line">        Disjointset(int n): fa(vector&lt;int&gt;(n)), rank(n, 1)</span><br><span class="line">        &#123;</span><br><span class="line">            iota(fa.begin(), fa.end(), 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int find(int x)</span><br><span class="line">        &#123;</span><br><span class="line">            if(x == fa[x])</span><br><span class="line">                return x;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                fa[x] = find(fa[x]);</span><br><span class="line">                return fa[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void Union(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            int pa_a = find(x);</span><br><span class="line">            int pa_b = find(y);</span><br><span class="line"></span><br><span class="line">            if(pa_a == pa_b)</span><br><span class="line">                return;</span><br><span class="line">            if(rank[pa_a] &gt; rank[pa_b])</span><br><span class="line">            &#123;</span><br><span class="line">                fa[pa_b] = pa_a;</span><br><span class="line">                rank[pa_a] += rank[pa_b];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                fa[pa_a] = pa_b;</span><br><span class="line">                rank[pa_b] += rank[pa_a];</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int get(int x)</span><br><span class="line">        &#123;</span><br><span class="line">            return rank[x];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        Disjointset disjointset(n);</span><br><span class="line">        for(const auto &amp; edge : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            disjointset.Union(edge[0], edge[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        long long res = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += n - disjointset.get(disjointset.find(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return res / 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树 Trie"></a>字典树 Trie</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/09/26/cs144/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/26/cs144/" class="post-title-link" itemprop="url">cs144</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-26 15:10:29" itemprop="dateCreated datePublished" datetime="2023-09-26T15:10:29+08:00">2023-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-18 09:43:38" itemprop="dateModified" datetime="2023-10-18T09:43:38+08:00">2023-10-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LAB0文档"><a href="#LAB0文档" class="headerlink" title="LAB0文档"></a>LAB0<a target="_blank" rel="noopener" href="https://cs144.github.io/assignments/check0.pdf">文档</a></h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>选择 VirtualBox + <a target="_blank" rel="noopener" href="https://stanford.edu/class/cs144/vm_files/cs144-intel-2023.ova">CS144 Image</a> + Xshell 远程连接 + vscode remote插件远程开发环境</p>
<p>安装好VirtualBox后，导入下载的实验虚拟电脑.ova文件，以cs144为账号和密码登录至虚拟机，首次登录需要修改密码</p>
<p>Xshell中建立以localhost为ip，2222为端口号的ssh连接，输入账号密码即可进行连接</p>
<p>在vscode中安装remote explorer插件，如图打开config配置文件，</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202309262117800.png"></p>
<p>写上ssh连接信息</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202309262117167.png"></p>
<p>或者点击加号新建一个ssh连接，并输入命令行</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202309262117837.png"></p>
<p>还可以在虚拟机中添加本地电脑的ssh公钥，从而实现免密码的登录</p>
<h2 id="实验Networking-by-hand"><a href="#实验Networking-by-hand" class="headerlink" title="实验Networking  by hand"></a>实验Networking  by hand</h2><h3 id="Fetch-a-Web-page"><a href="#Fetch-a-Web-page" class="headerlink" title="Fetch a Web page"></a>Fetch a Web page</h3><p>访问<a target="_blank" rel="noopener" href="http://cs144.keithw.org/hello">网页</a>并获取结果</p>
<p>依次输入<code>telnet cs144.keithw.org http</code> 表明telnet程序通过http服务访问</p>
<p><code>GET /hello HTTP/1.1</code> 表明GET方法获取URL下的路径</p>
<p><code>Host: cs144.keithw/org</code> 表明URL中的主机名</p>
<p><code>Connection: close</code> 表明在服务器完成响应后关闭连接</p>
<p>需要在较短时间内完成命令输入，否则会出现408超时</p>
<h3 id="Send-yourself-an-email"><a href="#Send-yourself-an-email" class="headerlink" title="Send yourself an email"></a>Send yourself an email</h3><p>使用telnet还可以指定让telnet程序通过smtp进行邮件发送</p>
<h3 id="Listening-and-connecting"><a href="#Listening-and-connecting" class="headerlink" title="Listening and connecting"></a>Listening and connecting</h3><p><code>netcat -v -l -p 9090</code>即可以对端口9090进行监听，开启另一个终端输入<code>telnet localhost 9090</code>对9090端口进行访问，此时可以在两个终端上互相发送消息并立即显示到另一个终端上</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/05/17/LeetCode%E9%93%BE%E8%A1%A8%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/17/LeetCode%E9%93%BE%E8%A1%A8%E7%AB%A0%E8%8A%82/" class="post-title-link" itemprop="url">LeetCode链表章节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-17 08:59:04 / 修改时间：14:33:29" itemprop="dateCreated datePublished" datetime="2023-05-17T08:59:04+08:00">2023-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/24/Leetcode%E6%95%B0%E7%BB%84%E7%AB%A0%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/24/Leetcode%E6%95%B0%E7%BB%84%E7%AB%A0%E8%8A%82/" class="post-title-link" itemprop="url">Leetcode数组章节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-24 15:13:04" itemprop="dateCreated datePublished" datetime="2023-04-24T15:13:04+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-25 15:08:02" itemprop="dateModified" datetime="2023-04-25T15:08:02+08:00">2023-04-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数组章节"><a href="#数组章节" class="headerlink" title="数组章节"></a>数组章节</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找模板题"><a href="#二分查找模板题" class="headerlink" title="二分查找模板题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">二分查找模板题</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        while(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] &lt; target)</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            else if(nums[mid] &gt; target)</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            else</span><br><span class="line">                return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，变形题可根据不同的判断条件进行判断，如将三种情况重新分成两种等</p>
<h3 id="lower-bound和upper-bound的实现"><a href="#lower-bound和upper-bound的实现" class="headerlink" title="lower_bound和upper_bound的实现"></a><code>lower_bound</code>和<code>upper_bound</code>的实现</h3><p><code>lower_bound</code>—返回第一个 大于等于 的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                r = mid - 1; // 可能左边还有值等于target的元素</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>upper_bound</code>—返回第一个 大于 的元素</p>
<p>类似，第一个 大于 的元素则判断条件中 遇到 小于等于 的元素时执行<code>l = mid + 1</code>， 遇到大于的元素 记录<code>ans</code>的同时<code>r = mid - 1</code>，因为左边可能还有值 大于 的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if (nums[mid] &lt;= target)</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">            	r = mid - 1;</span><br><span class="line">            	ans =mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="找到值等于target的区间"><a href="#找到值等于target的区间" class="headerlink" title="找到值等于target的区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">找到值等于target的区间</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int binary_search(vector&lt;int&gt;&amp; nums, int target)</span><br><span class="line">    &#123;</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                r = mid - 1; // 可能左边还有值等于target的元素</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int n = nums.size() - 1;</span><br><span class="line">        if(n &lt; 0)   return &#123;-1, -1&#125;;</span><br><span class="line">        int st = -1, en = -1;</span><br><span class="line">        st = binary_search(nums, target);</span><br><span class="line">        en = binary_search(nums, target + 1);</span><br><span class="line">        if(st == en) // 数组中找不到相等的元素</span><br><span class="line">            return &#123;-1, -1&#125;;</span><br><span class="line">        else if(en == -1) // 找到相等的元素但没有比target更大的元素</span><br><span class="line">            return &#123;st, n&#125;;</span><br><span class="line">        else</span><br><span class="line">            return &#123;st, en - 1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>应用 <code>lower_bound</code>的实现（找到第一个 大于等于 的元素），通过寻找区间首元素和尾元素的位置判断，传入不同的target值， 即可实现；但不能用 <code>upper_bound</code>来实现，因为<code>st = binary_search(nums, target - 1), en = binary_search(nums, target)</code>中，想要得知数组中 是否存在与target值相等的元素 与 当en为尾后元素时 冲突，例如<code>[5,7,7], target = 6</code>和<code>[2,2], target = 2</code></p>
<h3 id="找到第一个-逆序排序-小于等于-的元素"><a href="#找到第一个-逆序排序-小于等于-的元素" class="headerlink" title="找到第一个(逆序排序) 小于等于 的元素"></a>找到第一个(逆序排序) 小于等于 的元素</h3><h3 id="x的平方根"><a href="#x的平方根" class="headerlink" title="x的平方根"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">x的平方根</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        int l = 0, r = x, ans = -1;</span><br><span class="line">        while (l &lt;= r) &#123;</span><br><span class="line">            int mid = l + (r - l) / 2;</span><br><span class="line">            if ((long long)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>(当从小到大排序时)与上述不同，这一题要求的是 小于等于 的元素，则判断条件中当遇到 小于等于 的元素时，记录该元素同时<code>l = mid + 1</code>，因为右边可能还有 小于等于 的元素；而当遇到大于的元素，则直接<code>r = mid - 1</code>不用记录</p>
<h2 id="双指针——滑动窗口"><a href="#双指针——滑动窗口" class="headerlink" title="双指针——滑动窗口"></a>双指针——滑动窗口</h2><h3 id="移动元素"><a href="#移动元素" class="headerlink" title="移动元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">移动元素</a></h3><p>使用双指针在O(n)时间复杂度和O(1)空间复杂度下实现</p>
<p>同向遍历，即快慢指针实现，r指针遍历数组，不断的将r遍历到的不需要删除的元素赋值到l中，同时l++，当r遇到需要删除的元素则跳过，再次遇到不需要删除元素时，覆盖到l上，并逐一将后续需要的元素按顺序覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        // 同向遍历</span><br><span class="line">        int l = 0, r = 0;</span><br><span class="line">        for(r; r &lt; nums.size(); r++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[r] != val) // 需要删除的元素</span><br><span class="line">            &#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对向遍历，当l指针遇到需要删除的元素时与r指针交换，同时r–，此时，有可能r指针也指向需要删除的元素，因此这一轮中l指针不动，只移动r指针，也就在下一轮中再次判断l指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        // 对向遍历</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        while(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[l] == val) // 需要删除的元素</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[l], nums[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                l++;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方</a></h3><p>首先利用有序性，找到负数与非负数的分界线，从分界线开始向左右两边使用双指针遍历，其中，寻找分界线时可以使用二分法进行加速查找；或者从数组两端开始遍历并比较，最后则需要将数组逆序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// 从分界线开始遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()==1)</span><br><span class="line">            return &#123;nums[0]*nums[0]&#125;;</span><br><span class="line">        // 先找零 或者最小的正数</span><br><span class="line">        int l = 0, r = nums.size() - 1;</span><br><span class="line">        int ind = nums.size() - 1;</span><br><span class="line">        while(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] &gt;= 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ind = mid;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        l = ind - 1, r = ind;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        while(l &gt;= 0 &amp;&amp; r &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[l]*nums[l] &lt; nums[r]*nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(nums[l]*nums[l]);</span><br><span class="line">                l--;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(nums[r]*nums[r]);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l &gt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(nums[l]*nums[l]);</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">        while(r &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(nums[r]*nums[r]);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 从两端开始遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int i = 0, j = n - 1;</span><br><span class="line">        while(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            if(abs(nums[i]) &gt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(nums[i] * nums[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(nums[j] * nums[j]);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(nums[i]*nums[i]);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h4><p>通常，在使用快慢指针时，用快指针遍历数组并判断是否符合条件，而不是用慢指针，因此是判断<code>if(nums[r] != val)</code>而不是<code>if(val == nums[l]</code>，否则会miss掉一些值</p>
<h3 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() == 1)    return 1;</span><br><span class="line">        int l = 1;</span><br><span class="line">        for(int r = 1; r &lt; nums.size(); r++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[r] &gt; nums[r - 1])</span><br><span class="line">                nums[l++] = nums[r];</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="删除有序数组中的重复项-II"><a href="#删除有序数组中的重复项-II" class="headerlink" title="删除有序数组中的重复项 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">删除有序数组中的重复项 II</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int l = 2;</span><br><span class="line">        if(nums.size() &lt; 3) return nums.size();</span><br><span class="line">        for(int r = 2; r &lt; nums.size(); r++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[r] != nums[l - 2])</span><br><span class="line">                nums[l++] = nums[r];</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="总结2"><a href="#总结2" class="headerlink" title="总结2"></a>总结2</h4><p>都使用快慢指针，但当允许有两个重复值时，应该比较的是 <strong>快指针和慢指针-2</strong>，<strong>而不是 快指针和快指针-2</strong>，因为快慢指针都被初始化为2，当相等时，则快指针（&#x3D;慢指针）当前值多余，快指针继续遍历；遍历至当快指针遇到与慢指针-2不相等时，则可以将快指针的值赋值到慢指针，此时慢指针 &#x3D; 慢指针 - 1 &#x3D; 慢指针 - 2，需要删除的是慢指针而不是快指针。</p>
<p>同理，I中也可以将判断条件改为<code>if(nums[r] != nums[l - 1])</code>，也可以延伸到重复项数量为k</p>
<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title=" 长度最小的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/"> 长度最小的子数组</a></h3><p>右指针遍历整个数组，并不断扩大窗口，直至满足条件后，while循环中不断缩小窗口并更新结果，维持动态窗口满足条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        long long sum = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int res = nums.size() + 1;</span><br><span class="line">        for(int j = 0; j &lt; nums.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            while(sum &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                res = min(res, j - i + 1);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res == nums.size() + 1? 0 : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title=" 最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/"> 最小覆盖子串</a></h3><p>同样地，右指针遍历整个数组，而左指针不断缩小窗口，同时更新结果。此外，需要用哈希表记录窗口的访问记录并判断是否符合条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;char, int&gt; store, vis;</span><br><span class="line"></span><br><span class="line">    bool check()</span><br><span class="line">    &#123;</span><br><span class="line">        for (const auto &amp; it : store)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((vis.find(it.first) == vis.end()) || (vis.find(it.first) != vis.end() &amp;&amp; vis[it.first] &lt; it.second))</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line"></span><br><span class="line">        for (auto c : t)</span><br><span class="line">        &#123;</span><br><span class="line">            store[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        int res = s.size() + 1;</span><br><span class="line">        int ind = i;</span><br><span class="line">        while (j &lt; s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            vis[s[j]]++;</span><br><span class="line">            while (check()) // 已覆盖t字符串，则尝试缩小左边范围</span><br><span class="line">            &#123;</span><br><span class="line">                if(res &gt; j - i + 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = j - i + 1;</span><br><span class="line">                    ind = i;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[s[i++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res == s.size() + 1 ? &quot;&quot; : s.substr(ind, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruit-into-baskets/">水果成篮</a></h3><p>同样，右指针遍历数组，并扩大窗口，在不满足条件后，左指针不断缩小窗口，直至满足条件后更新结果。另外，还需要用哈希表来判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int totalFruit(vector&lt;int&gt;&amp; fruits) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; vis;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(int j = 0; j &lt; fruits.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[fruits[j]]++;</span><br><span class="line">            while(vis.size() &gt; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[fruits[i]]--;</span><br><span class="line">                if(vis[fruits[i]] == 0)</span><br><span class="line">                    vis.erase(fruits[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, j - i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h3><p>同样地思路，右指针不断扩大窗口，为了在扩大的时候不重复包含已有的元素，在添加元素到窗口之前把窗口中已有的对应元素删除掉，即左指针缩小窗口的过程，然后再更新结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int j = 0 , i = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        unordered_set&lt;char&gt; store;</span><br><span class="line">        for(j; j &lt; s.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            while(store.find(s[j]) != store.end())// 如果出现重复则先删除</span><br><span class="line">            &#123;</span><br><span class="line">                store.erase(s[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(store.find(s[j]) == store.end()) // 没有重复则加入</span><br><span class="line">                store.insert(s[j]);</span><br><span class="line">            res = max(res, j - i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="总结3"><a href="#总结3" class="headerlink" title="总结3"></a>总结3</h4><p><u>水果成篮和无重复字符的最长子串所求的是<strong>最大窗口长度</strong></u>，<u>而长度最小的子数组和最小覆盖子串求的是<strong>最小窗口长度</strong></u>，因此同样的遍历循环下，要在不同位置对结果进行更新，即求最大窗口长度时要在<strong>左指针</strong>遍历结束后更新，求最小窗口长度则是在<strong>右指针</strong>遍历过程中更新</p>
<h2 id="双指针——固定窗口"><a href="#双指针——固定窗口" class="headerlink" title="双指针——固定窗口"></a>双指针——固定窗口</h2><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title=" 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/"> 螺旋矩阵</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">        int up = 0, down = m-1, left = 0, right = n-1;</span><br><span class="line">        while (up &lt;= down &amp;&amp; left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = left; j &lt;= right; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[up][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            up++;</span><br><span class="line">            for (int i = up; i &lt;= down; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            if(up &gt; down || left &gt; right)</span><br><span class="line">                break;</span><br><span class="line">            for (int j = right; j &gt;= left; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[down][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            down--;</span><br><span class="line">            for (int i = down; i &gt;= up; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵 II</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        int cnt = n * n;</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        int up = 0, down = n - 1, left = 0, right = n - 1;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n));</span><br><span class="line">        while (tmp &lt;= cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = left; j &lt;= right; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[up][j] = tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            up++;</span><br><span class="line">            for (int i = up; i &lt;= down; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i][right] = tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            if (tmp &gt; cnt)</span><br><span class="line">                break;</span><br><span class="line">            for (int j = right; j &gt;= left; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                res[down][j] = tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            down--;</span><br><span class="line">            for (int i = down; i &gt;= up; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i][left] = tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/24/create_blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/24/create_blog/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-24 11:31:13" itemprop="dateCreated datePublished" datetime="2023-04-24T11:31:13+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-29 19:58:38" itemprop="dateModified" datetime="2022-11-29T19:58:38+08:00">2022-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="hexo-github部署个人博客"><a href="#hexo-github部署个人博客" class="headerlink" title="hexo+github部署个人博客"></a>hexo+github部署个人博客</h1><h2 id="环境与软件需求"><a href="#环境与软件需求" class="headerlink" title="环境与软件需求"></a>环境与软件需求</h2><ul>
<li>win10</li>
<li>git<br><em><strong>本教程需要先安装好git</strong></em><br><em><strong>本教程需要先安装好git</strong></em><br><em><strong>本教程需要先安装好git</strong></em></li>
</ul>
<ol>
<li><p>在<a target="_blank" rel="noopener" href="http://nodejs.org/">node.js官网</a>下载对应版本</p>
<p><img src="/create_blog/node_js.png" alt="nodejs"></p>
</li>
<li><p>安装完成后打开Git Bash.exe，输入<code>node -v</code>可查看node.js安装版本，输入<code>npm -v</code>可查看npm安装版本</p>
<p><img src="/create_blog/-v.png" alt="查看版本"></p>
</li>
<li><p>利用npm安装cnpm，同时使用镜像源</p>
<p><code>npm install -g cnpm --registry=https://registry.nmp.taobao.org</code></p>
</li>
<li><p>同样地，可以输入<code>cnpm</code>查看cnpm版本</p>
</li>
<li><p>这时，就可利用cnpm安装hexo，输入<code>cnpm install -g hexo-cli</code></p>
<p><img src="/create_blog/hexo.png" alt="hexo"></p>
</li>
<li><p>至此，创建博客前序步骤全部完成，在bash中指定一个路径，输入<code>mkdir </code>+文件夹名称，如blog，作为博客的根目录，进入该目录路径（有关博客操作都要在博客的根目录下进行），输入<code>hexo init</code>即完成博客的初始化。此时，输入<code>hexo s</code>即可通过<a href="localhost:4000">localhost:4000</a>对博客进行访问</p>
</li>
<li><p>在github中新建一个仓库待用，仓库名字通常为github名.github.io</p>
</li>
<li><p>安装git部署插件，输入<code>npm install hexo-deployer-git --save</code>，每次新建一个blog都要安装一次插件</p>
</li>
<li><p>更改配置文件（很多时候都会用到配置文件），输入<code>vim _config.yml</code>，先输入<code>i</code>使改为<code>insert</code>模式，找到<code>Deployment</code>进行配置修改，修改成如下</p>
<p><img src="/create_blog/deployment.png" alt="deployment"></p>
<p>即修改<code>type</code>属性为<code>git</code>，在<code>repo</code>下输入在github新建仓库的地址，并加上<code>branch:master</code>指定分支为master，然后即可退出vim，按下esc再按两次大写Z</p>
</li>
<li><p>此时即可对博客进行在github上的部署，在输入<code>hexo d</code>之前需要先输入<code>git config --global user.email &quot;18khhuang2@stu.edu.cn&quot;</code>和<code>git config --global user.name &quot;kevin346-sc&quot;</code>进行认证，否则将会无法进行远端部署</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-24 10:49:36" itemprop="dateCreated datePublished" datetime="2023-04-24T10:49:36+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-29 19:48:16" itemprop="dateModified" datetime="2022-11-29T19:48:16+08:00">2022-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/19/collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/19/collection/" class="post-title-link" itemprop="url">collection</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-19 11:23:27" itemprop="dateCreated datePublished" datetime="2023-04-19T11:23:27+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-03 09:25:18" itemprop="dateModified" datetime="2023-05-03T09:25:18+08:00">2023-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1. </p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"> </span><br><span class="line">struct PriceInfo &#123; double price; &#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const std::vector&lt;int&gt; data &#123;1, 2, 4, 5, 5, 6&#125;;</span><br><span class="line"> </span><br><span class="line">    for (int i = 0; i &lt; 7; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        // Search first element that is greater than i</span><br><span class="line">        auto upper = std::upper_bound(data.begin(), data.end(), i);</span><br><span class="line"> </span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; &quot; &lt; &quot;;</span><br><span class="line">        upper != data.end()</span><br><span class="line">            ? std::cout &lt;&lt; *upper &lt;&lt; &quot; at index &quot; &lt;&lt; std::distance(data.begin(), upper)</span><br><span class="line">            : std::cout &lt;&lt; &quot;not found&quot;;</span><br><span class="line">        std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;PriceInfo&gt; prices &#123;&#123;100.0&#125;, &#123;101.5&#125;, &#123;102.5&#125;, &#123;102.5&#125;, &#123;107.3&#125;&#125;;</span><br><span class="line"> </span><br><span class="line">    for (double to_find : &#123;102.5, 110.2&#125;)</span><br><span class="line">    &#123;</span><br><span class="line">        auto prc_info = std::lower_bound(prices.begin(), prices.end(), to_find,</span><br><span class="line">            [](double va,const PriceInfo&amp; info)</span><br><span class="line">            // no known conversion for argument 1 from &#x27;PriceInfo&#x27; to &#x27;double&#x27;</span><br><span class="line">            &#123;</span><br><span class="line">                return va &gt; info.price;</span><br><span class="line">            &#125;);</span><br><span class="line"> </span><br><span class="line">        prc_info != prices.end()</span><br><span class="line">            ? std::cout &lt;&lt; prc_info-&gt;price &lt;&lt; &quot; at index &quot; &lt;&lt; prc_info - prices.begin()</span><br><span class="line">            : std::cout &lt;&lt; to_find &lt;&lt; &quot; not found&quot;;</span><br><span class="line">        std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>需要将lambda函数 捕获列表中参数位置互换
</code></pre>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto prc_info = std::lower_bound(prices.begin(), prices.end(), to_find,</span><br><span class="line">            [](const PriceInfo&amp; info, double va)</span><br><span class="line">            &#123;</span><br><span class="line">                return va &gt; info.price;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>2. </p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 修改时间</span><br><span class="line">   char* t = ctime(&amp;st.st_mtime); // 这个字符串包含最后的换行符</span><br><span class="line">   // printf(&quot;%s\n&quot;, t);</span><br><span class="line">   </span><br><span class="line">   char* tt;</span><br><span class="line">   strncpy(tt, t, strlen(t) - 1); // 发生段错误</span><br><span class="line">   </span><br><span class="line">   char tt[1024];</span><br><span class="line">   // strncpy(tt, t, sizeof(t) - 1); // Tue May</span><br><span class="line">   strncpy(tt, t, strlen(t) - 1); // Tue May  2 10:15:54 2023</span><br><span class="line">   printf(&quot;%s\n&quot;, tt);</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<pre><code>`dest`不能用`char*`的`tt`，只能用`char tt[1024]`；
</code></pre>
<p>   <code>sizeof</code>只有前半段字符串，<code>strlen</code>才能全部复制</p>
<p>   并且<code>char tt[1024]</code>会改变前面变量<code>quanxian</code>的值，在后面加上了<code>tt</code>，而修改成更大的值则正常</p>
<p>3. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/04/11/Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/Nginx/" class="post-title-link" itemprop="url">Nginx</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-11 16:41:59" itemprop="dateCreated datePublished" datetime="2023-04-11T16:41:59+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-01 09:36:42" itemprop="dateModified" datetime="2023-05-01T09:36:42+08:00">2023-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="在Ubuntu18中使用Nginx"><a href="#在Ubuntu18中使用Nginx" class="headerlink" title="在Ubuntu18中使用Nginx"></a>在Ubuntu18中使用Nginx</h1><p>准备Nginx所需的库</p>
<ol>
<li><p>GCC编译器</p>
<p>Nginx不直接提供二进制可执行程序</p>
</li>
<li><p>PCRE库</p>
<p><code>sudo apt-get install libpcre3-dev</code></p>
<p>安装完成后用 <code>pcre-config --version</code>查看是否安装成功</p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927013.png" style="zoom: 50%;" />
</li>
<li><p>zlib库</p>
<p><code>zlib</code>库主要用于对HTTP包的内容进行压缩，进而减少网络传输量</p>
<p><code>sudo apt install zlib1g</code></p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927790.png" style="zoom: 80%;" />

<p><code>zlib</code>是直接使用的库，<code>zlib-devel</code>是二次开发所需要的库</p>
<p><code>sudo apt install zlib1g-dev</code></p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927372.png" style="zoom: 80%;" />
</li>
<li><p>OpenSSL开发库</p>
<p>通过OpenSSL库，可以使用SSL协议传输HTTP，另外，使用MD5、SHA1等散列函数也需要该库</p>
<p>在Ubuntu系统中，<code>openssl-devel</code>库需要分开来安装</p>
<p><code>sudo apt-get install openssl</code></p>
<p><code>sudo apt-get install libssl-dev</code></p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927704.png" style="zoom: 50%;" /></li>
</ol>
<h1 id="在centos-7-中使用Nginx"><a href="#在centos-7-中使用Nginx" class="headerlink" title="在centos 7 中使用Nginx"></a>在centos 7 中使用Nginx</h1><h2 id="安装所需要的库"><a href="#安装所需要的库" class="headerlink" title="安装所需要的库"></a>安装所需要的库</h2><ol>
<li><p>gcc 和 g++</p>
<p><code>yum installl -y gcc</code></p>
<p><img src="D:\hexo_blog\source_posts\Nginx\gcc_c.png"></p>
<p><code>yum install -y gcc-c++</code></p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010926366.png"></p>
</li>
<li><p>pcre</p>
<p><code>yum install -y pcre pcre-devel</code></p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927886.png" style="zoom: 50%;" />
</li>
<li><p>zlib</p>
<p><code>yum install -y zlib zlib-devel</code></p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010927713.png" style="zoom: 50%;" />
</li>
<li><p>openssl</p>
<p><code>yum install -y openssl openssl-devel</code></p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010925548.png"></p>
</li>
</ol>
<h2 id="让centos7实现联网"><a href="#让centos7实现联网" class="headerlink" title="让centos7实现联网"></a>让centos7实现联网</h2><p>默认情况下是不联网，而我们通常需要赋予静态IP让虚拟机联网</p>
<p>centos 系统默认没有<code>ifconfig</code>命令，需要先下载<code>yum install -y  net-tools.x86_64</code>或者使用<code>ip addr</code>命令，关注<code>ens33</code></p>
<ol>
<li><p>修改ens33的配置文件</p>
<p><code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305010925247.png"></p>
<p>将<code>BOOTPROTO</code>由原来的dhcp改为static，表明使用静态IP地址，将<code>ONBOOT</code>由原来的no改为yes，启动网络连接，再给出IP地址、子网掩码、网关和DNS服务器。以上DNS服务器是免费的</p>
</li>
<li><p>重启网络服务</p>
<p><code>systemctl restart network</code></p>
</li>
<li><p>输入<code>ip addr</code>命令可以看到网络配置完成，可以通过<code>ping www.baidu.com</code>进行测试，完成联网</p>
</li>
</ol>
<h2 id="编译Nginx源码"><a href="#编译Nginx源码" class="headerlink" title="编译Nginx源码"></a>编译Nginx源码</h2><p>上一步中联网的目的是获取虚拟机的IP地址，通过xshell以及xftp连接进行Nginx源码的传输</p>
<p>准备好以下的目录</p>
<ol>
<li>Nginx源码的存放目录，存放Nginx源码文件，非官方的模块源代码文件</li>
<li>编译阶段产生的中间文件存放目录，默认情况下编译过程中自动生成objs目录，存放在源码目录下</li>
<li>部署目录，存放实际Nginx运行所需要的二进制文件、配置文件，默认情况下为 <code>/usr/local/nginx</code></li>
<li>日志文件存放目录</li>
</ol>
<p>默认情况下，linux内核参数考虑最通用的场景，不符合用于高并发访问的web服务器的定义，所以通过修改内核参数，使得Nginx拥有更高性能</p>
<p>修改<code>/etc/sysctl.conf</code>来更改内核参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fs .file-max = 999999</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.ip_local_port_range = 1024		61000</span><br><span class="line">net.ipv4.tcp_rmem = 4096 32768 262142</span><br><span class="line">net.ipv4.tcp_wmem = 4096 32768 262142</span><br><span class="line">net.core.netdev_max_backlog = 8096</span><br><span class="line">net.core.rmem_default = 262144</span><br><span class="line">net.core.wmem_default = 262144</span><br><span class="line">net.core.rmem_max = 2097152</span><br><span class="line">net.core.wmem_max = 2097152</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_syn.backlog=1024</span><br></pre></td></tr></table></figure>

<p>然后执行<code>sysctl -p</code>命令，使上述修改生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">file-max: 这个参数表示进程 (比如一个 worker 进程) 可以同时打开的最大句柄数这个参数直接限制最大并发连接数，需根据实际情况配置。</span><br><span class="line">tcp_tw_reuse: 这个参数设置为 1，表示允许将 TIME-WAIT 状态的 socket 重新用于新的 TCP 连接，这对于服务器来说很有意义，因为服务器上总会有大量 TIME-WAIT 状态的连接</span><br><span class="line">tcp_keepalive_time: 这个参数表示当 keepalive 启用时，TCP 发送 keepalive 消息的频度。默认是 2 小时，若将其设置得小一些，可以更快地清理无效的连接。</span><br><span class="line">tcp_fin_timeout:这个参数表示当服务器主动关闭连接时，socket 保持在 FIN-WAIT-2状态的最大时间。</span><br><span class="line">tcp_max_tw_buckets: 这个参数表示操作系统允许 TIME WAIT 套接字数量的最大值如果超过这个数字，TIME WAIT 套接字将立刻被清除并打印警告信息。该参数默认为 180 000，过多的 TIME WAIT 套接字会使 Web 服务器变慢。</span><br><span class="line">tcp_max_syn_backlog: 这个参数表示 TCP 三次握手建立阶段接收 SYN 请求队列的最大长度，默认为 1024，将其设置得大一些可以使出现 Nginx 繁忙来不及 accept 新连接的情况时，Linux 不至于丢失客户端发起的连接请求。</span><br><span class="line">ip_local_port_range:这个参数定义了在 UDP 和TCP 连接中本地 (不括连接的远端)端口的取值范围。</span><br><span class="line">net.ipv4.tcp_rmem : 这个参数定义了 TCP 接收缓存 (用于 TCP 接收滑动窗口)的最小值、默认值、最大值。</span><br><span class="line">net.ipv4.tcp_wmem: 这个参数定义了 TCP 发送缓存 (用于 TCP 发送滑动窗口)的最小值、默认值、最大值。</span><br><span class="line">netdev_max_backlog: 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。这个参数表示该队列的最大值。</span><br><span class="line">rmem_default: 这个参数表示内核套接字接收缓存区默认的大小。</span><br><span class="line">wmem_default: 这个参数表示内核套接字发送缓存区默认的大小</span><br><span class="line">rmem_max: 这个参数表示内核套接字接收缓存区的最大大小。</span><br><span class="line">wmem_max: 这个参数表示内核套接字发送缓存区的最大大小。</span><br><span class="line">tcp_syncookies：该参数与性能无关，用于解决 TCP 的 SYN 攻击</span><br></pre></td></tr></table></figure>

<p>进入到Nginx源码目录，执行以下3行命令：</p>
<p><code>./configure</code>——检测操作系统内核和已经安装的软件，参数的解析，中间目录的生成以及根据各种参数生成一些 C 源码文件、Makefile 文件等</p>
<p><code>make</code>——根据 configure 命令生成的 Makefile 文件编译Nginx 工程，并生成目标文件最终的二进制文件</p>
<p><code>make install</code>——根据configure 执行时的参数将Nginx 部署到指定的安装目录，包括相关目录的建立和二进制文件、配置文件的复制</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kevin346-sc.github.io/2023/03/12/webserver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Huang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein’s Blog">
      <meta itemprop="description" content="c++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Serein’s Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/12/webserver/" class="post-title-link" itemprop="url">webserver</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-12 08:45:41" itemprop="dateCreated datePublished" datetime="2023-03-12T08:45:41+08:00">2023-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-07 16:56:54" itemprop="dateModified" datetime="2023-06-07T16:56:54+08:00">2023-06-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="webserver高性能服务器"><a href="#webserver高性能服务器" class="headerlink" title="webserver高性能服务器"></a>webserver高性能服务器</h1><p>系统：Linux</p>
<p>发行版：Ubuntu18</p>
<p>涉及知识点：</p>
<p>软件：VMware Station、Visual Studio Code、Xshell、Xftp</p>
<p>linux发行版中，有两个主流，CentOs和Ubuntu，分别是基于红帽企业和Debian，Ubuntu需要经常更新，用到.deb和apt软件包；而CentOS不常更新，使用.rpm和flatpak软件包。这说明了CentOS会更稳定。在此项目中，因为Ubuntu有一个庞大的社区，有更多的文档和免费的问题信息支持，并且Ubuntu上手更为简单，因此选择的发行版为Ubuntu18</p>
<h1 id="0、搭建linux虚拟机开发环境"><a href="#0、搭建linux虚拟机开发环境" class="headerlink" title="0、搭建linux虚拟机开发环境"></a>0、搭建linux虚拟机开发环境</h1><h2 id="Ubuntu-18安装"><a href="#Ubuntu-18安装" class="headerlink" title="Ubuntu 18安装"></a>Ubuntu 18安装</h2><p>下载Ubuntu18光驱，在VMware Station中创建Ubuntu 64位虚拟机并导入光驱进行安装，推荐安装VMware Tools，能够自适应虚拟机屏幕大小和实现在主机拖拽文件到虚拟机中等功能。</p>
<p>终端安装ssh，输入<code>sudo apt install openssh-server</code></p>
<p>[报错]暂时不能解析域名“sercurity.ubuntu.com”——这是因为虚拟机没有连上网，可以打开虚拟机设置选择桥接模式，并勾上复制物理网络连接状态（复习桥接模式和NAT）<img src="C:\myblog\source\_posts\webserver\ubuntu_net.png" style="zoom:60%;" /></p>
<p>为连接虚拟机，需要获取虚拟机的IP地址，在终端输入<code>sudo apt install net-tools</code>安装<code>net-tools</code>后即可通过<code>ifconfig</code>命令获取IP地址</p>
<p>[报错]没有可安装的候选——执行<code>sudo apt install net-tools</code>之后再次安装即可</p>
<h2 id="用xshell连接虚拟机"><a href="#用xshell连接虚拟机" class="headerlink" title="用xshell连接虚拟机"></a>用xshell连接虚拟机</h2><p>复制虚拟机的IP地址，在xshell中新建会话，填写会话名称和主机号（虚拟机IP地址），协议选择ssh，其余默认即可</p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003845.png" style="zoom:60%;" />

<p>输入用户名，密码就可以连接上</p>
<h2 id="在vscode中连接虚拟机"><a href="#在vscode中连接虚拟机" class="headerlink" title="在vscode中连接虚拟机"></a>在vscode中连接虚拟机</h2><p>在扩展中下载remote development，可以看到左侧栏多出的“远程资源管理器”图标，进入远程资源管理器，选择ssh并打开ssh配置文件，填写正确参数</p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302001098.png" style="zoom: 80%;" />

<p>之后，能看到左侧ssh栏下有对应的主机连接信息，选择再新窗口中打开，输入密码就能在vscode实现对虚拟机的操作</p>
<h1 id="1、linux-系统编程入门"><a href="#1、linux-系统编程入门" class="headerlink" title="1、linux 系统编程入门"></a>1、linux 系统编程入门</h1><h2 id="静态库创建和使用"><a href="#静态库创建和使用" class="headerlink" title="静态库创建和使用"></a>静态库创建和使用</h2><ol>
<li><code>gcc -c *.c</code>编译生成<code>.o</code>类型文件</li>
<li><code>ar rcs libxxx.a *.o</code>利用ar工具将<code>.o</code>文件生成名为xxx的静态库，其中，<code>lib</code>和<code>.a</code>为固定命名</li>
</ol>
<p>编译<code>main.c</code>文件时，需要包含函数声明的头文件，以及函数定义的静态库文件 </p>
<p>文件结构如下时，</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003238.png"></p>
<p><code>gcc -o app main.c -I ./include -l calc -L ./lib</code>生成 可执行文件<code>app</code></p>
<h2 id="动态库创建和使用"><a href="#动态库创建和使用" class="headerlink" title="动态库创建和使用"></a>动态库创建和使用</h2><ol>
<li><code>gcc -fpic -c *.c </code>编译生成与位置无关的<code>.o</code>文件</li>
<li><code>gcc -shared *.o -o libxxx.so</code>生成名为xxx的动态库，其中，<code>lib</code>和<code>.so</code>为固定命名</li>
</ol>
<p>在dynamic文件夹下生成动态库文件如下：</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003732.png"></p>
<p>在使用动态库时，如果直接像静态库那样使用，则在运行生成的可执行文件<code>app</code>时会报错</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003380.png"></p>
<p>使用<code>ldd(list dynamic dependencies)</code>命令查看动态库的依赖关系</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302003737.png"></p>
<p>可以看到，最终生成的可执行文件不能运行的原因在于其对应的动态库<code>libcalc.so</code>缺失</p>
<p>而文件在定位共享库时，对应ELF格式的可执行程序，先后搜索 DT_RPATH段 -&gt; 环境变量LD_LIBRARY_PATH -&gt; &#x2F;etc&#x2F;ld.so.cache 文件列表 -&gt; &#x2F;lib&#x2F;, &#x2F;usr&#x2F;lib 目录找到库文件后将其载入内存</p>
<p>因此，第一种方法可以在环境变量LD_LIBRARY_PATH中加入动态库路径</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004567.png"></p>
<p><strong>但环境变量在每次关闭终端后都会恢复到打开终端之前</strong></p>
<p>第二种方法则可以在用户级别下配置文件 <code>~/.bashrc</code> 中保存该环境变量</p>
<p><code>vim .bashrc</code>敲入<code>shift+g</code>移动到最后一行，敲入<code>o</code>在下一行中插入编辑</p>
<p>输入相同的<code>export</code>语句，保存并退出，<code>. .bashrc</code>或<code>source .bashrc</code>重新运行配置文件使其生效</p>
<p>第三种方法在系统级别下配置文件 <code>/etc/profile</code> 中加入同样的<code>export</code>语句</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004159.png"></p>
<p>以上是通过环境变量来找到路径</p>
<p>另外，还可以修改<code>/etc/ld.so.cache </code>文件，<code>sudo vim /etc/ld.so.conf</code>在文件中加入路径，间接修改<code>.cache</code>文件，保存退出，<code>sudo ldconfig</code>进行更新</p>
<p>最后，不推荐将动态库文件放到 <code>/lib/</code>,<code>/usr/lib/</code>目录中，因为这两个目录下有很多文件，可能会有重复命名问题</p>
<h2 id="静态库vs动态库"><a href="#静态库vs动态库" class="headerlink" title="静态库vs动态库"></a>静态库vs动态库</h2><p>静态库</p>
<ul>
<li>加载速度快</li>
<li>程序发布不需要提供静态库，移植方便</li>
<li>但浪费内存</li>
<li>不利于更新部署</li>
</ul>
<p>动态库</p>
<ul>
<li>实现进程间资源共享</li>
<li>更新部署简单</li>
<li>何时加载可控</li>
<li>但加载速度慢</li>
<li>程序发布需要提供动态库</li>
</ul>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>目标 ： 依赖</p>
<p>​		(tab)命令</p>
<p>其他规则通常为第一条规则服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app : sub.c add.c mult.c div.c main.c</span><br><span class="line">	gcc sub.c add.c mult.c div.c main.c -o app</span><br></pre></td></tr></table></figure>

<p>依赖存在，则执行命令；否则向下检查其他规则，寻找生成依赖的命令</p>
<p>依赖生成时间比目标晚，则需要执行命令对目标进行更新</p>
<p>变量定义：变量名&#x3D;变量值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AR : 归档维护程序的名称，默认值为 ar</span><br><span class="line">CC : C 编译器的名称，默认值为 cc</span><br><span class="line">CXX : C++ 编译器的名称，默认值为 g++</span><br><span class="line">$@ : 目标的完整名称</span><br><span class="line">$&lt; : 第一个依赖文件的名称</span><br><span class="line">$^ : 所有的依赖文件</span><br><span class="line"></span><br><span class="line">%.o : %.c 匹配同一个字符串</span><br><span class="line"></span><br><span class="line">$(wildcard ./*.c ./PATH/*.c)</span><br><span class="line">返回 a.c b.c c.c</span><br><span class="line">src=$(wildcard ./*.c)</span><br><span class="line"></span><br><span class="line">$(patsubst %.c %.o a.c b.c)</span><br><span class="line">返回替换a.c, b.c 后的字符串 a.o, b.o</span><br><span class="line">objs=$(patsubst %.c, %.o, $(src))</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">	rm $(objs) -f</span><br></pre></td></tr></table></figure>



<h2 id="GDB调试工具"><a href="#GDB调试工具" class="headerlink" title="GDB调试工具"></a>GDB调试工具</h2><p>gcc -g -Wall a.c -o test</p>
<p>-g作用是在可执行文件中加入源代码信息，-wall打开所有warning</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">list/l (行号)</span><br><span class="line">list/l (文件名:函数名)</span><br><span class="line">show list</span><br><span class="line">set list (要显示的行数大小)</span><br><span class="line">set args (给程序输入的参数1) (给程序输入的参数2)</span><br><span class="line">show args</span><br><span class="line">b (行号)</span><br><span class="line">b (文件名:函数名)</span><br><span class="line">b (行号) if (条件)</span><br><span class="line">i b</span><br><span class="line">d (断点编号)</span><br><span class="line">dis (断点编号)</span><br><span class="line">ena (断点编号)</span><br><span class="line">run  ——遇到断点才停</span><br><span class="line">start ——停在第一行</span><br><span class="line">c ——到下一个断点</span><br><span class="line">n ——下一行(不进入函数体)</span><br><span class="line">s ——下一步(进入函数体)</span><br><span class="line">finish ——调出函数体</span><br><span class="line">p (变量名) ——打印变量值</span><br><span class="line">ptype (变量名) ——打印变量类型</span><br><span class="line">display (变量名) ——自动打印变量名</span><br><span class="line">undisplay(变量名) ——取消自动打印</span><br><span class="line">i display ——显示自动打印信息</span><br><span class="line">set var (变量名)=(变量值)</span><br></pre></td></tr></table></figure>

<h2 id="文件I-x2F-O函数"><a href="#文件I-x2F-O函数" class="headerlink" title="文件I&#x2F;O函数"></a>文件I&#x2F;O函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* open 函数</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">	- flags: O_RDONLY, O_WRONLY, O_RDWR, O_CREAT...</span><br><span class="line">	- mode: 八进制，最终文件权限值为 mode &amp; ~umask, umask 默认 0002， 也可以使用宏，如 S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*read 函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">	从fd指向的文件中读取 count字节，存到buf中</span><br><span class="line">	返回-1则读取失败，0则表示读取到文件末尾，否则返回读取到的字节数</span><br><span class="line">size_t and ssize_t are,  respectively,  unsigned  and  signed</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*write 函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">	将buf中的count字节写入到文件fd中</span><br><span class="line">	返回写入的字节数，有可能小于count，因为写入空间不够。-1或0则写入失败</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*lseek 函数</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">	改变文件 fd 中的读写指针位置</span><br><span class="line">	- whence 可选参数 </span><br><span class="line">		宏定义 SEEK_SET, 文件开始位置</span><br><span class="line">		SEEK_CUR, 文件指针当前位置</span><br><span class="line">		SEEK_END, 文件结束位置</span><br><span class="line">	返回从文件开头开始的指针位置，-1则报错，并将报错记录在perrno中</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*stat 函数</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int stat(const char *pathname, struct stat *statbuf);</span><br><span class="line">	获取文件信息，记录在statbuf当中</span><br><span class="line">- struct stat &#123;</span><br><span class="line">              dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">              ino_t     st_ino;         /* Inode number */</span><br><span class="line">              mode_t    st_mode;        /* File type and mode */</span><br><span class="line">              nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">              uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">              gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">              dev_t     st_rdev;        /* Device ID (if special file) */</span><br><span class="line">              off_t     st_size;        /* Total size, in bytes */</span><br><span class="line">              blksize_t st_blksize;     /* Block size for filesystem I/O */</span><br><span class="line">              blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line">              time_t	 st_atime;		/* Time of last access */</span><br><span class="line">              time_t	 st_mtime;		/* Time of last modification */</span><br><span class="line">              time_t	 st_ctime;		/* Time of last status change */</span><br><span class="line">          &#125;;</span><br><span class="line">- 返回0则成功，否则返回-1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>其中，st_mode 变量如下：</p>
<p>setGID - 设置组id，setUID - 设置用户id，Sticky - 粘住位</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004423.png" alt="st_mode"></p>
<p>根据文件类型位，与相应位的宏定义 相与 运算即可，</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202304302004953.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*lstat 函数</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/stat.h&gt;</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int lstat(const char *pathname, struct stat *statbuf);</span><br><span class="line">    	stat函数如果传入的是软连接，则返回链接文件信息而非链接指向的文件，而lstat函数返回链接指向文件的信息</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>利用上述函数实现<code>ls -l</code> 命令</p>
<p>接受一个文件名当做函数参数，输出该文件的信息</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305011616507.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">//ls-l.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;grp.h&gt;</span><br><span class="line">#include &lt;pwd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">// 类型权限 硬链接数 用户名 组名 文件大小 修改时间 文件名</span><br><span class="line">//-rw-rw-r-- 1 kevin kevin 0 5月   1 16:07 ls-l.c</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;too few arguments&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    struct stat st;</span><br><span class="line">    int flag = stat(argv[1], &amp;st);</span><br><span class="line">    if(flag == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;stat&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char filetype;</span><br><span class="line">    switch(st.st_mode &amp; __S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">        case __S_IFLNK:</span><br><span class="line">            filetype = &#x27;l&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFSOCK:</span><br><span class="line">            filetype = &#x27;s&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFREG:</span><br><span class="line">            filetype = &#x27;-&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFDIR:</span><br><span class="line">            filetype = &#x27;d&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFBLK:</span><br><span class="line">            filetype = &#x27;b&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFCHR:</span><br><span class="line">            filetype = &#x27;c&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case __S_IFIFO:</span><br><span class="line">            filetype = &#x27;f&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            filetype = &#x27;?&#x27;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    char quanxian[10];</span><br><span class="line">    memset(quanxian, &#x27;-&#x27;, sizeof(quanxian));</span><br><span class="line">    // user</span><br><span class="line">    if(st.st_mode &amp; S_IRUSR)</span><br><span class="line">        quanxian[1] = &#x27;R&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IWUSR)</span><br><span class="line">        quanxian[2] = &#x27;W&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IXUSR)</span><br><span class="line">        quanxian[3] = &#x27;X&#x27;;</span><br><span class="line">    </span><br><span class="line">    // group</span><br><span class="line">    if(st.st_mode &amp; S_IRGRP)</span><br><span class="line">        quanxian[4] = &#x27;R&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IWGRP)</span><br><span class="line">        quanxian[5] = &#x27;W&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IXGRP)</span><br><span class="line">        quanxian[6] = &#x27;X&#x27;;</span><br><span class="line">    </span><br><span class="line">    // other</span><br><span class="line">    if(st.st_mode &amp; S_IROTH)</span><br><span class="line">        quanxian[7] = &#x27;R&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IWOTH)</span><br><span class="line">        quanxian[8] = &#x27;W&#x27;;</span><br><span class="line">    if(st.st_mode &amp; S_IXOTH)</span><br><span class="line">        quanxian[9] = &#x27;X&#x27;;</span><br><span class="line">    // printf(&quot;%c%s\n&quot;, filetype,quanxian);</span><br><span class="line"></span><br><span class="line">    // 硬链接数</span><br><span class="line">    int linknum = st.st_nlink;</span><br><span class="line"></span><br><span class="line">    // 组名 用户名</span><br><span class="line">    char* u = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line">    char* g = getgrgid(st.st_gid)-&gt;gr_name;</span><br><span class="line">    </span><br><span class="line">    // 文件大小</span><br><span class="line">    long int fsize = st.st_size;</span><br><span class="line"></span><br><span class="line">    // 文件名</span><br><span class="line">    char* file_name = argv[1];</span><br><span class="line"></span><br><span class="line">    // 修改时间</span><br><span class="line">    char* t = ctime(&amp;st.st_mtime); // 这个字符串包含最后的换行符</span><br><span class="line">    // printf(&quot;%s\n&quot;, t);</span><br><span class="line">    char tt[100];</span><br><span class="line">    // strncpy(tt, t, sizeof(t) - 1); // Tue May</span><br><span class="line">    strncpy(tt, t, strlen(t) - 1); // Tue May  2 10:15:54 2023</span><br><span class="line">    // printf(&quot;%s\n&quot;, tt);</span><br><span class="line"></span><br><span class="line">    // 最终输出结果</span><br><span class="line">    char disp[1024] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    sprintf(disp, &quot;%c%s %d %s %s %ld %s %s\n&quot;, filetype, quanxian, linknum, u, g, fsize, tt, file_name);</span><br><span class="line">    // --RW-RW-R--Tue May  2 10:23:42 2023 1 kevin kevin 2590 Tue May  2 10:23:42 2023 ls-l.c</span><br><span class="line">    // -rw-rw-r-- 1 kevin kevin  2668 5月   2 10:26 ls-l.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;%s&quot;, disp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件属性操作函数"><a href="#文件属性操作函数" class="headerlink" title="文件属性操作函数"></a>文件属性操作函数</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*access 函数</span><br><span class="line"> #include&lt;unistd.h&gt;</span><br><span class="line"> int access(const char * pathname, int mode)</span><br><span class="line"> 	判断文件的权限或是否存在</span><br><span class="line"> 	-mode, R_OK, W_OK, X_OK, F_OK</span><br><span class="line"> 	成功返回0，否则返回-1</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*chmod 函数</span><br><span class="line">	#include &lt;sys/stat.h&gt;</span><br><span class="line">	int chmod(const char *pathname, mode_t mode);</span><br><span class="line">	改变文件权限</span><br><span class="line">	-mode, 八进制数，使用不同用户宏定义</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*truncate 函数</span><br><span class="line">	#include &lt;unistd.h&gt;</span><br><span class="line">	#include &lt;sys/types.h&gt;</span><br><span class="line">int truncate(const char *path, off_t length);</span><br><span class="line">	截断或扩展文件长度</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*mkdir 函数</span><br><span class="line">	#include &lt;sys/stat.h&gt;</span><br><span class="line">	#include &lt;sys/types.h&gt;</span><br><span class="line">	int mkdir(const char *pathname, mode_t mode);</span><br><span class="line">		- 创建目录，赋予mode权限，mode是八进制数，最终权限 = mode &amp; ~umask &amp; 0777</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*rmdir 函数</span><br><span class="line">     #include &lt;unistd.h&gt;</span><br><span class="line">     int rmdir(const char *pathname);</span><br><span class="line">         - 删除目录，目录要求是空目录</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*raname 函数</span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    int rename(const char *oldpath, const char *newpath);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*chdir 函数</span><br><span class="line">	#include &lt;unistd.h&gt;</span><br><span class="line">	int chdir(const char *path);</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*getcwd 函数</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    char *getcwd(char *buf, size_t size);</span><br><span class="line">    	- 获得当前工作目录</span><br><span class="line">    	- buf 用于存储路径的数组，size 是数组的大小</span><br><span class="line">    	- 返回值就是buf</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*opendir 函数</span><br><span class="line">	#include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;dirent.h&gt;</span><br><span class="line">    DIR *opendir(const char *name);</span><br><span class="line">    	- name 目录的名称</span><br><span class="line">    	- 返回 DIR* 类型，目录流，失败返回null</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*readdir 函数</span><br><span class="line">    #include &lt;dirent.h&gt;</span><br><span class="line">    struct dirent *readdir(DIR *dirp);</span><br><span class="line">        - dirp是opendir返回值</span><br><span class="line">        - 返回struct dirent，代表读取到的文件的信息</span><br><span class="line">          读取到了末尾或者失败则返回NULL</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*closedir 函数</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;dirent.h&gt;</span><br><span class="line">    int closedir(DIR *dirp);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>利用上述函数实现对目录的遍历和对该目录下普通文件数量的统计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#define _DEFAULT_SOURCE</span><br><span class="line">// #define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int tongji(const char * path)</span><br><span class="line">&#123;</span><br><span class="line">    DIR* dir = opendir(path);</span><br><span class="line">    if(dir == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;opendir&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    struct dirent* dent;</span><br><span class="line">    while((dent = readdir(dir)) != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        char* dirname = dent-&gt;d_name;</span><br><span class="line">        if(strcmp(dirname, &quot;.&quot;) == 0|| strcmp(dirname, &quot;..&quot;) == 0)</span><br><span class="line">            continue;</span><br><span class="line">        if(dent-&gt;d_type == DT_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            char newpath[1024];</span><br><span class="line">            sprintf(newpath, &quot;%s/%s&quot;, path, dirname);</span><br><span class="line">            cnt += tongji(newpath);</span><br><span class="line">        &#125;</span><br><span class="line">        if(dent-&gt;d_type == DT_REG)</span><br><span class="line">            cnt += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;too few args.&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = tongji(argv[1]);</span><br><span class="line">    printf(&quot;普通文件个数为：%d\n&quot;, res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件描述符复制函数"><a href="#文件描述符复制函数" class="headerlink" title="文件描述符复制函数"></a>文件描述符复制函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*dup 函数</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int dup(int oldfd);</span><br><span class="line">    	复制旧的文件描述符，返回一个新的最小空闲描述符</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*dup2 函数</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int dup2(int oldfd, int newfd);</span><br><span class="line">    	重定向文件描述符，将原本指向文件a的描述符oldfd 转向成指向文件b的描述符 newfd</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*fcntl 函数</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    #include &lt;fcntl.h&gt;</span><br><span class="line">    int fcntl(int fd, int cmd, ...);</span><br><span class="line">    	对需要操作的文件fd进行cmd操作</span><br><span class="line">    	- F_DUPFD : 复制文件描述符,复制fd，返回一个新的文件描述符</span><br><span class="line">    	- F_GETFL : 获取指定的文件描述符文件状态flag，类似open函数传递的flag</span><br><span class="line">    	- F_SETFL : 设置文件描述符文件状态flag</span><br><span class="line">              必选：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span><br><span class="line">              可选：O_APPEND, O_NONBLOCK非阻塞</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h1 id="2、Linux多进程开发"><a href="#2、Linux多进程开发" class="headerlink" title="2、Linux多进程开发"></a>2、Linux多进程开发</h1><h2 id="进程创建与查看"><a href="#进程创建与查看" class="headerlink" title="进程创建与查看"></a>进程创建与查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br><span class="line">	成功：子进程返回0，父进程返回子进程ID</span><br><span class="line">	失败则返回-1</span><br><span class="line">		- 当前系统的进程数达到系统规定上限，errno置为EAGAIN</span><br><span class="line">		- 系统内存不足，errno置为ENOMEM</span><br></pre></td></tr></table></figure>

<p><code>ps aux</code>、<code>ps ajx</code>列出与作业控制相关的信息、<code>ps -ef</code></p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305041430373.png"></p>
<p><code>top</code>命令实时显示进程动态 <code>-d</code>指定更新时间间隔</p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305041434410.png"></p>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305041437661.png"></p>
<h2 id="多进程GDB调试"><a href="#多进程GDB调试" class="headerlink" title="多进程GDB调试"></a>多进程GDB调试</h2><p>GDB默认只跟踪一个进程，调试当前进程时，其他进程继续运行</p>
<p><code>set follow-fork-mode [parent | child]</code>设置当前调试父进程或子进程</p>
<p><code>set detach-on-fork [on | off]</code> off表示调试当前进程时，其他进程被挂起，否则继续运行</p>
<p><code>info inferiors</code>查看调试的进程</p>
<p><code>inferior id</code>切换当前调试的进程</p>
<p><code>detach inferiors id</code>使进程脱离GDB调试</p>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><p>exec函数族的作用是根据指定的文件名找到可执行文件，调用后直接取代当前进程的内容，调用进程覆盖原来的内存</p>
<p>调用成功不返回，调用失败则返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line"></span><br><span class="line">int execlp(const char *file, const char *arg, ... /* (char *) NULL */);</span><br><span class="line"></span><br><span class="line">int execle(const char *path, const char *arg, .../*, (char *) NULL, char *const envp[] */);</span><br><span class="line"></span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line"></span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line"></span><br><span class="line">int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line"></span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure>

<p>l(list)——参数地址列表，以空指针结尾<br>v(vector)——存有各参数地址的指针数组的地址<br>p(path)——按 PATH 环境变量指定的目录搜索可执行文件<br>e(environment)——存有环境变量字符串地址的指针数组的地址</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>标准C库<code>exit</code>与Linux标准库<code>_exit</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);</span><br><span class="line">	在终止进程之前会刷新I/O缓冲区，而_exit则不会</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure>

<p>孤儿进程：父进程在子进程之前退出，子进程就被称为孤儿进程，将成为init进程的子进程，孤儿进程没有危害</p>
<p>僵尸进程：子进程在父进程之前退出，内核会在子进程退出后会保留一定的信息，而父进程没有进行处理，则产生僵尸进程，大量僵尸进程占用进程号，导致无法创建新的进程</p>
<h2 id="僵尸进程的解决"><a href="#僵尸进程的解决" class="headerlink" title="僵尸进程的解决"></a>僵尸进程的解决</h2><ol>
<li><p>干掉父进程，让子进程变为孤儿进程，由init进程负责释放</p>
</li>
<li><p>父进程调用<code>wait()</code>或<code>waitpid()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t wait(int *wstatus);</span><br><span class="line">	- wstatus 储存子进程退出状态，使用相关宏函数可以获取退出状态信息</span><br><span class="line">	- 返回值 &gt; 0 返回的是子进程ID号, &lt; 0 失败，所有子进程结束</span><br><span class="line">pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">	- pid = -1, options = WNOHANG时等同于wait()</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305061511601.png" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305061513010.png" style="zoom:50%;" />
</li>
<li><p><code>fork</code>两次</p>
<p>父进程fork子进程，子进程fork孙进程后退出，则孙进程被init接管，但需要父进程回收子进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t  pid;</span><br><span class="line">    //创建第一个子进程</span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fork error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //第一个子进程</span><br><span class="line">    else if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //子进程再创建子进程</span><br><span class="line">        printf(&quot;I am the first child process.pid:%d\tppid:%d\n&quot;,getpid(),getppid());</span><br><span class="line">        pid = fork();</span><br><span class="line">        if (pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fork error:&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        //第一个子进程退出</span><br><span class="line">        else if (pid &gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;first procee is exited.\n&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        //第二个子进程</span><br><span class="line">        //睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里</span><br><span class="line">        sleep(3);</span><br><span class="line">        printf(&quot;I am the second child process.pid: %d\tppid:%d\n&quot;,getpid(),getppid());</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //父进程处理第一个子进程退出</span><br><span class="line">    if (waitpid(pid, NULL, 0) != pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;waitepid error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>signal</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">static void sig_child(int signo);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    //创建捕捉子进程退出信号</span><br><span class="line">    signal(SIGCHLD,sig_child);</span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fork error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;I am child process,pid id %d.I am exiting.\n&quot;,getpid());</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;I am father process.I will sleep two seconds\n&quot;);</span><br><span class="line">    //等待子进程先退出</span><br><span class="line">    sleep(2);</span><br><span class="line">    //输出进程信息</span><br><span class="line">    system(&quot;ps -o pid,ppid,state,tty,command&quot;);</span><br><span class="line">    printf(&quot;father process is exiting.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sig_child(int signo)</span><br><span class="line">&#123;</span><br><span class="line">     pid_t        pid;</span><br><span class="line">     int        stat;</span><br><span class="line">     //处理僵尸进程</span><br><span class="line">     while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt;0)</span><br><span class="line">            printf(&quot;child %d terminated.\n&quot;, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间通讯的目的：</p>
<ol>
<li>数据传输</li>
<li>通知事件</li>
<li>资源共享</li>
<li>进程控制</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305061537759.png"></p>
<h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>管道即匿名管道，没有文件实体，但有名管道有文件实体</p>
<p>管道是字节流，能够读取任意大小的数据块</p>
<p>匿名管道只能在<strong>具有公共祖先</strong>的进程中使用</p>
<p>使用命令<code>ulimit -a</code>可以查看管道缓冲大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int pipefd[2])</span><br><span class="line">	- 创建管道</span><br><span class="line">	- pipefd数组中，pipefd[0]表示管道读端， pipefd[1]表示写端，相当于管道两端的文件描述符</span><br><span class="line"></span><br><span class="line">int pipe2(int pipefd[2], int flags)</span><br><span class="line">	- flags参数O_NONBLOCK可以将管道设为非阻塞</span><br><span class="line"></span><br><span class="line">long fpathconf(int fd, int name)</span><br><span class="line">	- 查看管道缓冲大小函数</span><br><span class="line">	- fd是管道的读端或者写端，根据name所对应的宏定义可以获取管道的相关信息，_PC_PIPE_BUF最大缓冲区大小</span><br></pre></td></tr></table></figure>

<h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><p>有名管道克服了匿名管道只能在有亲缘关系的进程间通信的缺点，以FIFO文件形式存在于文件系统中，只要能够访问该文件，就能彼此进行通信</p>
<p>作为一个特殊文件存在，但FIFO中的内容存放在内存中</p>
<p>与匿名管道一样，都不支持<code>lseek()</code>文件定位操作</p>
<p>可以通过<code>mkfifo</code>命令创建有名管道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int mkfifo(const char* pathname, mode_t mode);</span><br><span class="line">	- mode 与 open中一样，八进制数</span><br></pre></td></tr></table></figure>

<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.</span><br><span class="line">void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">	- addr = NULL, 由内核指定</span><br><span class="line">	- length是要映射的数据长度，可以用lseek、stat获取文件的长度</span><br><span class="line">	- prot是映射内存的操作权限，</span><br><span class="line">	  PROT_EXEC,PROT_WRITE,PROT_READ,PROT_NONE，通常要小于等于磁盘文件open的权限</span><br><span class="line">	- flags， MAP_SHARED：映射区数据自动与磁盘文件同步	MAP_PRIVATE：不同步</span><br><span class="line">	- fd 映射的文件描述符</span><br><span class="line">	- offset 偏移量，要求是4k的整数倍，通常是0</span><br><span class="line">	- 返回创建的内存的首地址，失败则返回MAP_FAILD，即-1</span><br><span class="line">int munmap(void *addr, size_t length);</span><br><span class="line">	- 释放内存映射，参数需要与mmap对应</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>flags=MAP_ANONYMOUS</code>不依赖磁盘文件，使用匿名内存映射</p>
<p><code>void* ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</code></p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是在软件层次上对中断机制的一种模拟，属于异步通信</p>
<p>命令<code>kill -l</code>查看系统定义的信号列表，前31个为常规信号，其余为实时信号</p>
<p><code>SIGINT</code>——用户按下<code>&lt;Ctrl+C&gt;</code>组合键引发——终止进程</p>
<p><code>SIGQUIT</code>——用户按下<code>&lt;Ctrl+C&gt;</code>组合键引发——终止进程</p>
<p><code>SIGKILL</code>——无条件终止进程，不能被忽略，处理和阻塞——终止除了僵尸以外的所有进程</p>
<p><code>SIGPIPE</code>——管道破裂，向一个没有读端的管道写数据——终止进程</p>
<p><code>SIGSEGV</code>——段错误，无效内存访问——终止进程并产生core文件</p>
<p><code>SIGCHLD</code>——子进程结束时，父进程收到该信号——忽略</p>
<p><code>SIGCONT</code>——进程停止则继续运行——忽略</p>
<p><code>SIGSTOP</code>——停止进程的执行，不能被忽略，处理和阻塞——暂停进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int kill(pid_t pid, int sig);// 产生任意信号sig给进程pid</span><br><span class="line">	- pid = 0, 当前组；pid &gt; 0, 进程号为pid的进程；pid = -1, 所有能接受sig信号的进程，除了init进程；pid &lt; 0，组号为pid绝对值的进程</span><br><span class="line"></span><br><span class="line">int raise(int sig);// 相当于kill(getpid(), sig)</span><br><span class="line">void abort(void);// 相当于kill(getpid(), SIGABRT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">	- 传入0取消闹钟，传入任何值都会取消之前的闹钟</span><br><span class="line">	- 返回上一个闹钟剩余时间， 0 则没有闹钟</span><br><span class="line">	- 非阻塞，产生SIGALARM信号，默认终止当前进程</span><br><span class="line"></span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">int setitimer(int which, const struct itimerval *new_val,struct itimerval *old_value);</span><br><span class="line">	- which参数：ITIMER_REAL指真实时间，同alarm()，产生SIGALRM信号；ITIMER_VIRTUAL指内核态CPU执行时间，包括所有线程消耗的时间，产生SIGVTALRM信号；ITIMER_PROF指该进程在用户态和内核态CPU消耗的时间，产生SIGPROF信号</span><br><span class="line">	- struct itimerval &#123;</span><br><span class="line">               struct timeval it_interval; /* Interval for periodic timer */</span><br><span class="line">               struct timeval it_value;    /* Time until next expiration */</span><br><span class="line">           &#125;;</span><br><span class="line">           struct timeval &#123;</span><br><span class="line">               time_t      tv_sec;         /* seconds */</span><br><span class="line">               suseconds_t tv_usec;        /* microseconds */</span><br><span class="line">           &#125;;</span><br><span class="line">	- old_value 即getitimer()返回的指针，用于返回先前设定的值，为NULL则不需要返回先前值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*ANSI C 标准*/</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">	- signum 捕捉的信号，整型数或宏定义</span><br><span class="line">	- handler 设为SIG_IGN则忽略信号；SIG_DFL则默认动作；也可以传入函数指针自定义动作</span><br><span class="line">	- 返回先前的信号处理函数指针，SIG_ERR则捕捉不成功</span><br><span class="line">	- SIGKILL和SIGSTOP不能被捕捉和忽略</span><br><span class="line">	</span><br><span class="line">/*POSIX标准*/</span><br><span class="line">int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);</span><br><span class="line">	- signum 捕捉的信号</span><br><span class="line">	-  struct sigaction &#123;</span><br><span class="line">               void (*sa_handler)(int);// 自定义的操作函数指针，也可以是SIG_IGN或SIG_DFL</span><br><span class="line">               void (*sa_sigaction)(int, siginfo_t *, void *);// 只有在sa_flags指定时才定义，与sa_handler只定义一个</span><br><span class="line">               sigset_t  sa_mask;//自定义临时阻塞信号集</span><br><span class="line">               int sa_flags;// 设为0时使用sa_handler；设为SA_SIGINFO时使用sa_sigaction</span><br><span class="line">               void (*sa_restorer)(void);// 已废弃</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h2><p>未决信号集：未决是一种状态，指从信号产生到信号被处理前的时间</p>
<p>阻塞信号集：阻塞是一种动作，阻止信号被处理，但不阻止信号产生</p>
<p>信号集在内核使用位图实现，数据类型为<code>sigset_t</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*对自定义的信号集进行操作*/</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigemptyset(sigset_t *set);</span><br><span class="line">	- 初始化信号集set所有信号为0</span><br><span class="line">int sigfillset(sigset_t *set);</span><br><span class="line">	- 初始化信号集set所有信号为1</span><br><span class="line">int sigaddset(sigset_t *set, int signum);</span><br><span class="line">	- 置单个信号为1</span><br><span class="line">int sigdelset(sigset_t *set, int signum);</span><br><span class="line">	- 置单个信号为0</span><br><span class="line">int sigismember(const sigset_t *set, int signum);</span><br><span class="line">	- 查询单个信号是否为1</span><br><span class="line">	- 返回1则是，0则不是，-1查询失败</span><br><span class="line"></span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="line">	- 用于获取或者改变信号掩码，即阻塞信号集</span><br><span class="line">	- how 设为SIG_BLOCK，阻塞信号集则是与set相或的结果，即并集；设为SIG_UNBLOCK，阻塞信号集则是与~set相与的结果；设为SIG_SETMASK，阻塞信号集则是set</span><br><span class="line">	- oldset如果非NULL，则用来存储修改之前的阻塞信号集</span><br><span class="line">	- 返回0成功，-1失败</span><br><span class="line">int sigpending(sigset_t *set);</span><br><span class="line">	- 获取当前线程的未决信号集，存储在set中</span><br></pre></td></tr></table></figure>

<h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h2><p><code>SIGCHLD</code>信号产生的条件：子进程终止；子进程收到<code>SIGSTOP</code>信号停止；子进程停止后收到<code>SIGCONT</code>信号被唤醒。父进程接收到信号后默认忽略该信号</p>
<p>因为信号是异步通信，使用<code>waitpid(-1, NULL, WNOHANG)</code>实现不阻塞父进程情况下完成对子进程的回收，以及获取到子进程的状态信息</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是在物理内存中创建一块可以由多个进程共享的区域，需要其他机制实现同步对共享内存的访问，共享内存无需内核介入，因此速度更快</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">	- key表示一个共享内存的标志，十六进制，设为IPC_PRIVATE 或者 不为IPC_PRIVATE，同时没有key对应的共享内存段，并且shmflg中指定IPC_CREAT，则创建新的共享内存段</span><br><span class="line">	- size共享内存的大小，向上取整到PAGE_SIZE的整数倍</span><br><span class="line">	- shmflg设为IPC_CREAT新建共享内存段；设为IPC_EXCL|IPC_CREAT如果已经存在，则返回错误号EEXIST</span><br><span class="line">	- 成功则返回共享内存id号，失败返回01</span><br><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line">	- 将共享内存与当前进程关联</span><br><span class="line">	- shmaddr设为NULL，系统安排段地址</span><br><span class="line">	- shmflg设为SHM_EXEC，共享内存可以被执行；设为SHM_RDONLY,共享内存只读；不指定（0）则为读写</span><br><span class="line">	- 成功则返回共享内存的首地址，失败返回-1</span><br><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line">	- 将共享内存与当前进程取消关联，更新共享内存的shmid_ds结构体</span><br><span class="line">	- 成功则返回0，失败返回-1</span><br><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br><span class="line">	- 对共享内存进行cmd操作，设为IPC_STAT，获取当前共享内存状态；设为IPC_SET,设置共享内存状态；设为IPC_RMID,标记共享内存为销毁</span><br><span class="line">	- buf需要设置或者获取的共享内存的属性信息，当cmd为IPC_STAT时指定在buf中存储信息；IPC_SET根据buf指定的信息修改共享内存属性；IPC_RMID为NULL</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">key_t ftok(const char *pathname， int proj_id);</span><br><span class="line">	- 根据存在的路径名pathname和八位的整型数proj_id，生成一个共享内存的key值，相同路径名和proj_id相同时返回相同的key值</span><br></pre></td></tr></table></figure>

<p>共享内存操作命令</p>
<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305121456792.png" style="zoom:67%;" />

<p>内存映射与共享内存的区别</p>
<ol>
<li>共享内存直接创建，内存映射需要磁盘文件</li>
<li>共享内存速度更快</li>
<li>进程操作的是同一块共享内存，内存映射在每个进程虚拟空间中有独立内存</li>
<li>进程突然退出共享内存依然存在，内存映射区消失；电脑死机共享内存消失，内存映射磁盘文件存在</li>
<li>进程退出共享内存区标记为删除，内存映射区销毁</li>
</ol>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><ul>
<li><p>守护进程运行在后台，独立于控制终端，内核不为守护进程自动生成任何控制信号以及终端相关的信号</p>
</li>
<li><p>会周期性执行某种任务，一般采用以d结尾的名字</p>
</li>
<li><p>守护进程的父进程是init进程，是孤儿进程</p>
</li>
</ul>
<p>创建守护进程步骤</p>
<ol>
<li>在父进程中fork并退出父进程，使子进程成为孤儿进程，此时子进程继承父进程的会话、进程组、控制终端、文件描述符等</li>
<li>在子进程中调用setsid创建新会话，脱离原来的进程组，会话以及终止终端。但此时可能会申请一个控制终端，因此可以再fork出子进程2，这样子进程2就不是会话组长，就不能申请控制终端了</li>
<li>更改当前工作目录，因为守护进程运行到系统关机，这就要求其所在目录不能被卸载</li>
<li>设置掩码，不受父进程的umask影响，可以设为0</li>
<li>关闭文件描述符，将0,1,2三个文件描述符重定向到”&#x2F;dev&#x2F;null”</li>
</ol>
<p>另外，也可以利用库函数daemon()创建守护进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int daemon(int nochdir, int noclose);</span><br><span class="line">	- nochdir 设为0时将当前目录更改为&quot;/&quot;</span><br><span class="line">	- noclose 设为0时将标准输入、标准输出、标准错误重定向至&quot;/dev/null&quot;</span><br><span class="line">	- 成功返回0，失败返回-1</span><br></pre></td></tr></table></figure>

<h1 id="3、Linux多线程开发"><a href="#3、Linux多线程开发" class="headerlink" title="3、Linux多线程开发"></a>3、Linux多线程开发</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程当中的一条执行流程</p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源</p>
<p>每个线程各自有一套独立的寄存器和栈，确保线程的控制流相对独立</p>
<p>使用命令<code>ps -Lf pid</code>查看指定进程的LWP号</p>
<h2 id="线程vs进程"><a href="#线程vs进程" class="headerlink" title="线程vs进程"></a>线程vs进程</h2><p>进程是分配资源的基本单位，线程是调度的基本单位</p>
<p>进程间不共享内存，需要采用进程通信方式，线程共享内存和文件资源</p>
<p>进程创建需要资源管理信息，内存、文件管理信息等，线程创建共享它们</p>
<p>进程上下文切换开销大，切换时要把页表切换掉，同一个进程内的线程切换只需要切换私有数据、寄存器等不共享数据</p>
<h2 id="线程操作函数"><a href="#线程操作函数" class="headerlink" title="线程操作函数"></a>线程操作函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span><br><span class="line">	- 以执行函数指针start_routine指向的函数创建线程，并且向函数传递arg参数，创建的线程属性由attr指定</span><br><span class="line">	- thread存储新建线程的线程ID</span><br><span class="line">pthread_t pthread_self(void);</span><br><span class="line">	- 成功返回0</span><br><span class="line">int pthread_equal(pthread_t t1, pthread_t t2);</span><br><span class="line">	- 判断两个线程ID是否相同 </span><br><span class="line">void pthread_exit(void *retval);</span><br><span class="line">	- 当前线程退出，返回retval，能够在pthread_join函数中使用</span><br><span class="line">int pthread_join(pthread_t thread, void **retval);</span><br><span class="line">	- 以阻塞的方式等待一个线程结束</span><br><span class="line">	- retval接受线程退出传递参数的地址</span><br><span class="line">int pthread_detach(pthread_t thread);</span><br><span class="line">	- 分离一个线程，被分离的线程在终止时自动释放资源，不能连接一个分离的线程</span><br><span class="line">int pthread_cancel(pthread_t thread);</span><br><span class="line">	- 当线程到达一个取消点时取消</span><br><span class="line">	- 线程取消取决于 cancelability state and type</span><br><span class="line">	- cancelability state由pthread_setcancelstate决定，新线程默认启用(enabled)，启用后由cancelability type决定线程取消时机</span><br><span class="line">	- cancelability type由pthread_setcanceltype决定，新线程默认为deferred,也可以是asynchronous，deferred意味着直到下一次取消点线程才会取消</span><br><span class="line">	- 只有连接线程才能获取PTHREAD_CANCELED退出状态码，才能知道线程取消成功</span><br></pre></td></tr></table></figure>

<h2 id="线程属性操作函数"><a href="#线程属性操作函数" class="headerlink" title="线程属性操作函数"></a>线程属性操作函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_attr_init(pthread_attr_t *attr);</span><br><span class="line">	- 初始化线程属性attr</span><br><span class="line">int pthread_attr_destroy(pthread_attr_t *attr);</span><br><span class="line">	- 释放线程属性资源</span><br><span class="line">int pthread_attr_getdetachstate(const pthread_attr_t *attr, int* detachstate);</span><br><span class="line">	- 获取线程分离状态的属性</span><br><span class="line">int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</span><br><span class="line">	- 设置线程分离状态的属性</span><br><span class="line">	- detachstate可设为 PTHREAD_CREATE_DETACHED或者PTHREAD_CREATE_JOINABLE(默认)</span><br></pre></td></tr></table></figure>

<h2 id="互斥与同步"><a href="#互斥与同步" class="headerlink" title="互斥与同步"></a>互斥与同步</h2><p>互斥：一个线程在临界区执行时，其他线程应该被阻止进入临界区</p>
<p>同步：并发线程或进程在一些关键点上需要相互等待与互通信息</p>
<p>加锁解锁操作可以实现互斥，信号量可以实现互斥和同步</p>
<h2 id="互斥锁Mutex"><a href="#互斥锁Mutex" class="headerlink" title="互斥锁Mutex"></a>互斥锁Mutex</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">互斥量的类型 pthread_mutex_t</span><br><span class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);</span><br><span class="line">	-初始化互斥锁</span><br><span class="line">	- attr互斥锁相关属性，可以为NULL</span><br><span class="line">int pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br><span class="line">	- 释放互斥锁资源</span><br><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</span><br><span class="line">	- 加锁，并且阻塞当前线程</span><br><span class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex);</span><br><span class="line">	- 尝试加锁，如果加锁失败则返回</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br><span class="line">	- 解锁</span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>如果有其他线程读数据，则允许其他线程执行读操作，但不允许写操作</p>
<p>如果有其他线程写数据，则其他线程不允许读或写操作</p>
<p>写独占，优先级更高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">读写锁的类型 pthread_rwlock_t</span><br><span class="line"></span><br><span class="line">int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</span><br><span class="line">	- </span><br><span class="line">int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">条件变量的类型 pthread_cond_t</span><br><span class="line"></span><br><span class="line">int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</span><br><span class="line">	- 初始化条件变量</span><br><span class="line">int pthread_cond_destroy(pthread_cond_t *cond);</span><br><span class="line">	- 释放条件变量资源</span><br><span class="line">int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</span><br><span class="line">	- 解除互斥锁并阻塞等待，直到条件变量发出信号；当接收到信号时将会重新加上互斥锁</span><br><span class="line">int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</span><br><span class="line">	- 解除互斥锁并阻塞等待指定时间</span><br><span class="line">int pthread_cond_signal(pthread_cond_t *cond);</span><br><span class="line">	- 唤醒等待的线程</span><br><span class="line">int pthread_cond_broadcast(pthread_cond_t *cond);</span><br><span class="line">	- 唤醒所有等待的线程</span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">信号量的类型 sem_t</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line">	- 初始化信号量</span><br><span class="line">	- pshared设为0，表示线程；否则表示进程</span><br><span class="line">	- value信号量的初始值</span><br><span class="line">int sem_destroy(sem_t *sem);</span><br><span class="line">	- 释放信号量资源</span><br><span class="line">int sem_wait(sem_t *sem);</span><br><span class="line">	- 加锁，相当于P操作，信号量值value减一，如果值为0则阻塞</span><br><span class="line">	- 返回0成功</span><br><span class="line">int sem_trywait(sem_t *sem);</span><br><span class="line">	- 如果无法加锁，返回-1，errorno为EAGAIN而不阻塞</span><br><span class="line">int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span><br><span class="line">	- 超过时长abs_timeout无法加锁，返回-1，errorno为ETIMEOUT而不阻塞</span><br><span class="line">int sem_post(sem_t *sem);</span><br><span class="line">	- 释放锁，相当于V操作，信号量值value加一</span><br><span class="line">int sem_getvalue(sem_t *sem, int *sval);</span><br><span class="line">	- 获取信号量sem的value</span><br></pre></td></tr></table></figure>

<h1 id="4、Linux网络编程"><a href="#4、Linux网络编程" class="headerlink" title="4、Linux网络编程"></a>4、Linux网络编程</h1><h2 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//主机字节序转换成网络字节序</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">// 端口号转换</span><br><span class="line">uint16_t htons(uint16_t hostshort)</span><br><span class="line">uint16_t ntohs(uint16_t netshort)</span><br><span class="line"></span><br><span class="line">// IP地址转换</span><br><span class="line">uint32_t htonl(uint32_t hostlong)</span><br><span class="line">uint32_t ntohl(uint32_t netlong)</span><br></pre></td></tr></table></figure>

<h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span><br><span class="line">int inet_pton(int af, const char *src, void *dst);</span><br><span class="line">	- af:地址族： AF_INET AF_INET6</span><br><span class="line">	- src:需要转换的点分十进制的IP字符串</span><br><span class="line">	- dst:转换后的结果保存在这个里面</span><br><span class="line">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span><br><span class="line">const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</span><br><span class="line">	- af:地址族： AF_INET AF_INET6</span><br><span class="line">	- src: 要转换的ip的整数的地址</span><br><span class="line">	- dst: 转换成IP地址字符串保存的地方</span><br><span class="line">	- size：第三个参数的大小（数组的大小）</span><br><span class="line">	- 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure>

<h2 id="套接字函数"><a href="#套接字函数" class="headerlink" title="套接字函数"></a>套接字函数</h2><img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305221047814.png" style="zoom: 50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">    - 功能：创建一个套接字</span><br><span class="line">    - domain: 协议族 ，AF_INET : ipv4、AF_INET6 : ipv6、AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">    - type: 通信过程中使用的协议类型</span><br><span class="line">        SOCK_STREAM : 流式协议</span><br><span class="line">        SOCK_DGRAM : 报式协议</span><br><span class="line">    - protocol : 具体的一个协议。一般写0，流式协议默认使用 TCP；报式协议默认使用 UDP</span><br><span class="line">    - 成功：返回文件描述符，操作的就是内核缓冲区，失败：-1</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命名</span><br><span class="line">    - 功能：绑定，将fd 和本地的IP + 端口进行绑定</span><br><span class="line">    - sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">    - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">    - addrlen : 第二个参数结构体占的内存大小</span><br><span class="line">int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn</span><br><span class="line">    - 功能：监听这个socket上的连接</span><br><span class="line">    - sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">    - backlog : 未连接的和已经连接的和的最大值， 5</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">    - 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">    - sockfd : 用于监听的文件描述符</span><br><span class="line">    - addr : 传出参数，记录了连接成功后客户端的地址信息（ip + port）</span><br><span class="line">    - addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">    - 成功返回用于通信的文件描述符，失败返回-1</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">    - 功能： 客户端连接服务器</span><br><span class="line">    - sockfd : 用于通信的文件描述符</span><br><span class="line">    - addr : 客户端要连接的服务器的地址信息</span><br><span class="line">    - addrlen : 第二个参数的内存大小</span><br><span class="line">    - 返回值：成功 0， 失败 -1</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count); // 写数据</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count); // 读数据</span><br></pre></td></tr></table></figure>

<h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><p>端口复用允许一个程序中多个套接字在一个端口号上绑定，但只有最后一个套接字能够接受信息；程序退出而系统没有释放端口，跳过TIME_WAIT状态</p>
<p>使用<code>setsockopt</code>函数中的<code>SO_REUSEADDR</code>选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">// 设置套接字的属性（不仅仅能设置端口复用）,在服务器绑定端口之前设置，绑定到同一个端口的所有套接字都得设置复用</span><br><span class="line">int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</span><br><span class="line">	- sockfd : 要操作的文件描述符</span><br><span class="line">	- level : 级别 设为SOL_SOCKET </span><br><span class="line">	- optname : 选项的名称 设为SO_REUSEADDR</span><br><span class="line">	- optval : 端口复用的值（整形），设为1可以复用，0则不可以</span><br><span class="line">	- optlen : optval参数的大小</span><br></pre></td></tr></table></figure>



<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用使程序能够同时监听多个文件描述符，能够提高程序的性能</p>
<p>select函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line">	- 允许程序监听多个文件描述符，直到一个或多个文件描述符有数据改动，监听数量小于 FD_SETSIZE(1024)</span><br><span class="line">	- readfds 指向fd_set结构的指针，监听读缓冲区是否有数据可以读入（不被阻塞）如果有则返回大于0的值，如果超出timeout的时间返回0，错误返回-1；writefds 指向fd_set结构的指针，监听写缓冲区是否可以写入，如果有则返回大于0的值，如果超出timeout的时间返回0，错误返回-1；execptfds 指向fd_set结构的指针，用来监听文件错误异常</span><br><span class="line">	- nfds设为最大文件描述符+1</span><br><span class="line">	- timeout指定阻塞监听文件描述符的时长，NULL则阻塞直到文件描述符有变化</span><br><span class="line">	- 监听成功返回sets中的文件描述符数量</span><br><span class="line">void FD_CLR(int fd, fd_set *set);</span><br><span class="line">	- 从set中移除fd指定的文件描述符</span><br><span class="line">int  FD_ISSET(int fd, fd_set *set);</span><br><span class="line">	- 判断select返回的set中fd文件描述符是否为1，即有改动</span><br><span class="line">void FD_SET(int fd, fd_set *set);</span><br><span class="line">	- 从set中添加fd指定的文件描述符</span><br><span class="line">void FD_ZERO(fd_set *set);</span><br><span class="line">	- 清除set中所有文件描述符</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li>每次调用 select ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大</li>
<li>同时每次调用 select 都需要在内核遍历传递进来的所有 fd ，这个开销在 fd 很多时也很大</li>
<li>select支持的文件描述符数量太小了，默认是 1024</li>
<li>fds集合不能重用，每次都需要重置</li>
</ol>
<p>poll函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;</span><br><span class="line"></span><br><span class="line">int poll(struct pollfd* fds, nfds_t nfds, int timeout);</span><br><span class="line">	- struct pollfd &#123;</span><br><span class="line">               int   fd;         /* file descriptor */</span><br><span class="line">               short events;     /* requested events */</span><br><span class="line">               short revents;    /* returned events */</span><br><span class="line">      &#125;;</span><br><span class="line">     - events 输入参数，指定对文件描述符fd监听的位掩码，revents 输出参数，由内核填充，与实际发生事件联系</span><br><span class="line">     - timeout 指定监听文件描述符应该阻塞的毫秒数，-1则一直阻塞直到有变化</span><br><span class="line">     - 返回0则超时且无文件描述符有变化；大于0返回变化的文件描述符数；-1错误</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/kevin346-sc/figure/main/202305271009920.png" style="zoom:80%;" />

<p>解决了select的3、4缺点，但依然存在1、2缺点</p>
<p>epoll函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">int epoll_create(int size);</span><br><span class="line">	- 创建一个保证能够正确处理的size大小的epoll句柄，已放弃使用</span><br><span class="line">	- 创建后占用一个文件描述符，将文件描述符作为返回值，失败返回-1</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line">	- 操作创建的epoll，注册要监听的事件类型</span><br><span class="line">	- op表示动作，EPOLL_CTL_ADD添加新的fd到epfd中；EPOLL_CTL_MOD修改已注册的fd的监听事件；EPOLL_CTL_DEL从epfd中删除一个fd</span><br><span class="line">	- fd 表示需要监听的文件描述符</span><br><span class="line">	- struct epoll_event &#123;</span><br><span class="line">  		__uint32_t events;  /* Epoll events */</span><br><span class="line">  		epoll_data_t data;  /* User data variable */</span><br><span class="line">	  &#125;;</span><br><span class="line">	  其中，events监听事件有EPOLLIN对应的文件描述符可读；EPOLLOUT可写；EPOLLERR发生错误；EPOLLLET边缘触发模式（默认为水平触发模式）</span><br><span class="line">	- typedef union epoll_data &#123;</span><br><span class="line">        void *ptr;</span><br><span class="line">        int fd;</span><br><span class="line">        uint32_t u32;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        &#125; epoll_data_t;</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br><span class="line">	- 等待监听事件的发生</span><br><span class="line">	- events 传出参数，从内核得到事件的集合</span><br><span class="line">	- maxevents 结构体数组events的大小</span><br><span class="line">	- timeout 阻塞时间，设为0不阻塞；-1一直阻塞；&gt; 0 阻塞的时长（毫秒）</span><br><span class="line">	- 返回发生变化的文件描述符个数，失败返回-1</span><br></pre></td></tr></table></figure>











<h2 id="库CentOS与Ubuntu哪个更适合做服务器系统"><a href="#库CentOS与Ubuntu哪个更适合做服务器系统" class="headerlink" title="库CentOS与Ubuntu哪个更适合做服务器系统"></a><a target="_blank" rel="noopener" href="https://www.jb51.net/article/110710.htm">库CentOS与Ubuntu哪个更适合做服务器系统</a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
